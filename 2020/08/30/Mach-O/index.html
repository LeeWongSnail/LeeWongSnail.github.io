<!DOCTYPE html>
<html lang="zh-CN">
    <head>
    <meta charset="utf-8">

    

    <!-- 渲染优化 -->
    <meta name="renderer" content="webkit">
    <meta name="force-rendering" content="webkit">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="HandheldFriendly" content="True" >
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <!--icon-->

    
        <link rel="shortcut icon" href="https://tva1.sinaimg.cn/large/0081Kckwly1glcsnw2jatj303k03k748.jpg">
    
    
    
    
    


    <!-- meta -->


<title>Mach-O 探究 | LeeWong</title>


    <meta name="keywords" content="Mach-O 加载器, iOS">




    <!-- OpenGraph -->
 
    <meta name="description" content="Mach-O为Mach Object文件格式的缩写，它是一种用于可执行文件，目标代码，动态库，内核转储的文件格式。作为a.out格式的替代，Mach-O提供了更强的扩展性，并提升了符号表中信息的访问速度。Mach-O格式为大部分基于Mach内核的操作系统所使用的，包括NeXTSTEP, Mac OS X和iOS，它们都以Mach-O格式作为其可执行文件，动态库，目标代码的文件格式。">
<meta property="og:type" content="article">
<meta property="og:title" content="Mach-O 探究">
<meta property="og:url" content="https://www.leewong.cn/2020/08/30/Mach-O/index.html">
<meta property="og:site_name" content="LeeWong">
<meta property="og:description" content="Mach-O为Mach Object文件格式的缩写，它是一种用于可执行文件，目标代码，动态库，内核转储的文件格式。作为a.out格式的替代，Mach-O提供了更强的扩展性，并提升了符号表中信息的访问速度。Mach-O格式为大部分基于Mach内核的操作系统所使用的，包括NeXTSTEP, Mac OS X和iOS，它们都以Mach-O格式作为其可执行文件，动态库，目标代码的文件格式。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/0081Kckwgy1gld48z8trfj31b80b4q4c.jpg">
<meta property="article:published_time" content="2020-08-30T08:20:39.000Z">
<meta property="article:modified_time" content="2020-12-05T09:39:08.965Z">
<meta property="article:author" content="LeeWong">
<meta property="article:tag" content="Mach-O 加载器">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://tva1.sinaimg.cn/large/0081Kckwgy1gld48z8trfj31b80b4q4c.jpg">


    
<link rel="stylesheet" href="/css/style/main.css">
 


    
<link rel="stylesheet" href="/css/style/dark.css">

    
<script src="/js/darkmode.js"></script>



    
    
        <link rel="stylesheet" id="hl-default-theme" href="/css/highlight/highlihgt.css" media="none" onload="if(getComputedStyle(document.documentElement).getPropertyValue('--color-mode').indexOf('dark')===-1)this.media='all'">
        
            <link rel="stylesheet" id="hl-dark-theme" href="/css/highlight/prismjs.css" media="none" onload="if(getComputedStyle(document.documentElement).getPropertyValue('--color-mode').indexOf('dark')!==-1)this.media='all'">
        
    

    
    

     
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
 

    <!-- custom head -->

    
        <meta name="google-site-verification" content="4NmLVard-jFEKaV6857m9tKb41Tpo4FiKj8L1TJg7lU" /> 
    

<meta name="generator" content="Hexo 5.1.1"></head>

    <body>
        <div id="app">
            <header class="header">
    <div class="header__left">
        <a href="/" class="button">
            <span class="logo__text">LeeWong</span>
        </a>
    </div>
    <div class="header__right">
        
            <div class="navbar__menus">
                
                    <a href="/" class="navbar-menu button">首页</a>
                
                    <a href="/tags/" class="navbar-menu button">标签</a>
                
                    <a href="/archives/" class="navbar-menu button">归档</a>
                
                    <a href="/about/" class="navbar-menu button">关于我</a>
                
            </div>
        
        
        

        
        
    <a href="javaScript:void(0);" id="btn-toggle-dark">
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path></svg>
    </a>


         
    <a href="#" class="button" id="b2t" aria-label="回到顶部" title="回到顶部">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1024 1024" width="32" height="32">
            <path d="M233.376 722.752L278.624 768 512 534.624 745.376 768l45.248-45.248L512 444.128zM192 352h640V288H192z" fill="currentColor"></path>
        </svg>
    </a>


        
            <a class="dropdown-icon button" id="btn-dropdown" tabindex="0"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" width='24' height='24' fill="none" stroke="currentColor" stroke-width="0.7" stroke-linecap="round" stroke-linejoin="round"><path fill="currentColor" d="M3.314,4.8h13.372c0.41,0,0.743-0.333,0.743-0.743c0-0.41-0.333-0.743-0.743-0.743H3.314c-0.41,0-0.743,0.333-0.743,0.743C2.571,4.467,2.904,4.8,3.314,4.8z M16.686,15.2H3.314c-0.41,0-0.743,0.333-0.743,0.743s0.333,0.743,0.743,0.743h13.372c0.41,0,0.743-0.333,0.743-0.743S17.096,15.2,16.686,15.2z M16.686,9.257H3.314c-0.41,0-0.743,0.333-0.743,0.743s0.333,0.743,0.743,0.743h13.372c0.41,0,0.743-0.333,0.743-0.743S17.096,9.257,16.686,9.257z"></path></svg></a>
            <div class="dropdown-menus" id="dropdown-menus">
                
                    <a href="/" class="dropdown-menu button">首页</a>
                
                    <a href="/tags/" class="dropdown-menu button">标签</a>
                
                    <a href="/archives/" class="dropdown-menu button">归档</a>
                
                    <a href="/about/" class="dropdown-menu button">关于我</a>
                
            </div>
        
    </div>
</header>


            <main class="main">
    

<div class="post-title">
    <h1 class="post-title__text">
        Mach-O 探究
    </h1>
    <div class="post-title__meta">
        <a href="/archives/2020/08/" class="post-meta__date button">2020-08-30</a>
        
    <span class="separate-dot"></span><a href="/categories/iOS%E9%AB%98%E7%BA%A7%E5%BC%80%E5%8F%91/" class="button">iOS高级开发</a>

 
        
    
     
    <span id="busuanzi_container_page_pv" hidden>
        <span class="separate-dot"></span>
        <span></span>
        <span id="busuanzi_value_page_pv"></span>
        <span>Views</span>
    </span>



 

 
    </div>
</div>


    <aside class="post-side">
        <div class="post-side__toc">
            <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#Mach-O%E7%AE%80%E4%BB%8B"><span class="toc-number">1.</span> <span class="toc-text">Mach-O简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Mach-O%E7%BB%93%E6%9E%84"><span class="toc-number">2.</span> <span class="toc-text">Mach-O结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Mach64-Header"><span class="toc-number">3.</span> <span class="toc-text">Mach64 Header</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Magic-Number"><span class="toc-number">3.1.</span> <span class="toc-text">Magic Number</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CPU-Type-CPU-SubType"><span class="toc-number">3.2.</span> <span class="toc-text">CPU Type ,CPU SubType</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#File-Type"><span class="toc-number">3.3.</span> <span class="toc-text">File Type</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ncmds-Number-of-Load-Commands"><span class="toc-number">3.4.</span> <span class="toc-text">ncmds(Number of Load Commands)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sizeofcmds-Size-of-Load-Commands"><span class="toc-number">3.5.</span> <span class="toc-text">sizeofcmds(Size of Load Commands)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Flags"><span class="toc-number">3.6.</span> <span class="toc-text">Flags</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Load-Commands"><span class="toc-number">4.</span> <span class="toc-text">Load Commands</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Segment"><span class="toc-number">4.1.</span> <span class="toc-text">Segment</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Section"><span class="toc-number">4.2.</span> <span class="toc-text">Section</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DATA-%E6%95%B0%E6%8D%AE"><span class="toc-number">5.</span> <span class="toc-text">DATA(数据)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#TEXT%E6%AE%B5"><span class="toc-number">5.1.</span> <span class="toc-text">__TEXT段</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#cstring"><span class="toc-number">5.1.1.</span> <span class="toc-text">cstring</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#objc-methname"><span class="toc-number">5.1.2.</span> <span class="toc-text">objc_methname</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#classname"><span class="toc-number">5.1.3.</span> <span class="toc-text">classname</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DATA"><span class="toc-number">5.2.</span> <span class="toc-text">_DATA</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#objc-imageinfo"><span class="toc-number">5.2.1.</span> <span class="toc-text">__objc_imageinfo</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#objc-classlist"><span class="toc-number">5.2.2.</span> <span class="toc-text">__objc_classlist</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#objc-catlist"><span class="toc-number">5.2.3.</span> <span class="toc-text">__objc_catlist</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#objc-protolist"><span class="toc-number">5.2.4.</span> <span class="toc-text">__objc_protolist</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#objc-classrefs"><span class="toc-number">5.2.5.</span> <span class="toc-text">__objc_classrefs</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#objc-selrefs"><span class="toc-number">5.2.6.</span> <span class="toc-text">__objc_selrefs</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#objc-superrefs"><span class="toc-number">5.2.7.</span> <span class="toc-text">__objc_superrefs</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#objc-const"><span class="toc-number">5.2.8.</span> <span class="toc-text">__objc_const</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%90%AF%E5%8A%A8"><span class="toc-number">6.</span> <span class="toc-text">应用启动</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E8%B0%83%E7%94%A8%E5%A0%86%E6%A0%88"><span class="toc-number">6.1.</span> <span class="toc-text">启动调用堆栈</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#dyld"><span class="toc-number">6.2.</span> <span class="toc-text">dyld</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ImageLoader"><span class="toc-number">6.3.</span> <span class="toc-text">ImageLoader</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ImageLoaderMachO"><span class="toc-number">6.4.</span> <span class="toc-text">ImageLoaderMachO</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#doInitialization"><span class="toc-number">6.4.1.</span> <span class="toc-text">doInitialization</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#doModInitFunctions"><span class="toc-number">6.4.2.</span> <span class="toc-text">doModInitFunctions</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">7.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E6%96%87%E7%AB%A0"><span class="toc-number">8.</span> <span class="toc-text">参考文章</span></a></li></ol>
        </div>
    </aside>
    <a class="btn-toc button" id="btn-toc" tabindex="0">
        <svg viewBox="0 0 1024 1024" width="32" height="32" xmlns="http://www.w3.org/2000/svg">
            <path d="M128 256h64V192H128zM320 256h576V192H320zM128 544h64v-64H128zM320 544h576v-64H320zM128 832h64v-64H128zM320 832h576v-64H320z" fill="currentColor"></path>
        </svg>
    </a>
    <div class="toc-menus" id="toc-menus">
        <div class="toc-title">文章目录</div>
        <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#Mach-O%E7%AE%80%E4%BB%8B"><span class="toc-number">1.</span> <span class="toc-text">Mach-O简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Mach-O%E7%BB%93%E6%9E%84"><span class="toc-number">2.</span> <span class="toc-text">Mach-O结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Mach64-Header"><span class="toc-number">3.</span> <span class="toc-text">Mach64 Header</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Magic-Number"><span class="toc-number">3.1.</span> <span class="toc-text">Magic Number</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CPU-Type-CPU-SubType"><span class="toc-number">3.2.</span> <span class="toc-text">CPU Type ,CPU SubType</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#File-Type"><span class="toc-number">3.3.</span> <span class="toc-text">File Type</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ncmds-Number-of-Load-Commands"><span class="toc-number">3.4.</span> <span class="toc-text">ncmds(Number of Load Commands)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sizeofcmds-Size-of-Load-Commands"><span class="toc-number">3.5.</span> <span class="toc-text">sizeofcmds(Size of Load Commands)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Flags"><span class="toc-number">3.6.</span> <span class="toc-text">Flags</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Load-Commands"><span class="toc-number">4.</span> <span class="toc-text">Load Commands</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Segment"><span class="toc-number">4.1.</span> <span class="toc-text">Segment</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Section"><span class="toc-number">4.2.</span> <span class="toc-text">Section</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DATA-%E6%95%B0%E6%8D%AE"><span class="toc-number">5.</span> <span class="toc-text">DATA(数据)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#TEXT%E6%AE%B5"><span class="toc-number">5.1.</span> <span class="toc-text">__TEXT段</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#cstring"><span class="toc-number">5.1.1.</span> <span class="toc-text">cstring</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#objc-methname"><span class="toc-number">5.1.2.</span> <span class="toc-text">objc_methname</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#classname"><span class="toc-number">5.1.3.</span> <span class="toc-text">classname</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DATA"><span class="toc-number">5.2.</span> <span class="toc-text">_DATA</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#objc-imageinfo"><span class="toc-number">5.2.1.</span> <span class="toc-text">__objc_imageinfo</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#objc-classlist"><span class="toc-number">5.2.2.</span> <span class="toc-text">__objc_classlist</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#objc-catlist"><span class="toc-number">5.2.3.</span> <span class="toc-text">__objc_catlist</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#objc-protolist"><span class="toc-number">5.2.4.</span> <span class="toc-text">__objc_protolist</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#objc-classrefs"><span class="toc-number">5.2.5.</span> <span class="toc-text">__objc_classrefs</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#objc-selrefs"><span class="toc-number">5.2.6.</span> <span class="toc-text">__objc_selrefs</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#objc-superrefs"><span class="toc-number">5.2.7.</span> <span class="toc-text">__objc_superrefs</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#objc-const"><span class="toc-number">5.2.8.</span> <span class="toc-text">__objc_const</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%90%AF%E5%8A%A8"><span class="toc-number">6.</span> <span class="toc-text">应用启动</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E8%B0%83%E7%94%A8%E5%A0%86%E6%A0%88"><span class="toc-number">6.1.</span> <span class="toc-text">启动调用堆栈</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#dyld"><span class="toc-number">6.2.</span> <span class="toc-text">dyld</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ImageLoader"><span class="toc-number">6.3.</span> <span class="toc-text">ImageLoader</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ImageLoaderMachO"><span class="toc-number">6.4.</span> <span class="toc-text">ImageLoaderMachO</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#doInitialization"><span class="toc-number">6.4.1.</span> <span class="toc-text">doInitialization</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#doModInitFunctions"><span class="toc-number">6.4.2.</span> <span class="toc-text">doModInitFunctions</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">7.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E6%96%87%E7%AB%A0"><span class="toc-number">8.</span> <span class="toc-text">参考文章</span></a></li></ol>
    </div>


<article class="post content-card">
    <div class="post__header">
    
        <div class="post-thumbnail" style="background-image: url('https://tva1.sinaimg.cn/large/0081Kckwgy1gld48z8trfj31b80b4q4c.jpg');"></div>
    
</div>
    <div class="post__content">
        <p><code>Mach-O</code>为<code>Mach Object</code>文件格式的缩写，它是一种用于可执行文件，目标代码，动态库，内核转储的文件格式。作为a.out格式的替代，Mach-O提供了更强的扩展性，并提升了符号表中信息的访问速度。<br><code>Mach-O</code>格式为大部分基于<code>Mach</code>内核的操作系统所使用的，包括<code>NeXTSTEP</code>, <code>Mac OS X</code>和<code>iOS</code>，它们都以<code>Mach-O</code>格式作为其可执行文件，动态库，目标代码的文件格式。</p>
<a id="more"></a>


<h3 id="Mach-O简介"><a href="#Mach-O简介" class="headerlink" title="Mach-O简介"></a>Mach-O简介</h3><p>在iOS开发中，我们的代码在编译后会生成一个.app的文件(Product文件夹下),而.app文件我们可以把它看做是一个文件夹,内部存放了APP正常运行所需要的文件，通常比较容易识别的是一些资源文件。如图：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gi8xlznb88j30fm0keajq.jpg"></p>
<p>我们通过显示包内容看下.app文件夹内都有什么：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gi8xow8jvoj30s40duwhk.jpg"></p>
<p>当然我们这片文章的主角也在这个文件夹内：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gi8xfafmakj30yq0hqah8.jpg"></p>
<p>系统识别Mach-O(这个名字是项目的名字)为可执行文件(Mach-O是一种可执行文件格式)，我们来看下这个文件,Mach-O文件是无法直接打开或者查看包内容，这里我们需要借助MachOView工具来查看，工具是开源的如果你想看具体的实现，你可以看<a target="_blank" rel="noopener" href="https://github.com/gdbinit/MachOView">工具的源码</a>，当然你可以直接<a target="_blank" rel="noopener" href="http://sourceforge.net/projects/machoview/">下载</a>使用。</p>
<p>打开后的页面是这样的：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gi8xv47qi7j31fg0sc44j.jpg"></p>
<h3 id="Mach-O结构"><a href="#Mach-O结构" class="headerlink" title="Mach-O结构"></a>Mach-O结构</h3><p>实际上我们从使用MachOView打开后的文件目录也可以看出，Mach-O的文件结构分为三大部分:<code>Header</code>,<code>Load Commands</code>,<code>Data</code>。</p>
<p>下面是官方提供的一张结构图：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gi8yhakxzbj30b50but9m.jpg"></p>
<p>根据上图，我们将我们看到的目录大致划分为：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gi8yllkqyyj30ju1000y2.jpg"></p>
<ul>
<li>Mach-O 头（Mach Header）：这里描述了 Mach-O 的 CPU 架构、文件类型以及加载命令等信息；</li>
<li>加载命令（Load Command）：当系统加载Mach-O文件时，load command会指导苹果的动态加载器(dyld)h或内核，该如何加载文件的Data数据。</li>
<li>数据区（Data）：Mach-O文件的数据区，包含代码和数据。其中包含若干Segment块，每个Segment块中包含0个或多个seciton。Segment根据对应的load command被dyld加载入内存中。</li>
</ul>
<p><code>注意</code>：通过对比我们发现实际上官网给出的结构并不准确，在实际结果中还包含了<code>Dynamic Loader Info</code>,<code>Function Starts</code>,<code>Symbol Table</code>,<code>Data In Code Entries</code>,<code>Dynamic Symbol Table</code>,<code>String Table</code>,<code>Code Signature</code>等。</p>
<p>下面我们来详细看下每部分的内容</p>
<h3 id="Mach64-Header"><a href="#Mach64-Header" class="headerlink" title="Mach64 Header"></a>Mach64 Header</h3><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gi8xxtz5kij31fa0g6dkw.jpg"></p>
<p>这里我们可以和苹果开源的Darwin源码一起看方便理解,源码在<a target="_blank" rel="noopener" href="https://opensource.apple.com/source/xnu/xnu-1456.1.26/EXTERNAL_HEADERS/mach-o/loader.h">这里</a>。</p>
<p>32位</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The 32-bit mach header appears at the very beginning of the object file for</span></span><br><span class="line"><span class="comment"> * 32-bit architectures.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mach_header</span> &#123;</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	magic;		<span class="comment">/* mach magic number identifier */</span></span><br><span class="line">	<span class="keyword">cpu_type_t</span>	cputype;	<span class="comment">/* cpu specifier */</span></span><br><span class="line">	<span class="keyword">cpu_subtype_t</span>	cpusubtype;	<span class="comment">/* machine specifier */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	filetype;	<span class="comment">/* type of file */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	ncmds;		<span class="comment">/* number of load commands */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	sizeofcmds;	<span class="comment">/* the size of all the load commands */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	flags;		<span class="comment">/* flags */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>64位:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The 64-bit mach header appears at the very beginning of object files for</span></span><br><span class="line"><span class="comment"> * 64-bit architectures.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mach_header_64</span> &#123;</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	magic;		<span class="comment">/* mach magic number identifier */</span></span><br><span class="line">	<span class="keyword">cpu_type_t</span>	cputype;	<span class="comment">/* cpu specifier */</span></span><br><span class="line">	<span class="keyword">cpu_subtype_t</span>	cpusubtype;	<span class="comment">/* machine specifier */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	filetype;	<span class="comment">/* type of file */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	ncmds;		<span class="comment">/* number of load commands */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	sizeofcmds;	<span class="comment">/* the size of all the load commands */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	flags;		<span class="comment">/* flags */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	reserved;	<span class="comment">/* reserved */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们看到32位和64位的<code>mach_header</code>基本是一致的，只是在64位中新增了<code>reserved</code>字段，下面我们来看下其中每个字段所表示的意义。</p>
<h4 id="Magic-Number"><a href="#Magic-Number" class="headerlink" title="Magic Number"></a>Magic Number</h4><table>
<thead>
<tr>
<th>offset</th>
<th>data</th>
<th>description</th>
<th>value</th>
</tr>
</thead>
<tbody><tr>
<td>00000000</td>
<td>FEEDFACF</td>
<td>Magic Number</td>
<td>MH_MAGIC_64</td>
</tr>
</tbody></table>
<p>我们可以将其直译为<code>魔数</code>，他的值(Value)有两个:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	MH_MAGIC	0xfeedface	<span class="comment">/* the mach magic number */</span> 32位</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MH_MAGIC_64 0xfeedfacf <span class="comment">/* the 64-bit mach magic number */</span> 64位</span></span><br></pre></td></tr></table></figure>
<p>用于这个Mach-O文件的标识，有32位和64位两个值。由此可以看出我们的示例是一个64位的Mach-O文件。</p>
<h4 id="CPU-Type-CPU-SubType"><a href="#CPU-Type-CPU-SubType" class="headerlink" title="CPU Type ,CPU SubType"></a>CPU Type ,CPU SubType</h4><table>
<thead>
<tr>
<th>offset</th>
<th>data</th>
<th>description</th>
<th>value</th>
</tr>
</thead>
<tbody><tr>
<td>00000004</td>
<td>0100000C</td>
<td>CPU Type</td>
<td>CPU_TYPE_64</td>
</tr>
<tr>
<td>00000008</td>
<td>00000000</td>
<td>CPU SubType</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>00000000</td>
<td>CPU_SubType_ARM64_ALL</td>
</tr>
</tbody></table>
<p>CPU Type和CPU SubType 表示支持的CUP架构类型和子类型，如ARM。而具体的类型有哪些我们可以通过查询<code>/mach/machine.h.</code>中的定义查看这里不做过多的扩展,具体可以看<a target="_blank" rel="noopener" href="https://opensource.apple.com/source/xnu/xnu-4570.41.2/osfmk/mach/machine.h.auto.html">这里</a><br>我们的示例中，APP是支持所有arm64的机型的:CUP_SUBTYPE_ARM64_ALL。</p>
<h4 id="File-Type"><a href="#File-Type" class="headerlink" title="File Type"></a>File Type</h4><table>
<thead>
<tr>
<th>offset</th>
<th>data</th>
<th>description</th>
<th>value</th>
</tr>
</thead>
<tbody><tr>
<td>0000000C</td>
<td>00000002</td>
<td>File Type</td>
<td>MH_EXECUTE</td>
</tr>
</tbody></table>
<p>File Type 表示 Mach-O的文件类型。包括</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#define	MH_OBJECT	0x1		&#x2F;* Target 文件：编译器对源码编译后得到的中间结果 *&#x2F;</span><br><span class="line">#define	MH_EXECUTE	0x2		&#x2F;* 可执行二进制文件 *&#x2F;</span><br><span class="line">#define	MH_FVMLIB	0x3		&#x2F;* VM 共享库文件（还不清楚是什么东西） *&#x2F;</span><br><span class="line">#define	MH_CORE		0x4		&#x2F;* Core 文件，一般在 App Crash 产生 *&#x2F;</span><br><span class="line">#define	MH_PRELOAD	0x5		&#x2F;* preloaded executable file *&#x2F;</span><br><span class="line">#define	MH_DYLIB	0x6		   &#x2F;* 动态库 *&#x2F;</span><br><span class="line">#define	MH_DYLINKER	0x7		&#x2F;* 动态连接器 &#x2F;usr&#x2F;lib&#x2F;dyld *&#x2F;</span><br><span class="line">#define	MH_BUNDLE	0x8		&#x2F;* 非独立的二进制文件，往往通过 gcc-bundle 生成 *&#x2F;</span><br><span class="line">#define	MH_DYLIB_STUB	0x9	&#x2F;* 静态链接文件（还不清楚是什么东西） *&#x2F;</span><br><span class="line">#define	MH_DSYM		0xa		&#x2F;* 符号文件以及调试信息，在解析堆栈符号中常用 *&#x2F;</span><br><span class="line">#define	MH_KEXT_BUNDLE	0xb	&#x2F;* x86_64 内核扩展 *&#x2F;</span><br></pre></td></tr></table></figure>
<p>这里类型均是在<code>loader.h</code>文件中定义的</p>
<p>对于我们示例中的我们的File Type为 <code>MH_EXECUTE</code>表示 可执行的二进制文件。</p>
<h4 id="ncmds-Number-of-Load-Commands"><a href="#ncmds-Number-of-Load-Commands" class="headerlink" title="ncmds(Number of Load Commands)"></a>ncmds(Number of Load Commands)</h4><table>
<thead>
<tr>
<th>offset</th>
<th>data</th>
<th>description</th>
<th>value</th>
</tr>
</thead>
<tbody><tr>
<td>00000010</td>
<td>00000017</td>
<td>Number of Load Commands</td>
<td>23</td>
</tr>
</tbody></table>
<p>ncmds表示load command的数量。在我们的示例中表示数量为23个。</p>
<h4 id="sizeofcmds-Size-of-Load-Commands"><a href="#sizeofcmds-Size-of-Load-Commands" class="headerlink" title="sizeofcmds(Size of Load Commands)"></a>sizeofcmds(Size of Load Commands)</h4><table>
<thead>
<tr>
<th>offset</th>
<th>data</th>
<th>description</th>
<th>value</th>
</tr>
</thead>
<tbody><tr>
<td>00000014</td>
<td>00000AF8</td>
<td>Size of Load Commands</td>
<td>2808</td>
</tr>
</tbody></table>
<p>sizeofcmds表示所有load command的总大小。示例中总大小为2808。</p>
<h4 id="Flags"><a href="#Flags" class="headerlink" title="Flags"></a>Flags</h4><table>
<thead>
<tr>
<th>offset</th>
<th>data</th>
<th>description</th>
<th>value</th>
</tr>
</thead>
<tbody><tr>
<td>00000018</td>
<td>00200085</td>
<td>Flags</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>00000001</td>
<td>MH_NOUNDEFS</td>
</tr>
<tr>
<td></td>
<td></td>
<td>00000004</td>
<td>MH_DYLDLINK</td>
</tr>
<tr>
<td></td>
<td></td>
<td>00000080</td>
<td>MH_TWOLEVEL</td>
</tr>
<tr>
<td></td>
<td></td>
<td>00200000</td>
<td>MH_PIE</td>
</tr>
</tbody></table>
<p>Flags 是Mach-O文件的标志位。主要作用是告诉系统该如何加载这个Mach-O文件以及该文件的一些特性。有很多值，我们取常见的几种</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	MH_NOUNDEFS	0x1		<span class="comment">/* Target 文件中没有带未定义的符号，常为静态二进制文件 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MH_SPLIT_SEGS	0x20  <span class="comment">/* Target 文件中的只读 Segment 和可读写 Segment 分开  */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MH_TWOLEVEL	0x80		<span class="comment">/* 该 Image 使用二级命名空间(two name space binding)绑定方案 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MH_FORCE_FLAT	0x100 <span class="comment">/* 使用扁平命名空间(flat name space binding)绑定（与 MH_TWOLEVEL 互斥） */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MH_WEAK_DEFINES	0x8000 <span class="comment">/* 二进制文件使用了弱符号 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MH_BINDS_TO_WEAK 0x10000 <span class="comment">/* 二进制文件链接了弱符号 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MH_ALLOW_STACK_EXECUTION 0x20000<span class="comment">/* 允许 Stack 可执行 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	MH_PIE 0x200000  <span class="comment">/* 加载程序在随机的地址空间，只在 MH_EXECUTE中使用 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MH_NO_HEAP_EXECUTION 0x1000000 <span class="comment">/* 将 Heap 标记为不可执行，可防止 heap spray 攻击 */</span></span></span><br></pre></td></tr></table></figure>

<p>结合我们的示例，我们共有4个Flags:</p>
<ul>
<li>MH_NOUNDEFS</li>
<li>MH_DYLDLINK dyld是苹果公司的动态链接库，用来把Mach-O文件加载入内存</li>
<li>MH_TWOLEVEL 表示其符号空间中还会包含所在库的信息。这样可以使得不同的库导出通用的符号。与其相对的是扁平命名空间。</li>
<li>MH_PIE 每次系统加载进程后，都会为其随机分配一个虚拟内存空间(在传统系统中，进程每次加载的虚拟内存是相同的。这就让黑客有可能篡改内存来破解软件)</li>
</ul>
<p><code>注意</code>:flags的值也定义在loader.h文件中 都可以通过源码查看。</p>
<h3 id="Load-Commands"><a href="#Load-Commands" class="headerlink" title="Load Commands"></a>Load Commands</h3><p>Load Commands 紧跟在Header之后，用来告诉内核和dyld，如何将各个Segment加载入内存中。load command被源码表示为struct，有若干种load command，但是共同的特点是，在其结构的开头处，必须是如下两个属性：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The load commands directly follow the mach_header.  The total size of all</span></span><br><span class="line"><span class="comment"> * of the commands is given by the sizeofcmds field in the mach_header.  All</span></span><br><span class="line"><span class="comment"> * load commands must have as their first two fields cmd and cmdsize.  </span></span><br><span class="line"><span class="comment"> * The cmd</span></span><br><span class="line"><span class="comment"> * field is filled in with a constant for that command type.  </span></span><br><span class="line"><span class="comment"> * Each command type</span></span><br><span class="line"><span class="comment"> * has a structure specifically for it.  </span></span><br><span class="line"><span class="comment"> * The cmdsize field is the size in bytes</span></span><br><span class="line"><span class="comment"> * of the particular load command structure plus anything that follows it that</span></span><br><span class="line"><span class="comment"> * is a part of the load command (i.e. section structures, strings, etc.). </span></span><br><span class="line"><span class="comment"> *  To</span></span><br><span class="line"><span class="comment"> * advance to the next load command the cmdsize can be added to the offset or</span></span><br><span class="line"><span class="comment"> * pointer of the current load command.  </span></span><br><span class="line"><span class="comment"> * The cmdsize for 32-bit architectures</span></span><br><span class="line"><span class="comment"> * MUST be a multiple of 4 bytes and for 64-bit architectures MUST be a multiple</span></span><br><span class="line"><span class="comment"> * of 8 bytes (these are forever the maximum alignment of any load commands).</span></span><br><span class="line"><span class="comment"> * The padded bytes must be zero.  All tables in the object file must also</span></span><br><span class="line"><span class="comment"> * follow these rules so the file can be memory mapped.  Otherwise the pointers</span></span><br><span class="line"><span class="comment"> * to these tables will not work well or at all on some machines.  With all</span></span><br><span class="line"><span class="comment"> * padding zeroed like objects will compare byte for byte.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">load_command</span> &#123;</span></span><br><span class="line">	<span class="keyword">uint32_t</span> cmd;		<span class="comment">/* type of load command */</span></span><br><span class="line">	<span class="keyword">uint32_t</span> cmdsize;	<span class="comment">/* total size of command in bytes */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>对应我们示例中的Load Commands</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gi8zwcgxxfj31py0s645r.jpg"></p>
<p>我们在尝试去理解<code>load_command</code>的注释:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">load commands紧跟着mach_header,load commands的总大小由mach_header汇总的sizeofcmds字段给出，所有的load commands都必须以cmd和cmdsize两个字段作为前两个字段(结合我们的示例也得到验证)，cmd字段的值为commandtype常量，每一个commandtype都有一种特定的结构。cmdsize字段以字节为单位包含loadcommand结构和额外的其他字段(例如  section structures，strings等)。要前进到下一个加载命令，可以将cmdsize添加到当前加载命令的偏移量或指针。对于32位体系结构的cmdsize</span><br><span class="line"> 必须是4字节的倍数，并且对于64位架构，必须是8字节的倍数（这些永远是所有装入命令的最大对齐),填充字节必须为零。</span><br></pre></td></tr></table></figure>

<h4 id="Segment"><a href="#Segment" class="headerlink" title="Segment"></a>Segment</h4><p>在这么多的load command中，需要我们重点关注的是segment load command，segment command解释了该如何将Data中的各个Segment加载入内存中，而和我们APP相关的逻辑及数据，则大部分位于各个Segment中。</p>
<p>而和我们的Run time相关的Segment，则位于__DATA类型Segment下。</p>
<p>Segment load command也分为32位和64位：</p>
<p>32位</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The segment load command indicates that a part of this file is to be</span></span><br><span class="line"><span class="comment"> * mapped into the task&#x27;s address space.  The size of this segment in memory,</span></span><br><span class="line"><span class="comment"> * vmsize, maybe equal to or larger than the amount to map from this file,</span></span><br><span class="line"><span class="comment"> * filesize.  The file is mapped starting at fileoff to the beginning of</span></span><br><span class="line"><span class="comment"> * the segment in memory, vmaddr.  The rest of the memory of the segment,</span></span><br><span class="line"><span class="comment"> * if any, is allocated zero fill on demand.  The segment&#x27;s maximum virtual</span></span><br><span class="line"><span class="comment"> * memory protection and initial virtual memory protection are specified</span></span><br><span class="line"><span class="comment"> * by the maxprot and initprot fields.  If the segment has sections then the</span></span><br><span class="line"><span class="comment"> * section structures directly follow the segment command and their size is</span></span><br><span class="line"><span class="comment"> * reflected in cmdsize.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">segment_command</span> &#123;</span> <span class="comment">/* for 32-bit architectures */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	cmd;		<span class="comment">/* LC_SEGMENT */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	cmdsize;	<span class="comment">/* includes sizeof section structs */</span></span><br><span class="line">	<span class="keyword">char</span>		segname[<span class="number">16</span>];	<span class="comment">/* segment name */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	vmaddr;		<span class="comment">/* memory address of this segment */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	vmsize;		<span class="comment">/* memory size of this segment */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	fileoff;	<span class="comment">/* file offset of this segment */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	filesize;	<span class="comment">/* amount to map from the file */</span></span><br><span class="line">	<span class="keyword">vm_prot_t</span>	maxprot;	<span class="comment">/* maximum VM protection */</span></span><br><span class="line">	<span class="keyword">vm_prot_t</span>	initprot;	<span class="comment">/* initial VM protection */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	nsects;		<span class="comment">/* number of sections in segment */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	flags;		<span class="comment">/* flags */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>64位</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The 64-bit segment load command indicates that a part of this file is to be</span></span><br><span class="line"><span class="comment"> * mapped into a 64-bit task&#x27;s address space.  If the 64-bit segment has</span></span><br><span class="line"><span class="comment"> * sections then section_64 structures directly follow the 64-bit segment</span></span><br><span class="line"><span class="comment"> * command and their size is reflected in cmdsize.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">segment_command_64</span> &#123;</span> <span class="comment">/* for 64-bit architectures */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	cmd;		<span class="comment">/* LC_SEGMENT_64 */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	cmdsize;	<span class="comment">/* includes sizeof section_64 structs */</span></span><br><span class="line">	<span class="keyword">char</span>		segname[<span class="number">16</span>];	<span class="comment">/* segment name */</span></span><br><span class="line">	<span class="keyword">uint64_t</span>	vmaddr;		<span class="comment">/* memory address of this segment */</span></span><br><span class="line">	<span class="keyword">uint64_t</span>	vmsize;		<span class="comment">/* memory size of this segment */</span></span><br><span class="line">	<span class="keyword">uint64_t</span>	fileoff;	<span class="comment">/* file offset of this segment */</span></span><br><span class="line">	<span class="keyword">uint64_t</span>	filesize;	<span class="comment">/* amount to map from the file */</span></span><br><span class="line">	<span class="keyword">vm_prot_t</span>	maxprot;	<span class="comment">/* maximum VM protection */</span></span><br><span class="line">	<span class="keyword">vm_prot_t</span>	initprot;	<span class="comment">/* initial VM protection */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	nsects;		<span class="comment">/* number of sections in segment */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	flags;		<span class="comment">/* flags */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>32位和64位的segment_command基本一致，只是在64位的结构中把和寻址相关的数据类型由<code>uint32_t</code>改为<code>uint64_t</code></p>
<p>我们先看下示例中，和Segment相关的Command：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gi90jod69hj30i808ewfe.jpg"></p>
<p>结合源码我们可以看到：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#define    SEG_PAGEZERO    &quot;__PAGEZERO&quot; &#x2F;* 当时 MH_EXECUTE 文件时，捕获到空指针 *&#x2F;</span><br><span class="line">#define    SEG_TEXT    &quot;__TEXT&quot; &#x2F;* 代码&#x2F;只读数据段 *&#x2F;</span><br><span class="line">#define    SEG_DATA    &quot;__DATA&quot; &#x2F;* 数据段 *&#x2F;</span><br><span class="line">#define    SEG_LINKEDIT    &quot;__LINKEDIT&quot; &#x2F;* 包含需要被动态链接器使用的符号和其他表，包括符号表、字符串表等 *&#x2F;</span><br></pre></td></tr></table></figure>

<p>根据前面结构图我们知道Load Commands实际上是一个二级结构:Segment-&gt;Section,正如示例中所示</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gi90uyqf0ij314k0c8n0z.jpg"></p>
<p>因此，下面我们在看下section的结构</p>
<h4 id="Section"><a href="#Section" class="headerlink" title="Section"></a>Section</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * A segment is made up of zero or more sections.  Non-MH_OBJECT files have</span></span><br><span class="line"><span class="comment"> * all of their segments with the proper sections in each, and padded to the</span></span><br><span class="line"><span class="comment"> * specified segment alignment when produced by the link editor.  The first</span></span><br><span class="line"><span class="comment"> * segment of a MH_EXECUTE and MH_FVMLIB format file contains the mach_header</span></span><br><span class="line"><span class="comment"> * and load commands of the object file before its first section.  The zero</span></span><br><span class="line"><span class="comment"> * fill sections are always last in their segment (in all formats).  This</span></span><br><span class="line"><span class="comment"> * allows the zeroed segment padding to be mapped into memory where zero fill</span></span><br><span class="line"><span class="comment"> * sections might be. The gigabyte zero fill sections, those with the section</span></span><br><span class="line"><span class="comment"> * type S_GB_ZEROFILL, can only be in a segment with sections of this type.</span></span><br><span class="line"><span class="comment"> * These segments are then placed after all other segments.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The MH_OBJECT format has all of its sections in one segment for</span></span><br><span class="line"><span class="comment"> * compactness.  There is no padding to a specified segment boundary and the</span></span><br><span class="line"><span class="comment"> * mach_header and load commands are not part of the segment.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Sections with the same section name, sectname, going into the same segment,</span></span><br><span class="line"><span class="comment"> * segname, are combined by the link editor.  The resulting section is aligned</span></span><br><span class="line"><span class="comment"> * to the maximum alignment of the combined sections and is the new section&#x27;s</span></span><br><span class="line"><span class="comment"> * alignment.  The combined sections are aligned to their original alignment in</span></span><br><span class="line"><span class="comment"> * the combined section.  Any padded bytes to get the specified alignment are</span></span><br><span class="line"><span class="comment"> * zeroed.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The format of the relocation entries referenced by the reloff and nreloc</span></span><br><span class="line"><span class="comment"> * fields of the section structure for mach object files is described in the</span></span><br><span class="line"><span class="comment"> * header file &lt;reloc.h&gt;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> section &#123; <span class="comment">/* for 32-bit architectures */</span></span><br><span class="line">	<span class="keyword">char</span>		sectname[<span class="number">16</span>];	<span class="comment">/* name of this section Section 名字 */</span></span><br><span class="line">	<span class="keyword">char</span>		segname[<span class="number">16</span>];	<span class="comment">/* segment this section goes in */</span></span><br><span class="line">	uint32_t	addr;		<span class="comment">/* memory address of this section */</span></span><br><span class="line">	uint32_t	size;		<span class="comment">/* size in bytes of this section */</span></span><br><span class="line">	uint32_t	offset;		<span class="comment">/* file offset of this section */</span></span><br><span class="line">	uint32_t	align;		<span class="comment">/* section alignment (power of 2) */</span></span><br><span class="line">	uint32_t	reloff;		<span class="comment">/* file offset of relocation entries */</span></span><br><span class="line">	uint32_t	nreloc;		<span class="comment">/* number of relocation entries */</span></span><br><span class="line">	uint32_t	flags;		<span class="comment">/* flags (section type and attributes)*/</span></span><br><span class="line">	uint32_t	reserved1;	<span class="comment">/* reserved (for offset or index) */</span></span><br><span class="line">	uint32_t	reserved2;	<span class="comment">/* reserved (for count or sizeof) */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> section_64 &#123; <span class="comment">/* for 64-bit architectures */</span></span><br><span class="line">	<span class="keyword">char</span>		sectname[<span class="number">16</span>];	<span class="comment">/* Section 名字 */</span></span><br><span class="line">	<span class="keyword">char</span>		segname[<span class="number">16</span>];	<span class="comment">/* 所在的Segment名称*/</span></span><br><span class="line">	uint64_t	addr;		<span class="comment">/* Section 所在的内存地址 */</span></span><br><span class="line">	uint64_t	size;		<span class="comment">/* Section 的大小 */</span></span><br><span class="line">	uint32_t	offset;		<span class="comment">/* Section 所在的文件偏移 */</span></span><br><span class="line">	uint32_t	align;		<span class="comment">/* Section 的内存对齐边界 (2 的次幂) */</span></span><br><span class="line">	uint32_t	reloff;		<span class="comment">/* 重定位信息的文件偏移 */</span></span><br><span class="line">	uint32_t	nreloc;		<span class="comment">/* 重定位条目的数目 */</span></span><br><span class="line">	uint32_t	flags;		<span class="comment">/* 标志属性 (section type and attributes)*/</span></span><br><span class="line">	uint32_t	reserved1;	<span class="comment">/* 保留字段1 (for offset or index) */</span></span><br><span class="line">	uint32_t	reserved2;	<span class="comment">/* 保留字段2 (for count or sizeof) */</span></span><br><span class="line">	uint32_t	reserved3;	<span class="comment">/* 保留字段3 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在64位和32位的section定义中，64位新增了一个reserved3保留字段，以及将section的addr和size字段由原来的uint32_t类型升级为uint64_t。</p>
<p>在Data中，程序的逻辑和数据是按照Segment（段）存储，在Segment中，又分为0或多个section，每个section中在存储实际的内容。而之所以这么做的原因在于，在section中，可以不用内存对齐达到节约内存的作用，而所有的section作为整体的Segment，又可以整体的内存对齐。</p>
<p>结合我们示例中的一个section结构如下图：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gi914f1x7fj31240ie0vn.jpg"></p>
<h3 id="DATA-数据"><a href="#DATA-数据" class="headerlink" title="DATA(数据)"></a>DATA(数据)</h3><p>Mach-O的Data部分，其实是真正存储APP二进制数据的位置，前面的header和load command，仅是提供文件的说明以及加载信息的功能。</p>
<p>前面我们介绍过，我们通过Load Commands从DATA中读取数据，而Load Commands被划分成了多个Segment，也就是说 我们通过不同的Load Commands从DATA中读取不同的数据。</p>
<p>在介绍Segment的时候我们说过Segment被划分成<code>__PAGEZERO</code>,<code>__TEXT</code>,<code>__DATA</code>,<code>__LINKEDIT</code>这几段。</p>
<p>结合我们的示例，我们发现DATA被划分为:<code>__TEXT</code>,<code>__DATA</code></p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gi91bdekm9j31j80u0gy7.jpg"></p>
<p>下面我们来看下这几个数据段(section):</p>
<h4 id="TEXT段"><a href="#TEXT段" class="headerlink" title="__TEXT段"></a>__TEXT段</h4><p>__TEXT是程序的只读段，用于保存我们所写的代码和字符串常量，const修饰常量等。</p>
<p>下面是几个我们常见的section：</p>
<table>
<thead>
<tr>
<th>Section</th>
<th>存储内容</th>
</tr>
</thead>
<tbody><tr>
<td>__TEXT.__text</td>
<td>主程序代码</td>
</tr>
<tr>
<td>__TEXT.__cstring</td>
<td>C 语言字符串</td>
</tr>
<tr>
<td>__TEXT.__const</td>
<td>const 关键字修饰的常量</td>
</tr>
<tr>
<td>__TEXT.__stubs</td>
<td>用于 Stub 的占位代码，很多地方称之为桩代码。</td>
</tr>
<tr>
<td>__TEXT.__stubs_helper</td>
<td>当 Stub 无法找到真正的符号地址后的最终指向</td>
</tr>
<tr>
<td>__TEXT.__objc_methname</td>
<td>Objective-C 方法名称</td>
</tr>
<tr>
<td>__TEXT.__objc_methtype</td>
<td>Objective-C 方法类型</td>
</tr>
<tr>
<td>__TEXT.__objc_classname</td>
<td>Objective-C 类名称</td>
</tr>
</tbody></table>
<p>我们来结合示例看下这几个section的内容：</p>
<h5 id="cstring"><a href="#cstring" class="headerlink" title="cstring"></a>cstring</h5><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gi939ehxldj31vk0mu7ef.jpg"></p>
<p>我们可以从中看到<code>lw_property</code>,<code>lw_publicproperty</code>这两个属性名。以及我们打印的NSLog中的内容,同时我们发现，我们可能定义的某些三方key或者appid在这里都暴露在外部。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static const NSString *lw_constsecretKey &#x3D; @&quot;11234455556&quot;;</span><br></pre></td></tr></table></figure>

<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gi93d875bdj31r60imtgw.jpg"></p>
<h5 id="objc-methname"><a href="#objc-methname" class="headerlink" title="objc_methname"></a>objc_methname</h5><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gi91tzgretj31oq0j247e.jpg"></p>
<p>我们可以看到我们自定义的方法名<code>lw_publicMethod</code>,<code>lw_privateMethod</code>以及<code>lw_property</code>,<code>lw_publicproperty</code>重写的setter和getter方法。</p>
<h5 id="classname"><a href="#classname" class="headerlink" title="classname"></a>classname</h5><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gi91z90xhnj31og0fo43z.jpg"></p>
<p>我们可以看到我们自定义的类的类:<code>LWCustomClass</code></p>
<h4 id="DATA"><a href="#DATA" class="headerlink" title="_DATA"></a>_DATA</h4><p>__DATA段用于存储程序中所定义的数据，可读写。__DATA段下常见的sectin有：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gigtuycksmj30jo0pqgpu.jpg"></p>
<p>下面我们看下常见的__DATA下的section:</p>
<table>
<thead>
<tr>
<th>Section</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>__DATA.__data</td>
<td>初始化过的可变数据</td>
</tr>
<tr>
<td>__DATA.__la_symbol_ptr</td>
<td>lazy binding 的指针表，表中的指针一开始都指向 __stub_helper</td>
</tr>
<tr>
<td>__DATA.nl_symbol_ptr</td>
<td>非 lazy binding 的指针表，每个表项中的指针都指向一个在装载过程中，被动态链机器搜索完成的符号</td>
</tr>
<tr>
<td>__DATA.__const</td>
<td>没有初始化过的常量</td>
</tr>
<tr>
<td>__DATA.__cfstring</td>
<td>程序中使用的 Core Foundation 字符串（CFStringRefs）</td>
</tr>
<tr>
<td>__DATA.__bss</td>
<td>BSS，存放为初始化的全局变量，即常说的静态内存分配</td>
</tr>
<tr>
<td>__DATA.__common</td>
<td>没有初始化过的符号声明</td>
</tr>
<tr>
<td>__DATA.__objc_classlist</td>
<td>Objective-C 类列表</td>
</tr>
<tr>
<td>__DATA.__objc_protolist</td>
<td>Objective-C 协议列表</td>
</tr>
<tr>
<td>__DATA.__objc_imginfo</td>
<td>Objective-C 镜像信息</td>
</tr>
<tr>
<td>__DATA.__objc_selfrefs</td>
<td>Objective-C self 引用</td>
</tr>
<tr>
<td>__DATA.__objc_protorefs</td>
<td>Objective-C 原型引用</td>
</tr>
<tr>
<td>__DATA.__objc_superrefs</td>
<td>Objective-C 超类引用</td>
</tr>
</tbody></table>
<p>这些以objc开头的DATA字段都是跟runtime有关的，后面我们会详细分析。</p>
<h5 id="objc-imageinfo"><a href="#objc-imageinfo" class="headerlink" title="__objc_imageinfo"></a>__objc_imageinfo</h5><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gih51mnkp7j31n60s6agt.jpg"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">objc_image_info</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> version; <span class="comment">// currently 0</span></span><br><span class="line">    <span class="keyword">uint32_t</span> flags;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __cplusplus &gt;= 201103L</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// 位移枚举 </span></span><br><span class="line">    <span class="keyword">enum</span> : <span class="keyword">uint32_t</span> &#123;</span><br><span class="line">        IsReplacement       = <span class="number">1</span>&lt;&lt;<span class="number">0</span>,  <span class="comment">// used for Fix&amp;Continue, now ignored</span></span><br><span class="line">        SupportsGC          = <span class="number">1</span>&lt;&lt;<span class="number">1</span>,  <span class="comment">// 是否支持垃圾回收</span></span><br><span class="line">        RequiresGC          = <span class="number">1</span>&lt;&lt;<span class="number">2</span>,  <span class="comment">// 镜像是否需要回收</span></span><br><span class="line">        OptimizedByDyld     = <span class="number">1</span>&lt;&lt;<span class="number">3</span>,  <span class="comment">// image is from an optimized shared cache</span></span><br><span class="line">        CorrectedSynthesize = <span class="number">1</span>&lt;&lt;<span class="number">4</span>,  <span class="comment">// used for an old workaround, now ignored</span></span><br><span class="line">        IsSimulated         = <span class="number">1</span>&lt;&lt;<span class="number">5</span>,  <span class="comment">// image compiled for a simulator platform</span></span><br><span class="line">        HasCategoryClassProperties  = <span class="number">1</span>&lt;&lt;<span class="number">6</span>,  <span class="comment">// class properties in category_t</span></span><br><span class="line"></span><br><span class="line">        SwiftVersionMaskShift = <span class="number">8</span>,</span><br><span class="line">        SwiftVersionMask    = <span class="number">0xff</span> &lt;&lt; SwiftVersionMaskShift  <span class="comment">// Swift ABI version</span></span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">enum</span> : <span class="keyword">uint32_t</span> &#123;</span><br><span class="line">        SwiftVersion1   = <span class="number">1</span>,</span><br><span class="line">        SwiftVersion1_2 = <span class="number">2</span>,</span><br><span class="line">        SwiftVersion2   = <span class="number">3</span>,</span><br><span class="line">        SwiftVersion3   = <span class="number">4</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isReplacement</span><span class="params">()</span>   <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> flags &amp; IsReplacement; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">supportsGC</span><span class="params">()</span>      <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> flags &amp; SupportsGC; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">requiresGC</span><span class="params">()</span>      <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> flags &amp; RequiresGC; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">optimizedByDyld</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> flags &amp; OptimizedByDyld; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasCategoryClassProperties</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> flags &amp; HasCategoryClassProperties; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">containsSwift</span><span class="params">()</span>   <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> (flags &amp; SwiftVersionMask) != <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">uint32_t</span> <span class="title">swiftVersion</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> (flags &amp; SwiftVersionMask) &gt;&gt; SwiftVersionMaskShift; &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125; objc_image_info;</span><br></pre></td></tr></table></figure>

<p>我们发现<code>objc_image_info</code>中主要是有version字段和flag字段，</p>
<h5 id="objc-classlist"><a href="#objc-classlist" class="headerlink" title="__objc_classlist"></a>__objc_classlist</h5><p>这个section列出了所有的class，包括meta class。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gih4x7u5ckj31pr0u01b9.jpg"></p>
<p>图中的value值是就是这个类结构体的地址(包括元类)，类结构体的结构为objc中的objc_class结构体，结构如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_class : objc_object &#123;</span><br><span class="line">    <span class="comment">// Class ISA;</span></span><br><span class="line">    Class superclass;</span><br><span class="line">    cache_t cache;             <span class="comment">// formerly cache pointer and vtable</span></span><br><span class="line">    class_data_bits_t bits;    <span class="comment">// class_rw_t * plus custom rr/alloc flags</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="objc-catlist"><a href="#objc-catlist" class="headerlink" title="__objc_catlist"></a>__objc_catlist</h5><p>这里可以查看代码中的所有分类，其value的值为指向分类结构体的指针</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gih63wv6xzj31mv0u04jn.jpg"></p>
<p>对应oc中的结构为category_t，具体结构如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> category_t &#123;</span><br><span class="line">    <span class="comment">// 是指 class_name 而不是 category_name</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="comment">// 要扩展的类对象，编译期间是不会定义的，而是在运行时通过 * name 对应到对应的类对象。</span></span><br><span class="line">    classref_t cls;</span><br><span class="line">    <span class="comment">// 对象方法列表</span></span><br><span class="line">    <span class="keyword">struct</span> method_list_t *instanceMethods;</span><br><span class="line">    <span class="comment">// 类方法列表</span></span><br><span class="line">    <span class="keyword">struct</span> method_list_t *classMethods;</span><br><span class="line">    <span class="comment">// 协议列表</span></span><br><span class="line">    <span class="keyword">struct</span> protocol_list_t *protocols;</span><br><span class="line">    <span class="comment">// 实例属性</span></span><br><span class="line">    <span class="keyword">struct</span> property_list_t *instanceProperties;</span><br><span class="line">    <span class="comment">// Fields below this point are not always present on disk.</span></span><br><span class="line">    <span class="comment">// 类属性(这个结构体以_开头命名？？？)</span></span><br><span class="line">    <span class="keyword">struct</span> property_list_t *_classProperties;</span><br><span class="line">    <span class="comment">// methodsForMeta 返回类方法列表或者对象方法列表</span></span><br><span class="line">    method_list_t *methodsForMeta(<span class="keyword">bool</span> isMeta) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isMeta) <span class="keyword">return</span> classMethods;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> instanceMethods;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 属性列表返回方法</span></span><br><span class="line">    property_list_t *propertiesForMeta(<span class="keyword">bool</span> isMeta, <span class="keyword">struct</span> header_info *hi);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="objc-protolist"><a href="#objc-protolist" class="headerlink" title="__objc_protolist"></a>__objc_protolist</h5><p>该Section中记录了项目中所有的协议。 其value值为指向协议的指针</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gih6ao4ee6j31nd0u01b2.jpg"></p>
<p>协议的结构体为protocol_t，具体如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">struct</span> protocol_t : objc_object &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *mangledName;</span><br><span class="line">    <span class="keyword">struct</span> protocol_list_t *protocols;</span><br><span class="line">    method_list_t *instanceMethods;</span><br><span class="line">    method_list_t *classMethods;</span><br><span class="line">    method_list_t *optionalInstanceMethods;</span><br><span class="line">    method_list_t *optionalClassMethods;</span><br><span class="line">    property_list_t *instanceProperties;</span><br><span class="line">    uint32_t size;   <span class="comment">// sizeof(protocol_t)</span></span><br><span class="line">    uint32_t flags;</span><br><span class="line">    <span class="comment">// Fields below this point are not always present on disk.</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> **_extendedMethodTypes;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *_demangledName;</span><br><span class="line">    property_list_t *_classProperties;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="objc-classrefs"><a href="#objc-classrefs" class="headerlink" title="__objc_classrefs"></a>__objc_classrefs</h5><p>该section记录了哪些class被引用了，这里记录了所有被实例化的class，有些类虽然在包里，但是我们并未使用，因此这里不会有。<br><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gih6fqzemuj31rl0u0dyd.jpg"></p>
<h5 id="objc-selrefs"><a href="#objc-selrefs" class="headerlink" title="__objc_selrefs"></a>__objc_selrefs</h5><p>这section记录哪些SEL对应的字符串被引用了，有系统方法，也有自定义方法：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gih4rgf693j31lk0u07qb.jpg"></p>
<h5 id="objc-superrefs"><a href="#objc-superrefs" class="headerlink" title="__objc_superrefs"></a>__objc_superrefs</h5><p>该section记录了调用super方法的类。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gih6sbnruvj31uy0u04gr.jpg"></p>
<p>比如，在子类方法中，我们调用了父类的方法，就会将子类记录在这里。</p>
<h5 id="objc-const"><a href="#objc-const" class="headerlink" title="__objc_const"></a>__objc_const</h5><p>该section用来记录在OC内存初始化过程中的不可变内容。这里所谓的不可变内容并不是我们在程序中所写的const NSInteger k = 5这种常量数据（它存在__TEXT的const section中），而是在OC内存布局中不可变得部分。</p>
<h3 id="应用启动"><a href="#应用启动" class="headerlink" title="应用启动"></a>应用启动</h3><p>根据上面介绍的在应用启动期间，dyld和kern会读取Mach-O文件中的Load Command去读取和加载_DATA数据段下的内容，而这一切都发生在main函数之前。所以我们看下main函数之前都发生了什么？</p>
<h4 id="启动调用堆栈"><a href="#启动调用堆栈" class="headerlink" title="启动调用堆栈"></a>启动调用堆栈</h4><p>添加一个符号断点(Symbolic BreakPoint)让应用在执行到<code>_objc_init</code>方法是断点执行。<br><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gip6quvmz0j30yk0d6qnx.jpg"></p>
<p>这样我们就能看到下面的这个调用栈:</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gip6q2kpiwj30nw0le4oi.jpg"></p>
<p>因为<code>_objc_init</code>方法是runtime的入口，因此在这之前调用的方法都是dyld和ImageLoader的操作</p>
<h4 id="dyld"><a href="#dyld" class="headerlink" title="dyld"></a>dyld</h4><p>dyld(the dynamic link editor)动态链接器,系统 kernel 做好启动程序的初始准备后，交给 dyld 负责，dyld的主要工作内容为(参考<a target="_blank" rel="noopener" href="https://www.mikeash.com/pyblog/friday-qa-2012-11-09-dyld-dynamic-linking-on-os-x.html"> dyld: Dynamic Linking On OS X </a>):</p>
<ul>
<li>从 kernel 留下的原始调用栈引导和启动自己</li>
<li>将程序依赖的动态链接库递归加载进内存，当然这里有缓存机制</li>
<li>non-lazy 符号立即 link 到可执行文件，lazy 的存表里</li>
<li>Runs static initializers for the executable</li>
<li>找到可执行文件的 main 函数，准备参数并调用</li>
<li>程序执行中负责绑定 lazy 符号、提供 runtime dynamic loading services、提供调试器接口</li>
<li>程序main函数 return 后执行 static terminator</li>
<li>某些场景下 main 函数结束后调 libSystem 的 _exit 函数</li>
</ul>
<h4 id="ImageLoader"><a href="#ImageLoader" class="headerlink" title="ImageLoader"></a>ImageLoader</h4><p>这里的image不是图片的意思，它是一个二进制文件，你可以把他理解为一个镜像文件。内部是被编译过的符号、代码等，因此<code>ImageLoader</code>作用是将这些文件加载进内存，且每一个文件对应一个<code>ImageLoader</code>实例来负责加载。</p>
<p>他的主要工作为：</p>
<ul>
<li>在程序运行时它先将动态链接的 image 递归加载 （也就是上面测试栈中一串的递归调用的时刻）</li>
<li>再从可执行文件 image 递归加载所有符号</li>
</ul>
<h4 id="ImageLoaderMachO"><a href="#ImageLoaderMachO" class="headerlink" title="ImageLoaderMachO"></a>ImageLoaderMachO</h4><p>顾名思义这里应该是去加载MachO文件，从堆栈中我们可以看到主要跟<code>doInitialization</code>方法和<code>doModInitFunctions</code>方法。</p>
<h5 id="doInitialization"><a href="#doInitialization" class="headerlink" title="doInitialization"></a>doInitialization</h5><p>这个方法的主要作用是：获取<code>Mach-O</code>的init方法的地址并调用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ImageLoaderMachO::doInitialization</span><span class="params">(<span class="keyword">const</span> LinkContext&amp; context)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	CRSetCrashLogMessage2(<span class="keyword">this</span>-&gt;getPath());</span><br><span class="line"></span><br><span class="line">	<span class="comment">// mach-o has -init and static initializers</span></span><br><span class="line">	doImageInit(context);</span><br><span class="line">	doModInitFunctions(context);</span><br><span class="line">	</span><br><span class="line">	CRSetCrashLogMessage2(<span class="literal">NULL</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> (fHasDashInit || fHasInitializers);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ImageLoaderMachO::doImageInit</span><span class="params">(<span class="keyword">const</span> LinkContext&amp; context)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> ( fHasDashInit ) &#123;</span><br><span class="line">		<span class="comment">// mach-o文件中指令的个数</span></span><br><span class="line">		<span class="keyword">const</span> <span class="keyword">uint32_t</span> cmd_count = ((macho_header*)fMachOData)-&gt;ncmds;</span><br><span class="line">		<span class="comment">// 遍历指令</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; cmd_count; ++i) &#123;</span><br><span class="line">			<span class="keyword">switch</span> (cmd-&gt;cmd) &#123;</span><br><span class="line">				<span class="keyword">case</span> LC_ROUTINES_COMMAND:</span><br><span class="line">					<span class="comment">// 获取macho_routines_command的init_address</span></span><br><span class="line">					Initializer func = (Initializer)(((struct macho_routines_command*)cmd)-&gt;init_address + fSlide);</span><br><span class="line">					<span class="comment">// 执行-init方法</span></span><br><span class="line">					func(context.argc, context.argv, context.envp, context.apple, &amp;context.programVars);</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 计算下一个指令((char*)cmd)+cmd-&gt;cmdsize</span></span><br><span class="line">			cmd = (<span class="keyword">const</span> struct load_command*)(((<span class="keyword">char</span>*)cmd)+cmd-&gt;cmdsize);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="doModInitFunctions"><a href="#doModInitFunctions" class="headerlink" title="doModInitFunctions"></a>doModInitFunctions</h5><p>这个方法的主要作用是：获取<code>Mach-O</code>的static initializer的地址并调用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ImageLoaderMachO::doModInitFunctions</span><span class="params">(<span class="keyword">const</span> LinkContext&amp; context)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> ( fHasInitializers ) &#123;</span><br><span class="line">	   <span class="comment">// mach-o文件中指令的个数</span></span><br><span class="line">		<span class="keyword">const</span> <span class="keyword">uint32_t</span> cmd_count = ((macho_header*)fMachOData)-&gt;ncmds;</span><br><span class="line">		<span class="comment">// 遍历所有的指令</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; cmd_count; ++i) &#123;</span><br><span class="line">		   <span class="comment">// 如果指令是Mach-o中的LC_SEGMENT_COMMAND</span></span><br><span class="line">			<span class="keyword">if</span> ( cmd-&gt;cmd == LC_SEGMENT_COMMAND ) &#123;</span><br><span class="line">			     <span class="comment">// 从sectionsStart到sectionsEnd</span></span><br><span class="line">					<span class="keyword">for</span> (<span class="keyword">const</span> struct macho_section* sect=sectionsStart; sect &lt; sectionsEnd; ++sect) &#123;</span><br><span class="line">					<span class="keyword">const</span> <span class="keyword">uint8_t</span> type = sect-&gt;flags &amp; SECTION_TYPE;</span><br><span class="line">					<span class="keyword">if</span> ( type == S_MOD_INIT_FUNC_POINTERS ) &#123;</span><br><span class="line">						</span><br><span class="line">						<span class="keyword">for</span> (<span class="keyword">size_t</span> i=<span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line">							<span class="keyword">if</span> ( context.verboseInit )</span><br><span class="line">								dyld::<span class="built_in">log</span>(<span class="string">&quot;dyld: calling initializer function %p in %s\n&quot;</span>, func, <span class="keyword">this</span>-&gt;getPath());</span><br><span class="line">							<span class="comment">// 执行initializer方法</span></span><br><span class="line">							func(context.argc, context.argv, context.envp, context.apple, &amp;context.programVars);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 根据指令的地址+指令大小获取到下一个指令</span></span><br><span class="line">			cmd = (<span class="keyword">const</span> struct load_command*)(((<span class="keyword">char</span>*)cmd)+cmd-&gt;cmdsize);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>上述我们介绍了Mach-O文件的主要结构，以及每个segment和section的功能和字段的作用，结尾处我们通过查看应用启动调用堆栈来确认Mach-O文件何时被ImageLoader解析并加载到内存中，提供给后续的runtime使用。鉴于main函数之前系统内核,dyld,ImageLoader,rumtime做了很多准备，我们决定新开一篇文章来讲述这个过程发生了什么，敬请期待！</p>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a target="_blank" rel="noopener" href="https://opensource.apple.com/source/dyld/dyld-95.3/src/ImageLoaderMachO.cpp.auto.html">XNU源码</a><br><a target="_blank" rel="noopener" href="http://hawk0620.github.io/blog/2018/03/22/study-mach-o-file/#%E5%A6%82%E4%BD%95%E7%94%A8%20MachO%20%E6%96%87%E4%BB%B6%E5%85%B3%E8%81%94%E7%B1%BB%E7%9A%84%E6%96%B9%E6%B3%95%E5%90%8D">探秘 Mach-O 文件</a><br><a target="_blank" rel="noopener" href="https://jianli2017.top/wiki/IOS/MachO/MachO_FileStructure/">Mach-O文件结构理解</a><br><a target="_blank" rel="noopener" href="https://zhangbuhuai.com/post/macho-dynamic-link.html">Mach-O 与动态链接</a><br><a target="_blank" rel="noopener" href="https://blog.sunnyxx.com/2014/08/30/objc-pre-main/">iOS 程序 main 函数之前发生了什么</a></p>

    </div>
     
    <div class="post-footer__meta"><p>更新于 2020-12-05</p></div> 
    <div class="post-meta__cats"><a href="/categories/iOS%E9%AB%98%E7%BA%A7%E5%BC%80%E5%8F%91/" class="post-cats__link button">iOS高级开发</a><a href="/tags/Mach-O-%E5%8A%A0%E8%BD%BD%E5%99%A8/" class="post-tags__link button"># Mach-O 加载器</a></div> 
</article>


    <div class="nav">
        <div class="nav__prev">
            
                <a href="/2020/09/13/applaunchbeforemain/" class="nav__link">
                    <div>
                        <svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" width="24" height="24"><path d="M589.088 790.624L310.464 512l278.624-278.624 45.248 45.248L400.96 512l233.376 233.376z" fill="#808080"></path></svg>
                    </div>
                    <div>
                        <div class="nav__label">
                            Previous Post
                        </div>
                        <div class="nav__title">
                            应用启动-Main函数之前的那些事儿
                        </div>
                    </div>
                </a>
            
        </div>
        <div class="nav__next">
            
                <a href="/2020/08/22/runtimecategory/" class="nav__link">
                    <div>
                        <div class="nav__label">
                            Next Post
                        </div>
                        <div class="nav__title">
                            RunTime解析--Category(分类)实现
                        </div>
                    </div>
                    <div>
                        <svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" width="24" height="24"><path d="M434.944 790.624l-45.248-45.248L623.04 512l-233.376-233.376 45.248-45.248L713.568 512z" fill="#808080"></path></svg>
                    </div>
                </a>
            
        </div>
    </div>





</main>

            <footer class="footer">
    


    
    
    
        <span id="busuanzi_container_site_uv" hidden>
            <span></span>
            <span id="busuanzi_value_site_uv"></span>
            <span>Viewers</span>
            
                <span>&amp;nbsp;&amp;nbsp;&amp;nbsp;|</span>
            
        </span>
    
    
        <span id="busuanzi_container_site_pv" hidden>
            <span></span>
            <span id="busuanzi_value_site_pv"></span>
            <span>Views</span>
            
        </span>
    
 
 

 
    
        
        <p class="footer-copyright">
            Copyright © 2015&nbsp;-&nbsp;2020 <a href="/">LeeWong</a>
        </p>
    
    
    <p>Powered by <a href="https://hexo.io" target="_blank">Hexo</a> | Theme - <a href="https://github.com/ChrAlpha/hexo-theme-cards" target="_blank">Cards</a></p>
</footer>

        </div>
         

 
    <script>
        window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
        ga('create', '4NmLVard-jFEKaV6857m9tKb41Tpo4FiKj8L1TJg7lU', 'auto');
        ga('send', 'pageview');
    </script>
    <script async src="https://www.google-analytics.com/analytics.js"></script>
 

 

 
    <script>
        var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement('script');
            hm.src = 'https://hm.baidu.com/hm.js?DR81zbdrQ3';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(hm, s);
        })();
    </script>
 

  



 


    
 


    
<script src="https://cdn.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.min.js"></script>

    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.4.1/dist/jquery.fancybox.min.css">

    
<script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.4.1/dist/jquery.fancybox.min.js"></script>

    <script>
        let lazyloadT = Boolean('false'),
            auto_fancybox = Boolean('false')
        if (auto_fancybox) {
            $(".post__content").find('img').each(function () {
                var element = document.createElement("a");
                $(element).attr("data-fancybox", "gallery");
                $(element).attr("href", $(this).attr("src"));
                if (lazyloadT) {
                    $(element).attr("href", $(this).attr("data-srcset"));
                }
                $(this).wrap(element);
            });
        } else {
            $(".post__content").find("fancybox").find('img').each(function () {
                var element = document.createElement("a");
                $(element).attr("data-fancybox", "gallery");
                $(element).attr("href", $(this).attr("src"));
                if (lazyloadT) {
                    $(element).attr("href", $(this).attr("data-srcset"));
                }
                $(this).wrap(element);
            });
        }
    </script>
 

 

 

 




    </body>
</html>
