<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.1.1">
<meta name="google-site-verification" content="4NmLVard-jFEKaV6857m9tKb41Tpo4FiKj8L1TJg7lU" />
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.14.0/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.leewong.cn","root":"/","scheme":"Mist","version":"8.0.0-rc.5","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}};
  </script>

  <meta name="description" content="Mach-O为Mach Object文件格式的缩写，它是一种用于可执行文件，目标代码，动态库，内核转储的文件格式。作为a.out格式的替代，Mach-O提供了更强的扩展性，并提升了符号表中信息的访问速度。Mach-O格式为大部分基于Mach内核的操作系统所使用的，包括NeXTSTEP, Mac OS X和iOS，它们都以Mach-O格式作为其可执行文件，动态库，目标代码的文件格式。">
<meta property="og:type" content="article">
<meta property="og:title" content="Mach-O 探究">
<meta property="og:url" content="https://www.leewong.cn/2020/08/30/Mach-O/index.html">
<meta property="og:site_name" content="LeeWong">
<meta property="og:description" content="Mach-O为Mach Object文件格式的缩写，它是一种用于可执行文件，目标代码，动态库，内核转储的文件格式。作为a.out格式的替代，Mach-O提供了更强的扩展性，并提升了符号表中信息的访问速度。Mach-O格式为大部分基于Mach内核的操作系统所使用的，包括NeXTSTEP, Mac OS X和iOS，它们都以Mach-O格式作为其可执行文件，动态库，目标代码的文件格式。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/007S8ZIlly1gi8xlznb88j30fm0keajq.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/007S8ZIlly1gi8xow8jvoj30s40duwhk.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/007S8ZIlly1gi8xfafmakj30yq0hqah8.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/007S8ZIlgy1gi8xv47qi7j31fg0sc44j.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/007S8ZIlgy1gi8yhakxzbj30b50but9m.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/007S8ZIlgy1gi8yllkqyyj30ju1000y2.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/007S8ZIlgy1gi8xxtz5kij31fa0g6dkw.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/007S8ZIlgy1gi8zwcgxxfj31py0s645r.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/007S8ZIlgy1gi90jod69hj30i808ewfe.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/007S8ZIlgy1gi90uyqf0ij314k0c8n0z.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/007S8ZIlgy1gi914f1x7fj31240ie0vn.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/007S8ZIlgy1gi91bdekm9j31j80u0gy7.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/007S8ZIlly1gi939ehxldj31vk0mu7ef.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/007S8ZIlly1gi93d875bdj31r60imtgw.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/007S8ZIlgy1gi91tzgretj31oq0j247e.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/007S8ZIlgy1gi91z90xhnj31og0fo43z.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/007S8ZIlly1gigtuycksmj30jo0pqgpu.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/007S8ZIlly1gih51mnkp7j31n60s6agt.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/007S8ZIlly1gih4x7u5ckj31pr0u01b9.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/007S8ZIlly1gih63wv6xzj31mv0u04jn.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/007S8ZIlly1gih6ao4ee6j31nd0u01b2.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/007S8ZIlly1gih6fqzemuj31rl0u0dyd.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/007S8ZIlly1gih4rgf693j31lk0u07qb.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/007S8ZIlly1gih6sbnruvj31uy0u04gr.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/007S8ZIlly1gip6quvmz0j30yk0d6qnx.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/007S8ZIlly1gip6q2kpiwj30nw0le4oi.jpg">
<meta property="article:published_time" content="2020-08-30T08:20:39.000Z">
<meta property="article:modified_time" content="2020-09-13T11:25:25.969Z">
<meta property="article:author" content="LeeWong">
<meta property="article:tag" content="iOS">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://tva1.sinaimg.cn/large/007S8ZIlly1gi8xlznb88j30fm0keajq.jpg">


<link rel="canonical" href="https://www.leewong.cn/2020/08/30/Mach-O/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Mach-O 探究 | LeeWong</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=4NmLVard-jFEKaV6857m9tKb41Tpo4FiKj8L1TJg7lU"></script>
    <script>
      if (CONFIG.hostname === location.hostname) {
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', '4NmLVard-jFEKaV6857m9tKb41Tpo4FiKj8L1TJg7lU');
      }
    </script>


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?DR81zbdrQ3";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">LeeWong</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">What is Life But One Chanllege After Another</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <section class="post-toc-wrap sidebar-panel">
          <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#Mach-O%E7%AE%80%E4%BB%8B"><span class="nav-number">1.</span> <span class="nav-text">Mach-O简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Mach-O%E7%BB%93%E6%9E%84"><span class="nav-number">2.</span> <span class="nav-text">Mach-O结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Mach64-Header"><span class="nav-number">3.</span> <span class="nav-text">Mach64 Header</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Magic-Number"><span class="nav-number">3.1.</span> <span class="nav-text">Magic Number</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CPU-Type-CPU-SubType"><span class="nav-number">3.2.</span> <span class="nav-text">CPU Type ,CPU SubType</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#File-Type"><span class="nav-number">3.3.</span> <span class="nav-text">File Type</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ncmds-Number-of-Load-Commands"><span class="nav-number">3.4.</span> <span class="nav-text">ncmds(Number of Load Commands)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#sizeofcmds-Size-of-Load-Commands"><span class="nav-number">3.5.</span> <span class="nav-text">sizeofcmds(Size of Load Commands)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Flags"><span class="nav-number">3.6.</span> <span class="nav-text">Flags</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Load-Commands"><span class="nav-number">4.</span> <span class="nav-text">Load Commands</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Segment"><span class="nav-number">4.1.</span> <span class="nav-text">Segment</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Section"><span class="nav-number">4.2.</span> <span class="nav-text">Section</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DATA-%E6%95%B0%E6%8D%AE"><span class="nav-number">5.</span> <span class="nav-text">DATA(数据)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#TEXT%E6%AE%B5"><span class="nav-number">5.1.</span> <span class="nav-text">__TEXT段</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#cstring"><span class="nav-number">5.1.1.</span> <span class="nav-text">cstring</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#objc-methname"><span class="nav-number">5.1.2.</span> <span class="nav-text">objc_methname</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#classname"><span class="nav-number">5.1.3.</span> <span class="nav-text">classname</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#DATA"><span class="nav-number">5.2.</span> <span class="nav-text">_DATA</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#objc-imageinfo"><span class="nav-number">5.2.1.</span> <span class="nav-text">__objc_imageinfo</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#objc-classlist"><span class="nav-number">5.2.2.</span> <span class="nav-text">__objc_classlist</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#objc-catlist"><span class="nav-number">5.2.3.</span> <span class="nav-text">__objc_catlist</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#objc-protolist"><span class="nav-number">5.2.4.</span> <span class="nav-text">__objc_protolist</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#objc-classrefs"><span class="nav-number">5.2.5.</span> <span class="nav-text">__objc_classrefs</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#objc-selrefs"><span class="nav-number">5.2.6.</span> <span class="nav-text">__objc_selrefs</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#objc-superrefs"><span class="nav-number">5.2.7.</span> <span class="nav-text">__objc_superrefs</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#objc-const"><span class="nav-number">5.2.8.</span> <span class="nav-text">__objc_const</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E5%90%AF%E5%8A%A8"><span class="nav-number">6.</span> <span class="nav-text">应用启动</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%AF%E5%8A%A8%E8%B0%83%E7%94%A8%E5%A0%86%E6%A0%88"><span class="nav-number">6.1.</span> <span class="nav-text">启动调用堆栈</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#dyld"><span class="nav-number">6.2.</span> <span class="nav-text">dyld</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ImageLoader"><span class="nav-number">6.3.</span> <span class="nav-text">ImageLoader</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ImageLoaderMachO"><span class="nav-number">6.4.</span> <span class="nav-text">ImageLoaderMachO</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#doInitialization"><span class="nav-number">6.4.1.</span> <span class="nav-text">doInitialization</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#doModInitFunctions"><span class="nav-number">6.4.2.</span> <span class="nav-text">doModInitFunctions</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">7.</span> <span class="nav-text">总结</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E6%96%87%E7%AB%A0"><span class="nav-number">8.</span> <span class="nav-text">参考文章</span></a></li></ol></div>
      </section>
      <!--/noindex-->

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="LeeWong"
      src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gi7obtinvfj30hq0hqgme.jpg">
  <p class="site-author-name" itemprop="name">LeeWong</p>
  <div class="site-description" itemprop="description">What is Life But One Chanllege After Another</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">76</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">19</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">80</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/LeeWongSnail" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;LeeWongSnail" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/wangli_0632@163.com" title="E-Mail → wangli_0632@163.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </section>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/LeeWongSnail" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">
      

      

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.leewong.cn/2020/08/30/Mach-O/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://tva1.sinaimg.cn/large/007S8ZIlgy1gi7obtinvfj30hq0hqgme.jpg">
      <meta itemprop="name" content="LeeWong">
      <meta itemprop="description" content="What is Life But One Chanllege After Another">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LeeWong">
    </span>

    
    
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Mach-O 探究
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-08-30 16:20:39" itemprop="dateCreated datePublished" datetime="2020-08-30T16:20:39+08:00">2020-08-30</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-09-13 19:25:25" itemprop="dateModified" datetime="2020-09-13T19:25:25+08:00">2020-09-13</time>
      </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p><code>Mach-O</code>为<code>Mach Object</code>文件格式的缩写，它是一种用于可执行文件，目标代码，动态库，内核转储的文件格式。作为a.out格式的替代，Mach-O提供了更强的扩展性，并提升了符号表中信息的访问速度。<br><code>Mach-O</code>格式为大部分基于<code>Mach</code>内核的操作系统所使用的，包括<code>NeXTSTEP</code>, <code>Mac OS X</code>和<code>iOS</code>，它们都以<code>Mach-O</code>格式作为其可执行文件，动态库，目标代码的文件格式。</p>
<a id="more"></a>


<h3 id="Mach-O简介"><a href="#Mach-O简介" class="headerlink" title="Mach-O简介"></a>Mach-O简介</h3><p>在iOS开发中，我们的代码在编译后会生成一个.app的文件(Product文件夹下),而.app文件我们可以把它看做是一个文件夹,内部存放了APP正常运行所需要的文件，通常比较容易识别的是一些资源文件。如图：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gi8xlznb88j30fm0keajq.jpg"></p>
<p>我们通过显示包内容看下.app文件夹内都有什么：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gi8xow8jvoj30s40duwhk.jpg"></p>
<p>当然我们这片文章的主角也在这个文件夹内：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gi8xfafmakj30yq0hqah8.jpg"></p>
<p>系统识别Mach-O(这个名字是项目的名字)为可执行文件(Mach-O是一种可执行文件格式)，我们来看下这个文件,Mach-O文件是无法直接打开或者查看包内容，这里我们需要借助MachOView工具来查看，工具是开源的如果你想看具体的实现，你可以看<a target="_blank" rel="noopener" href="https://github.com/gdbinit/MachOView">工具的源码</a>，当然你可以直接<a target="_blank" rel="noopener" href="http://sourceforge.net/projects/machoview/">下载</a>使用。</p>
<p>打开后的页面是这样的：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gi8xv47qi7j31fg0sc44j.jpg"></p>
<h3 id="Mach-O结构"><a href="#Mach-O结构" class="headerlink" title="Mach-O结构"></a>Mach-O结构</h3><p>实际上我们从使用MachOView打开后的文件目录也可以看出，Mach-O的文件结构分为三大部分:<code>Header</code>,<code>Load Commands</code>,<code>Data</code>。</p>
<p>下面是官方提供的一张结构图：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gi8yhakxzbj30b50but9m.jpg"></p>
<p>根据上图，我们将我们看到的目录大致划分为：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gi8yllkqyyj30ju1000y2.jpg"></p>
<ul>
<li>Mach-O 头（Mach Header）：这里描述了 Mach-O 的 CPU 架构、文件类型以及加载命令等信息；</li>
<li>加载命令（Load Command）：当系统加载Mach-O文件时，load command会指导苹果的动态加载器(dyld)h或内核，该如何加载文件的Data数据。</li>
<li>数据区（Data）：Mach-O文件的数据区，包含代码和数据。其中包含若干Segment块，每个Segment块中包含0个或多个seciton。Segment根据对应的load command被dyld加载入内存中。</li>
</ul>
<p><code>注意</code>：通过对比我们发现实际上官网给出的结构并不准确，在实际结果中还包含了<code>Dynamic Loader Info</code>,<code>Function Starts</code>,<code>Symbol Table</code>,<code>Data In Code Entries</code>,<code>Dynamic Symbol Table</code>,<code>String Table</code>,<code>Code Signature</code>等。</p>
<p>下面我们来详细看下每部分的内容</p>
<h3 id="Mach64-Header"><a href="#Mach64-Header" class="headerlink" title="Mach64 Header"></a>Mach64 Header</h3><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gi8xxtz5kij31fa0g6dkw.jpg"></p>
<p>这里我们可以和苹果开源的Darwin源码一起看方便理解,源码在<a target="_blank" rel="noopener" href="https://opensource.apple.com/source/xnu/xnu-1456.1.26/EXTERNAL_HEADERS/mach-o/loader.h">这里</a>。</p>
<p>32位</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The 32-bit mach header appears at the very beginning of the object file for</span></span><br><span class="line"><span class="comment"> * 32-bit architectures.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mach_header</span> &#123;</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	magic;		<span class="comment">/* mach magic number identifier */</span></span><br><span class="line">	<span class="keyword">cpu_type_t</span>	cputype;	<span class="comment">/* cpu specifier */</span></span><br><span class="line">	<span class="keyword">cpu_subtype_t</span>	cpusubtype;	<span class="comment">/* machine specifier */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	filetype;	<span class="comment">/* type of file */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	ncmds;		<span class="comment">/* number of load commands */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	sizeofcmds;	<span class="comment">/* the size of all the load commands */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	flags;		<span class="comment">/* flags */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>64位:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The 64-bit mach header appears at the very beginning of object files for</span></span><br><span class="line"><span class="comment"> * 64-bit architectures.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mach_header_64</span> &#123;</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	magic;		<span class="comment">/* mach magic number identifier */</span></span><br><span class="line">	<span class="keyword">cpu_type_t</span>	cputype;	<span class="comment">/* cpu specifier */</span></span><br><span class="line">	<span class="keyword">cpu_subtype_t</span>	cpusubtype;	<span class="comment">/* machine specifier */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	filetype;	<span class="comment">/* type of file */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	ncmds;		<span class="comment">/* number of load commands */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	sizeofcmds;	<span class="comment">/* the size of all the load commands */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	flags;		<span class="comment">/* flags */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	reserved;	<span class="comment">/* reserved */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们看到32位和64位的<code>mach_header</code>基本是一致的，只是在64位中新增了<code>reserved</code>字段，下面我们来看下其中每个字段所表示的意义。</p>
<h4 id="Magic-Number"><a href="#Magic-Number" class="headerlink" title="Magic Number"></a>Magic Number</h4><table>
<thead>
<tr>
<th>offset</th>
<th>data</th>
<th>description</th>
<th>value</th>
</tr>
</thead>
<tbody><tr>
<td>00000000</td>
<td>FEEDFACF</td>
<td>Magic Number</td>
<td>MH_MAGIC_64</td>
</tr>
</tbody></table>
<p>我们可以将其直译为<code>魔数</code>，他的值(Value)有两个:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	MH_MAGIC	0xfeedface	<span class="comment">/* the mach magic number */</span> 32位</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MH_MAGIC_64 0xfeedfacf <span class="comment">/* the 64-bit mach magic number */</span> 64位</span></span><br></pre></td></tr></table></figure>
<p>用于这个Mach-O文件的标识，有32位和64位两个值。由此可以看出我们的示例是一个64位的Mach-O文件。</p>
<h4 id="CPU-Type-CPU-SubType"><a href="#CPU-Type-CPU-SubType" class="headerlink" title="CPU Type ,CPU SubType"></a>CPU Type ,CPU SubType</h4><table>
<thead>
<tr>
<th>offset</th>
<th>data</th>
<th>description</th>
<th>value</th>
</tr>
</thead>
<tbody><tr>
<td>00000004</td>
<td>0100000C</td>
<td>CPU Type</td>
<td>CPU_TYPE_64</td>
</tr>
<tr>
<td>00000008</td>
<td>00000000</td>
<td>CPU SubType</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>00000000</td>
<td>CPU_SubType_ARM64_ALL</td>
</tr>
</tbody></table>
<p>CPU Type和CPU SubType 表示支持的CUP架构类型和子类型，如ARM。而具体的类型有哪些我们可以通过查询<code>/mach/machine.h.</code>中的定义查看这里不做过多的扩展,具体可以看<a target="_blank" rel="noopener" href="https://opensource.apple.com/source/xnu/xnu-4570.41.2/osfmk/mach/machine.h.auto.html">这里</a><br>我们的示例中，APP是支持所有arm64的机型的:CUP_SUBTYPE_ARM64_ALL。</p>
<h4 id="File-Type"><a href="#File-Type" class="headerlink" title="File Type"></a>File Type</h4><table>
<thead>
<tr>
<th>offset</th>
<th>data</th>
<th>description</th>
<th>value</th>
</tr>
</thead>
<tbody><tr>
<td>0000000C</td>
<td>00000002</td>
<td>File Type</td>
<td>MH_EXECUTE</td>
</tr>
</tbody></table>
<p>File Type 表示 Mach-O的文件类型。包括</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#define	MH_OBJECT	0x1		&#x2F;* Target 文件：编译器对源码编译后得到的中间结果 *&#x2F;</span><br><span class="line">#define	MH_EXECUTE	0x2		&#x2F;* 可执行二进制文件 *&#x2F;</span><br><span class="line">#define	MH_FVMLIB	0x3		&#x2F;* VM 共享库文件（还不清楚是什么东西） *&#x2F;</span><br><span class="line">#define	MH_CORE		0x4		&#x2F;* Core 文件，一般在 App Crash 产生 *&#x2F;</span><br><span class="line">#define	MH_PRELOAD	0x5		&#x2F;* preloaded executable file *&#x2F;</span><br><span class="line">#define	MH_DYLIB	0x6		   &#x2F;* 动态库 *&#x2F;</span><br><span class="line">#define	MH_DYLINKER	0x7		&#x2F;* 动态连接器 &#x2F;usr&#x2F;lib&#x2F;dyld *&#x2F;</span><br><span class="line">#define	MH_BUNDLE	0x8		&#x2F;* 非独立的二进制文件，往往通过 gcc-bundle 生成 *&#x2F;</span><br><span class="line">#define	MH_DYLIB_STUB	0x9	&#x2F;* 静态链接文件（还不清楚是什么东西） *&#x2F;</span><br><span class="line">#define	MH_DSYM		0xa		&#x2F;* 符号文件以及调试信息，在解析堆栈符号中常用 *&#x2F;</span><br><span class="line">#define	MH_KEXT_BUNDLE	0xb	&#x2F;* x86_64 内核扩展 *&#x2F;</span><br></pre></td></tr></table></figure>
<p>这里类型均是在<code>loader.h</code>文件中定义的</p>
<p>对于我们示例中的我们的File Type为 <code>MH_EXECUTE</code>表示 可执行的二进制文件。</p>
<h4 id="ncmds-Number-of-Load-Commands"><a href="#ncmds-Number-of-Load-Commands" class="headerlink" title="ncmds(Number of Load Commands)"></a>ncmds(Number of Load Commands)</h4><table>
<thead>
<tr>
<th>offset</th>
<th>data</th>
<th>description</th>
<th>value</th>
</tr>
</thead>
<tbody><tr>
<td>00000010</td>
<td>00000017</td>
<td>Number of Load Commands</td>
<td>23</td>
</tr>
</tbody></table>
<p>ncmds表示load command的数量。在我们的示例中表示数量为23个。</p>
<h4 id="sizeofcmds-Size-of-Load-Commands"><a href="#sizeofcmds-Size-of-Load-Commands" class="headerlink" title="sizeofcmds(Size of Load Commands)"></a>sizeofcmds(Size of Load Commands)</h4><table>
<thead>
<tr>
<th>offset</th>
<th>data</th>
<th>description</th>
<th>value</th>
</tr>
</thead>
<tbody><tr>
<td>00000014</td>
<td>00000AF8</td>
<td>Size of Load Commands</td>
<td>2808</td>
</tr>
</tbody></table>
<p>sizeofcmds表示所有load command的总大小。示例中总大小为2808。</p>
<h4 id="Flags"><a href="#Flags" class="headerlink" title="Flags"></a>Flags</h4><table>
<thead>
<tr>
<th>offset</th>
<th>data</th>
<th>description</th>
<th>value</th>
</tr>
</thead>
<tbody><tr>
<td>00000018</td>
<td>00200085</td>
<td>Flags</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>00000001</td>
<td>MH_NOUNDEFS</td>
</tr>
<tr>
<td></td>
<td></td>
<td>00000004</td>
<td>MH_DYLDLINK</td>
</tr>
<tr>
<td></td>
<td></td>
<td>00000080</td>
<td>MH_TWOLEVEL</td>
</tr>
<tr>
<td></td>
<td></td>
<td>00200000</td>
<td>MH_PIE</td>
</tr>
</tbody></table>
<p>Flags 是Mach-O文件的标志位。主要作用是告诉系统该如何加载这个Mach-O文件以及该文件的一些特性。有很多值，我们取常见的几种</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	MH_NOUNDEFS	0x1		<span class="comment">/* Target 文件中没有带未定义的符号，常为静态二进制文件 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MH_SPLIT_SEGS	0x20  <span class="comment">/* Target 文件中的只读 Segment 和可读写 Segment 分开  */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MH_TWOLEVEL	0x80		<span class="comment">/* 该 Image 使用二级命名空间(two name space binding)绑定方案 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MH_FORCE_FLAT	0x100 <span class="comment">/* 使用扁平命名空间(flat name space binding)绑定（与 MH_TWOLEVEL 互斥） */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MH_WEAK_DEFINES	0x8000 <span class="comment">/* 二进制文件使用了弱符号 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MH_BINDS_TO_WEAK 0x10000 <span class="comment">/* 二进制文件链接了弱符号 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MH_ALLOW_STACK_EXECUTION 0x20000<span class="comment">/* 允许 Stack 可执行 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	MH_PIE 0x200000  <span class="comment">/* 加载程序在随机的地址空间，只在 MH_EXECUTE中使用 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MH_NO_HEAP_EXECUTION 0x1000000 <span class="comment">/* 将 Heap 标记为不可执行，可防止 heap spray 攻击 */</span></span></span><br></pre></td></tr></table></figure>

<p>结合我们的示例，我们共有4个Flags:</p>
<ul>
<li>MH_NOUNDEFS</li>
<li>MH_DYLDLINK dyld是苹果公司的动态链接库，用来把Mach-O文件加载入内存</li>
<li>MH_TWOLEVEL 表示其符号空间中还会包含所在库的信息。这样可以使得不同的库导出通用的符号。与其相对的是扁平命名空间。</li>
<li>MH_PIE 每次系统加载进程后，都会为其随机分配一个虚拟内存空间(在传统系统中，进程每次加载的虚拟内存是相同的。这就让黑客有可能篡改内存来破解软件)</li>
</ul>
<p><code>注意</code>:flags的值也定义在loader.h文件中 都可以通过源码查看。</p>
<h3 id="Load-Commands"><a href="#Load-Commands" class="headerlink" title="Load Commands"></a>Load Commands</h3><p>Load Commands 紧跟在Header之后，用来告诉内核和dyld，如何将各个Segment加载入内存中。load command被源码表示为struct，有若干种load command，但是共同的特点是，在其结构的开头处，必须是如下两个属性：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The load commands directly follow the mach_header.  The total size of all</span></span><br><span class="line"><span class="comment"> * of the commands is given by the sizeofcmds field in the mach_header.  All</span></span><br><span class="line"><span class="comment"> * load commands must have as their first two fields cmd and cmdsize.  </span></span><br><span class="line"><span class="comment"> * The cmd</span></span><br><span class="line"><span class="comment"> * field is filled in with a constant for that command type.  </span></span><br><span class="line"><span class="comment"> * Each command type</span></span><br><span class="line"><span class="comment"> * has a structure specifically for it.  </span></span><br><span class="line"><span class="comment"> * The cmdsize field is the size in bytes</span></span><br><span class="line"><span class="comment"> * of the particular load command structure plus anything that follows it that</span></span><br><span class="line"><span class="comment"> * is a part of the load command (i.e. section structures, strings, etc.). </span></span><br><span class="line"><span class="comment"> *  To</span></span><br><span class="line"><span class="comment"> * advance to the next load command the cmdsize can be added to the offset or</span></span><br><span class="line"><span class="comment"> * pointer of the current load command.  </span></span><br><span class="line"><span class="comment"> * The cmdsize for 32-bit architectures</span></span><br><span class="line"><span class="comment"> * MUST be a multiple of 4 bytes and for 64-bit architectures MUST be a multiple</span></span><br><span class="line"><span class="comment"> * of 8 bytes (these are forever the maximum alignment of any load commands).</span></span><br><span class="line"><span class="comment"> * The padded bytes must be zero.  All tables in the object file must also</span></span><br><span class="line"><span class="comment"> * follow these rules so the file can be memory mapped.  Otherwise the pointers</span></span><br><span class="line"><span class="comment"> * to these tables will not work well or at all on some machines.  With all</span></span><br><span class="line"><span class="comment"> * padding zeroed like objects will compare byte for byte.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">load_command</span> &#123;</span></span><br><span class="line">	<span class="keyword">uint32_t</span> cmd;		<span class="comment">/* type of load command */</span></span><br><span class="line">	<span class="keyword">uint32_t</span> cmdsize;	<span class="comment">/* total size of command in bytes */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>对应我们示例中的Load Commands</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gi8zwcgxxfj31py0s645r.jpg"></p>
<p>我们在尝试去理解<code>load_command</code>的注释:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">load commands紧跟着mach_header,load commands的总大小由mach_header汇总的sizeofcmds字段给出，所有的load commands都必须以cmd和cmdsize两个字段作为前两个字段(结合我们的示例也得到验证)，cmd字段的值为commandtype常量，每一个commandtype都有一种特定的结构。cmdsize字段以字节为单位包含loadcommand结构和额外的其他字段(例如  section structures，strings等)。要前进到下一个加载命令，可以将cmdsize添加到当前加载命令的偏移量或指针。对于32位体系结构的cmdsize</span><br><span class="line"> 必须是4字节的倍数，并且对于64位架构，必须是8字节的倍数（这些永远是所有装入命令的最大对齐),填充字节必须为零。</span><br></pre></td></tr></table></figure>

<h4 id="Segment"><a href="#Segment" class="headerlink" title="Segment"></a>Segment</h4><p>在这么多的load command中，需要我们重点关注的是segment load command，segment command解释了该如何将Data中的各个Segment加载入内存中，而和我们APP相关的逻辑及数据，则大部分位于各个Segment中。</p>
<p>而和我们的Run time相关的Segment，则位于__DATA类型Segment下。</p>
<p>Segment load command也分为32位和64位：</p>
<p>32位</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The segment load command indicates that a part of this file is to be</span></span><br><span class="line"><span class="comment"> * mapped into the task&#x27;s address space.  The size of this segment in memory,</span></span><br><span class="line"><span class="comment"> * vmsize, maybe equal to or larger than the amount to map from this file,</span></span><br><span class="line"><span class="comment"> * filesize.  The file is mapped starting at fileoff to the beginning of</span></span><br><span class="line"><span class="comment"> * the segment in memory, vmaddr.  The rest of the memory of the segment,</span></span><br><span class="line"><span class="comment"> * if any, is allocated zero fill on demand.  The segment&#x27;s maximum virtual</span></span><br><span class="line"><span class="comment"> * memory protection and initial virtual memory protection are specified</span></span><br><span class="line"><span class="comment"> * by the maxprot and initprot fields.  If the segment has sections then the</span></span><br><span class="line"><span class="comment"> * section structures directly follow the segment command and their size is</span></span><br><span class="line"><span class="comment"> * reflected in cmdsize.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">segment_command</span> &#123;</span> <span class="comment">/* for 32-bit architectures */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	cmd;		<span class="comment">/* LC_SEGMENT */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	cmdsize;	<span class="comment">/* includes sizeof section structs */</span></span><br><span class="line">	<span class="keyword">char</span>		segname[<span class="number">16</span>];	<span class="comment">/* segment name */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	vmaddr;		<span class="comment">/* memory address of this segment */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	vmsize;		<span class="comment">/* memory size of this segment */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	fileoff;	<span class="comment">/* file offset of this segment */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	filesize;	<span class="comment">/* amount to map from the file */</span></span><br><span class="line">	<span class="keyword">vm_prot_t</span>	maxprot;	<span class="comment">/* maximum VM protection */</span></span><br><span class="line">	<span class="keyword">vm_prot_t</span>	initprot;	<span class="comment">/* initial VM protection */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	nsects;		<span class="comment">/* number of sections in segment */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	flags;		<span class="comment">/* flags */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>64位</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The 64-bit segment load command indicates that a part of this file is to be</span></span><br><span class="line"><span class="comment"> * mapped into a 64-bit task&#x27;s address space.  If the 64-bit segment has</span></span><br><span class="line"><span class="comment"> * sections then section_64 structures directly follow the 64-bit segment</span></span><br><span class="line"><span class="comment"> * command and their size is reflected in cmdsize.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">segment_command_64</span> &#123;</span> <span class="comment">/* for 64-bit architectures */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	cmd;		<span class="comment">/* LC_SEGMENT_64 */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	cmdsize;	<span class="comment">/* includes sizeof section_64 structs */</span></span><br><span class="line">	<span class="keyword">char</span>		segname[<span class="number">16</span>];	<span class="comment">/* segment name */</span></span><br><span class="line">	<span class="keyword">uint64_t</span>	vmaddr;		<span class="comment">/* memory address of this segment */</span></span><br><span class="line">	<span class="keyword">uint64_t</span>	vmsize;		<span class="comment">/* memory size of this segment */</span></span><br><span class="line">	<span class="keyword">uint64_t</span>	fileoff;	<span class="comment">/* file offset of this segment */</span></span><br><span class="line">	<span class="keyword">uint64_t</span>	filesize;	<span class="comment">/* amount to map from the file */</span></span><br><span class="line">	<span class="keyword">vm_prot_t</span>	maxprot;	<span class="comment">/* maximum VM protection */</span></span><br><span class="line">	<span class="keyword">vm_prot_t</span>	initprot;	<span class="comment">/* initial VM protection */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	nsects;		<span class="comment">/* number of sections in segment */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	flags;		<span class="comment">/* flags */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>32位和64位的segment_command基本一致，只是在64位的结构中把和寻址相关的数据类型由<code>uint32_t</code>改为<code>uint64_t</code></p>
<p>我们先看下示例中，和Segment相关的Command：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gi90jod69hj30i808ewfe.jpg"></p>
<p>结合源码我们可以看到：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#define    SEG_PAGEZERO    &quot;__PAGEZERO&quot; &#x2F;* 当时 MH_EXECUTE 文件时，捕获到空指针 *&#x2F;</span><br><span class="line">#define    SEG_TEXT    &quot;__TEXT&quot; &#x2F;* 代码&#x2F;只读数据段 *&#x2F;</span><br><span class="line">#define    SEG_DATA    &quot;__DATA&quot; &#x2F;* 数据段 *&#x2F;</span><br><span class="line">#define    SEG_LINKEDIT    &quot;__LINKEDIT&quot; &#x2F;* 包含需要被动态链接器使用的符号和其他表，包括符号表、字符串表等 *&#x2F;</span><br></pre></td></tr></table></figure>

<p>根据前面结构图我们知道Load Commands实际上是一个二级结构:Segment-&gt;Section,正如示例中所示</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gi90uyqf0ij314k0c8n0z.jpg"></p>
<p>因此，下面我们在看下section的结构</p>
<h4 id="Section"><a href="#Section" class="headerlink" title="Section"></a>Section</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * A segment is made up of zero or more sections.  Non-MH_OBJECT files have</span></span><br><span class="line"><span class="comment"> * all of their segments with the proper sections in each, and padded to the</span></span><br><span class="line"><span class="comment"> * specified segment alignment when produced by the link editor.  The first</span></span><br><span class="line"><span class="comment"> * segment of a MH_EXECUTE and MH_FVMLIB format file contains the mach_header</span></span><br><span class="line"><span class="comment"> * and load commands of the object file before its first section.  The zero</span></span><br><span class="line"><span class="comment"> * fill sections are always last in their segment (in all formats).  This</span></span><br><span class="line"><span class="comment"> * allows the zeroed segment padding to be mapped into memory where zero fill</span></span><br><span class="line"><span class="comment"> * sections might be. The gigabyte zero fill sections, those with the section</span></span><br><span class="line"><span class="comment"> * type S_GB_ZEROFILL, can only be in a segment with sections of this type.</span></span><br><span class="line"><span class="comment"> * These segments are then placed after all other segments.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The MH_OBJECT format has all of its sections in one segment for</span></span><br><span class="line"><span class="comment"> * compactness.  There is no padding to a specified segment boundary and the</span></span><br><span class="line"><span class="comment"> * mach_header and load commands are not part of the segment.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Sections with the same section name, sectname, going into the same segment,</span></span><br><span class="line"><span class="comment"> * segname, are combined by the link editor.  The resulting section is aligned</span></span><br><span class="line"><span class="comment"> * to the maximum alignment of the combined sections and is the new section&#x27;s</span></span><br><span class="line"><span class="comment"> * alignment.  The combined sections are aligned to their original alignment in</span></span><br><span class="line"><span class="comment"> * the combined section.  Any padded bytes to get the specified alignment are</span></span><br><span class="line"><span class="comment"> * zeroed.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The format of the relocation entries referenced by the reloff and nreloc</span></span><br><span class="line"><span class="comment"> * fields of the section structure for mach object files is described in the</span></span><br><span class="line"><span class="comment"> * header file &lt;reloc.h&gt;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> section &#123; <span class="comment">/* for 32-bit architectures */</span></span><br><span class="line">	<span class="keyword">char</span>		sectname[<span class="number">16</span>];	<span class="comment">/* name of this section Section 名字 */</span></span><br><span class="line">	<span class="keyword">char</span>		segname[<span class="number">16</span>];	<span class="comment">/* segment this section goes in */</span></span><br><span class="line">	uint32_t	addr;		<span class="comment">/* memory address of this section */</span></span><br><span class="line">	uint32_t	size;		<span class="comment">/* size in bytes of this section */</span></span><br><span class="line">	uint32_t	offset;		<span class="comment">/* file offset of this section */</span></span><br><span class="line">	uint32_t	align;		<span class="comment">/* section alignment (power of 2) */</span></span><br><span class="line">	uint32_t	reloff;		<span class="comment">/* file offset of relocation entries */</span></span><br><span class="line">	uint32_t	nreloc;		<span class="comment">/* number of relocation entries */</span></span><br><span class="line">	uint32_t	flags;		<span class="comment">/* flags (section type and attributes)*/</span></span><br><span class="line">	uint32_t	reserved1;	<span class="comment">/* reserved (for offset or index) */</span></span><br><span class="line">	uint32_t	reserved2;	<span class="comment">/* reserved (for count or sizeof) */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> section_64 &#123; <span class="comment">/* for 64-bit architectures */</span></span><br><span class="line">	<span class="keyword">char</span>		sectname[<span class="number">16</span>];	<span class="comment">/* Section 名字 */</span></span><br><span class="line">	<span class="keyword">char</span>		segname[<span class="number">16</span>];	<span class="comment">/* 所在的Segment名称*/</span></span><br><span class="line">	uint64_t	addr;		<span class="comment">/* Section 所在的内存地址 */</span></span><br><span class="line">	uint64_t	size;		<span class="comment">/* Section 的大小 */</span></span><br><span class="line">	uint32_t	offset;		<span class="comment">/* Section 所在的文件偏移 */</span></span><br><span class="line">	uint32_t	align;		<span class="comment">/* Section 的内存对齐边界 (2 的次幂) */</span></span><br><span class="line">	uint32_t	reloff;		<span class="comment">/* 重定位信息的文件偏移 */</span></span><br><span class="line">	uint32_t	nreloc;		<span class="comment">/* 重定位条目的数目 */</span></span><br><span class="line">	uint32_t	flags;		<span class="comment">/* 标志属性 (section type and attributes)*/</span></span><br><span class="line">	uint32_t	reserved1;	<span class="comment">/* 保留字段1 (for offset or index) */</span></span><br><span class="line">	uint32_t	reserved2;	<span class="comment">/* 保留字段2 (for count or sizeof) */</span></span><br><span class="line">	uint32_t	reserved3;	<span class="comment">/* 保留字段3 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在64位和32位的section定义中，64位新增了一个reserved3保留字段，以及将section的addr和size字段由原来的uint32_t类型升级为uint64_t。</p>
<p>在Data中，程序的逻辑和数据是按照Segment（段）存储，在Segment中，又分为0或多个section，每个section中在存储实际的内容。而之所以这么做的原因在于，在section中，可以不用内存对齐达到节约内存的作用，而所有的section作为整体的Segment，又可以整体的内存对齐。</p>
<p>结合我们示例中的一个section结构如下图：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gi914f1x7fj31240ie0vn.jpg"></p>
<h3 id="DATA-数据"><a href="#DATA-数据" class="headerlink" title="DATA(数据)"></a>DATA(数据)</h3><p>Mach-O的Data部分，其实是真正存储APP二进制数据的位置，前面的header和load command，仅是提供文件的说明以及加载信息的功能。</p>
<p>前面我们介绍过，我们通过Load Commands从DATA中读取数据，而Load Commands被划分成了多个Segment，也就是说 我们通过不同的Load Commands从DATA中读取不同的数据。</p>
<p>在介绍Segment的时候我们说过Segment被划分成<code>__PAGEZERO</code>,<code>__TEXT</code>,<code>__DATA</code>,<code>__LINKEDIT</code>这几段。</p>
<p>结合我们的示例，我们发现DATA被划分为:<code>__TEXT</code>,<code>__DATA</code></p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gi91bdekm9j31j80u0gy7.jpg"></p>
<p>下面我们来看下这几个数据段(section):</p>
<h4 id="TEXT段"><a href="#TEXT段" class="headerlink" title="__TEXT段"></a>__TEXT段</h4><p>__TEXT是程序的只读段，用于保存我们所写的代码和字符串常量，const修饰常量等。</p>
<p>下面是几个我们常见的section：</p>
<table>
<thead>
<tr>
<th>Section</th>
<th>存储内容</th>
</tr>
</thead>
<tbody><tr>
<td>__TEXT.__text</td>
<td>主程序代码</td>
</tr>
<tr>
<td>__TEXT.__cstring</td>
<td>C 语言字符串</td>
</tr>
<tr>
<td>__TEXT.__const</td>
<td>const 关键字修饰的常量</td>
</tr>
<tr>
<td>__TEXT.__stubs</td>
<td>用于 Stub 的占位代码，很多地方称之为桩代码。</td>
</tr>
<tr>
<td>__TEXT.__stubs_helper</td>
<td>当 Stub 无法找到真正的符号地址后的最终指向</td>
</tr>
<tr>
<td>__TEXT.__objc_methname</td>
<td>Objective-C 方法名称</td>
</tr>
<tr>
<td>__TEXT.__objc_methtype</td>
<td>Objective-C 方法类型</td>
</tr>
<tr>
<td>__TEXT.__objc_classname</td>
<td>Objective-C 类名称</td>
</tr>
</tbody></table>
<p>我们来结合示例看下这几个section的内容：</p>
<h5 id="cstring"><a href="#cstring" class="headerlink" title="cstring"></a>cstring</h5><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gi939ehxldj31vk0mu7ef.jpg"></p>
<p>我们可以从中看到<code>lw_property</code>,<code>lw_publicproperty</code>这两个属性名。以及我们打印的NSLog中的内容,同时我们发现，我们可能定义的某些三方key或者appid在这里都暴露在外部。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static const NSString *lw_constsecretKey &#x3D; @&quot;11234455556&quot;;</span><br></pre></td></tr></table></figure>

<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gi93d875bdj31r60imtgw.jpg"></p>
<h5 id="objc-methname"><a href="#objc-methname" class="headerlink" title="objc_methname"></a>objc_methname</h5><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gi91tzgretj31oq0j247e.jpg"></p>
<p>我们可以看到我们自定义的方法名<code>lw_publicMethod</code>,<code>lw_privateMethod</code>以及<code>lw_property</code>,<code>lw_publicproperty</code>重写的setter和getter方法。</p>
<h5 id="classname"><a href="#classname" class="headerlink" title="classname"></a>classname</h5><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gi91z90xhnj31og0fo43z.jpg"></p>
<p>我们可以看到我们自定义的类的类:<code>LWCustomClass</code></p>
<h4 id="DATA"><a href="#DATA" class="headerlink" title="_DATA"></a>_DATA</h4><p>__DATA段用于存储程序中所定义的数据，可读写。__DATA段下常见的sectin有：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gigtuycksmj30jo0pqgpu.jpg"></p>
<p>下面我们看下常见的__DATA下的section:</p>
<table>
<thead>
<tr>
<th>Section</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>__DATA.__data</td>
<td>初始化过的可变数据</td>
</tr>
<tr>
<td>__DATA.__la_symbol_ptr</td>
<td>lazy binding 的指针表，表中的指针一开始都指向 __stub_helper</td>
</tr>
<tr>
<td>__DATA.nl_symbol_ptr</td>
<td>非 lazy binding 的指针表，每个表项中的指针都指向一个在装载过程中，被动态链机器搜索完成的符号</td>
</tr>
<tr>
<td>__DATA.__const</td>
<td>没有初始化过的常量</td>
</tr>
<tr>
<td>__DATA.__cfstring</td>
<td>程序中使用的 Core Foundation 字符串（CFStringRefs）</td>
</tr>
<tr>
<td>__DATA.__bss</td>
<td>BSS，存放为初始化的全局变量，即常说的静态内存分配</td>
</tr>
<tr>
<td>__DATA.__common</td>
<td>没有初始化过的符号声明</td>
</tr>
<tr>
<td>__DATA.__objc_classlist</td>
<td>Objective-C 类列表</td>
</tr>
<tr>
<td>__DATA.__objc_protolist</td>
<td>Objective-C 协议列表</td>
</tr>
<tr>
<td>__DATA.__objc_imginfo</td>
<td>Objective-C 镜像信息</td>
</tr>
<tr>
<td>__DATA.__objc_selfrefs</td>
<td>Objective-C self 引用</td>
</tr>
<tr>
<td>__DATA.__objc_protorefs</td>
<td>Objective-C 原型引用</td>
</tr>
<tr>
<td>__DATA.__objc_superrefs</td>
<td>Objective-C 超类引用</td>
</tr>
</tbody></table>
<p>这些以objc开头的DATA字段都是跟runtime有关的，后面我们会详细分析。</p>
<h5 id="objc-imageinfo"><a href="#objc-imageinfo" class="headerlink" title="__objc_imageinfo"></a>__objc_imageinfo</h5><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gih51mnkp7j31n60s6agt.jpg"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">objc_image_info</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> version; <span class="comment">// currently 0</span></span><br><span class="line">    <span class="keyword">uint32_t</span> flags;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __cplusplus &gt;= 201103L</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// 位移枚举 </span></span><br><span class="line">    <span class="keyword">enum</span> : <span class="keyword">uint32_t</span> &#123;</span><br><span class="line">        IsReplacement       = <span class="number">1</span>&lt;&lt;<span class="number">0</span>,  <span class="comment">// used for Fix&amp;Continue, now ignored</span></span><br><span class="line">        SupportsGC          = <span class="number">1</span>&lt;&lt;<span class="number">1</span>,  <span class="comment">// 是否支持垃圾回收</span></span><br><span class="line">        RequiresGC          = <span class="number">1</span>&lt;&lt;<span class="number">2</span>,  <span class="comment">// 镜像是否需要回收</span></span><br><span class="line">        OptimizedByDyld     = <span class="number">1</span>&lt;&lt;<span class="number">3</span>,  <span class="comment">// image is from an optimized shared cache</span></span><br><span class="line">        CorrectedSynthesize = <span class="number">1</span>&lt;&lt;<span class="number">4</span>,  <span class="comment">// used for an old workaround, now ignored</span></span><br><span class="line">        IsSimulated         = <span class="number">1</span>&lt;&lt;<span class="number">5</span>,  <span class="comment">// image compiled for a simulator platform</span></span><br><span class="line">        HasCategoryClassProperties  = <span class="number">1</span>&lt;&lt;<span class="number">6</span>,  <span class="comment">// class properties in category_t</span></span><br><span class="line"></span><br><span class="line">        SwiftVersionMaskShift = <span class="number">8</span>,</span><br><span class="line">        SwiftVersionMask    = <span class="number">0xff</span> &lt;&lt; SwiftVersionMaskShift  <span class="comment">// Swift ABI version</span></span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">enum</span> : <span class="keyword">uint32_t</span> &#123;</span><br><span class="line">        SwiftVersion1   = <span class="number">1</span>,</span><br><span class="line">        SwiftVersion1_2 = <span class="number">2</span>,</span><br><span class="line">        SwiftVersion2   = <span class="number">3</span>,</span><br><span class="line">        SwiftVersion3   = <span class="number">4</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isReplacement</span><span class="params">()</span>   <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> flags &amp; IsReplacement; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">supportsGC</span><span class="params">()</span>      <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> flags &amp; SupportsGC; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">requiresGC</span><span class="params">()</span>      <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> flags &amp; RequiresGC; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">optimizedByDyld</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> flags &amp; OptimizedByDyld; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasCategoryClassProperties</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> flags &amp; HasCategoryClassProperties; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">containsSwift</span><span class="params">()</span>   <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> (flags &amp; SwiftVersionMask) != <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">uint32_t</span> <span class="title">swiftVersion</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> (flags &amp; SwiftVersionMask) &gt;&gt; SwiftVersionMaskShift; &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125; objc_image_info;</span><br></pre></td></tr></table></figure>

<p>我们发现<code>objc_image_info</code>中主要是有version字段和flag字段，</p>
<h5 id="objc-classlist"><a href="#objc-classlist" class="headerlink" title="__objc_classlist"></a>__objc_classlist</h5><p>这个section列出了所有的class，包括meta class。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gih4x7u5ckj31pr0u01b9.jpg"></p>
<p>图中的value值是就是这个类结构体的地址(包括元类)，类结构体的结构为objc中的objc_class结构体，结构如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_class : objc_object &#123;</span><br><span class="line">    <span class="comment">// Class ISA;</span></span><br><span class="line">    Class superclass;</span><br><span class="line">    cache_t cache;             <span class="comment">// formerly cache pointer and vtable</span></span><br><span class="line">    class_data_bits_t bits;    <span class="comment">// class_rw_t * plus custom rr/alloc flags</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="objc-catlist"><a href="#objc-catlist" class="headerlink" title="__objc_catlist"></a>__objc_catlist</h5><p>这里可以查看代码中的所有分类，其value的值为指向分类结构体的指针</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gih63wv6xzj31mv0u04jn.jpg"></p>
<p>对应oc中的结构为category_t，具体结构如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> category_t &#123;</span><br><span class="line">    <span class="comment">// 是指 class_name 而不是 category_name</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="comment">// 要扩展的类对象，编译期间是不会定义的，而是在运行时通过 * name 对应到对应的类对象。</span></span><br><span class="line">    classref_t cls;</span><br><span class="line">    <span class="comment">// 对象方法列表</span></span><br><span class="line">    <span class="keyword">struct</span> method_list_t *instanceMethods;</span><br><span class="line">    <span class="comment">// 类方法列表</span></span><br><span class="line">    <span class="keyword">struct</span> method_list_t *classMethods;</span><br><span class="line">    <span class="comment">// 协议列表</span></span><br><span class="line">    <span class="keyword">struct</span> protocol_list_t *protocols;</span><br><span class="line">    <span class="comment">// 实例属性</span></span><br><span class="line">    <span class="keyword">struct</span> property_list_t *instanceProperties;</span><br><span class="line">    <span class="comment">// Fields below this point are not always present on disk.</span></span><br><span class="line">    <span class="comment">// 类属性(这个结构体以_开头命名？？？)</span></span><br><span class="line">    <span class="keyword">struct</span> property_list_t *_classProperties;</span><br><span class="line">    <span class="comment">// methodsForMeta 返回类方法列表或者对象方法列表</span></span><br><span class="line">    method_list_t *methodsForMeta(<span class="keyword">bool</span> isMeta) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isMeta) <span class="keyword">return</span> classMethods;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> instanceMethods;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 属性列表返回方法</span></span><br><span class="line">    property_list_t *propertiesForMeta(<span class="keyword">bool</span> isMeta, <span class="keyword">struct</span> header_info *hi);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="objc-protolist"><a href="#objc-protolist" class="headerlink" title="__objc_protolist"></a>__objc_protolist</h5><p>该Section中记录了项目中所有的协议。 其value值为指向协议的指针</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gih6ao4ee6j31nd0u01b2.jpg"></p>
<p>协议的结构体为protocol_t，具体如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">struct</span> protocol_t : objc_object &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *mangledName;</span><br><span class="line">    <span class="keyword">struct</span> protocol_list_t *protocols;</span><br><span class="line">    method_list_t *instanceMethods;</span><br><span class="line">    method_list_t *classMethods;</span><br><span class="line">    method_list_t *optionalInstanceMethods;</span><br><span class="line">    method_list_t *optionalClassMethods;</span><br><span class="line">    property_list_t *instanceProperties;</span><br><span class="line">    uint32_t size;   <span class="comment">// sizeof(protocol_t)</span></span><br><span class="line">    uint32_t flags;</span><br><span class="line">    <span class="comment">// Fields below this point are not always present on disk.</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> **_extendedMethodTypes;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *_demangledName;</span><br><span class="line">    property_list_t *_classProperties;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="objc-classrefs"><a href="#objc-classrefs" class="headerlink" title="__objc_classrefs"></a>__objc_classrefs</h5><p>该section记录了哪些class被引用了，这里记录了所有被实例化的class，有些类虽然在包里，但是我们并未使用，因此这里不会有。<br><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gih6fqzemuj31rl0u0dyd.jpg"></p>
<h5 id="objc-selrefs"><a href="#objc-selrefs" class="headerlink" title="__objc_selrefs"></a>__objc_selrefs</h5><p>这section记录哪些SEL对应的字符串被引用了，有系统方法，也有自定义方法：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gih4rgf693j31lk0u07qb.jpg"></p>
<h5 id="objc-superrefs"><a href="#objc-superrefs" class="headerlink" title="__objc_superrefs"></a>__objc_superrefs</h5><p>该section记录了调用super方法的类。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gih6sbnruvj31uy0u04gr.jpg"></p>
<p>比如，在子类方法中，我们调用了父类的方法，就会将子类记录在这里。</p>
<h5 id="objc-const"><a href="#objc-const" class="headerlink" title="__objc_const"></a>__objc_const</h5><p>该section用来记录在OC内存初始化过程中的不可变内容。这里所谓的不可变内容并不是我们在程序中所写的const NSInteger k = 5这种常量数据（它存在__TEXT的const section中），而是在OC内存布局中不可变得部分。</p>
<h3 id="应用启动"><a href="#应用启动" class="headerlink" title="应用启动"></a>应用启动</h3><p>根据上面介绍的在应用启动期间，dyld和kern会读取Mach-O文件中的Load Command去读取和加载_DATA数据段下的内容，而这一切都发生在main函数之前。所以我们看下main函数之前都发生了什么？</p>
<h4 id="启动调用堆栈"><a href="#启动调用堆栈" class="headerlink" title="启动调用堆栈"></a>启动调用堆栈</h4><p>添加一个符号断点(Symbolic BreakPoint)让应用在执行到<code>_objc_init</code>方法是断点执行。<br><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gip6quvmz0j30yk0d6qnx.jpg"></p>
<p>这样我们就能看到下面的这个调用栈:</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gip6q2kpiwj30nw0le4oi.jpg"></p>
<p>因为<code>_objc_init</code>方法是runtime的入口，因此在这之前调用的方法都是dyld和ImageLoader的操作</p>
<h4 id="dyld"><a href="#dyld" class="headerlink" title="dyld"></a>dyld</h4><p>dyld(the dynamic link editor)动态链接器,系统 kernel 做好启动程序的初始准备后，交给 dyld 负责，dyld的主要工作内容为(参考<a target="_blank" rel="noopener" href="https://www.mikeash.com/pyblog/friday-qa-2012-11-09-dyld-dynamic-linking-on-os-x.html"> dyld: Dynamic Linking On OS X </a>):</p>
<ul>
<li>从 kernel 留下的原始调用栈引导和启动自己</li>
<li>将程序依赖的动态链接库递归加载进内存，当然这里有缓存机制</li>
<li>non-lazy 符号立即 link 到可执行文件，lazy 的存表里</li>
<li>Runs static initializers for the executable</li>
<li>找到可执行文件的 main 函数，准备参数并调用</li>
<li>程序执行中负责绑定 lazy 符号、提供 runtime dynamic loading services、提供调试器接口</li>
<li>程序main函数 return 后执行 static terminator</li>
<li>某些场景下 main 函数结束后调 libSystem 的 _exit 函数</li>
</ul>
<h4 id="ImageLoader"><a href="#ImageLoader" class="headerlink" title="ImageLoader"></a>ImageLoader</h4><p>这里的image不是图片的意思，它是一个二进制文件，你可以把他理解为一个镜像文件。内部是被编译过的符号、代码等，因此<code>ImageLoader</code>作用是将这些文件加载进内存，且每一个文件对应一个<code>ImageLoader</code>实例来负责加载。</p>
<p>他的主要工作为：</p>
<ul>
<li>在程序运行时它先将动态链接的 image 递归加载 （也就是上面测试栈中一串的递归调用的时刻）</li>
<li>再从可执行文件 image 递归加载所有符号</li>
</ul>
<h4 id="ImageLoaderMachO"><a href="#ImageLoaderMachO" class="headerlink" title="ImageLoaderMachO"></a>ImageLoaderMachO</h4><p>顾名思义这里应该是去加载MachO文件，从堆栈中我们可以看到主要跟<code>doInitialization</code>方法和<code>doModInitFunctions</code>方法。</p>
<h5 id="doInitialization"><a href="#doInitialization" class="headerlink" title="doInitialization"></a>doInitialization</h5><p>这个方法的主要作用是：获取<code>Mach-O</code>的init方法的地址并调用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ImageLoaderMachO::doInitialization</span><span class="params">(<span class="keyword">const</span> LinkContext&amp; context)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	CRSetCrashLogMessage2(<span class="keyword">this</span>-&gt;getPath());</span><br><span class="line"></span><br><span class="line">	<span class="comment">// mach-o has -init and static initializers</span></span><br><span class="line">	doImageInit(context);</span><br><span class="line">	doModInitFunctions(context);</span><br><span class="line">	</span><br><span class="line">	CRSetCrashLogMessage2(<span class="literal">NULL</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> (fHasDashInit || fHasInitializers);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ImageLoaderMachO::doImageInit</span><span class="params">(<span class="keyword">const</span> LinkContext&amp; context)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> ( fHasDashInit ) &#123;</span><br><span class="line">		<span class="comment">// mach-o文件中指令的个数</span></span><br><span class="line">		<span class="keyword">const</span> <span class="keyword">uint32_t</span> cmd_count = ((macho_header*)fMachOData)-&gt;ncmds;</span><br><span class="line">		<span class="comment">// 遍历指令</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; cmd_count; ++i) &#123;</span><br><span class="line">			<span class="keyword">switch</span> (cmd-&gt;cmd) &#123;</span><br><span class="line">				<span class="keyword">case</span> LC_ROUTINES_COMMAND:</span><br><span class="line">					<span class="comment">// 获取macho_routines_command的init_address</span></span><br><span class="line">					Initializer func = (Initializer)(((struct macho_routines_command*)cmd)-&gt;init_address + fSlide);</span><br><span class="line">					<span class="comment">// 执行-init方法</span></span><br><span class="line">					func(context.argc, context.argv, context.envp, context.apple, &amp;context.programVars);</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 计算下一个指令((char*)cmd)+cmd-&gt;cmdsize</span></span><br><span class="line">			cmd = (<span class="keyword">const</span> struct load_command*)(((<span class="keyword">char</span>*)cmd)+cmd-&gt;cmdsize);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="doModInitFunctions"><a href="#doModInitFunctions" class="headerlink" title="doModInitFunctions"></a>doModInitFunctions</h5><p>这个方法的主要作用是：获取<code>Mach-O</code>的static initializer的地址并调用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ImageLoaderMachO::doModInitFunctions</span><span class="params">(<span class="keyword">const</span> LinkContext&amp; context)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> ( fHasInitializers ) &#123;</span><br><span class="line">	   <span class="comment">// mach-o文件中指令的个数</span></span><br><span class="line">		<span class="keyword">const</span> <span class="keyword">uint32_t</span> cmd_count = ((macho_header*)fMachOData)-&gt;ncmds;</span><br><span class="line">		<span class="comment">// 遍历所有的指令</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; cmd_count; ++i) &#123;</span><br><span class="line">		   <span class="comment">// 如果指令是Mach-o中的LC_SEGMENT_COMMAND</span></span><br><span class="line">			<span class="keyword">if</span> ( cmd-&gt;cmd == LC_SEGMENT_COMMAND ) &#123;</span><br><span class="line">			     <span class="comment">// 从sectionsStart到sectionsEnd</span></span><br><span class="line">					<span class="keyword">for</span> (<span class="keyword">const</span> struct macho_section* sect=sectionsStart; sect &lt; sectionsEnd; ++sect) &#123;</span><br><span class="line">					<span class="keyword">const</span> <span class="keyword">uint8_t</span> type = sect-&gt;flags &amp; SECTION_TYPE;</span><br><span class="line">					<span class="keyword">if</span> ( type == S_MOD_INIT_FUNC_POINTERS ) &#123;</span><br><span class="line">						</span><br><span class="line">						<span class="keyword">for</span> (<span class="keyword">size_t</span> i=<span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line">							<span class="keyword">if</span> ( context.verboseInit )</span><br><span class="line">								dyld::<span class="built_in">log</span>(<span class="string">&quot;dyld: calling initializer function %p in %s\n&quot;</span>, func, <span class="keyword">this</span>-&gt;getPath());</span><br><span class="line">							<span class="comment">// 执行initializer方法</span></span><br><span class="line">							func(context.argc, context.argv, context.envp, context.apple, &amp;context.programVars);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 根据指令的地址+指令大小获取到下一个指令</span></span><br><span class="line">			cmd = (<span class="keyword">const</span> struct load_command*)(((<span class="keyword">char</span>*)cmd)+cmd-&gt;cmdsize);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>上述我们介绍了Mach-O文件的主要结构，以及每个segment和section的功能和字段的作用，结尾处我们通过查看应用启动调用堆栈来确认Mach-O文件何时被ImageLoader解析并加载到内存中，提供给后续的runtime使用。鉴于main函数之前系统内核,dyld,ImageLoader,rumtime做了很多准备，我们决定新开一篇文章来讲述这个过程发生了什么，敬请期待！</p>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a target="_blank" rel="noopener" href="https://opensource.apple.com/source/dyld/dyld-95.3/src/ImageLoaderMachO.cpp.auto.html">XNU源码</a><br><a target="_blank" rel="noopener" href="http://hawk0620.github.io/blog/2018/03/22/study-mach-o-file/#%E5%A6%82%E4%BD%95%E7%94%A8%20MachO%20%E6%96%87%E4%BB%B6%E5%85%B3%E8%81%94%E7%B1%BB%E7%9A%84%E6%96%B9%E6%B3%95%E5%90%8D">探秘 Mach-O 文件</a><br><a target="_blank" rel="noopener" href="https://jianli2017.top/wiki/IOS/MachO/MachO_FileStructure/">Mach-O文件结构理解</a><br><a target="_blank" rel="noopener" href="https://zhangbuhuai.com/post/macho-dynamic-link.html">Mach-O 与动态链接</a><br><a target="_blank" rel="noopener" href="https://blog.sunnyxx.com/2014/08/30/objc-pre-main/">iOS 程序 main 函数之前发生了什么</a></p>

    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2020/08/22/runtimecategory/" rel="prev" title="RunTime解析--Category(分类)实现">
                  <i class="fa fa-chevron-left"></i> RunTime解析--Category(分类)实现
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2020/09/13/applaunchbeforemain/" rel="next" title="应用启动-Main函数之前的那些事儿">
                  应用启动-Main函数之前的那些事儿 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
  
  
  



      
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

    </div>
  </main>

  <footer class="footer">
    <div class="footer-inner">
      

      

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">LeeWong</span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.0/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  
  <script>
    (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      bp.src = (curProtocol === 'https') ? 'https://zz.bdstatic.com/linksubmit/push.js' : 'http://push.zhanzhang.baidu.com/push.js';
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>















  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>








  

  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1.6.2/dist/gitalk.css">

<script>
NexT.utils.loadComments('#gitalk-container', () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1.6.2/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : '5f882cde7fcb86a5d699',
      clientSecret: '0d812b90fe7a94b3599b62e61b2bbaaa8134baa6',
      repo        : 'BlogComment',
      owner       : 'LeeWongSnail',
      admin       : ['LeeWongSnail'],
      id          : '7d1ba9b0985d701484d21ecc54494eb7',
        language: 'zh-CN',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>

</body>
</html>
