<!DOCTYPE html>
<html lang="zh-CN">
    <head>
    <meta charset="utf-8">

    

    <!-- 渲染优化 -->
    <meta name="renderer" content="webkit">
    <meta name="force-rendering" content="webkit">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="HandheldFriendly" content="True" >
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <!--icon-->

    
        <link rel="shortcut icon" href="https://tva1.sinaimg.cn/large/0081Kckwly1glcsnw2jatj303k03k748.jpg">
    
    
    
    
    


    <!-- meta -->


<title>Runtime之KVO | LeeWong</title>


    <meta name="keywords" content="Runtime KVO, iOS">




    <!-- OpenGraph -->
 
    <meta name="description" content="KVO(Key-Value-Observer)即键值监听，我们在平时的开发中通常用来监听对象属性的变化，比如UIScrollView的ContentOffset,不过同时我们要注意在不需要继续监听的时候及时的移除监听，否则可能会导致崩溃。因此这篇文章让我们更好的了解KVO。">
<meta property="og:type" content="article">
<meta property="og:title" content="Runtime之KVO">
<meta property="og:url" content="https://www.leewong.cn/2020/12/05/runtime-kvo/index.html">
<meta property="og:site_name" content="LeeWong">
<meta property="og:description" content="KVO(Key-Value-Observer)即键值监听，我们在平时的开发中通常用来监听对象属性的变化，比如UIScrollView的ContentOffset,不过同时我们要注意在不需要继续监听的时候及时的移除监听，否则可能会导致崩溃。因此这篇文章让我们更好的了解KVO。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/0081Kckwly1gldao0qiauj30a403uglp.jpg">
<meta property="article:published_time" content="2020-12-05T13:19:49.000Z">
<meta property="article:modified_time" content="2020-12-13T13:39:33.854Z">
<meta property="article:author" content="LeeWong">
<meta property="article:tag" content="Runtime KVO">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://tva1.sinaimg.cn/large/0081Kckwly1gldao0qiauj30a403uglp.jpg">


    
<link rel="stylesheet" href="/css/style/main.css">
 


    
<link rel="stylesheet" href="/css/style/dark.css">

    
<script src="/js/darkmode.js"></script>



    
    
    
        <link rel="stylesheet" id="hl-default-theme" href="https://cdn.jsdelivr.net/npm/highlight.js@10.1.2/styles/default.min.css" media="none" onload="if(getComputedStyle(document.documentElement).getPropertyValue('--color-mode').indexOf('dark')===-1)this.media='all'">
        
            <link rel="stylesheet" id="hl-dark-theme" href="https://cdn.jsdelivr.net/npm/highlight.js@10.1.2/styles/dark.min.css" media="none" onload="if(getComputedStyle(document.documentElement).getPropertyValue('--color-mode').indexOf('dark')!==-1)this.media='all'">
        
    

    

     
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
 

    <!-- custom head -->

    
        <meta name="google-site-verification" content="4NmLVard-jFEKaV6857m9tKb41Tpo4FiKj8L1TJg7lU" /> 
    

<meta name="generator" content="Hexo 5.1.1"></head>

    <body>
        <div id="app">
            <header class="header">
    <div class="header__left">
        <a href="/" class="button">
            <span class="logo__text">LeeWong</span>
        </a>
    </div>
    <div class="header__right">
        
            <div class="navbar__menus">
                
                    <a href="/" class="navbar-menu button">首页</a>
                
                    <a href="/tags/" class="navbar-menu button">标签</a>
                
                    <a href="/archives/" class="navbar-menu button">归档</a>
                
                    <a href="/about/" class="navbar-menu button">关于我</a>
                
            </div>
        
        
        

        
        
    <a href="javaScript:void(0);" id="btn-toggle-dark">
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path></svg>
    </a>


         
    <a href="#" class="button" id="b2t" aria-label="回到顶部" title="回到顶部">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1024 1024" width="32" height="32">
            <path d="M233.376 722.752L278.624 768 512 534.624 745.376 768l45.248-45.248L512 444.128zM192 352h640V288H192z" fill="currentColor"></path>
        </svg>
    </a>


        
            <a class="dropdown-icon button" id="btn-dropdown" tabindex="0"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" width='24' height='24' fill="none" stroke="currentColor" stroke-width="0.7" stroke-linecap="round" stroke-linejoin="round"><path fill="currentColor" d="M3.314,4.8h13.372c0.41,0,0.743-0.333,0.743-0.743c0-0.41-0.333-0.743-0.743-0.743H3.314c-0.41,0-0.743,0.333-0.743,0.743C2.571,4.467,2.904,4.8,3.314,4.8z M16.686,15.2H3.314c-0.41,0-0.743,0.333-0.743,0.743s0.333,0.743,0.743,0.743h13.372c0.41,0,0.743-0.333,0.743-0.743S17.096,15.2,16.686,15.2z M16.686,9.257H3.314c-0.41,0-0.743,0.333-0.743,0.743s0.333,0.743,0.743,0.743h13.372c0.41,0,0.743-0.333,0.743-0.743S17.096,9.257,16.686,9.257z"></path></svg></a>
            <div class="dropdown-menus" id="dropdown-menus">
                
                    <a href="/" class="dropdown-menu button">首页</a>
                
                    <a href="/tags/" class="dropdown-menu button">标签</a>
                
                    <a href="/archives/" class="dropdown-menu button">归档</a>
                
                    <a href="/about/" class="dropdown-menu button">关于我</a>
                
            </div>
        
    </div>
</header>


            <main class="main">
    

<div class="post-title">
    <h1 class="post-title__text">
        Runtime之KVO
    </h1>
    <div class="post-title__meta">
        <a href="/archives/2020/12/" class="post-meta__date button">2020-12-05</a>
        
    <span class="separate-dot"></span><a href="/categories/Runtime/" class="button">Runtime</a>

 
        
    
     
    <span id="busuanzi_container_page_pv" hidden>
        <span class="separate-dot"></span>
        <span></span>
        <span id="busuanzi_value_page_pv"></span>
        <span>Views</span>
    </span>



 

 
    </div>
</div>


    <aside class="post-side">
        <div class="post-side__toc">
            <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#KVO%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">1.</span> <span class="toc-text">KVO的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E7%9B%91%E5%90%AC"><span class="toc-number">1.1.</span> <span class="toc-text">添加监听</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%91%E5%90%AC%E6%94%B9%E5%8F%98"><span class="toc-number">1.2.</span> <span class="toc-text">监听改变</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#keyPath"><span class="toc-number">1.2.1.</span> <span class="toc-text">keyPath</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#object"><span class="toc-number">1.2.2.</span> <span class="toc-text">object</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#change"><span class="toc-number">1.2.3.</span> <span class="toc-text">change</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#context"><span class="toc-number">1.2.4.</span> <span class="toc-text">context</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A7%BB%E9%99%A4%E7%9B%91%E5%90%AC-removeObserver"><span class="toc-number">1.3.</span> <span class="toc-text">移除监听 removeObserver</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#KVO-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.</span> <span class="toc-text">KVO 如何实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#KVO-%E5%A6%82%E6%9E%9C%E8%A6%81%E4%BD%A0%E5%8E%BB%E5%AE%9E%E7%8E%B0-%E4%BD%A0%E4%BC%9A%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="toc-number">2.1.</span> <span class="toc-text">KVO 如果要你去实现 你会如何实现？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#KVO-%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.2.</span> <span class="toc-text">KVO 实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#NSObject-NSKeyValueObserverNotification"><span class="toc-number">2.2.1.</span> <span class="toc-text">NSObject(NSKeyValueObserverNotification)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#KVO-%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.2.2.</span> <span class="toc-text">KVO 底层实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#KVO-%E5%BA%94%E7%94%A8"><span class="toc-number">3.</span> <span class="toc-text">KVO 应用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%9B%91%E5%90%AC%E6%95%B0%E7%BB%84%E4%B8%AA%E6%95%B0%E6%94%B9%E5%8F%98"><span class="toc-number">3.1.</span> <span class="toc-text">如何监听数组个数改变</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%9B%91%E5%90%AC%E5%A4%8D%E5%90%88%E6%94%B9%E5%8F%98"><span class="toc-number">3.2.</span> <span class="toc-text">如何监听复合改变</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%89%8B%E5%8A%A8%E6%8E%A7%E5%88%B6KVO"><span class="toc-number">3.3.</span> <span class="toc-text">如何手动控制KVO</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%91%E5%90%AC%E4%BF%A1%E6%81%AF"><span class="toc-number">3.4.</span> <span class="toc-text">监听信息</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">4.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-number">5.</span> <span class="toc-text">参考</span></a></li></ol>
        </div>
    </aside>
    <a class="btn-toc button" id="btn-toc" tabindex="0">
        <svg viewBox="0 0 1024 1024" width="32" height="32" xmlns="http://www.w3.org/2000/svg">
            <path d="M128 256h64V192H128zM320 256h576V192H320zM128 544h64v-64H128zM320 544h576v-64H320zM128 832h64v-64H128zM320 832h576v-64H320z" fill="currentColor"></path>
        </svg>
    </a>
    <div class="toc-menus" id="toc-menus">
        <div class="toc-title">文章目录</div>
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#KVO%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">1.</span> <span class="toc-text">KVO的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E7%9B%91%E5%90%AC"><span class="toc-number">1.1.</span> <span class="toc-text">添加监听</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%91%E5%90%AC%E6%94%B9%E5%8F%98"><span class="toc-number">1.2.</span> <span class="toc-text">监听改变</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#keyPath"><span class="toc-number">1.2.1.</span> <span class="toc-text">keyPath</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#object"><span class="toc-number">1.2.2.</span> <span class="toc-text">object</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#change"><span class="toc-number">1.2.3.</span> <span class="toc-text">change</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#context"><span class="toc-number">1.2.4.</span> <span class="toc-text">context</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A7%BB%E9%99%A4%E7%9B%91%E5%90%AC-removeObserver"><span class="toc-number">1.3.</span> <span class="toc-text">移除监听 removeObserver</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#KVO-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.</span> <span class="toc-text">KVO 如何实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#KVO-%E5%A6%82%E6%9E%9C%E8%A6%81%E4%BD%A0%E5%8E%BB%E5%AE%9E%E7%8E%B0-%E4%BD%A0%E4%BC%9A%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="toc-number">2.1.</span> <span class="toc-text">KVO 如果要你去实现 你会如何实现？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#KVO-%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.2.</span> <span class="toc-text">KVO 实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#NSObject-NSKeyValueObserverNotification"><span class="toc-number">2.2.1.</span> <span class="toc-text">NSObject(NSKeyValueObserverNotification)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#KVO-%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.2.2.</span> <span class="toc-text">KVO 底层实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#KVO-%E5%BA%94%E7%94%A8"><span class="toc-number">3.</span> <span class="toc-text">KVO 应用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%9B%91%E5%90%AC%E6%95%B0%E7%BB%84%E4%B8%AA%E6%95%B0%E6%94%B9%E5%8F%98"><span class="toc-number">3.1.</span> <span class="toc-text">如何监听数组个数改变</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%9B%91%E5%90%AC%E5%A4%8D%E5%90%88%E6%94%B9%E5%8F%98"><span class="toc-number">3.2.</span> <span class="toc-text">如何监听复合改变</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%89%8B%E5%8A%A8%E6%8E%A7%E5%88%B6KVO"><span class="toc-number">3.3.</span> <span class="toc-text">如何手动控制KVO</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%91%E5%90%AC%E4%BF%A1%E6%81%AF"><span class="toc-number">3.4.</span> <span class="toc-text">监听信息</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">4.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-number">5.</span> <span class="toc-text">参考</span></a></li></ol>
    </div>


<article class="post content-card">
    <div class="post__header">
    
        <div class="post-thumbnail" style="background-image: url('https://tva1.sinaimg.cn/large/0081Kckwly1gldao0qiauj30a403uglp.jpg');"></div>
    
</div>
    <div class="post__content">
        <p><code>KVO(Key-Value-Observer)</code>即键值监听，我们在平时的开发中通常用来监听对象属性的变化，比如<code>UIScrollView</code>的<code>ContentOffset</code>,不过同时我们要注意在不需要继续监听的时候及时的移除监听，否则可能会导致崩溃。因此这篇文章让我们更好的了解<code>KVO</code>。</p>
<a id="more"></a>

<h2 id="KVO的使用"><a href="#KVO的使用" class="headerlink" title="KVO的使用"></a>KVO的使用</h2><p>下面我们来看下我们平时使用KVO的方式：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">ViewController</span> ()</span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) Person *man;<br><span class="hljs-keyword">@end</span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">ViewController</span></span><br><br>- (<span class="hljs-keyword">void</span>)viewDidLoad &#123;<br>    [<span class="hljs-keyword">super</span> viewDidLoad];<br>    <span class="hljs-comment">// Do any additional setup after loading the view.</span><br>    <span class="hljs-keyword">self</span>.man = [[Person alloc] init];<br>    [<span class="hljs-keyword">self</span> addKVO];<br>&#125;<br><br>- (<span class="hljs-keyword">void</span>)addKVO &#123;<br>    [<span class="hljs-keyword">self</span>.man addObserver:<span class="hljs-keyword">self</span> forKeyPath:<span class="hljs-string">@&quot;name&quot;</span> options:<span class="hljs-built_in">NSKeyValueObservingOptionNew</span>|<span class="hljs-built_in">NSKeyValueObservingOptionOld</span> context:<span class="hljs-literal">nil</span>];<br>&#125;<br><br>- (<span class="hljs-keyword">void</span>)removeKVO &#123;<br>    [<span class="hljs-keyword">self</span>.man removeObserver:<span class="hljs-keyword">self</span> forKeyPath:<span class="hljs-string">@&quot;name&quot;</span>];<br>&#125;<br><br>- (<span class="hljs-keyword">void</span>)touchesBegan:(<span class="hljs-built_in">NSSet</span>&lt;<span class="hljs-built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="hljs-built_in">UIEvent</span> *)event &#123;<br>    [<span class="hljs-keyword">super</span> touchesBegan:touches withEvent:event];<br>    <span class="hljs-keyword">self</span>.man.name = <span class="hljs-string">@&quot;LeeWong&quot;</span>;<br>&#125;<br><br>- (<span class="hljs-keyword">void</span>)observeValueForKeyPath:(<span class="hljs-built_in">NSString</span> *)keyPath ofObject:(<span class="hljs-keyword">id</span>)object change:(<span class="hljs-built_in">NSDictionary</span>&lt;<span class="hljs-built_in">NSKeyValueChangeKey</span>,<span class="hljs-keyword">id</span>&gt; *)change context:(<span class="hljs-keyword">void</span> *)context &#123;<br>    <span class="hljs-keyword">if</span> ([keyPath isEqual:<span class="hljs-string">@&quot;name&quot;</span>]) &#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;keyPath %@ object %@ change%@ context %@&quot;</span>,keyPath,object,change,context);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure>

<p>每次点击屏幕控制台打印如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-06</span> <span class="hljs-number">20</span>:<span class="hljs-number">05</span>:<span class="hljs-number">15.531233</span>+<span class="hljs-number">0800</span> Runtime-KVO[<span class="hljs-number">2252</span>:<span class="hljs-number">11056787</span>] keyPath name object &lt;Person: <span class="hljs-number">0x600001028060</span>&gt; change&#123;<br>    kind = <span class="hljs-number">1</span>;<br>    new = LeeWong;<br>    old = <span class="hljs-string">&quot;&lt;null&gt;&quot;</span>;<br>&#125; context <span class="hljs-keyword">self</span><br></code></pre></td></tr></table></figure>

<p><code>KVO</code>的使用主要有下面三步：</p>
<h3 id="添加监听"><a href="#添加监听" class="headerlink" title="添加监听"></a>添加监听</h3><p> 我们可以通过调用<code>addObserver</code>方法添加对某个对象的某个属性进行监听,同时我们还可以设置什么情况下会触发我们的监听，这里有一个枚举：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">typedef</span> <span class="hljs-built_in">NS_OPTIONS</span>(<span class="hljs-built_in">NSUInteger</span>, <span class="hljs-built_in">NSKeyValueObservingOptions</span>) &#123;<br>    <span class="hljs-comment">// 属性发生改变时是否需要提供属性的新值</span><br>    <span class="hljs-built_in">NSKeyValueObservingOptionNew</span> = <span class="hljs-number">0x01</span>,<br>    <span class="hljs-comment">// 属性发生改变时是否需要提供属性的旧值</span><br>    <span class="hljs-built_in">NSKeyValueObservingOptionOld</span> = <span class="hljs-number">0x02</span>,<br>    <span class="hljs-comment">// 如果指定，则在添加观察者的时候立即发送一个通知给观察者 并且是在注册观察者方法返回之前</span><br>    <span class="hljs-built_in">NSKeyValueObservingOptionInitial</span> API_AVAILABLE(macos(<span class="hljs-number">10.5</span>), ios(<span class="hljs-number">2.0</span>), watchos(<span class="hljs-number">2.0</span>), tvos(<span class="hljs-number">9.0</span>)) = <span class="hljs-number">0x04</span>,<br>    <span class="hljs-comment">// 并且是在注册观察者方法返回之前这与-willChangeValueForKey:被触发的时间是相对应的</span><br>    <span class="hljs-comment">// 这样，在每次修改属性时，实际上是会发送两条通知</span><br>    <span class="hljs-built_in">NSKeyValueObservingOptionPrior</span> API_AVAILABLE(macos(<span class="hljs-number">10.5</span>), ios(<span class="hljs-number">2.0</span>), watchos(<span class="hljs-number">2.0</span>), tvos(<span class="hljs-number">9.0</span>)) = <span class="hljs-number">0x08</span><br><br>&#125;;<br></code></pre></td></tr></table></figure>
<p>  对于<code>context</code>这个字段实际上我们可以看做给我们提供了一个在观察者与被观察者之间传值的属性，当多个对象监听同一个对象的某个属性发生改变时可用来区分来源。</p>
<h3 id="监听改变"><a href="#监听改变" class="headerlink" title="监听改变"></a>监听改变</h3><p>当被监听的属性发生改变时，会触发<code>observeValueForKeyPath</code>方法</p>
<p>这个方法共有四个参数：</p>
<h4 id="keyPath"><a href="#keyPath" class="headerlink" title="keyPath"></a>keyPath</h4><p>被监听的属性 </p>
<h4 id="object"><a href="#object" class="headerlink" title="object"></a>object</h4><p>被监听的属性所属的对象</p>
<h4 id="change"><a href="#change" class="headerlink" title="change"></a>change</h4><p>本次监听的改变 具体值与添加监听者时<code>NSKeyValueObservingOptions</code>设置有关</p>
<p>在上面的例子中<code>change</code>对应的值为：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs objc">change&#123;<br>    kind = <span class="hljs-number">1</span>;<br>    new = LeeWong;<br>    old = <span class="hljs-string">&quot;&lt;null&gt;&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们来看下<code>change</code>中对应信息的<code>key</code>值有哪些分别用来获取哪些<code>value</code>值：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">// 属性变化的类型，是一个NSNumber对象，包含NSKeyValueChange枚举相关的值</span><br><span class="hljs-built_in">NSString</span> *<span class="hljs-keyword">const</span> <span class="hljs-built_in">NSKeyValueChangeKindKey</span>;<br> <br><span class="hljs-comment">// 属性的新值。当NSKeyValueChangeKindKey是 NSKeyValueChangeSetting，</span><br><span class="hljs-comment">// 且添加观察的方法设置了NSKeyValueObservingOptionNew时，我们能获取到属性的新值。</span><br><span class="hljs-comment">// 如果NSKeyValueChangeKindKey是NSKeyValueChangeInsertion或者NSKeyValueChangeReplacement，</span><br><span class="hljs-comment">// 且指定了NSKeyValueObservingOptionNew时，则我们能获取到一个NSArray对象，包含被插入的对象或</span><br><span class="hljs-comment">// 用于替换其它对象的对象。</span><br><span class="hljs-built_in">NSString</span> *<span class="hljs-keyword">const</span> <span class="hljs-built_in">NSKeyValueChangeNewKey</span>;<br> <br><span class="hljs-comment">// 属性的旧值。当NSKeyValueChangeKindKey是 NSKeyValueChangeSetting，</span><br><span class="hljs-comment">// 且添加观察的方法设置了NSKeyValueObservingOptionOld时，我们能获取到属性的旧值。</span><br><span class="hljs-comment">// 如果NSKeyValueChangeKindKey是NSKeyValueChangeRemoval或者NSKeyValueChangeReplacement，</span><br><span class="hljs-comment">// 且指定了NSKeyValueObservingOptionOld时，则我们能获取到一个NSArray对象，包含被移除的对象或</span><br><span class="hljs-comment">// 被替换的对象。</span><br><span class="hljs-built_in">NSString</span> *<span class="hljs-keyword">const</span> <span class="hljs-built_in">NSKeyValueChangeOldKey</span>;<br> <br><span class="hljs-comment">// 如果NSKeyValueChangeKindKey的值是NSKeyValueChangeInsertion、NSKeyValueChangeRemoval</span><br><span class="hljs-comment">// 或者NSKeyValueChangeReplacement，则这个key对应的值是一个NSIndexSet对象，</span><br><span class="hljs-comment">// 包含了被插入、移除或替换的对象的索引</span><br><span class="hljs-built_in">NSString</span> *<span class="hljs-keyword">const</span> <span class="hljs-built_in">NSKeyValueChangeIndexesKey</span>;<br> <br><span class="hljs-comment">// 当指定了NSKeyValueObservingOptionPrior选项时，在属性被修改的通知发送前，</span><br><span class="hljs-comment">// 会先发送一条通知给观察者。我们可以使用NSKeyValueChangeNotificationIsPriorKey</span><br><span class="hljs-comment">// 来获取到通知是否是预先发送的，如果是，获取到的值总是@(YES)</span><br><span class="hljs-built_in">NSString</span> *<span class="hljs-keyword">const</span> <span class="hljs-built_in">NSKeyValueChangeNotificationIsPriorKey</span>;<br></code></pre></td></tr></table></figure>

<p>同时，<code>NSKeyValueChangeKindKey</code>对应的枚举有：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">typedef</span> <span class="hljs-built_in">NS_ENUM</span>(<span class="hljs-built_in">NSUInteger</span>, <span class="hljs-built_in">NSKeyValueChange</span>) &#123;<br>    <span class="hljs-comment">//设置一个新值。被监听的属性可以是一个对象，也可以是一对一关系的属性或一对多关系的属性。</span><br>    <span class="hljs-built_in">NSKeyValueChangeSetting</span> = <span class="hljs-number">1</span>,<br>    <span class="hljs-comment">//表示一个对象被插入到一对多关系的属性。</span><br>    <span class="hljs-built_in">NSKeyValueChangeInsertion</span> = <span class="hljs-number">2</span>,<br>    <span class="hljs-comment">// 表示一个对象被从一对多关系的属性中移除。</span><br>    <span class="hljs-built_in">NSKeyValueChangeRemoval</span> = <span class="hljs-number">3</span>,<br>    <span class="hljs-comment">// 表示一个对象在一对多的关系的属性中被替换</span><br>    <span class="hljs-built_in">NSKeyValueChangeReplacement</span> = <span class="hljs-number">4</span>,<br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="context"><a href="#context" class="headerlink" title="context"></a>context</h4><p>额外数据</p>
<h3 id="移除监听-removeObserver"><a href="#移除监听-removeObserver" class="headerlink" title="移除监听 removeObserver"></a>移除监听 removeObserver</h3><p> 当监听者不需要监听变化时，需要调用<code>removeObserver</code>方法移除监听。需要注意的是，在监听者被释放前，必须要调用<code>removeObserver:forKeyPath:</code>将其移除，否则会<code>crash</code>。我们看下下面这段代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs objc">- (<span class="hljs-keyword">void</span>)addKVOCrashTest &#123;<br>    Person *person = [Person new];<br>    Person *person2 = [Person new];<br>    [person2 addObserver:person forKeyPath:<span class="hljs-string">@&quot;name&quot;</span> options:<span class="hljs-built_in">NSKeyValueObservingOptionNew</span>|<span class="hljs-built_in">NSKeyValueObservingOptionOld</span> context:<span class="hljs-string">@&quot;person&quot;</span>];<br>    person2.name = <span class="hljs-string">@&quot;LeeWong&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>很明显，上述代码在<code>person</code>释放时并没有移除监听，因此控制台打印如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs objc">libc++abi.dylib: terminating with uncaught exception of type <span class="hljs-built_in">NSException</span><br>*** Terminating app due to uncaught exception <span class="hljs-string">&#x27;NSInternalInconsistencyException&#x27;</span>, reason: <span class="hljs-string">&#x27;&lt;Person: 0x6000018fc120&gt;: An -observeValueForKeyPath:ofObject:change:context: message was received but not handled.</span><br><span class="hljs-string">Key path: name</span><br><span class="hljs-string">Observed object: &lt;Person: 0x6000018fc100&gt;</span><br><span class="hljs-string">Change: &#123;</span><br><span class="hljs-string">    kind = 1;</span><br><span class="hljs-string">    new = LeeWong;</span><br><span class="hljs-string">    old = &quot;&lt;null&gt;&quot;;</span><br><span class="hljs-string">&#125;</span><br></code></pre></td></tr></table></figure>

<p>通过上面的描述我们对<code>KVO</code>的使用有了一个基本的了解，下面我们来看下KVO相关的干货。</p>
<h2 id="KVO-如何实现"><a href="#KVO-如何实现" class="headerlink" title="KVO 如何实现"></a>KVO 如何实现</h2><h3 id="KVO-如果要你去实现-你会如何实现？"><a href="#KVO-如果要你去实现-你会如何实现？" class="headerlink" title="KVO 如果要你去实现 你会如何实现？"></a>KVO 如果要你去实现 你会如何实现？</h3><p>我们可以先来思考下这个问题，<code>KVO</code>实际上就是监听属性改变，我们可能最先想到的就是重写<code>setter</code>方法，在<code>setter</code>方法被调用时我们额外调用一个代理方法通知外部，如果不如想监听属性的改变，添加代理监听就可以了，而且在<code>setter</code>方法中我们可以拿到对应的新值或者旧值，示例代码如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs objc"><br><span class="hljs-class"><span class="hljs-keyword">@protocol</span> <span class="hljs-title">PersonKVODelegate</span> &lt;<span class="hljs-title">NSObject</span>&gt;</span><br><span class="hljs-keyword">@optional</span><br>- (<span class="hljs-keyword">void</span>)personObjectNamePropertyChangeFrom:(<span class="hljs-built_in">NSString</span> *)oldName newName:(<span class="hljs-built_in">NSString</span> *)newName;<br><br><span class="hljs-keyword">@end</span><br><br>- (<span class="hljs-keyword">void</span>)setName:(<span class="hljs-built_in">NSString</span> *)name &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>.delegate &amp;&amp; [<span class="hljs-keyword">self</span>.delegate respondsToSelector:<span class="hljs-keyword">@selector</span>(personObjectNamePropertyChangeFrom:newName:)]) &#123;<br>        [<span class="hljs-keyword">self</span>.delegate personObjectNamePropertyChangeFrom:_name newName:name];<br>    &#125;<br>    _name = name;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这样外部在想监听值改变的时候先设置代理，然后实现对应的方法就可以了。那么系统到底是怎么实现的呢？我们下面来一探究竟。</p>
<h3 id="KVO-实现"><a href="#KVO-实现" class="headerlink" title="KVO 实现"></a>KVO 实现</h3><p>在我们查看<code>KVO</code>监听时我们看到下面这段代码注释：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">// 对于任意类型的属性 NSKeyValueChangeSetting 表示被监听的对象接收到-setValue:forKey:</span><br><span class="hljs-comment">// 消息调用或对象的setter方法被调用或者</span><br><span class="hljs-comment">// -willChangeValueForKey:/-didChangeValueForKey: 被调用</span><br>- For any sort of property (attribute, to-one relationship, or ordered or unordered to-many relationship) <span class="hljs-built_in">NSKeyValueChangeSetting</span> indicates that the observed object has received a -setValue:forKey: message, or that the key-value coding-compliant set method <span class="hljs-keyword">for</span> the key has been invoked, or that a -willChangeValueForKey:/-didChangeValueForKey: pair has otherwise been invoked.<br><br><span class="hljs-comment">// 对于一个有序一对多关系，NSKeyValueChangeInsertion、NSKeyValueChangeRemoval NSKeyValueChangeReplacement 表示通过调用对象的mutableArrayValueForKey：方法给array发送了一个修改消息或者数组或有序集合的修改方法被调用再或者-willChange:valuesAtIndexes:forKey:/-didChange:valuesAtIndexes:forKey 被调用</span><br>- For an _ordered_ to-many relationship, <span class="hljs-built_in">NSKeyValueChangeInsertion</span>, <span class="hljs-built_in">NSKeyValueChangeRemoval</span>, and <span class="hljs-built_in">NSKeyValueChangeReplacement</span> indicate that a mutating message has been sent to the array returned by a -mutableArrayValueForKey: message sent to the object, or sent to the ordered set returned by a -mutableOrderedSetValueForKey: message sent to the object, or that one of the key-value coding-compliant array or ordered set mutation methods <span class="hljs-keyword">for</span> the key has been invoked, or that a -willChange:valuesAtIndexes:forKey:/-didChange:valuesAtIndexes:forKey: pair has otherwise been invoked.<br><span class="hljs-comment">// 对于一个无序的一对多关系 NSKeyValueChangeInsertion NSKeyValueChangeRemoval NSKeyValueChangeReplacement 表示通过调用对象mutableSetValueForKey方法，导致集合的修改方法被调用，或者key-value coding-compliant set 修改方法被调用，或者willChangeValueForKey:withSetMutation:usingObjects:/-didChangeValueForKey:withSetMutation:usingObjects: 方法被调用</span><br>- For an _unordered_ to-many relationship (introduced <span class="hljs-keyword">in</span> Mac OS <span class="hljs-number">10.4</span>), <span class="hljs-built_in">NSKeyValueChangeInsertion</span>, <span class="hljs-built_in">NSKeyValueChangeRemoval</span>, and <span class="hljs-built_in">NSKeyValueChangeReplacement</span> indicate that a mutating message has been sent to the set returned by a -mutableSetValueForKey: message sent to the object, or that one of the key-value coding-compliant set mutation methods <span class="hljs-keyword">for</span> the key has been invoked, or that a -willChangeValueForKey:withSetMutation:usingObjects:/-didChangeValueForKey:withSetMutation:usingObjects: pair has otherwise been invoked.<br></code></pre></td></tr></table></figure>

<p>我们看到无论是一对一还是一对多或者有序还是无序触发的原因之一都有<code>willChangeValueForKey</code>、<code>didChangeValueForKey</code>这两个方法，那么这两个方法是做什么的呢？</p>
<h4 id="NSObject-NSKeyValueObserverNotification"><a href="#NSObject-NSKeyValueObserverNotification" class="headerlink" title="NSObject(NSKeyValueObserverNotification)"></a>NSObject(NSKeyValueObserverNotification)</h4><p>我们在<code>NSKeyValueObserving.h</code>文件中，看到了<code>NSObject(NSKeyValueObserverNotification)</code>分类，在这个分类中，我们我们看到上面提到的几个方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">NSObject</span>(<span class="hljs-title">NSKeyValueObserverNotification</span>)</span><br><span class="hljs-comment">// 通知外部对象的某个属性改变</span><br>- (<span class="hljs-keyword">void</span>)willChangeValueForKey:(<span class="hljs-built_in">NSString</span> *)key;<br>- (<span class="hljs-keyword">void</span>)didChangeValueForKey:(<span class="hljs-built_in">NSString</span> *)key;<br><br><span class="hljs-comment">// 有序的一对多的集合 通知外部属性发生了改变</span><br>- (<span class="hljs-keyword">void</span>)willChange:(<span class="hljs-built_in">NSKeyValueChange</span>)changeKind valuesAtIndexes:(<span class="hljs-built_in">NSIndexSet</span> *)indexes forKey:(<span class="hljs-built_in">NSString</span> *)key;<br>- (<span class="hljs-keyword">void</span>)didChange:(<span class="hljs-built_in">NSKeyValueChange</span>)changeKind valuesAtIndexes:(<span class="hljs-built_in">NSIndexSet</span> *)indexes forKey:(<span class="hljs-built_in">NSString</span> *)key;<br><br><span class="hljs-comment">// 无需的一对多的结合 通知外部属性发生了改变</span><br>- (<span class="hljs-keyword">void</span>)willChangeValueForKey:(<span class="hljs-built_in">NSString</span> *)key withSetMutation:(<span class="hljs-built_in">NSKeyValueSetMutationKind</span>)mutationKind usingObjects:(<span class="hljs-built_in">NSSet</span> *)objects;<br>- (<span class="hljs-keyword">void</span>)didChangeValueForKey:(<span class="hljs-built_in">NSString</span> *)key withSetMutation:(<span class="hljs-built_in">NSKeyValueSetMutationKind</span>)mutationKind usingObjects:(<span class="hljs-built_in">NSSet</span> *)objects;<br><br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure>

<p>我们发现分类中的几个方法和上面我们提到的被调用的方法是一一对应的。</p>
<p>我们先简单看下前两个方法</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">/* Given a key that identifies a property (attribute, to-one relationship, or ordered or unordered to-many relationship), send -observeValueForKeyPath:ofObject:change:context: notification messages of kind NSKeyValueChangeSetting to each observer registered for the key, including those that are registered with other objects using key paths that locate the keyed value in this object. Invocations of these methods must always be paired.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">The change dictionaries in notifications resulting from use of these methods contain optional entries if requested at observer registration time:</span><br><span class="hljs-comment">    - The NSKeyValueChangeOldKey entry, if present, contains the value returned by -valueForKey: at the instant that -willChangeValueForKey: is invoked (or an NSNull if -valueForKey: returns nil).</span><br><span class="hljs-comment">    - The NSKeyValueChangeNewKey entry, if present, contains the value returned by -valueForKey: at the instant that -didChangeValueForKey: is invoked (or an NSNull if -valueForKey: returns nil).</span><br><span class="hljs-comment">*/</span><br>- (<span class="hljs-keyword">void</span>)willChangeValueForKey:(<span class="hljs-built_in">NSString</span> *)key;<br>- (<span class="hljs-keyword">void</span>)didChangeValueForKey:(<span class="hljs-built_in">NSString</span> *)key;<br></code></pre></td></tr></table></figure>

<p>给定一个标识属性的键（属性，一对一关系或有序或无序多对关系），向每个注册该键的观察者发送<code>-observeValueForKeyPath：ofObject：change：context：</code>类型为<code>NSKeyValueChangeSetting</code>的通知消息。这些方法的调用必须始终配对。</p>
<p>如果注册监听的时候有添加，改变通知的字典中会包含下面这两个属性：<br><code>NSKeyValueChangeOldKey：</code>旧值，<code>NSKeyValueChangeNewKey</code> 新值</p>
<p>简单一点去理解就是这两个方法被调用时会触发调用<code>observeValueForKeyPath:ofObject:change:context: </code>方法</p>
<p>既然在属性改变的时候回调用这两个方法，我们是否可以通过重写这两个方法来控制KVO的调用呢？或者什么时间我们需要重写呢？</p>
<p>我们先重写这两个方法，然后看下调用时机：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs objc">- (<span class="hljs-keyword">void</span>)willChangeValueForKey:(<span class="hljs-built_in">NSString</span> *)key &#123;<br>    [<span class="hljs-keyword">super</span> willChangeValueForKey:key];<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;Person willChangeValueForKey %@&quot;</span>,key);<br>&#125;<br><br>- (<span class="hljs-keyword">void</span>)didChangeValueForKey:(<span class="hljs-built_in">NSString</span> *)key &#123;<br>    [<span class="hljs-keyword">super</span> didChangeValueForKey:key];<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;Person didChangeValueForKey %@&quot;</span>,key);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>控制台输出结果：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-12</span> <span class="hljs-number">12</span>:<span class="hljs-number">39</span>:<span class="hljs-number">40.433214</span>+<span class="hljs-number">0800</span> Runtime-KVO[<span class="hljs-number">52130</span>:<span class="hljs-number">15055464</span>] Person willChangeValueForKey name<br><span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-12</span> <span class="hljs-number">12</span>:<span class="hljs-number">39</span>:<span class="hljs-number">40.433527</span>+<span class="hljs-number">0800</span> Runtime-KVO[<span class="hljs-number">52130</span>:<span class="hljs-number">15055464</span>] keyPath name object &lt;Person: <span class="hljs-number">0x600002f65740</span>&gt; change&#123;<br>    kind = <span class="hljs-number">1</span>;<br>    new = LeeWong;<br>    old = <span class="hljs-string">&quot;&lt;null&gt;&quot;</span>;<br>&#125; context <span class="hljs-keyword">self</span><br><span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-12</span> <span class="hljs-number">12</span>:<span class="hljs-number">39</span>:<span class="hljs-number">40.433643</span>+<span class="hljs-number">0800</span> Runtime-KVO[<span class="hljs-number">52130</span>:<span class="hljs-number">15055464</span>] Person didChangeValueForKey name<br></code></pre></td></tr></table></figure>
<p>这里我们可以明显的看出<code>willChangeValueForKey</code>、<code>didChangeValueForKey</code>的调用时机。因此我们猜测其具体的实现应该是：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs objc">- (<span class="hljs-keyword">void</span>)setName:(<span class="hljs-built_in">NSString</span> *)name &#123;<br>    [<span class="hljs-keyword">self</span> willChangeValueForKey:name];<br>    _name = name;<br>    [<span class="hljs-keyword">self</span> didChangeValueForKey:name];<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面是我们从方法调用层看到的<code>KVO</code>的实现，下面我们从底层分析下<code>KVO</code>具体是如何实现的。</p>
<h4 id="KVO-底层实现"><a href="#KVO-底层实现" class="headerlink" title="KVO 底层实现"></a>KVO 底层实现</h4><p>我们先从官方文档中看下<a target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/KeyValueObserving/Articles/KVOImplementation.html">官方对KVO的解释</a>：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs objc">Automatic key-value observing is implemented using a technique called isa-swizzling.<br><br>The isa pointer, as the name suggests, points to the object<span class="hljs-string">&#x27;s class which maintains a dispatch table. This dispatch table essentially contains pointers to the methods the class implements, among other data.</span><br><span class="hljs-string"></span><br><span class="hljs-string">When an observer is registered for an attribute of an object the isa pointer of the observed object is modified, pointing to an intermediate class rather than at the true class. As a result the value of the isa pointer does not necessarily reflect the actual class of the instance.</span><br><span class="hljs-string"></span><br><span class="hljs-string">You should never rely on the isa pointer to determine class membership. Instead, you should use the class method to determine the class of an object instance.</span><br></code></pre></td></tr></table></figure>
<p>自动的键值监听是通过使用<code>isa-swizzling</code>技术实现，即<code>isa</code>交换，下面我们重点看下这段话：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs objc">When an observer is registered <span class="hljs-keyword">for</span> an attribute of an object the isa pointer of the observed object is modified, pointing to an intermediate <span class="hljs-keyword">class</span> rather than at the <span class="hljs-literal">true</span> <span class="hljs-keyword">class</span>.<br></code></pre></td></tr></table></figure>
<p>当注册了某各类的属性监听后，<code>isa</code>指针指向的实际上是另一个中间类而不是真正的类。</p>
<p>我们先通过下面这个例子来验证一下这个说法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;class %@&quot;</span>,<span class="hljs-built_in">NSStringFromClass</span>([<span class="hljs-keyword">self</span>.man <span class="hljs-keyword">class</span>]));<br><br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;isa class %@&quot;</span>,object_getClass(<span class="hljs-keyword">self</span>.man));<br></code></pre></td></tr></table></figure>

<p>打印结果：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-12</span> <span class="hljs-number">13</span>:<span class="hljs-number">36</span>:<span class="hljs-number">28.533095</span>+<span class="hljs-number">0800</span> Runtime-KVO[<span class="hljs-number">55411</span>:<span class="hljs-number">15105963</span>] <span class="hljs-keyword">class</span> Person<br><span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-12</span> <span class="hljs-number">13</span>:<span class="hljs-number">36</span>:<span class="hljs-number">28.533274</span>+<span class="hljs-number">0800</span> Runtime-KVO[<span class="hljs-number">55411</span>:<span class="hljs-number">15105963</span>] isa <span class="hljs-keyword">class</span> <span class="hljs-built_in">NSKVONotifying_Person</span><br></code></pre></td></tr></table></figure>

<p>果然我们通过<code>Class</code>方法和<code>object_getClass</code>获取到的类是不同的，这也验证了实际上系统对有监听的类实际上实现了一个中间类，那么如果我们移除了监听呢？</p>
<p>下面我们来看下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs objc">- (<span class="hljs-keyword">void</span>)kvoClassChange &#123;<br>    [<span class="hljs-keyword">self</span> printClassInfo];<br>    [<span class="hljs-keyword">self</span> addKVO];<br>    [<span class="hljs-keyword">self</span> printClassInfo];<br>    [<span class="hljs-keyword">self</span> removeKVO];<br>    [<span class="hljs-keyword">self</span> printClassInfo];<br>&#125;<br><br>- (<span class="hljs-keyword">void</span>)printClassInfo &#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;---------------------------------&quot;</span>);<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;class %@&quot;</span>,<span class="hljs-built_in">NSStringFromClass</span>([<span class="hljs-keyword">self</span>.man <span class="hljs-keyword">class</span>]));<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;isa class %@&quot;</span>,object_getClass(<span class="hljs-keyword">self</span>.man));<br>&#125;<br><br>- (<span class="hljs-keyword">void</span>)addKVO &#123;<br>    [<span class="hljs-keyword">self</span>.man addObserver:<span class="hljs-keyword">self</span> forKeyPath:<span class="hljs-string">@&quot;name&quot;</span> options:<span class="hljs-built_in">NSKeyValueObservingOptionNew</span>|<span class="hljs-built_in">NSKeyValueObservingOptionOld</span> context:<span class="hljs-string">@&quot;self&quot;</span>];<br>&#125;<br><br>- (<span class="hljs-keyword">void</span>)removeKVO &#123;<br>    [<span class="hljs-keyword">self</span>.man removeObserver:<span class="hljs-keyword">self</span> forKeyPath:<span class="hljs-string">@&quot;name&quot;</span>];<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们看下打印结果：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-12</span> <span class="hljs-number">14</span>:<span class="hljs-number">10</span>:<span class="hljs-number">07.443251</span>+<span class="hljs-number">0800</span> Runtime-KVO[<span class="hljs-number">57507</span>:<span class="hljs-number">15138615</span>] ---------------------------------<br><span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-12</span> <span class="hljs-number">14</span>:<span class="hljs-number">10</span>:<span class="hljs-number">07.443362</span>+<span class="hljs-number">0800</span> Runtime-KVO[<span class="hljs-number">57507</span>:<span class="hljs-number">15138615</span>] <span class="hljs-keyword">class</span> Person<br><span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-12</span> <span class="hljs-number">14</span>:<span class="hljs-number">10</span>:<span class="hljs-number">07.443446</span>+<span class="hljs-number">0800</span> Runtime-KVO[<span class="hljs-number">57507</span>:<span class="hljs-number">15138615</span>] isa <span class="hljs-keyword">class</span> Person<br><span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-12</span> <span class="hljs-number">14</span>:<span class="hljs-number">10</span>:<span class="hljs-number">07.443787</span>+<span class="hljs-number">0800</span> Runtime-KVO[<span class="hljs-number">57507</span>:<span class="hljs-number">15138615</span>] ---------------------------------<br><span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-12</span> <span class="hljs-number">14</span>:<span class="hljs-number">10</span>:<span class="hljs-number">07.443896</span>+<span class="hljs-number">0800</span> Runtime-KVO[<span class="hljs-number">57507</span>:<span class="hljs-number">15138615</span>] <span class="hljs-keyword">class</span> Person<br><span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-12</span> <span class="hljs-number">14</span>:<span class="hljs-number">10</span>:<span class="hljs-number">07.443988</span>+<span class="hljs-number">0800</span> Runtime-KVO[<span class="hljs-number">57507</span>:<span class="hljs-number">15138615</span>] isa <span class="hljs-keyword">class</span> <span class="hljs-built_in">NSKVONotifying_Person</span><br><span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-12</span> <span class="hljs-number">14</span>:<span class="hljs-number">10</span>:<span class="hljs-number">07.444116</span>+<span class="hljs-number">0800</span> Runtime-KVO[<span class="hljs-number">57507</span>:<span class="hljs-number">15138615</span>] ---------------------------------<br><span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-12</span> <span class="hljs-number">14</span>:<span class="hljs-number">10</span>:<span class="hljs-number">07.444209</span>+<span class="hljs-number">0800</span> Runtime-KVO[<span class="hljs-number">57507</span>:<span class="hljs-number">15138615</span>] <span class="hljs-keyword">class</span> Person<br><span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-12</span> <span class="hljs-number">14</span>:<span class="hljs-number">10</span>:<span class="hljs-number">07.444303</span>+<span class="hljs-number">0800</span> Runtime-KVO[<span class="hljs-number">57507</span>:<span class="hljs-number">15138615</span>] isa <span class="hljs-keyword">class</span> Person<br></code></pre></td></tr></table></figure>

<p>很明显我们发现，在我们添加<code>KVO</code>监听之后和移除<code>KVO</code>监听之前我们的对象的<code>isa</code>指针实际上指向了一个新的类<code>NSKVONotifying_Person</code>,因此我们在判断类型的时候应该使用<code>Class</code>而不是<code>isa</code>指向的<code>class</code>。</p>
<p>那么<code>NSKVONotifying_Person</code>和<code>Person</code>类是什么关系呢？</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs objc">- (<span class="hljs-keyword">void</span>)printKVOClassChain &#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;---------------------------------&quot;</span>);<br>    Class cls = object_getClass(<span class="hljs-keyword">self</span>.man);<br>    <span class="hljs-keyword">while</span> (cls) &#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;claas %@ &#x27;s supercls %@&quot;</span>,cls,class_getSuperclass(cls));<br>        cls = class_getSuperclass(cls);<br>    &#125;<br><br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;---------------------------------&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>打印结果如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-12</span> <span class="hljs-number">14</span>:<span class="hljs-number">38</span>:<span class="hljs-number">51.707598</span>+<span class="hljs-number">0800</span> Runtime-KVO[<span class="hljs-number">59228</span>:<span class="hljs-number">15165470</span>] claas <span class="hljs-built_in">NSKVONotifying_Person</span> <span class="hljs-string">&#x27;s supercls Person</span><br><span class="hljs-string">2020-12-12 14:38:51.707712+0800 Runtime-KVO[59228:15165470] claas Person &#x27;</span>s supercls <span class="hljs-built_in">NSObject</span><br><span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-12</span> <span class="hljs-number">14</span>:<span class="hljs-number">38</span>:<span class="hljs-number">51.707802</span>+<span class="hljs-number">0800</span> Runtime-KVO[<span class="hljs-number">59228</span>:<span class="hljs-number">15165470</span>] claas <span class="hljs-built_in">NSObject</span> <span class="hljs-string">&#x27;s supercls (null)</span><br></code></pre></td></tr></table></figure>

<p>通过打印结果我们发现实际上<code>NSKVONotifying_Person</code>是<code>Person</code>的一个子类。</p>
<p>那么<code>NSKVONotifying_Person</code>这个类的方法列表结构：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs objc">- (<span class="hljs-keyword">void</span>)printClassInfo &#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;---------------------------------&quot;</span>);<br>    Class cls = object_getClass(<span class="hljs-keyword">self</span>.man);<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;isa class %@&quot;</span>,cls);<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;---------------------------class method list &quot;</span>);<br>    <span class="hljs-built_in">NSUInteger</span> methodCount = <span class="hljs-number">0</span>;<br>    Method * methodList = class_copyMethodList(object_getClass(<span class="hljs-keyword">self</span>.man), &amp;methodCount);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-built_in">NSUInteger</span> i = <span class="hljs-number">0</span>; i &lt; methodCount; i++) &#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%@&quot;</span>,<span class="hljs-built_in">NSStringFromSelector</span>(method_getName(methodList[i])));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>打印结果：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-12</span> <span class="hljs-number">14</span>:<span class="hljs-number">33</span>:<span class="hljs-number">57.447079</span>+<span class="hljs-number">0800</span> Runtime-KVO[<span class="hljs-number">58941</span>:<span class="hljs-number">15160616</span>] ---------------------------------<br><span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-12</span> <span class="hljs-number">14</span>:<span class="hljs-number">33</span>:<span class="hljs-number">57.447190</span>+<span class="hljs-number">0800</span> Runtime-KVO[<span class="hljs-number">58941</span>:<span class="hljs-number">15160616</span>] isa <span class="hljs-keyword">class</span> <span class="hljs-built_in">NSKVONotifying_Person</span><br><span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-12</span> <span class="hljs-number">14</span>:<span class="hljs-number">33</span>:<span class="hljs-number">57.447283</span>+<span class="hljs-number">0800</span> Runtime-KVO[<span class="hljs-number">58941</span>:<span class="hljs-number">15160616</span>] ---------------------------<span class="hljs-keyword">class</span> method list<br><span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-12</span> <span class="hljs-number">14</span>:<span class="hljs-number">33</span>:<span class="hljs-number">57.447388</span>+<span class="hljs-number">0800</span> Runtime-KVO[<span class="hljs-number">58941</span>:<span class="hljs-number">15160616</span>] setName:<br><span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-12</span> <span class="hljs-number">14</span>:<span class="hljs-number">33</span>:<span class="hljs-number">57.447481</span>+<span class="hljs-number">0800</span> Runtime-KVO[<span class="hljs-number">58941</span>:<span class="hljs-number">15160616</span>] <span class="hljs-keyword">class</span><br><span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-12</span> <span class="hljs-number">14</span>:<span class="hljs-number">33</span>:<span class="hljs-number">57.447597</span>+<span class="hljs-number">0800</span> Runtime-KVO[<span class="hljs-number">58941</span>:<span class="hljs-number">15160616</span>] dealloc<br><span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-12</span> <span class="hljs-number">14</span>:<span class="hljs-number">33</span>:<span class="hljs-number">57.447694</span>+<span class="hljs-number">0800</span> Runtime-KVO[<span class="hljs-number">58941</span>:<span class="hljs-number">15160616</span>] _isKVOA<br></code></pre></td></tr></table></figure>
<p>上面我们已经知道<code>NSKVONotifying_Person</code>类实际是Person的一个子类:</p>
<ul>
<li>这里<code>setName</code>我们理解就是重写父类<code>Observer</code>监听属性的<code>setter</code>方法，然后内部调用了<code>didChangeValueForKey:</code>、<code>willChangeValueForKey:</code>方法用于通知外部，</li>
<li><code>class</code> 方法重写是为了外部在调用<code>class</code>方法获取类的类型是获取到的是父类的类型</li>
<li><code>dealloc</code> 是为了在父类被释放的时候子类检查是否被释放了</li>
<li><code>_isKVOA</code> 来说明自己是一个<code>KVO</code>类</li>
</ul>
<p>这样我们就了解了<code>KVO</code>的整个实现原理，下面我们来看下<code>KVO</code>的一些扩展用法。</p>
<h2 id="KVO-应用"><a href="#KVO-应用" class="headerlink" title="KVO 应用"></a>KVO 应用</h2><h3 id="如何监听数组个数改变"><a href="#如何监听数组个数改变" class="headerlink" title="如何监听数组个数改变"></a>如何监听数组个数改变</h3><p>我们上面都是用<code>KVO</code>监听对象的某个属性的改变，那么如果我们要监听集合类型的属性呢？</p>
<p>我们上面了解到了实际上系统是重写了属性的<code>setting</code>方法，然后通知到外部属性改变，但是当我们向数组中添加或者删除元素时，实际上我们并没有修改数组的<code>count</code>属性，那么我们该如何监听<code>count</code>的改变呢？</p>
<p>我们先尝试用正常监听对象属性的方式添加监听：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs objc">- (<span class="hljs-keyword">void</span>)arrayKVO &#123;<br>    <span class="hljs-keyword">self</span>.personArray = [@[<span class="hljs-string">@&quot;1&quot;</span>] mutableCopy];<br>    [<span class="hljs-keyword">self</span>.personArray addObserver:<span class="hljs-keyword">self</span> forKeyPath:<span class="hljs-string">@&quot;count&quot;</span> options:<span class="hljs-built_in">NSKeyValueObservingOptionNew</span>|<span class="hljs-built_in">NSKeyValueObservingOptionOld</span> context:<span class="hljs-string">@&quot;aaa&quot;</span>];<br>    [<span class="hljs-keyword">self</span>.personArray addObject:<span class="hljs-string">@&quot;2&quot;</span>];<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们看下输出结果：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-12</span> <span class="hljs-number">14</span>:<span class="hljs-number">51</span>:<span class="hljs-number">30.825912</span>+<span class="hljs-number">0800</span> Runtime-KVO[<span class="hljs-number">59915</span>:<span class="hljs-number">15176280</span>] *** Terminating app due to uncaught exception <span class="hljs-string">&#x27;NSInvalidArgumentException&#x27;</span>, reason: <span class="hljs-string">&#x27;[&lt;__NSArrayM 0x60000246f0c0&gt; addObserver:forKeyPath:options:context:] is not supported. Key path: count&#x27;</span><br>*** First throw call stack:<br></code></pre></td></tr></table></figure>

<p>结果很明显我们无法监听<code>count</code>，系统直接崩溃。那么我们应该如何监听呢？ 但是当我监听一个自定义对象中的一个数组属性时却并没有出现<code>crash</code>，这里苦思不得解。我们先来看下这段代码</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs objc">- (<span class="hljs-keyword">void</span>)personChildrenKVO &#123;<br>    [<span class="hljs-keyword">self</span>.man addObserver:<span class="hljs-keyword">self</span> forKeyPath:<span class="hljs-string">@&quot;children&quot;</span> options:<span class="hljs-built_in">NSKeyValueObservingOptionNew</span>|<span class="hljs-built_in">NSKeyValueObservingOptionOld</span> context:<span class="hljs-string">@&quot;aaa&quot;</span>];<br>    [<span class="hljs-keyword">self</span>.man.children addObject:<span class="hljs-string">@&quot;2&quot;</span>];<br>&#125;<br></code></pre></td></tr></table></figure>
<p>其中children是Person对象中的一个可变数组属性</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">Person</span> : <span class="hljs-title">NSObject</span></span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-built_in">NSMutableArray</span> *children;<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure>
<p>不过虽然没有崩溃但是依然我们无法监听到数组的改变，那么我们究竟如何才可以监听到数组的改变呢？</p>
<p>实际上通过上面对KVO的原理的理解，实际上对于<code>Person</code>对象，我们在<code>KVO</code>监听时，实际上系统实现了<code>KVO</code>的子类并实现了被监听属性的<code>setter</code>方法，然后在内部调用触发<code>KVO</code>的方法，但是很明显这里并没有调用到<code>KVO</code>的监听方法，那么这里对于集合类型的数组和普通的对象是否有区别呢？</p>
<p>我们按照上面的逻辑在进一步的分析一下：</p>
<p>我们修改数组中元素个数实际上是通过给数组增加或者删除元素来实现的，但是根据上面的了解，如果子类对象只是实现了<code>children</code>的<code>setter</code>方法，在我们添加或者删除元素的时候并不会调用到<code>setter</code>方法，而是调用了<code>addObject:</code>或者<code>removeObject:</code>。这样实际并不会通知到外部。我们在最开始讨论<code>KVO</code>实现的时候，我们看到了对于有序集合提到了一个方法<code>mutableArrayValueForKey:</code> 我们先看下这个方法</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">/* Given a key that identifies an _ordered_ to-many relationship, return a mutable array that provides read-write access to the related objects. Objects added to the mutable array will become related to the receiver, and objects removed from the mutable array will become unrelated.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">The default implementation of this method recognizes the same simple accessor methods and array accessor methods as -valueForKey:&#x27;s, and follows the same direct instance variable access policies, but always returns a mutable collection proxy object instead of the immutable collection that -valueForKey: would return. It also:</span><br><span class="hljs-comment">    1. Searches the class of the receiver for methods whose names match the patterns -insertObject:in&lt;Key&gt;AtIndex: and -removeObjectFrom&lt;Key&gt;AtIndex: (corresponding to the two most primitive methods defined by the NSMutableArray class), and (introduced in Mac OS 10.4) also -insert&lt;Key&gt;:atIndexes: and -remove&lt;Key&gt;AtIndexes: (corresponding to -[NSMutableArray insertObjects:atIndexes:] and -[NSMutableArray removeObjectsAtIndexes:). If at least one insertion method and at least one removal method are found each NSMutableArray message sent to the collection proxy object will result in some combination of -insertObject:in&lt;Key&gt;AtIndex:, -removeObjectFrom&lt;Key&gt;AtIndex:, -insert&lt;Key&gt;:atIndexes:, and -remove&lt;Key&gt;AtIndexes: messages being sent to the original receiver of -mutableArrayValueForKey:. If the class of the receiver also implements an optional method whose name matches the pattern -replaceObjectIn&lt;Key&gt;AtIndex:withObject: or (introduced in Mac OS 10.4) -replace&lt;Key&gt;AtIndexes:with&lt;Key&gt;: that method will be used when appropriate for best performance.</span><br><span class="hljs-comment">    2. Otherwise (no set of array mutation methods is found), searches the class of the receiver for an accessor method whose name matches the pattern -set&lt;Key&gt;:. If such a method is found each NSMutableArray message sent to the collection proxy object will result in a -set&lt;Key&gt;: message being sent to the original receiver of -mutableArrayValueForKey:.</span><br><span class="hljs-comment">    3. Otherwise (no set of array mutation methods or simple accessor method is found), if the receiver&#x27;s class&#x27; +accessInstanceVariablesDirectly property returns YES, searches the class of the receiver for an instance variable whose name matches the pattern _&lt;key&gt; or &lt;key&gt;, in that order. If such an instance variable is found, each NSMutableArray message sent to the collection proxy object will be forwarded to the instance variable&#x27;s value, which therefore must typically be an instance of NSMutableArray or a subclass of NSMutableArray.</span><br><span class="hljs-comment">    4. Otherwise (no set of array mutation methods, simple accessor method, or instance variable is found), returns a mutable collection proxy object anyway. Each NSMutableArray message sent to the collection proxy object will result in a -setValue:forUndefinedKey: message being sent to the original receiver of -mutableArrayValueForKey:. The default implementation of -setValue:forUndefinedKey: raises an NSUndefinedKeyException, but you can override it in your application.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">Performance note: the repetitive -set&lt;Key&gt;: messages implied by step 2&#x27;s description are a potential performance problem. For better performance implement insertion and removal methods that fulfill the requirements for step 1 in your KVC-compliant class. For best performance implement a replacement method too.</span><br><span class="hljs-comment">*/</span><br>- (<span class="hljs-built_in">NSMutableArray</span> *)mutableArrayValueForKey:(<span class="hljs-built_in">NSString</span> *)key;<br></code></pre></td></tr></table></figure>

<p>我们来看下官方对这个方法的解释：</p>
<p>调用<code>mutableArrayValueForKey</code>后，<code>KVC</code>先会搜索类中是否有<code>insertObject:in&lt;Key&gt;AtIndex:</code> , <code>removeObjectFrom&lt;Key&gt;AtIndex:</code> 或者 <code>insert&lt;Key&gt;AtIndexes</code> , <code>remove&lt;Key&gt;AtIndexes</code> 格式的方法，如果至少找到一个<code>insert</code>方法和一个<code>remove</code>方法，那么返回一个可以响应<code>NSMutableArray</code>所有方法的代理集合，那么给这个代理集合发送<code>NSMutableArray</code>的方法，以<code>insertObject:in&lt;Key&gt;AtIndex:</code> , <code>removeObjectFrom&lt;Key&gt;AtIndex: </code>或者 <code>insert&lt;Key&gt;AdIndexes </code>, <code>remove&lt;Key&gt;AtIndexes</code>组合的形式调用。<br>如果上述的方法没有找到，则搜索<code>set&lt;Key&gt;:</code> 格式的方法，如果找到，那么发送给代理集合的<code>NSMutableArray</code>最终都会调用<code>set&lt;Key&gt;:</code>方法。</p>
<p>结合我们上面猜测没有触发<code>KVO</code>监听的原因:没有调用到数组的<code>setter</code>方法，在结合上面的解释，我们做下面的尝试：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs objc">- (<span class="hljs-keyword">void</span>)personChildrenKVO &#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;111children class %@ object %p&quot;</span>,object_getClass(<span class="hljs-keyword">self</span>.man.children),<span class="hljs-keyword">self</span>.man.children);<br>    [<span class="hljs-keyword">self</span>.man addObserver:<span class="hljs-keyword">self</span> forKeyPath:<span class="hljs-string">@&quot;children&quot;</span> options:<span class="hljs-built_in">NSKeyValueObservingOptionNew</span>|<span class="hljs-built_in">NSKeyValueObservingOptionOld</span> context:<span class="hljs-string">@&quot;aaa&quot;</span>];<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;222children class %@ object %p&quot;</span>,object_getClass(<span class="hljs-keyword">self</span>.man.children),<span class="hljs-keyword">self</span>.man.children);<br>    [[<span class="hljs-keyword">self</span>.man mutableArrayValueForKey:<span class="hljs-string">@&quot;children&quot;</span>] addObject:<span class="hljs-string">@&quot;2&quot;</span>];<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;333children class %@ object %p&quot;</span>,object_getClass(<span class="hljs-keyword">self</span>.man.children),<span class="hljs-keyword">self</span>.man.children);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>我们在看下打印结果：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-13</span> <span class="hljs-number">13</span>:<span class="hljs-number">46</span>:<span class="hljs-number">35.174397</span>+<span class="hljs-number">0800</span> Runtime-KVO[<span class="hljs-number">76796</span>:<span class="hljs-number">15662273</span>] <span class="hljs-number">111</span>children <span class="hljs-keyword">class</span> __NSArrayM object <span class="hljs-number">0x6000016cc2a0</span><br><span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-13</span> <span class="hljs-number">13</span>:<span class="hljs-number">46</span>:<span class="hljs-number">35.174787</span>+<span class="hljs-number">0800</span> Runtime-KVO[<span class="hljs-number">76796</span>:<span class="hljs-number">15662273</span>] <span class="hljs-number">222</span>children <span class="hljs-keyword">class</span> __NSArrayM object <span class="hljs-number">0x6000016cc2a0</span><br><span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-13</span> <span class="hljs-number">13</span>:<span class="hljs-number">46</span>:<span class="hljs-number">35.175057</span>+<span class="hljs-number">0800</span> Runtime-KVO[<span class="hljs-number">76796</span>:<span class="hljs-number">15662273</span>] observeValueForKeyPath <span class="hljs-keyword">for</span> keyPath children<br><span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-13</span> <span class="hljs-number">13</span>:<span class="hljs-number">46</span>:<span class="hljs-number">35.175175</span>+<span class="hljs-number">0800</span> Runtime-KVO[<span class="hljs-number">76796</span>:<span class="hljs-number">15662273</span>] <span class="hljs-number">333</span>children <span class="hljs-keyword">class</span> __NSArrayM object <span class="hljs-number">0x6000016cccc0</span><br></code></pre></td></tr></table></figure>

<p>我们发现，我们的<code>KVO</code>生效了。</p>
<p>当我们在代理方法中打了断点后，方法调用的堆栈如下：</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glm6lu6wazj324g0eg1eh.jpg"></p>
<p>这也恰好与我们的猜测相对应：我们发现在监听被触发后，我们的<code>children</code>数组的地址也发生了变化，这里跟我们猜测相同，这里应该是有一个<code>children</code>的子类(图中的<code>NSKeyValueNotifyingMutableArray)</code>，实现了<code>children</code>的某些方法。</p>
<p>在刚才了解<code>mutableArrayValueForKey:</code>方法时，我们看到有一个提示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs objc">Performance note: the repetitive -set&lt;Key&gt;: messages implied by step <span class="hljs-number">2</span><span class="hljs-string">&#x27;s description are a potential performance problem. For better performance implement insertion and removal methods that fulfill the requirements for step 1 in your KVC-compliant class. For best performance implement a replacement method too.</span><br></code></pre></td></tr></table></figure>

<p>因为子类没有实现而调用<code>set</code>方法可能会有性能问题，因此最好实现<code>insert</code>或者<code>remove</code>方法。</p>
<p>那么我们看下该如何实现：<br>依据上面描述的，我们在<code>Person</code>类中新增下面几个方法</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs objc">- (<span class="hljs-keyword">instancetype</span>)initWithChildren:(<span class="hljs-built_in">NSMutableArray</span> *)children;<br><br>- (<span class="hljs-keyword">void</span>)removeObjectFromChildrenAtIndex:(<span class="hljs-built_in">NSUInteger</span>)index;<br>- (<span class="hljs-keyword">void</span>)removeChildrenAtIndexes:(<span class="hljs-built_in">NSIndexSet</span> *)indexes;<br>- (<span class="hljs-keyword">void</span>)insertObject:(<span class="hljs-keyword">id</span>)object inChildrenAtIndex:(<span class="hljs-built_in">NSUInteger</span>)index;<br>- (<span class="hljs-keyword">void</span>)insertChildren:(<span class="hljs-built_in">NSArray</span> *)array atIndexes:(<span class="hljs-built_in">NSIndexSet</span> *)indexes;<br><br></code></pre></td></tr></table></figure>

<p>然后在内部实现这几个方法:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs objc"><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">Person</span></span><br><br>- (<span class="hljs-keyword">instancetype</span>)initWithChildren:(<span class="hljs-built_in">NSMutableArray</span> *)children &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span> = [<span class="hljs-keyword">super</span> init]) &#123;<br>        _children = children;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>;<br>&#125;<br><br>- (<span class="hljs-keyword">instancetype</span>)init &#123;<br>    <span class="hljs-keyword">return</span> [<span class="hljs-keyword">self</span> initWithChildren:[<span class="hljs-built_in">NSMutableArray</span> array]];<br>&#125;<br><br>- (<span class="hljs-keyword">void</span>)setName:(<span class="hljs-built_in">NSString</span> *)name &#123;<br>    [<span class="hljs-keyword">self</span> willChangeValueForKey:name];<br>    _name = name;<br>    [<span class="hljs-keyword">self</span> didChangeValueForKey:name];<br>&#125;<br><br>- (<span class="hljs-keyword">void</span>)willChangeValueForKey:(<span class="hljs-built_in">NSString</span> *)key &#123;<br>    [<span class="hljs-keyword">super</span> willChangeValueForKey:key];<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;Person willChangeValueForKey %@&quot;</span>,key);<br>&#125;<br><br>- (<span class="hljs-keyword">void</span>)didChangeValueForKey:(<span class="hljs-built_in">NSString</span> *)key &#123;<br>    [<span class="hljs-keyword">super</span> didChangeValueForKey:key];<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;Person didChangeValueForKey %@&quot;</span>,key);<br>&#125;<br><br><br>- (<span class="hljs-keyword">void</span>)insertChildren:(<span class="hljs-built_in">NSArray</span> *)array atIndexes:(<span class="hljs-built_in">NSIndexSet</span> *)indexes &#123;<br>    [<span class="hljs-keyword">self</span>.children insertObjects:array atIndexes:indexes];<br>&#125;<br><br>- (<span class="hljs-keyword">void</span>)insertObject:(<span class="hljs-keyword">id</span>)object inChildrenAtIndex:(<span class="hljs-built_in">NSUInteger</span>)index &#123;<br>    [<span class="hljs-keyword">self</span>.children insertObject:object atIndex:index];<br>&#125;<br><br>- (<span class="hljs-keyword">void</span>)removeChildrenAtIndexes:(<span class="hljs-built_in">NSIndexSet</span> *)indexes &#123;<br>    [<span class="hljs-keyword">self</span>.children removeObjectsAtIndexes:indexes];<br>&#125;<br><br>- (<span class="hljs-keyword">void</span>)removeObjectFromChildrenAtIndex:(<span class="hljs-built_in">NSUInteger</span>)index &#123;<br>    [<span class="hljs-keyword">self</span>.children removeObjectAtIndex:index];<br>&#125;<br><br>- (<span class="hljs-keyword">void</span>)willChange:(<span class="hljs-built_in">NSKeyValueChange</span>)changeKind valuesAtIndexes:(<span class="hljs-built_in">NSIndexSet</span> *)indexes forKey:(<span class="hljs-built_in">NSString</span> *)key &#123;<br>    [<span class="hljs-keyword">super</span> willChange:changeKind valuesAtIndexes:indexes forKey:key];<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;Person willChange:changeKind %@ valuesAtIndexes:indexes= %@ forKey:key = %@&quot;</span>,@(changeKind),indexes,key);<br>&#125;<br><br>- (<span class="hljs-keyword">void</span>)didChange:(<span class="hljs-built_in">NSKeyValueChange</span>)changeKind valuesAtIndexes:(<span class="hljs-built_in">NSIndexSet</span> *)indexes forKey:(<span class="hljs-built_in">NSString</span> *)key &#123;<br>    [<span class="hljs-keyword">super</span> didChange:changeKind valuesAtIndexes:indexes forKey:key];<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;Person didChange:changeKind %@ valuesAtIndexes:indexes= %@ forKey:key = %@&quot;</span>,@(changeKind),indexes,key);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>然后我们看下调用的位置：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs objc">- (<span class="hljs-keyword">void</span>)personChildrenKVO &#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;111children class %@ object %p&quot;</span>,object_getClass(<span class="hljs-keyword">self</span>.man),<span class="hljs-keyword">self</span>.man);<br>    [<span class="hljs-keyword">self</span>.man addObserver:<span class="hljs-keyword">self</span> forKeyPath:<span class="hljs-string">@&quot;children&quot;</span> options:<span class="hljs-built_in">NSKeyValueObservingOptionNew</span>|<span class="hljs-built_in">NSKeyValueObservingOptionOld</span> context:<span class="hljs-string">@&quot;aaa&quot;</span>];<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;222children class %@ object %p&quot;</span>,object_getClass(<span class="hljs-keyword">self</span>.man),<span class="hljs-keyword">self</span>.man);<br>    [<span class="hljs-keyword">self</span>.man insertObject:<span class="hljs-string">@&quot;111&quot;</span> inChildrenAtIndex:<span class="hljs-number">0</span>];<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;333children class %@ object %p&quot;</span>,object_getClass(<span class="hljs-keyword">self</span>.man),<span class="hljs-keyword">self</span>.man);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>打印结果：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-13</span> <span class="hljs-number">14</span>:<span class="hljs-number">59</span>:<span class="hljs-number">04.047625</span>+<span class="hljs-number">0800</span> Runtime-KVO[<span class="hljs-number">78041</span>:<span class="hljs-number">15718979</span>] <span class="hljs-number">111</span>children <span class="hljs-keyword">class</span> Person object <span class="hljs-number">0x600000455340</span><br><span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-13</span> <span class="hljs-number">14</span>:<span class="hljs-number">59</span>:<span class="hljs-number">04.047936</span>+<span class="hljs-number">0800</span> Runtime-KVO[<span class="hljs-number">78041</span>:<span class="hljs-number">15718979</span>] <span class="hljs-number">222</span>children <span class="hljs-keyword">class</span> <span class="hljs-built_in">NSKVONotifying_Person</span> object <span class="hljs-number">0x600000455340</span><br><span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-13</span> <span class="hljs-number">14</span>:<span class="hljs-number">59</span>:<span class="hljs-number">04.048149</span>+<span class="hljs-number">0800</span> Runtime-KVO[<span class="hljs-number">78041</span>:<span class="hljs-number">15718979</span>] Person willChange:changeKind <span class="hljs-number">2</span> valuesAtIndexes:indexes= &lt;_NSCachedIndexSet: <span class="hljs-number">0x60000045c5c0</span>&gt;[number of indexes: <span class="hljs-number">1</span> (<span class="hljs-keyword">in</span> <span class="hljs-number">1</span> ranges), indexes: (<span class="hljs-number">0</span>)] forKey:key = children<br><span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-13</span> <span class="hljs-number">14</span>:<span class="hljs-number">59</span>:<span class="hljs-number">04.048284</span>+<span class="hljs-number">0800</span> Runtime-KVO[<span class="hljs-number">78041</span>:<span class="hljs-number">15718979</span>] observeValueForKeyPath <span class="hljs-keyword">for</span> keyPath children<br><span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-13</span> <span class="hljs-number">14</span>:<span class="hljs-number">59</span>:<span class="hljs-number">04.048412</span>+<span class="hljs-number">0800</span> Runtime-KVO[<span class="hljs-number">78041</span>:<span class="hljs-number">15718979</span>] Person didChange:changeKind <span class="hljs-number">2</span> valuesAtIndexes:indexes= &lt;_NSCachedIndexSet: <span class="hljs-number">0x60000045c5c0</span>&gt;[number of indexes: <span class="hljs-number">1</span> (<span class="hljs-keyword">in</span> <span class="hljs-number">1</span> ranges), indexes: (<span class="hljs-number">0</span>)] forKey:key = children<br><span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-13</span> <span class="hljs-number">14</span>:<span class="hljs-number">59</span>:<span class="hljs-number">04.048521</span>+<span class="hljs-number">0800</span> Runtime-KVO[<span class="hljs-number">78041</span>:<span class="hljs-number">15718979</span>] <span class="hljs-number">333</span>children <span class="hljs-keyword">class</span> <span class="hljs-built_in">NSKVONotifying_Person</span> object <span class="hljs-number">0x600000455340</span><br></code></pre></td></tr></table></figure>

<p>从log中我们看到，通过这种方法我们可以使用KVO捕捉到数组的变化。而且我们发现添加<code>KVO</code>之后我们的<code>Person</code>类也变成了<code>NSKVONotifying_Person</code>类型，同样在<code>KVO</code>被触发的前后<code>willChange:changeKind:valuesAtIndexes</code>和<code>didChange:changeKind:valuesAtIndexes</code>方法也被调用了。进而调用<code>KVO</code>的代理方法通知外部属性改变。</p>
<h3 id="如何监听复合改变"><a href="#如何监听复合改变" class="headerlink" title="如何监听复合改变"></a>如何监听复合改变</h3><p>在我们平时的工作中除了监听对象的某个属性的改变，还可能会用到监听某些复合条件的值的改变，尤其是之前用到RAC时，我们可以绑定监听2个属性的信号，两个监听的对象中中任何一个发生改变都需要通知到监听者，这种如果使用KVO该如何实现呢？</p>
<p>例如还是在我们Person对象中，我们有两个属性:姓名和年龄，我们还有一个方法用来获取这个人的简介</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs objc">- (<span class="hljs-built_in">NSString</span> *)personDescription &#123;<br>    <span class="hljs-keyword">return</span> [<span class="hljs-built_in">NSString</span> stringWithFormat:<span class="hljs-string">@&quot;My name is %@,I&#x27;m %@ years old&quot;</span>,<span class="hljs-keyword">self</span>.name,@(<span class="hljs-keyword">self</span>.age)];<br>&#125;<br></code></pre></td></tr></table></figure>
<p>我们希望监听<code>personDescription</code>的改变，但是<code>personDescription</code>的改变实际上依赖<code>name</code>和<code>age</code>的改变。</p>
<p>这种情况下实际上系统也为我们提供了一个方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs objc"><br><span class="hljs-comment">/* Return a set of key paths for properties whose values affect the value of the keyed property. When an observer for the key is registered with an instance of the receiving class, KVO itself automatically observes all of the key paths for the same instance, and sends change notifications for the key to the observer when the value for any of those key paths changes. The default implementation of this method searches the receiving class for a method whose name matches the pattern +keyPathsForValuesAffecting&lt;Key&gt;, and returns the result of invoking that method if it is found. So, any such method must return an NSSet too. If no such method is found, an NSSet that is computed from information provided by previous invocations of the now-deprecated +setKeys:triggerChangeNotificationsForDependentKey: method is returned, for backward binary compatibility.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">This method and KVO&#x27;s automatic use of it comprise a dependency mechanism that you can use instead of sending -willChangeValueForKey:/-didChangeValueForKey: messages for dependent, computed, properties.</span><br><span class="hljs-comment"> </span><br><span class="hljs-comment">You can override this method when the getter method of one of your properties computes a value to return using the values of other properties, including those that are located by key paths. Your override should typically invoke super and return a set that includes any members in the set that result from doing that (so as not to interfere with overrides of this method in superclasses).</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">You can&#x27;t really override this method when you add a computed property to an existing class using a category, because you&#x27;re not supposed to override methods in categories. In that case, implement a matching +keyPathsForValuesAffecting&lt;Key&gt; to take advantage of this mechanism.</span><br><span class="hljs-comment">*/</span><br>+ (<span class="hljs-built_in">NSSet</span>&lt;<span class="hljs-built_in">NSString</span> *&gt; *)keyPathsForValuesAffectingValueForKey:(<span class="hljs-built_in">NSString</span> *)key API_AVAILABLE(macos(<span class="hljs-number">10.5</span>), ios(<span class="hljs-number">2.0</span>), watchos(<span class="hljs-number">2.0</span>), tvos(<span class="hljs-number">9.0</span>));<br></code></pre></td></tr></table></figure>
<p>这个方法返回一个keypath集合，集合中的keyPath值的改变会影响到关键属性(key)的值，当有观察者被注册监听关键属性(key)时,KVO自身会自动观察这个对象的所有keyPath,当其中的任意一个发生改变时都会通知到注册监听的观察者。这个机制的默认实现是搜索接受者的方法列表查看是否有方法名匹配<code>keyPathsForValuesAffecting</code>的方法，通过调用这个方法返回一个属性集合。</p>
<p>下面我们来尝试实现下这个方法看看有何效果:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs objc">+ (<span class="hljs-built_in">NSSet</span>&lt;<span class="hljs-built_in">NSString</span> *&gt; *)keyPathsForValuesAffectingValueForKey:(<span class="hljs-built_in">NSString</span> *)key &#123;<br>    <span class="hljs-built_in">NSSet</span> *keyPaths = [<span class="hljs-keyword">super</span> keyPathsForValuesAffectingValueForKey:key];<br>    <span class="hljs-keyword">if</span> ([key isEqualToString:<span class="hljs-string">@&quot;personDescription&quot;</span>]) &#123;<br>        keyPaths = [keyPaths setByAddingObjectsFromArray:@[<span class="hljs-string">@&quot;name&quot;</span>,<span class="hljs-string">@&quot;age&quot;</span>]];<br>    &#125;<br>    <span class="hljs-keyword">return</span> keyPaths;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们在项目中添加监听：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs objc">- (<span class="hljs-keyword">void</span>)addPersonInfoDescrption &#123;<br>    [<span class="hljs-keyword">self</span>.man addObserver:<span class="hljs-keyword">self</span> forKeyPath:<span class="hljs-string">@&quot;personDescription&quot;</span> options:<span class="hljs-built_in">NSKeyValueObservingOptionNew</span>|<span class="hljs-built_in">NSKeyValueObservingOptionOld</span> context:<span class="hljs-string">@&quot;&quot;</span>];<br>    <span class="hljs-keyword">self</span>.man.name = <span class="hljs-string">@&quot;LeeWong&quot;</span>;<br>    <span class="hljs-keyword">self</span>.man.age = <span class="hljs-number">30</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>再来看下控制台的输出:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-13</span> <span class="hljs-number">20</span>:<span class="hljs-number">52</span>:<span class="hljs-number">59.084192</span>+<span class="hljs-number">0800</span> Runtime-KVO[<span class="hljs-number">81809</span>:<span class="hljs-number">15903199</span>] Person willChangeValueForKey name<br><span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-13</span> <span class="hljs-number">20</span>:<span class="hljs-number">52</span>:<span class="hljs-number">59.084354</span>+<span class="hljs-number">0800</span> Runtime-KVO[<span class="hljs-number">81809</span>:<span class="hljs-number">15903199</span>] observeValueForKeyPath <span class="hljs-keyword">for</span> keyPath personDescription<br><span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-13</span> <span class="hljs-number">20</span>:<span class="hljs-number">52</span>:<span class="hljs-number">59.084446</span>+<span class="hljs-number">0800</span> Runtime-KVO[<span class="hljs-number">81809</span>:<span class="hljs-number">15903199</span>] Person didChangeValueForKey name<br><span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-13</span> <span class="hljs-number">20</span>:<span class="hljs-number">52</span>:<span class="hljs-number">59.085154</span>+<span class="hljs-number">0800</span> Runtime-KVO[<span class="hljs-number">81809</span>:<span class="hljs-number">15903199</span>] Person willChangeValueForKey age<br><span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-13</span> <span class="hljs-number">20</span>:<span class="hljs-number">52</span>:<span class="hljs-number">59.085245</span>+<span class="hljs-number">0800</span> Runtime-KVO[<span class="hljs-number">81809</span>:<span class="hljs-number">15903199</span>] observeValueForKeyPath <span class="hljs-keyword">for</span> keyPath personDescription<br><span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-13</span> <span class="hljs-number">20</span>:<span class="hljs-number">52</span>:<span class="hljs-number">59.085350</span>+<span class="hljs-number">0800</span> Runtime-KVO[<span class="hljs-number">81809</span>:<span class="hljs-number">15903199</span>] Person didChangeValueForKey age<br></code></pre></td></tr></table></figure>

<p>这样我们就实现了复合属性的监听。</p>
<h3 id="如何手动控制KVO"><a href="#如何手动控制KVO" class="headerlink" title="如何手动控制KVO"></a>如何手动控制KVO</h3><p>在了解了KVO的机制之后，我们发现我们KVO监听的代理方法被调用频次非常高，尤其是无论是我们监听了多少属性的改变，我们的代理方法只有一个，我们要在其中做很多判断。所以是否有方法可以手动的去控制KVO监听的调用频次。</p>
<p>在上面的介绍中我们知道，代理方法被调用是因为<code>willChangeValueForKey</code>、<code>didChangeValueForKey</code>这类方法被调用,那么我们是否可以控制这些方法被调用的频次呢？</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">/* Return YES if the key-value observing machinery should automatically invoke -willChangeValueForKey:/-didChangeValueForKey:, -willChange:valuesAtIndexes:forKey:/-didChange:valuesAtIndexes:forKey:, or -willChangeValueForKey:withSetMutation:usingObjects:/-didChangeValueForKey:withSetMutation:usingObjects: whenever instances of the class receive key-value coding messages for the key, or mutating key-value coding-compliant methods for the key are invoked. Return NO otherwise. Starting in Mac OS 10.5, the default implementation of this method searches the receiving class for a method whose name matches the pattern +automaticallyNotifiesObserversOf&lt;Key&gt;, and returns the result of invoking that method if it is found. So, any such method must return BOOL too. If no such method is found YES is returned.</span><br><span class="hljs-comment">*/</span><br>+ (<span class="hljs-built_in">BOOL</span>)automaticallyNotifiesObserversForKey:(<span class="hljs-built_in">NSString</span> *)key;<br></code></pre></td></tr></table></figure>

<p>这个方法通过返回YES/NO控制是否应该自动调用<code>-willChangeValueForKey:/-didChangeValueForKey:</code>这类方法。当我们返回NO时就不会自动调用上述方法，我们先来尝试下</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs objc">+ (<span class="hljs-built_in">BOOL</span>)automaticallyNotifiesObserversForKey:(<span class="hljs-built_in">NSString</span> *)key &#123;<br>    <span class="hljs-built_in">BOOL</span> automatic = [<span class="hljs-keyword">super</span> automaticallyNotifiesObserversForKey:key];<br>    <span class="hljs-keyword">if</span> ([key isEqualToString:<span class="hljs-string">@&quot;name&quot;</span>]) &#123;<br>        automatic = <span class="hljs-literal">NO</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> automatic;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们在主工程在此添加对属性name的监听:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs objc">- (<span class="hljs-keyword">void</span>)addPersonNameKVO &#123;<br>    [<span class="hljs-keyword">self</span>.man addObserver:<span class="hljs-keyword">self</span> forKeyPath:<span class="hljs-string">@&quot;name&quot;</span> options:<span class="hljs-built_in">NSKeyValueObservingOptionNew</span>|<span class="hljs-built_in">NSKeyValueObservingOptionOld</span> context:<span class="hljs-string">@&quot;&quot;</span>];<br>    <span class="hljs-keyword">self</span>.man.name = <span class="hljs-string">@&quot;LeeWong&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>当我们执行之后控制台没有任何输出，这也证明了我们刚才实现的<code>automaticallyNotifiesObserversForKey</code>生效了，那么我们把系统的调用屏蔽之后需要自己手动调用对应的方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs objc">- (<span class="hljs-keyword">void</span>)setName:(<span class="hljs-built_in">NSString</span> *)name &#123;<br>    [<span class="hljs-keyword">self</span> willChangeValueForKey:<span class="hljs-string">@&quot;name&quot;</span>];<br>    _name = name;<br>    [<span class="hljs-keyword">self</span> didChangeValueForKey:<span class="hljs-string">@&quot;name&quot;</span>];<br>&#125;<br></code></pre></td></tr></table></figure>

<p>再次运行，控制台输出:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-13</span> <span class="hljs-number">20</span>:<span class="hljs-number">49</span>:<span class="hljs-number">08.814044</span>+<span class="hljs-number">0800</span> Runtime-KVO[<span class="hljs-number">81739</span>:<span class="hljs-number">15899611</span>] Person willChangeValueForKey name<br><span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-13</span> <span class="hljs-number">20</span>:<span class="hljs-number">49</span>:<span class="hljs-number">08.814166</span>+<span class="hljs-number">0800</span> Runtime-KVO[<span class="hljs-number">81739</span>:<span class="hljs-number">15899611</span>] observeValueForKeyPath <span class="hljs-keyword">for</span> keyPath name<br><span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-13</span> <span class="hljs-number">20</span>:<span class="hljs-number">49</span>:<span class="hljs-number">08.814406</span>+<span class="hljs-number">0800</span> Runtime-KVO[<span class="hljs-number">81739</span>:<span class="hljs-number">15899611</span>] keyPath name object &lt;Person: <span class="hljs-number">0x60000159e610</span>&gt; change&#123;<br>    kind = <span class="hljs-number">1</span>;<br>    new = LeeWong;<br>    old = <span class="hljs-string">&quot;&lt;null&gt;&quot;</span>;<br>&#125; context<br><span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-13</span> <span class="hljs-number">20</span>:<span class="hljs-number">49</span>:<span class="hljs-number">08.814578</span>+<span class="hljs-number">0800</span> Runtime-KVO[<span class="hljs-number">81739</span>:<span class="hljs-number">15899611</span>] Person didChangeValueForKey name<br></code></pre></td></tr></table></figure>
<p>这与系统实现的一致，只是调用KVO代理方法是由我们自己手动控制，这样我们就可以控制频率了。</p>
<h3 id="监听信息"><a href="#监听信息" class="headerlink" title="监听信息"></a>监听信息</h3><p>在最开始介绍KVO时，我们就提到了注册监听时一定要注意移除监听，那么我们是否可以获取，到所有的监听者的信息呢？</p>
<p>在<code>NSObject(NSKeyValueObservingCustomization)</code>分类中我们发现了下面这个方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">/* Take or return a pointer that identifies information about all of the observers that are registered with the receiver, the options that were used at registration-time, etc. The default implementation of these methods store observation info in a global dictionary keyed by the receivers&#x27; pointers. For improved performance, you can override these methods to store the opaque data pointer in an instance variable. Overrides of these methods must not attempt to send Objective-C messages to the passed-in observation info, including -retain and -release.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nullable</span>) <span class="hljs-keyword">void</span> *observationInfo <span class="hljs-built_in">NS_RETURNS_INNER_POINTER</span>;<br></code></pre></td></tr></table></figure>

<p>下面我们来看下其中具体包含了哪些信息:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs objc">- (<span class="hljs-keyword">void</span>)printKVOObserverInfo &#123;<br>    [<span class="hljs-keyword">self</span>.man addObserver:<span class="hljs-keyword">self</span> forKeyPath:<span class="hljs-string">@&quot;name&quot;</span> options:<span class="hljs-built_in">NSKeyValueObservingOptionNew</span>|<span class="hljs-built_in">NSKeyValueObservingOptionOld</span> context:<span class="hljs-string">@&quot;&quot;</span>];<br>    [<span class="hljs-keyword">self</span>.man addObserver:<span class="hljs-keyword">self</span> forKeyPath:<span class="hljs-string">@&quot;age&quot;</span> options:<span class="hljs-built_in">NSKeyValueObservingOptionNew</span>|<span class="hljs-built_in">NSKeyValueObservingOptionOld</span> context:<span class="hljs-string">@&quot;&quot;</span>];<br>    <span class="hljs-keyword">id</span> info = <span class="hljs-keyword">self</span>.man.observationInfo;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%@&quot;</span>, [info description]);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>下面我们看下通过断点看到的效果:</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1glmjeqwr1tj316v0u014g.jpg"></p>
<p>我们看到观察者实际上是一个<code>NSKeyValueObservance</code>对象，对象中包含观察者(observer)、监听的属性(property)。但是<code>NSKeyValueObservance</code>类是一个私有类，我们无法查看这个类的结构，不过在<a target="_blank" rel="noopener" href="https://blog.csdn.net/quanqinyang/article/details/45226753">这篇文章</a>作者通过dump的方法获取到类的具体结构，感兴趣的可以进一步了解。</p>
<p>既然我们能通过这种方式获取到某个对象都有哪些监听者，那么我们在添加或者删除监听者时都可以根据要添加或者要删除的监听者是否已经在监听者列表中了。这样就可以避免重复添加或者删除监听者，但是需要注意，这个类是私有类因此属性和方法也是私有的。虽然我们可以通过KVC获取到，但是也面临可能出现的各类问题。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在这篇文章中，我们首先从KVO的添加移除以及代理方法的介绍这几个方法中，让我们对KVO有一个初步的了解，然后我们在从实现的角度去看KVO的实现原理。最后，我们谈到了对于数组等集合类型的监听、对于符合类型的监听、以及如何手动控制KVO的触发。最后我们还介绍了如何获取某个对象KVO监听者列表。相信经过这篇文章，你应该对KVO有了一个更加全面的认知和更深层次的了解。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/quanqinyang/article/details/45226753">NSKeyValueObserving(KVO)</a></p>
<p><a target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/KeyValueObserving/Articles/KVOCompliance.html#//apple_ref/doc/uid/20002178-BAJEAIEE">Key-Value Observing Programming Guide</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.chenyalun.com/2019/05/31/Key-Value%20Observing%E6%BA%90%E7%A0%81%E5%88%9D%E6%8E%A2/#2-4-NSKeyValueObservationInfo%E7%9A%84%E5%AD%98%E5%82%A8-observationInfo">Key-Value Observing源码初探</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/LeeWongSnail/Blog_Demo/tree/master/Runtime-KVO">本文demo</a></p>

    </div>
     
    <div class="post-footer__meta"><p>更新于 2020-12-13</p></div> 
    <div class="post-meta__cats"><a href="/categories/Runtime/" class="post-cats__link button">Runtime</a><a href="/tags/Runtime-KVO/" class="post-tags__link button"># Runtime KVO</a></div> 
</article>


    <div class="nav">
        <div class="nav__prev">
            
                <a href="/2020/12/19/runtime-KVC/" class="nav__link">
                    <div>
                        <svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" width="24" height="24"><path d="M589.088 790.624L310.464 512l278.624-278.624 45.248 45.248L400.96 512l233.376 233.376z" fill="#808080"></path></svg>
                    </div>
                    <div>
                        <div class="nav__label">
                            Previous Post
                        </div>
                        <div class="nav__title">
                            iOS KVC 实现探究
                        </div>
                    </div>
                </a>
            
        </div>
        <div class="nav__next">
            
                <a href="/2020/11/29/runtime-objectlifetime/" class="nav__link">
                    <div>
                        <div class="nav__label">
                            Next Post
                        </div>
                        <div class="nav__title">
                            Runtime之对象的一生
                        </div>
                    </div>
                    <div>
                        <svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" width="24" height="24"><path d="M434.944 790.624l-45.248-45.248L623.04 512l-233.376-233.376 45.248-45.248L713.568 512z" fill="#808080"></path></svg>
                    </div>
                </a>
            
        </div>
    </div>





</main>

            <footer class="footer">
    


    
    
    
        <span id="busuanzi_container_site_uv" hidden>
            <span></span>
            <span id="busuanzi_value_site_uv"></span>
            <span>Viewers</span>
            
                <span>|</span>
            
        </span>
    
    
        <span id="busuanzi_container_site_pv" hidden>
            <span></span>
            <span id="busuanzi_value_site_pv"></span>
            <span>Views</span>
            
        </span>
    
 
 

 
    
        
        <p class="footer-copyright">
            Copyright © 2015&nbsp;-&nbsp;2022 <a href="/">LeeWong</a>
        </p>
    
    
    <p>Powered by <a href="https://hexo.io" target="_blank">Hexo</a> | Theme - <a href="https://github.com/ChrAlpha/hexo-theme-cards" target="_blank">Cards</a></p>
</footer>

        </div>
         

 
    <script>
        window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
        ga('create', '4NmLVard-jFEKaV6857m9tKb41Tpo4FiKj8L1TJg7lU', 'auto');
        ga('send', 'pageview');
    </script>
    <script async src="https://www.google-analytics.com/analytics.js"></script>
 

 

 
    <script>
        var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement('script');
            hm.src = 'https://hm.baidu.com/hm.js?DR81zbdrQ3';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(hm, s);
        })();
    </script>
 

  



 


    
 


    
<script src="https://cdn.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.min.js"></script>

    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.4.1/dist/jquery.fancybox.min.css">

    
<script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.4.1/dist/jquery.fancybox.min.js"></script>

    <script>
        let lazyloadT = Boolean('false'),
            auto_fancybox = Boolean('false')
        if (auto_fancybox) {
            $(".post__content").find('img').each(function () {
                var element = document.createElement("a");
                $(element).attr("data-fancybox", "gallery");
                $(element).attr("href", $(this).attr("src"));
                if (lazyloadT) {
                    $(element).attr("href", $(this).attr("data-srcset"));
                }
                $(this).wrap(element);
            });
        } else {
            $(".post__content").find("fancybox").find('img').each(function () {
                var element = document.createElement("a");
                $(element).attr("data-fancybox", "gallery");
                $(element).attr("href", $(this).attr("src"));
                if (lazyloadT) {
                    $(element).attr("href", $(this).attr("data-srcset"));
                }
                $(this).wrap(element);
            });
        }
    </script>
 

 

 

 




    </body>
</html>
