<!DOCTYPE html>
<html lang="zh-CN">
    <head>
    <meta charset="utf-8">

    

    <!-- 渲染优化 -->
    <meta name="renderer" content="webkit">
    <meta name="force-rendering" content="webkit">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="HandheldFriendly" content="True" >
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <!--icon-->

    
        <link rel="shortcut icon" href="https://tva1.sinaimg.cn/large/0081Kckwly1glcsnw2jatj303k03k748.jpg">
    
    
    
    
    


    <!-- meta -->


<title>Runtime之对象的一生 | LeeWong</title>


    <meta name="keywords" content="Runtime Retain Release, iOS">




    <!-- OpenGraph -->
 
    <meta name="description" content="在所有的面向对象语言中，万物皆对象。Objective-C也不例外，这篇文章我们从Runtime的源码去分析一个对象从创建到销毁的整个过程中都做了哪些操作，同时也加深我们对内存管理的理解。">
<meta property="og:type" content="article">
<meta property="og:title" content="Runtime之对象的一生">
<meta property="og:url" content="https://www.leewong.cn/2020/11/29/runtime-objectlifetime/index.html">
<meta property="og:site_name" content="LeeWong">
<meta property="og:description" content="在所有的面向对象语言中，万物皆对象。Objective-C也不例外，这篇文章我们从Runtime的源码去分析一个对象从创建到销毁的整个过程中都做了哪些操作，同时也加深我们对内存管理的理解。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/0081Kckwgy1gld5q77lfej30pp06yjrp.jpg">
<meta property="article:published_time" content="2020-11-29T02:58:14.000Z">
<meta property="article:modified_time" content="2020-12-05T10:30:15.141Z">
<meta property="article:author" content="LeeWong">
<meta property="article:tag" content="Runtime Retain Release">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://tva1.sinaimg.cn/large/0081Kckwgy1gld5q77lfej30pp06yjrp.jpg">


    
<link rel="stylesheet" href="/css/style/main.css">
 


    
<link rel="stylesheet" href="/css/style/dark.css">

    
<script src="/js/darkmode.js"></script>



    
    
    
        <link rel="stylesheet" id="hl-default-theme" href="https://cdn.jsdelivr.net/npm/highlight.js@10.1.2/styles/default.min.css" media="none" onload="if(getComputedStyle(document.documentElement).getPropertyValue('--color-mode').indexOf('dark')===-1)this.media='all'">
        
            <link rel="stylesheet" id="hl-dark-theme" href="https://cdn.jsdelivr.net/npm/highlight.js@10.1.2/styles/dark.min.css" media="none" onload="if(getComputedStyle(document.documentElement).getPropertyValue('--color-mode').indexOf('dark')!==-1)this.media='all'">
        
    

    

     
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
 

    <!-- custom head -->

    
        <meta name="google-site-verification" content="4NmLVard-jFEKaV6857m9tKb41Tpo4FiKj8L1TJg7lU" /> 
    

<meta name="generator" content="Hexo 5.1.1"></head>

    <body>
        <div id="app">
            <header class="header">
    <div class="header__left">
        <a href="/" class="button">
            <span class="logo__text">LeeWong</span>
        </a>
    </div>
    <div class="header__right">
        
            <div class="navbar__menus">
                
                    <a href="/" class="navbar-menu button">首页</a>
                
                    <a href="/tags/" class="navbar-menu button">标签</a>
                
                    <a href="/archives/" class="navbar-menu button">归档</a>
                
                    <a href="/about/" class="navbar-menu button">关于我</a>
                
            </div>
        
        
        

        
        
    <a href="javaScript:void(0);" id="btn-toggle-dark">
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path></svg>
    </a>


         
    <a href="#" class="button" id="b2t" aria-label="回到顶部" title="回到顶部">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1024 1024" width="32" height="32">
            <path d="M233.376 722.752L278.624 768 512 534.624 745.376 768l45.248-45.248L512 444.128zM192 352h640V288H192z" fill="currentColor"></path>
        </svg>
    </a>


        
            <a class="dropdown-icon button" id="btn-dropdown" tabindex="0"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" width='24' height='24' fill="none" stroke="currentColor" stroke-width="0.7" stroke-linecap="round" stroke-linejoin="round"><path fill="currentColor" d="M3.314,4.8h13.372c0.41,0,0.743-0.333,0.743-0.743c0-0.41-0.333-0.743-0.743-0.743H3.314c-0.41,0-0.743,0.333-0.743,0.743C2.571,4.467,2.904,4.8,3.314,4.8z M16.686,15.2H3.314c-0.41,0-0.743,0.333-0.743,0.743s0.333,0.743,0.743,0.743h13.372c0.41,0,0.743-0.333,0.743-0.743S17.096,15.2,16.686,15.2z M16.686,9.257H3.314c-0.41,0-0.743,0.333-0.743,0.743s0.333,0.743,0.743,0.743h13.372c0.41,0,0.743-0.333,0.743-0.743S17.096,9.257,16.686,9.257z"></path></svg></a>
            <div class="dropdown-menus" id="dropdown-menus">
                
                    <a href="/" class="dropdown-menu button">首页</a>
                
                    <a href="/tags/" class="dropdown-menu button">标签</a>
                
                    <a href="/archives/" class="dropdown-menu button">归档</a>
                
                    <a href="/about/" class="dropdown-menu button">关于我</a>
                
            </div>
        
    </div>
</header>


            <main class="main">
    

<div class="post-title">
    <h1 class="post-title__text">
        Runtime之对象的一生
    </h1>
    <div class="post-title__meta">
        <a href="/archives/2020/11/" class="post-meta__date button">2020-11-29</a>
        
    <span class="separate-dot"></span><a href="/categories/Runtime/" class="button">Runtime</a>

 
        
    
     
    <span id="busuanzi_container_page_pv" hidden>
        <span class="separate-dot"></span>
        <span></span>
        <span id="busuanzi_value_page_pv"></span>
        <span>Views</span>
    </span>



 

 
    </div>
</div>


    <aside class="post-side">
        <div class="post-side__toc">
            <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-number">1.</span> <span class="toc-text">对象的创建</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#alloc"><span class="toc-number">1.1.</span> <span class="toc-text">alloc</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#objc-rootAllocWithZone"><span class="toc-number">1.1.1.</span> <span class="toc-text">objc_rootAllocWithZone</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#class-createInstance"><span class="toc-number">1.1.2.</span> <span class="toc-text">class_createInstance</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#hasCxxDtor"><span class="toc-number">1.1.3.</span> <span class="toc-text">hasCxxDtor</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#canAllocNonpointer"><span class="toc-number">1.1.4.</span> <span class="toc-text">canAllocNonpointer</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#initInstanceIsa"><span class="toc-number">1.1.5.</span> <span class="toc-text">initInstanceIsa</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#hasCustomAWZ"><span class="toc-number">1.1.6.</span> <span class="toc-text">hasCustomAWZ</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#object-cxxConstructFromClass"><span class="toc-number">1.1.7.</span> <span class="toc-text">object_cxxConstructFromClass</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#allocWithZone"><span class="toc-number">1.1.8.</span> <span class="toc-text">allocWithZone</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#init"><span class="toc-number">2.</span> <span class="toc-text">init</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#new"><span class="toc-number">3.</span> <span class="toc-text">new</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E8%B5%8B%E5%80%BC"><span class="toc-number">4.</span> <span class="toc-text">对象赋值</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B5%8B%E5%80%BC"><span class="toc-number">4.1.</span> <span class="toc-text">赋值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#strong"><span class="toc-number">4.2.</span> <span class="toc-text">__strong</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#objc-retain"><span class="toc-number">4.2.1.</span> <span class="toc-text">objc_retain</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#weak"><span class="toc-number">4.3.</span> <span class="toc-text">__weak</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#retaincount"><span class="toc-number">4.4.</span> <span class="toc-text">retaincount</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E9%94%80%E6%AF%81"><span class="toc-number">5.</span> <span class="toc-text">对象的销毁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#release"><span class="toc-number">5.1.</span> <span class="toc-text">release</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#autorelease"><span class="toc-number">5.2.</span> <span class="toc-text">autorelease</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dealloc"><span class="toc-number">5.3.</span> <span class="toc-text">dealloc</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#objc-destructInstance"><span class="toc-number">5.3.1.</span> <span class="toc-text">objc_destructInstance</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#initIsa"><span class="toc-number">5.3.2.</span> <span class="toc-text">initIsa</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#objc-clear-deallocating"><span class="toc-number">5.3.3.</span> <span class="toc-text">objc_clear_deallocating</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sidetable-clearDeallocating"><span class="toc-number">5.3.4.</span> <span class="toc-text">sidetable_clearDeallocating</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#clearDeallocating-slow"><span class="toc-number">5.3.5.</span> <span class="toc-text">clearDeallocating_slow</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">6.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E6%96%87%E7%AB%A0"><span class="toc-number">7.</span> <span class="toc-text">参考文章</span></a></li></ol>
        </div>
    </aside>
    <a class="btn-toc button" id="btn-toc" tabindex="0">
        <svg viewBox="0 0 1024 1024" width="32" height="32" xmlns="http://www.w3.org/2000/svg">
            <path d="M128 256h64V192H128zM320 256h576V192H320zM128 544h64v-64H128zM320 544h576v-64H320zM128 832h64v-64H128zM320 832h576v-64H320z" fill="currentColor"></path>
        </svg>
    </a>
    <div class="toc-menus" id="toc-menus">
        <div class="toc-title">文章目录</div>
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-number">1.</span> <span class="toc-text">对象的创建</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#alloc"><span class="toc-number">1.1.</span> <span class="toc-text">alloc</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#objc-rootAllocWithZone"><span class="toc-number">1.1.1.</span> <span class="toc-text">objc_rootAllocWithZone</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#class-createInstance"><span class="toc-number">1.1.2.</span> <span class="toc-text">class_createInstance</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#hasCxxDtor"><span class="toc-number">1.1.3.</span> <span class="toc-text">hasCxxDtor</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#canAllocNonpointer"><span class="toc-number">1.1.4.</span> <span class="toc-text">canAllocNonpointer</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#initInstanceIsa"><span class="toc-number">1.1.5.</span> <span class="toc-text">initInstanceIsa</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#hasCustomAWZ"><span class="toc-number">1.1.6.</span> <span class="toc-text">hasCustomAWZ</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#object-cxxConstructFromClass"><span class="toc-number">1.1.7.</span> <span class="toc-text">object_cxxConstructFromClass</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#allocWithZone"><span class="toc-number">1.1.8.</span> <span class="toc-text">allocWithZone</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#init"><span class="toc-number">2.</span> <span class="toc-text">init</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#new"><span class="toc-number">3.</span> <span class="toc-text">new</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E8%B5%8B%E5%80%BC"><span class="toc-number">4.</span> <span class="toc-text">对象赋值</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B5%8B%E5%80%BC"><span class="toc-number">4.1.</span> <span class="toc-text">赋值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#strong"><span class="toc-number">4.2.</span> <span class="toc-text">__strong</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#objc-retain"><span class="toc-number">4.2.1.</span> <span class="toc-text">objc_retain</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#weak"><span class="toc-number">4.3.</span> <span class="toc-text">__weak</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#retaincount"><span class="toc-number">4.4.</span> <span class="toc-text">retaincount</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E9%94%80%E6%AF%81"><span class="toc-number">5.</span> <span class="toc-text">对象的销毁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#release"><span class="toc-number">5.1.</span> <span class="toc-text">release</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#autorelease"><span class="toc-number">5.2.</span> <span class="toc-text">autorelease</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dealloc"><span class="toc-number">5.3.</span> <span class="toc-text">dealloc</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#objc-destructInstance"><span class="toc-number">5.3.1.</span> <span class="toc-text">objc_destructInstance</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#initIsa"><span class="toc-number">5.3.2.</span> <span class="toc-text">initIsa</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#objc-clear-deallocating"><span class="toc-number">5.3.3.</span> <span class="toc-text">objc_clear_deallocating</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sidetable-clearDeallocating"><span class="toc-number">5.3.4.</span> <span class="toc-text">sidetable_clearDeallocating</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#clearDeallocating-slow"><span class="toc-number">5.3.5.</span> <span class="toc-text">clearDeallocating_slow</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">6.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E6%96%87%E7%AB%A0"><span class="toc-number">7.</span> <span class="toc-text">参考文章</span></a></li></ol>
    </div>


<article class="post content-card">
    <div class="post__header">
    
        <div class="post-thumbnail" style="background-image: url('https://tva1.sinaimg.cn/large/0081Kckwgy1gld5q77lfej30pp06yjrp.jpg');"></div>
    
</div>
    <div class="post__content">
        <p>在所有的面向对象语言中，万物皆对象。Objective-C也不例外，这篇文章我们从Runtime的源码去分析一个对象从创建到销毁的整个过程中都做了哪些操作，同时也加深我们对内存管理的理解。</p>
<a id="more"></a>

<h2 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h2><p>我们平时开发中创建一个对象的方式一般有三种</p>
<ul>
<li>alloc init </li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-built_in">NSString</span> *str = [[<span class="hljs-built_in">NSString</span> alloc] init];<br></code></pre></td></tr></table></figure>

<ul>
<li>new</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-built_in">NSString</span> *str = [<span class="hljs-built_in">NSString</span> new];<br></code></pre></td></tr></table></figure>

<ul>
<li>类方法构建</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-built_in">NSMutableString</span> *str = [<span class="hljs-built_in">NSMutableString</span> string];<br></code></pre></td></tr></table></figure>

<p>那么在这个过程中系统都做了哪些操作呢？这三种不同的创建方式又会有什么区别呢？下面我们对上述的几个关键词一一介绍然后在分析下这几种创建对象方式的区别。</p>
<h3 id="alloc"><a href="#alloc" class="headerlink" title="alloc"></a>alloc</h3><p>我们先来看下alloc方法在Runtime中的实现</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs objc">+ (<span class="hljs-keyword">id</span>)alloc &#123;<br>    <span class="hljs-keyword">return</span> _objc_rootAlloc(<span class="hljs-keyword">self</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们在进一步看下_objc_rootAlloc方法的实现：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">id</span><br>_objc_rootAlloc(Class cls)<br>&#123;<br>    <span class="hljs-keyword">return</span> callAlloc(cls, <span class="hljs-literal">false</span><span class="hljs-comment">/*checkNil*/</span>, <span class="hljs-literal">true</span><span class="hljs-comment">/*allocWithZone*/</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们继续跟进方法实现:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">// ALWAYS_INLINE 强制内联函数 所有加了__attribute__((always_inline))的函数再</span><br><span class="hljs-comment">// 把被调用时不会被编译成函数调用而是直接扩展到调用函数体内</span><br><span class="hljs-keyword">static</span> ALWAYS_INLINE <span class="hljs-keyword">id</span><br>callAlloc(Class cls, <span class="hljs-keyword">bool</span> checkNil, <span class="hljs-keyword">bool</span> allocWithZone=<span class="hljs-literal">false</span>)<br>&#123;<br>    <span class="hljs-comment">// slowpath 表示if条件为0的可能性较大 利于编译器优化指令跳转</span><br>    <span class="hljs-comment">// 如果需要检查nil 且cls 为nil 那么直接返回nil</span><br>    <span class="hljs-comment">// 因此 如果cls不存在使用alloc方法创建时可能返回nil</span><br>    <span class="hljs-keyword">if</span> (slowpath(checkNil &amp;&amp; !cls)) <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> __OBJC2__</span><br>    <span class="hljs-comment">// fastpath 表示if条件中为1的可能性较大</span><br>    <span class="hljs-comment">// 如果类没有自定义的allocwithzone方法</span><br>    <span class="hljs-keyword">if</span> (fastpath(!cls-&gt;ISA()-&gt;hasCustomAWZ())) &#123;<br>        <span class="hljs-comment">// cls 是否可以快速创建</span><br>        <span class="hljs-keyword">if</span> (fastpath(cls-&gt;canAllocFast())) &#123;<br>            <span class="hljs-comment">// No ctors, raw isa, etc. Go straight to the metal.</span><br>            <span class="hljs-comment">// cls是否有c++销毁方法 dtor = destructor</span><br>            <span class="hljs-keyword">bool</span> dtor = cls-&gt;hasCxxDtor();<br>            <span class="hljs-comment">// calloc 在内存中动态地分配 1 个长度为  cls-&gt;bits.fastInstanceSize() 的连续空间</span><br>            <span class="hljs-keyword">id</span> obj = (<span class="hljs-keyword">id</span>)calloc(<span class="hljs-number">1</span>, cls-&gt;bits.fastInstanceSize());<br>            <span class="hljs-comment">// 如果obj为空 类初始化失败 报错 attempt to allocate object of class &#x27;%s&#x27; failed</span><br>            <span class="hljs-keyword">if</span> (slowpath(!obj)) <span class="hljs-keyword">return</span> callBadAllocHandler(cls);<br>            <span class="hljs-comment">// 调用初始化对象isa方法</span><br>            obj-&gt;initInstanceIsa(cls, dtor);<br>            <span class="hljs-keyword">return</span> obj;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// Has ctor or raw isa or something. Use the slower path.</span><br>            <span class="hljs-comment">// 调用class_createInstance创建对象</span><br>            <span class="hljs-keyword">id</span> obj = class_createInstance(cls, <span class="hljs-number">0</span>);<br>            <span class="hljs-comment">// 如果对象为空 那么直接报错</span><br>            <span class="hljs-keyword">if</span> (slowpath(!obj)) <span class="hljs-keyword">return</span> callBadAllocHandler(cls);<br>            <span class="hljs-keyword">return</span> obj;<br>        &#125;<br>    &#125;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><br>    <span class="hljs-comment">// No shortcuts available.</span><br>    <span class="hljs-comment">// alloc 方法会进一步调用allocwithzone方法</span><br>    <span class="hljs-keyword">if</span> (allocWithZone) <span class="hljs-keyword">return</span> [cls allocWithZone:<span class="hljs-literal">nil</span>];<br>    <span class="hljs-comment">// 正常情况不会走到这里 想到与一个递归？</span><br>    <span class="hljs-keyword">return</span> [cls alloc];<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们将这个方法的流程通过下图来更好的了解下：</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gl55393ycbj31hr0u0dlg.jpg"></p>
<p><code>注意</code>:图中深色背景区域为<code>OBJC2</code>下会走的的位置，基本上目前都会做到这里</p>
<p><del>为了更好的了解这个方法的实现我们进一步看下这个方法中调用的几个方法：</del></p>
<p>写完这个方法后，<strong>发现在最新的Runtime(781)源码中这个方法变成了:</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">static</span> ALWAYS_INLINE <span class="hljs-keyword">id</span><br>callAlloc(Class cls, <span class="hljs-keyword">bool</span> checkNil, <span class="hljs-keyword">bool</span> allocWithZone=<span class="hljs-literal">false</span>)<br>&#123;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> __OBJC2__</span><br>    <span class="hljs-keyword">if</span> (slowpath(checkNil &amp;&amp; !cls)) <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>;<br>    <span class="hljs-comment">// 是否有自定义的allocWithZone方法</span><br>    <span class="hljs-keyword">if</span> (fastpath(!cls-&gt;ISA()-&gt;hasCustomAWZ())) &#123;<br>        <span class="hljs-comment">// 直接调用_objc_rootAllocWithZone</span><br>        <span class="hljs-keyword">return</span> _objc_rootAllocWithZone(cls, <span class="hljs-literal">nil</span>);<br>    &#125;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><br>    <span class="hljs-comment">// No shortcuts available.</span><br>    <span class="hljs-comment">// 是否需要调用allocWithZone _objc_rootAlloc方法调用时这个参数为yes</span><br>    <span class="hljs-keyword">if</span> (allocWithZone) &#123;<br>        <span class="hljs-keyword">return</span> ((<span class="hljs-keyword">id</span>(*)(<span class="hljs-keyword">id</span>, SEL, <span class="hljs-keyword">struct</span> _NSZone *))objc_msgSend)(cls, <span class="hljs-keyword">@selector</span>(allocWithZone:), <span class="hljs-literal">nil</span>);<br>    &#125;<br>    <span class="hljs-comment">// 调用alloc方法</span><br>    <span class="hljs-keyword">return</span> ((<span class="hljs-keyword">id</span>(*)(<span class="hljs-keyword">id</span>, SEL))objc_msgSend)(cls, <span class="hljs-keyword">@selector</span>(alloc));<br>&#125;<br></code></pre></td></tr></table></figure>


<p>实际上在<code>OBJC2</code>中这个方法的改变并不大，下面我们看下上面这两种实现用到的主要方法的实现，</p>
<h4 id="objc-rootAllocWithZone"><a href="#objc-rootAllocWithZone" class="headerlink" title="objc_rootAllocWithZone"></a>objc_rootAllocWithZone</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">//allocWithZone的根方法</span><br><span class="hljs-keyword">id</span><br>_objc_rootAllocWithZone(Class cls, malloc_zone_t *zone)<br>&#123;<br>    <span class="hljs-keyword">id</span> obj;<br>    <span class="hljs-comment">// 如果zone未空 那么直接调用class_createInstance方法 与之前750的实现一致</span><br>    <span class="hljs-keyword">if</span> (fastpath(!zone)) &#123;<br>        obj = class_createInstance(cls, <span class="hljs-number">0</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 如果返回的zone有值 那么调用class_createInstanceFromZone传入</span><br>        obj = class_createInstanceFromZone(cls, <span class="hljs-number">0</span>, zone);<br>    &#125;<br>    <span class="hljs-comment">// 如果创建的obj为空</span><br>    <span class="hljs-keyword">if</span> (slowpath(!obj)) obj = _objc_callBadAllocHandler(cls);<br>    <span class="hljs-keyword">return</span> obj;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这个方法实际上只是做了一层简单的包装，我们重点关注<code>class_createInstance</code>和<code>class_createInstanceFromZone</code>方法。</p>
<h4 id="class-createInstance"><a href="#class-createInstance" class="headerlink" title="class_createInstance"></a>class_createInstance</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">id</span><br>class_createInstance(Class cls, size_t extraBytes)<br>&#123;<br>    <span class="hljs-keyword">if</span> (!cls) <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>;<br>    <span class="hljs-keyword">return</span> _class_createInstanceFromZone(cls, extraBytes, <span class="hljs-literal">nil</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们继续看<code>_class_createInstanceFromZone</code>方法(即<code>_objc_rootAllocWithZone</code>方法中<code>zone</code>不为空时调用的方法)：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs objc">NEVER_INLINE<br><span class="hljs-keyword">id</span><br>_objc_rootAllocWithZone(Class cls, malloc_zone_t *zone __unused)<br>&#123;<br>    <span class="hljs-comment">// allocWithZone under __OBJC2__ ignores the zone parameter</span><br>    <span class="hljs-keyword">return</span> _class_createInstanceFromZone(cls, <span class="hljs-number">0</span>, <span class="hljs-literal">nil</span>,<br>                                         OBJECT_CONSTRUCT_CALL_BADALLOC);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>继续深入<code>_objc_rootAllocWithZone</code>方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">// 创建对象</span><br><span class="hljs-comment">// cls 创建对象的类型</span><br><span class="hljs-comment">// extraBytes 额外字节 正常alloc方法这个值为0</span><br><span class="hljs-comment">// zone construct_flags outAllocatedSize</span><br><span class="hljs-keyword">static</span> ALWAYS_INLINE <span class="hljs-keyword">id</span><br>_class_createInstanceFromZone(Class cls, size_t extraBytes, <span class="hljs-keyword">void</span> *zone,<br>                              <span class="hljs-keyword">int</span> construct_flags = OBJECT_CONSTRUCT_NONE,<br>                              <span class="hljs-keyword">bool</span> cxxConstruct = <span class="hljs-literal">true</span>,<br>                              size_t *outAllocatedSize = <span class="hljs-literal">nil</span>)<br>&#123;<br>    ASSERT(cls-&gt;isRealized());<br><br>    <span class="hljs-comment">// Read class&#x27;s info bits all at once for performance</span><br>    <span class="hljs-comment">// 是否有自定义的创建方法</span><br>    <span class="hljs-keyword">bool</span> hasCxxCtor = cxxConstruct &amp;&amp; cls-&gt;hasCxxCtor();<br>    <span class="hljs-comment">// 是否有自定义的销毁方法</span><br>    <span class="hljs-keyword">bool</span> hasCxxDtor = cls-&gt;hasCxxDtor();<br>    <span class="hljs-comment">// canAllocNonpointer:class&#x27;s instances requires raw isa</span><br>    <span class="hljs-comment">// #define FAST_CACHE_REQUIRES_RAW_ISA   (1&lt;&lt;13)</span><br>    <span class="hljs-comment">// 是否是 isa_t 类型的 isa</span><br>    <span class="hljs-keyword">bool</span> fast = cls-&gt;canAllocNonpointer();<br><br>    size_t size;<br>    <span class="hljs-comment">// 增加额外字节</span><br>    size = cls-&gt;instanceSize(extraBytes);<br>    <span class="hljs-keyword">if</span> (outAllocatedSize) *outAllocatedSize = size;<br><br>    <span class="hljs-keyword">id</span> obj;<br>    <span class="hljs-comment">// 新创建一个obj 并指向一块新创建的内存空间</span><br>    <span class="hljs-keyword">if</span> (zone) &#123;<br>        obj = (<span class="hljs-keyword">id</span>)malloc_zone_calloc((malloc_zone_t *)zone, <span class="hljs-number">1</span>, size);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        obj = (<span class="hljs-keyword">id</span>)calloc(<span class="hljs-number">1</span>, size);<br>    &#125;<br>    <span class="hljs-comment">// 如果对象创建失败 obj = nil</span><br>    <span class="hljs-keyword">if</span> (slowpath(!obj)) &#123;<br>        <span class="hljs-keyword">if</span> (construct_flags &amp; OBJECT_CONSTRUCT_CALL_BADALLOC) &#123;<br>            <span class="hljs-keyword">return</span> _objc_callBadAllocHandler(cls);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// isa如果是isa_t类型</span><br>    <span class="hljs-keyword">if</span> (!zone &amp;&amp; fast) &#123;<br>        obj-&gt;initInstanceIsa(cls, hasCxxDtor);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// Use raw pointer isa on the assumption that they might be</span><br>        <span class="hljs-comment">// doing something weird with the zone or RR.</span><br>        <span class="hljs-comment">// isa是cls类型</span><br>        obj-&gt;initIsa(cls);<br>    &#125;<br>    <span class="hljs-comment">// 如果没有自定义构建方法</span><br>    <span class="hljs-keyword">if</span> (fastpath(!hasCxxCtor)) &#123;<br>        <span class="hljs-keyword">return</span> obj;<br>    &#125;<br>    <span class="hljs-comment">// 自定义构建方法调用</span><br>    construct_flags |= OBJECT_CONSTRUCT_FREE_ONFAILURE;<br>    <span class="hljs-keyword">return</span> object_cxxConstructFromClass(obj, cls, construct_flags);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们在看下这个方法中用到的几个方法：</p>
<h4 id="hasCxxDtor"><a href="#hasCxxDtor" class="headerlink" title="hasCxxDtor"></a>hasCxxDtor</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">bool</span> hasCxxDtor() &#123;<br>    <span class="hljs-comment">// addSubclass() propagates this flag from the superclass.</span><br>    assert(isRealized());<br>    <span class="hljs-keyword">return</span> bits.hasCxxDtor();<br>&#125;<br><br><span class="hljs-keyword">bool</span> hasCxxDtor() &#123;<br>    <span class="hljs-keyword">return</span> data()-&gt;flags &amp; RW_HAS_CXX_DTOR;<br>&#125;<br><br><span class="hljs-comment">// class or superclass has .cxx_destruct implementation</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> RW_HAS_CXX_DTOR       (1&lt;&lt;17)</span><br></code></pre></td></tr></table></figure>

<p>从上述代码中，我们可以看到<code>hasCxxDtor</code>表示<code>cls</code>或者<code>supercls</code>是否有销毁<code>(cxx_destruct)</code>方法。</p>
<h4 id="canAllocNonpointer"><a href="#canAllocNonpointer" class="headerlink" title="canAllocNonpointer"></a>canAllocNonpointer</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-built_in">BOOL</span> canAllocNonpointer() &#123;<br>    ASSERT(!isFuture());<br>    <span class="hljs-keyword">return</span> !instancesRequireRawIsa();<br>&#125;<br><br><span class="hljs-built_in">BOOL</span> instancesRequireRawIsa() &#123;<br>    <span class="hljs-keyword">return</span> cache.getBit(FAST_CACHE_REQUIRES_RAW_ISA);<br>&#125;<br><br><span class="hljs-comment">// class&#x27;s instances requires raw isa</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FAST_CACHE_REQUIRES_RAW_ISA   (1&lt;&lt;13)</span><br></code></pre></td></tr></table></figure>

<h4 id="initInstanceIsa"><a href="#initInstanceIsa" class="headerlink" title="initInstanceIsa"></a>initInstanceIsa</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <br>objc_object::initInstanceIsa(Class cls, <span class="hljs-keyword">bool</span> hasCxxDtor)<br>&#123;<br>    assert(!cls-&gt;instancesRequireRawIsa());<br>    assert(hasCxxDtor == cls-&gt;hasCxxDtor());<br>    <span class="hljs-comment">// 相当于也是包装了一层</span><br>    initIsa(cls, <span class="hljs-literal">true</span>, hasCxxDtor);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>initInstanceIsa</code>主要是调用<code>initIsa</code>方法，我们在进一步看下这个方法的实现：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <br>objc_object::initIsa(Class cls, <span class="hljs-keyword">bool</span> nonpointer, <span class="hljs-keyword">bool</span> hasCxxDtor) <br>&#123; <br>    ASSERT(!isTaggedPointer()); <br>    <span class="hljs-comment">// 如果是非isa_t类型 直接返回 这个cls即可 因为isa中只有一个指针指向isa</span><br>    <span class="hljs-keyword">if</span> (!nonpointer) &#123;<br>        isa = isa_t((uintptr_t)cls);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        ASSERT(!DisableNonpointerIsa);<br>        ASSERT(!cls-&gt;instancesRequireRawIsa());<br>        <span class="hljs-comment">// 创建 isa_t 类型临时变量</span><br>        isa_t newisa(<span class="hljs-number">0</span>);<br><br>        <span class="hljs-comment">// 配置 magic 表示当前对象已经创建</span><br>        <span class="hljs-comment">// 配置 nonpointer 表示当前对象的 isa 为 isa_t 类型的</span><br>        newisa.bits = ISA_MAGIC_VALUE;<br>        <span class="hljs-comment">// isa.magic is part of ISA_MAGIC_VALUE</span><br>        <span class="hljs-comment">// isa.nonpointer is part of ISA_MAGIC_VALUE</span><br>        <span class="hljs-comment">// 配置 has_cxx_dtor 表示当前对象是否有 C++ 的析构器</span><br>        newisa.has_cxx_dtor = hasCxxDtor;<br>        <span class="hljs-comment">// 配置 shiftcls 指向类对象，右移了 3 位是因为类的指针是按照字节（8bits）对齐的，</span><br>        <span class="hljs-comment">// 其指针后三位都是没有意义的 0，因此可以右移 3 位进行消除，以减小无意义的内存占用。</span><br>        newisa.shiftcls = (uintptr_t)cls &gt;&gt; <span class="hljs-number">3</span>;<br>        <br>        <span class="hljs-comment">// 将临时变量赋值给结构体成员</span><br>        isa = newisa;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>从上面我们看出如果是<code>isa_t</code>类型，我们主要设置<code>ISA</code>的<code>bits</code>、<code>has_cxx_dtor</code>、<code>shiftcls</code>三个属性。</p>
<h4 id="hasCustomAWZ"><a href="#hasCustomAWZ" class="headerlink" title="hasCustomAWZ"></a>hasCustomAWZ</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs objc">    <span class="hljs-keyword">bool</span> hasCustomAWZ() &#123;<br>        <span class="hljs-keyword">return</span> ! bits.hasDefaultAWZ();<br>    &#125;<br>    <br>    <span class="hljs-keyword">bool</span> hasDefaultAWZ() &#123;<br>        <span class="hljs-keyword">return</span> data()-&gt;flags &amp; RW_HAS_DEFAULT_AWZ;<br>    &#125;<br>    <br><span class="hljs-comment">// class or superclass has default alloc/allocWithZone: implementation</span><br><span class="hljs-comment">// Note this is is stored in the metaclass.</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> RW_HAS_DEFAULT_AWZ    (1&lt;&lt;16)</span><br></code></pre></td></tr></table></figure>

<p><code>RW_HAS_DEFAULT_AWZ</code>这个标志位表明是<code>cls</code>或者<code>superclass</code>是否有默认的<code>alloc/allocWithZone</code>方法实现，<code>hasCustomAWZ</code>的意思是是否有自定义的<code>AWZ(allocWithZone)</code>方法,在我们前面的<a href="http://www.leewong.cn/2020/10/24/oc-object-structure/">NSObject结构</a>这篇文章中我们介绍过下面这张图</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gk0s5oef3ej30ro0imgtj.jpg"></p>
<p>在图中我们看到<code>NSObject</code>结构中有一个<code>uint32_t</code>类型的<code>flags</code>,而<code>hasDefaultAWZ</code>方法就是从我们的<code>NSObject</code>结构中通过按位与的方法获取到这个值。</p>
<h4 id="object-cxxConstructFromClass"><a href="#object-cxxConstructFromClass" class="headerlink" title="object_cxxConstructFromClass"></a>object_cxxConstructFromClass</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">// 递归调用对象的C++构造方法，从基类到子类的构造方法</span><br><span class="hljs-keyword">id</span> <br>object_cxxConstructFromClass(<span class="hljs-keyword">id</span> obj, Class cls, <span class="hljs-keyword">int</span> flags)<br>&#123;<br>    ASSERT(cls-&gt;hasCxxCtor());  <span class="hljs-comment">// required for performance, not correctness</span><br><br>    <span class="hljs-keyword">id</span> (*ctor)(<span class="hljs-keyword">id</span>);<br>    Class supercls;<br><br>    supercls = cls-&gt;superclass;<br><br>    <span class="hljs-comment">// Call superclasses&#x27; ctors first, if any.</span><br>    <span class="hljs-comment">// 如果父类有C++构造方法</span><br>    <span class="hljs-keyword">if</span> (supercls  &amp;&amp;  supercls-&gt;hasCxxCtor()) &#123;<br>        <span class="hljs-comment">// 调用父类构造方法</span><br>        <span class="hljs-keyword">bool</span> ok = object_cxxConstructFromClass(obj, supercls, flags);<br>        <span class="hljs-comment">// 父类构造方法失败 返回nil</span><br>        <span class="hljs-keyword">if</span> (slowpath(!ok)) <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>;  <span class="hljs-comment">// some superclass&#x27;s ctor failed - give up</span><br>    &#125;<br><br>    <span class="hljs-comment">// Find this class&#x27;s ctor, if any.</span><br>    <span class="hljs-comment">// 父类构造方法调用完成后调用当前类的SEL_cxx_construct方法</span><br>    ctor = (<span class="hljs-keyword">id</span>(*)(<span class="hljs-keyword">id</span>))lookupMethodInClassAndLoadCache(cls, SEL_cxx_construct);<br>    <span class="hljs-comment">// 如果当前类的构造为转发方法 那么直接返回 表示没有对应实现</span><br>    <span class="hljs-keyword">if</span> (ctor == (<span class="hljs-keyword">id</span>(*)(<span class="hljs-keyword">id</span>))_objc_msgForward_impcache) <span class="hljs-keyword">return</span> obj;  <span class="hljs-comment">// no ctor - ok</span><br>    <br>    <span class="hljs-comment">// Call this class&#x27;s ctor.</span><br>    <span class="hljs-keyword">if</span> (PrintCxxCtors) &#123;<br>        _objc_inform(<span class="hljs-string">&quot;CXX: calling C++ constructors for class %s&quot;</span>, <br>                     cls-&gt;nameForLogging());<br>    &#125;<br>    <span class="hljs-comment">// 调用构造方法 传入参数obj</span><br>    <span class="hljs-keyword">if</span> (fastpath((*ctor)(obj))) <span class="hljs-keyword">return</span> obj;  <span class="hljs-comment">// ctor called and succeeded - ok</span><br><br>    supercls = cls-&gt;superclass; <span class="hljs-comment">// this reload avoids a spill on the stack</span><br><br>    <span class="hljs-comment">// This class&#x27;s ctor was called and failed.</span><br>    <span class="hljs-comment">// Call superclasses&#x27;s dtors to clean up.</span><br>    <span class="hljs-keyword">if</span> (supercls) object_cxxDestructFromClass(obj, supercls);<br>    <span class="hljs-keyword">if</span> (flags &amp; OBJECT_CONSTRUCT_FREE_ONFAILURE) free(obj);<br>    <span class="hljs-keyword">if</span> (flags &amp; OBJECT_CONSTRUCT_CALL_BADALLOC) &#123;<br>        <span class="hljs-keyword">return</span> _objc_callBadAllocHandler(cls);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>;<br>&#125;<br></code></pre></td></tr></table></figure>


<h4 id="allocWithZone"><a href="#allocWithZone" class="headerlink" title="allocWithZone"></a>allocWithZone</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">// Replaced by ObjectAlloc</span><br>+ (<span class="hljs-keyword">id</span>)allocWithZone:(<span class="hljs-keyword">struct</span> _NSZone *)zone &#123;<br>    <span class="hljs-keyword">return</span> _objc_rootAllocWithZone(<span class="hljs-keyword">self</span>, (malloc_zone_t *)zone);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这里实际上又回到了上面的<code>_objc_rootAllocWithZone</code>方法，与<code>OBJC2</code>的区别只是是否做了<code>cls</code>为nil的判断以及是否有自定义的<code>allocWithZone</code>的方法。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">if</span> (slowpath(checkNil &amp;&amp; !cls)) <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>;<br><span class="hljs-comment">// 是否有自定义的allocWithZone方法</span><br><span class="hljs-keyword">if</span> (fastpath(!cls-&gt;ISA()-&gt;hasCustomAWZ())) &#123;<br>    <span class="hljs-comment">// 直接调用_objc_rootAllocWithZone</span><br>    <span class="hljs-keyword">return</span> _objc_rootAllocWithZone(cls, <span class="hljs-literal">nil</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>alloc</code>方法调用完成之后，我们实际上已经开辟了对应的内存空间初始化好了<code>ISA</code>的部分信息，下面我们来看下<code>init</code>方法。</p>
<h2 id="init"><a href="#init" class="headerlink" title="init"></a>init</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs objc">- (<span class="hljs-keyword">id</span>)init &#123;<br>    <span class="hljs-keyword">return</span> _objc_rootInit(<span class="hljs-keyword">self</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">id</span><br>_objc_rootInit(<span class="hljs-keyword">id</span> obj)<br>&#123;<br>    <span class="hljs-comment">// In practice, it will be hard to rely on this function.</span><br>    <span class="hljs-comment">// Many classes do not properly chain -init calls.</span><br>    <span class="hljs-keyword">return</span> obj;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>从这里我们看到<code>init</code>方法实际上并没有实现什么只是将我们在<code>alloc</code>方法创建好的对象返回了。</p>
<h2 id="new"><a href="#new" class="headerlink" title="new"></a>new</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs objc">+ (<span class="hljs-keyword">id</span>)new &#123;<br>    <span class="hljs-keyword">return</span> [callAlloc(<span class="hljs-keyword">self</span>, <span class="hljs-literal">false</span><span class="hljs-comment">/*checkNil*/</span>) init];<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们看到这个方法实际上就是调用了<code>callAlloc</code>方法然后<code>callAlloc</code>返回的对象在调用<code>init</code>方法。</p>
<p>至此对象创建的几种方式我们就分析完成了。</p>
<p>对象创建流程如下(主要是alloc方法)：</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gl58rskmkaj30u00xojzw.jpg"></p>
<h2 id="对象赋值"><a href="#对象赋值" class="headerlink" title="对象赋值"></a>对象赋值</h2><p>看完了对象的初始化，我们在平时常用的就是给对象赋值和拷贝，比如</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs objc">Person *person = [[Person alloc] init];<br>Person *personCpy = [person <span class="hljs-keyword">copy</span>];<br></code></pre></td></tr></table></figure>

<p>下面我们主要从上面这两个方面来看下在这个过程中<code>Runtime</code>都做了什么：</p>
<h3 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h3><p>我们都知道，对于一个对象的引用我们有弱引用和强引用两种，分别用<code>__weak</code>和<code>__strong</code>来修饰，如果我们不做显示说明那么默认是<code>__strong</code>。</p>
<p>我们在Runtime中去查找修饰变量的类型时发现了下面这个枚举:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">/*</span><br><span class="hljs-comment">  &quot;Unknown&quot; includes non-object ivars and non-ARC non-__weak ivars</span><br><span class="hljs-comment">  &quot;Strong&quot; includes ARC __strong ivars</span><br><span class="hljs-comment">  &quot;Weak&quot; includes ARC and new MRC __weak ivars</span><br><span class="hljs-comment">  &quot;Unretained&quot; includes ARC __unsafe_unretained and old GC+MRC __weak ivars</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">enum</span> &#123;<br>    objc_ivar_memoryUnknown,     <span class="hljs-comment">// unknown / unknown</span><br>    objc_ivar_memoryStrong,      <span class="hljs-comment">// direct access / objc_storeStrong</span><br>    objc_ivar_memoryWeak,        <span class="hljs-comment">// objc_loadWeak[Retained] / objc_storeWeak</span><br>    objc_ivar_memoryUnretained   <span class="hljs-comment">// direct access / direct access</span><br>&#125; objc_ivar_memory_management_t;<br></code></pre></td></tr></table></figure>

<p>下面我们来详细的了解下这其中的区别：</p>
<h3 id="strong"><a href="#strong" class="headerlink" title="__strong"></a>__strong</h3><p>上面看到的</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs objc">Person *stu = [[Person alloc] init];<br></code></pre></td></tr></table></figure>

<p>实际上可以翻译成：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs objc">__<span class="hljs-keyword">strong</span> Person *stu = [[Person alloc] init];<br></code></pre></td></tr></table></figure>

<p>那么<code>__strong</code>都做了什么呢？我们直接去看下<code>objc_storeStrong</code>方法都做了什么：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">void</span><br>objc_storeStrong(<span class="hljs-keyword">id</span> *location, <span class="hljs-keyword">id</span> obj)<br>&#123;<br>    <span class="hljs-keyword">id</span> prev = *location;<br>    <span class="hljs-comment">// 先判断之前的值和要新赋值的对象地址是否相同</span><br>    <span class="hljs-keyword">if</span> (obj == prev) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// 执行retain操作 保留新值</span><br>    objc_retain(obj);<br>    *location = obj;<br>    <span class="hljs-comment">// 释放旧值</span><br>    objc_release(prev);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这个方法的主要操作让我们很容易联想到<code>MRC</code>下<code>setter</code>方法的书写方式，保留新值，释放旧值。我们在进一步看下<code>objc_retain</code>和<code>objc_release</code>的实现。</p>
<h4 id="objc-retain"><a href="#objc-retain" class="headerlink" title="objc_retain"></a>objc_retain</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs objc">__attribute__((aligned(<span class="hljs-number">16</span>), flatten, noinline))<br><span class="hljs-keyword">id</span> <br>objc_retain(<span class="hljs-keyword">id</span> obj)<br>&#123;<br>    <span class="hljs-comment">// 如果为nil 直接返回nil</span><br>    <span class="hljs-keyword">if</span> (!obj) <span class="hljs-keyword">return</span> obj;<br>    <span class="hljs-comment">// 如果是taggedPointer 直接返回</span><br>    <span class="hljs-keyword">if</span> (obj-&gt;isTaggedPointer()) <span class="hljs-keyword">return</span> obj;<br>    <span class="hljs-comment">// 调用retain方法</span><br>    <span class="hljs-keyword">return</span> obj-&gt;<span class="hljs-keyword">retain</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这个方法里 判断了如果要被<code>retain</code>的对象为<code>nil</code>或者是<code>TaggedPointer</code>类型那么直接返回否则调用<code>retain</code>方法。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">// 等价于直接使用对象调用retain方法</span><br><span class="hljs-keyword">inline</span> <span class="hljs-keyword">id</span> <br>objc_object::<span class="hljs-keyword">retain</span>()<br>&#123;<br>    <span class="hljs-comment">// 如果是TaggedPointer类型 不涉及引用计数</span><br>    ASSERT(!isTaggedPointer());<br>    <span class="hljs-comment">// fastpath 表示if中的条件是一个大概率事件</span><br>    <span class="hljs-comment">// 如果当前对象没有自定义（override）retain 方法</span><br>    <span class="hljs-keyword">if</span> (fastpath(!ISA()-&gt;hasCustomRR())) &#123;<br>        <span class="hljs-keyword">return</span> rootRetain();<br>    &#125;<br>    <span class="hljs-comment">// 如果有自定义的retain方法</span><br>    <span class="hljs-comment">// 通过发消息的方式调用自定义的 retain 方法</span><br>    <span class="hljs-keyword">return</span> ((<span class="hljs-keyword">id</span>(*)(objc_object *, SEL))objc_msgSend)(<span class="hljs-keyword">this</span>, <span class="hljs-keyword">@selector</span>(<span class="hljs-keyword">retain</span>));<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这个方法实际上最后调用了<code>rootRetain</code>，对于这个方法我们在<br><a href="http://www.leewong.cn/2020/08/02/retaincount/">retain和release实现探究</a>这篇文章中详细的介绍过。这里我们就不做进一步的介绍了。我们只需要知道在这个方法中我们<code>newisa.nonpointer</code>判断需要增加哪里的引用计数：</p>
<ul>
<li>如果<code>newisa.nonpointer = 0</code> 则没有进行<code>runtime</code>优化，在<code>sidetable</code>中找到这个对象对应的节点更新将<code>SideTable</code>该对象对应的节点的<code>refcntStorage</code>值 + 1</li>
<li>如果<code>newisa.nonpointer = 1</code> 则进行了<code>runtime</code>优化，那么直接在<code>newisa.extra_rc</code>上做引用计数<code>+1</code>同时需要判断<code>newisa.extra_rc</code>是否溢出，如果溢出则需要将一半的引用计数放到<code>sidetable</code>的<code>refcntStorage</code>中同时将<code>newisa.has_sidetable_rc</code>置为true。</li>
</ul>
<p>从上面可以看出<code>objc_retain</code>的操作实际是：<strong>将新对象的引用计数+1，将旧对象的引用计数-1</strong>。</p>
<h3 id="weak"><a href="#weak" class="headerlink" title="__weak"></a>__weak</h3><p>当我们用<code>__weak</code>去修饰一个变量时根据上面的介绍我们实际上是调用<code>objc_storeWeak</code>方法，我们直接看下这个方法的实现。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">// location weak指针自身的地址</span><br><span class="hljs-comment">// newObj weak指针指向的新对象的地址</span><br><span class="hljs-keyword">id</span><br>objc_storeWeak(<span class="hljs-keyword">id</span> *location, <span class="hljs-keyword">id</span> newObj)<br>&#123;<br>    <span class="hljs-keyword">return</span> storeWeak&lt;DoHaveOld, DoHaveNew, DoCrashIfDeallocating&gt;<br>        (location, (objc_object *)newObj);<br></code></pre></td></tr></table></figure>

<p>这个方法内部实际调用了<code>storeWeak</code>方法，这个方法与<code>rootRetain</code>一起，我们在<a href="http://www.leewong.cn/2020/08/02/retaincount/">retain和release实现探究</a>这里都有详细的讲解这里不再赘述。</p>
<p>我们大概描述下<code>storeWeak</code>操作做了哪些事情：</p>
<ul>
<li>根据对象地址从<code>SideTable</code>中取出对应的节点，如果之前没有 则创建一个新的</li>
<li>调用<code>weak_unregister_no_lock</code>，将<code>weak pointer</code>的地址从旧对象的<code>weak_entry_t</code>中移除，同时判断是否<code>weak_entry_t</code>为空,则将<code>weak_entry_t</code>从<code>weaktable</code>中移除。</li>
<li>调用<code>weak_register_no_lock</code>方法，将<code>weak pointer</code>的地址(location)记录到对象对应的<code>weak_entry_t</code>中，并将对象的isa指针中的<code>weakly_referenced</code>标志位置为1，表明这个对象被弱引用了</li>
</ul>
<h3 id="retaincount"><a href="#retaincount" class="headerlink" title="retaincount"></a>retaincount</h3><p>我们上面创建或者给一个strong类型的指针赋值，实际上都是对引用计数的+1操作，那么我们看下这个引用计数是如何保存的呢？</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs objc">- (<span class="hljs-built_in">NSUInteger</span>)retainCount &#123;<br>    <span class="hljs-keyword">return</span> _objc_rootRetainCount(<span class="hljs-keyword">self</span>);<br>&#125;<br><br>uintptr_t<br>_objc_rootRetainCount(<span class="hljs-keyword">id</span> obj)<br>&#123;<br>    ASSERT(obj);<br><br>    <span class="hljs-keyword">return</span> obj-&gt;rootRetainCount();<br>&#125;<br><br></code></pre></td></tr></table></figure>

<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">// 获取引用高技术</span><br><span class="hljs-keyword">inline</span> uintptr_t <br>objc_object::rootRetainCount()<br>&#123;<br>    <span class="hljs-comment">//isTaggedPointer 不需要引用计数</span><br>    <span class="hljs-keyword">if</span> (isTaggedPointer()) <span class="hljs-keyword">return</span> (uintptr_t)<span class="hljs-keyword">this</span>;<br><br>    sidetable_lock();<br>    isa_t bits = LoadExclusive(&amp;isa.bits);<br>    ClearExclusive(&amp;isa.bits);<br>    <span class="hljs-comment">// 如果是nonpointer</span><br>    <span class="hljs-keyword">if</span> (bits.nonpointer) &#123;<br>        <span class="hljs-comment">// 先从extra_rc取出部分引用计数</span><br>        uintptr_t rc = <span class="hljs-number">1</span> + bits.extra_rc;<br>        <span class="hljs-comment">// sidetable中是否有额外的引用计数</span><br>        <span class="hljs-keyword">if</span> (bits.has_sidetable_rc) &#123;<br>            <span class="hljs-comment">// 从sidetable中获取引用计数</span><br>            rc += sidetable_getExtraRC_nolock();<br>        &#125;<br>        sidetable_unlock();<br>        <span class="hljs-keyword">return</span> rc;<br>    &#125;<br><br>    sidetable_unlock();<br>    <span class="hljs-comment">// 如果不是nonpointer 直接从sidetable中获取引用计数</span><br>    <span class="hljs-keyword">return</span> sidetable_retainCount();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果对象是<code>TaggedPointer</code> 直接返回这个对象(<code>TaggedPointer</code>不需要引用计数)，否则</p>
<ul>
<li><code>bits.nonpointer = 1</code> 则先从<code>bits.extra_rc</code>获取部分引用计数 然后判断<code>sidetable</code>中是否有额外的引用计数 如果有 二者相加</li>
<li><code>bits.nonpointer = 0</code> 则直接从<code>sidetable</code>中获取引用计数</li>
</ul>
<h2 id="对象的销毁"><a href="#对象的销毁" class="headerlink" title="对象的销毁"></a>对象的销毁</h2><p>对象常用的销毁方法实际上就是<code>release</code>和<code>autorelease</code>两种。我们来看下这两种的具体实现：</p>
<h3 id="release"><a href="#release" class="headerlink" title="release"></a>release</h3><p>在查看源码前，我们知道<code>release</code>的主要功能是：<strong>引用计数-1</strong>，我们来看下具体实现</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs objc">- (<span class="hljs-keyword">oneway</span> <span class="hljs-keyword">void</span>)release &#123;<br>    _objc_rootRelease(<span class="hljs-keyword">self</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们看下_objc_rootRelease的实现：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs objc">NEVER_INLINE <span class="hljs-keyword">void</span><br>_objc_rootRelease(<span class="hljs-keyword">id</span> obj)<br>&#123;<br>    ASSERT(obj);<br><br>    obj-&gt;rootRelease();<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>rootRelease</code>方法我们在<a href="http://www.leewong.cn/2020/08/02/retaincount/">retain和release实现探究</a>中也有详细介绍。</p>
<p>我们简单的说下<code>rootRelease</code>这个方法：</p>
<ul>
<li>如果<code>newisa.nonpointer = 0</code> 则调用<code>sidetable_release</code>方法，这个方法会判断<code>sidetable</code>中<code>refcnt</code>是否小于<code>SIDE_TABLE_DEALLOCATING</code> 如果小于则表示这个对象要被释放，则调用<code>dealloc</code>方法。如果不小于则直接执行<code>refcnt -= SIDE_TABLE_RC_ONE</code>;即<code>refcnt-1</code>操作。</li>
<li>如果<code>newisa.nonpointer = 1</code> 则 对<code>newisa.extra_rc</code>进行-1操作，然后判断<code>newisa.extra_rc</code>是否有向下溢出，并执行对应操作。</li>
</ul>
<h3 id="autorelease"><a href="#autorelease" class="headerlink" title="autorelease"></a>autorelease</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs objc">- (<span class="hljs-keyword">id</span>)autorelease &#123;<br>    <span class="hljs-keyword">return</span> _objc_rootAutorelease(<span class="hljs-keyword">self</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs objc">__attribute__((noinline,used))<br><span class="hljs-keyword">id</span> <br>objc_object::rootAutorelease2()<br>&#123;<br>    ASSERT(!isTaggedPointer());<br>    <span class="hljs-keyword">return</span> AutoreleasePoolPage::autorelease((<span class="hljs-keyword">id</span>)<span class="hljs-keyword">this</span>);<br>&#125;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">id</span> autorelease(<span class="hljs-keyword">id</span> obj)<br>    &#123;<br>        ASSERT(obj);<br>        ASSERT(!obj-&gt;isTaggedPointer());<br>        <span class="hljs-keyword">id</span> *dest __unused = autoreleaseFast(obj);<br>        ASSERT(!dest  ||  dest == EMPTY_POOL_PLACEHOLDER  ||  *dest == obj);<br>        <span class="hljs-keyword">return</span> obj;<br>    &#125;<br>    <br><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">id</span> *autoreleaseFast(<span class="hljs-keyword">id</span> obj)<br>    &#123;<br>        AutoreleasePoolPage *page = hotPage();<br>        <span class="hljs-keyword">if</span> (page &amp;&amp; !page-&gt;full()) &#123;<br>            <span class="hljs-keyword">return</span> page-&gt;add(obj);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (page) &#123;<br>            <span class="hljs-keyword">return</span> autoreleaseFullPage(obj, page);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> autoreleaseNoPage(obj);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>我们看到<code>autorelease</code>实际上最终是调用了<code>AutoreleasePoolPage</code>的<code>autorelease</code>方法，<code>AutoreleasePoolPage</code>我们在<a href="http://www.leewong.cn/2018/03/20/iOS%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B9%8BAutoreleasePool/">iOS内存管理之AutoreleasePool</a>中有详细介绍，这里我们也不再赘述。</p>
<p>我们简单的回忆下<code>AutoreleasePoolPage</code>几个重要方法：</p>
<ul>
<li><p>push</p>
<p>  1、首先取出当前的<code>hotPage</code>，所谓<code>hotPage</code>，就是在<code>autoreleasePage</code>链表中正在使用的<code>autoreleasePage</code>节点。<br>  2、如果有<code>hotPage</code>，且<code>hotPage</code>还没满，这将obj加入到page中。<br>  3、如果有<code>hotPage</code>，但是已经满了，则进入<code>page full</code>逻辑（autoreleaseFullPage）<br>  4、如果没有<code>hotPage</code>，进入no page逻辑<code>autoreleaseNoPage</code>。</p>
</li>
<li><p>pop(void pop(void *token))</p>
<p>当<code>autoreleasepool</code>需要被释放时，会调用<code>Pop</code>方法。而Pop方法需要接受一个<code>void *token</code>参数，来告诉池子，需要一直释放到token对应的那个page</p>
</li>
</ul>
<p>通过上面的介绍，我们知道<code>AutoreleasePoolPage</code>实际上就是一个存放待释放对象的缓存池。push为追加对象，pop为释放对象。</p>
<h3 id="dealloc"><a href="#dealloc" class="headerlink" title="dealloc"></a>dealloc</h3><p>在上面我们介绍<code>release</code>时，我们发现在对对象的引用计数进行-1操作时，如果判断对象引用计数为0，会主动调用<code>dealloc</code>,那么我们看下这个方法的实现</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs objc">- (<span class="hljs-keyword">void</span>)dealloc &#123;<br>    _objc_rootDealloc(<span class="hljs-keyword">self</span>);<br>&#125;<br><br>_objc_rootDealloc(<span class="hljs-keyword">id</span> obj)<br>&#123;<br>    ASSERT(obj);<br><br>    obj-&gt;rootDealloc();<br>&#125;<br><br><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span><br>objc_object::rootDealloc()<br>&#123;<br>    <span class="hljs-keyword">if</span> (isTaggedPointer()) <span class="hljs-keyword">return</span>;  <span class="hljs-comment">// fixme necessary?</span><br><br>    <span class="hljs-keyword">if</span> (fastpath(isa.nonpointer  &amp;&amp;  <br>                 !isa.weakly_referenced  &amp;&amp;  <br>                 !isa.has_assoc  &amp;&amp;  <br>                 !isa.has_cxx_dtor  &amp;&amp;  <br>                 !isa.has_sidetable_rc))<br>    &#123;<br>        assert(!sidetable_present());<br>        free(<span class="hljs-keyword">this</span>);<br>    &#125; <br>    <span class="hljs-keyword">else</span> &#123;<br>        object_dispose((<span class="hljs-keyword">id</span>)<span class="hljs-keyword">this</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们看到这个方法主要逻辑为：</p>
<ul>
<li>如果对象<code>isa.nonpointer=1</code>且没有弱指针指向他，且没有关联对象，没有自定义销毁方法，<code>sidetable</code>的<code>retainCount = 0</code> 则直接释放</li>
<li>如果对象<code>isa.nonpointer=0</code> 则需要调用<code>object_dispose</code>方法</li>
</ul>
<p>我们在看下<code>object_dispose</code>方法的实现：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">static</span> <span class="hljs-keyword">id</span> <br>_object_dispose(<span class="hljs-keyword">id</span> anObject) <br>&#123;<br>    <span class="hljs-keyword">if</span> (anObject==<span class="hljs-literal">nil</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>;<br>    <span class="hljs-comment">// 调用objc_destructInstance</span><br>    objc_destructInstance(anObject);<br>    <span class="hljs-comment">// isa指针为_objc_getFreedObjectClass类型</span><br>    anObject-&gt;initIsa(_objc_getFreedObjectClass ()); <br>    <span class="hljs-comment">// 释放对象</span><br>    free(anObject);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们进一步看下<code>_object_dispose</code>中的这几个方法</p>
<h4 id="objc-destructInstance"><a href="#objc-destructInstance" class="headerlink" title="objc_destructInstance"></a>objc_destructInstance</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">// 对象的析构方法</span><br><span class="hljs-keyword">void</span> *objc_destructInstance(<span class="hljs-keyword">id</span> obj) <br>&#123;<br>    <span class="hljs-keyword">if</span> (obj) &#123;<br>        <span class="hljs-comment">// 获取到isa</span><br>        Class isa = obj-&gt;getIsa();<br>        <span class="hljs-comment">// 是否有c++析构方法 有则执行</span><br>        <span class="hljs-keyword">if</span> (isa-&gt;hasCxxDtor()) &#123;<br>            object_cxxDestruct(obj);<br>        &#125;<br>        <span class="hljs-comment">// 是否有关联对象 有则移除</span><br>        <span class="hljs-keyword">if</span> (isa-&gt;instancesHaveAssociatedObjects()) &#123;<br>            _object_remove_assocations(obj);<br>        &#125;<br>        <span class="hljs-comment">// 调用objc_clear_deallocating方法</span><br>        objc_clear_deallocating(obj);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> obj;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="initIsa"><a href="#initIsa" class="headerlink" title="initIsa"></a>initIsa</h4><p>这个方法我们在上面介绍过了 这里主要看下参数<code>_objc_getFreedObjectClass ()</code>,我们看下系统给的解释</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">/***********************************************************************</span><br><span class="hljs-comment">* _class_getFreedObjectClass.  Return a pointer to the dummy freed</span><br><span class="hljs-comment">* object class.  Freed objects get their isa pointers replaced with</span><br><span class="hljs-comment">* a pointer to the freedObjectClass, so that we can catch usages of</span><br><span class="hljs-comment">* the freed object.</span><br><span class="hljs-comment">**********************************************************************/</span><br><span class="hljs-keyword">static</span> Class _class_getFreedObjectClass(<span class="hljs-keyword">void</span>)<br>&#123;<br>    <span class="hljs-keyword">return</span> (Class)freedObjectClass;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>我们可以简单的理解为，对于一个已释放的对象他的isa指针指向了<code>freedObjectClass</code>类型，系统以此作为已释放对象的标记。</p>
<p>我们在源码中搜索的时候还发现：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">if</span> (anObject-&gt;ISA() == _objc_getFreedObjectClass ())<br>       __objc_error(anObject, <span class="hljs-string">&quot;reallocating freed object&quot;</span>);<br><br></code></pre></td></tr></table></figure>
<p>重新分配已释放对象的空间，这也作证了我们上面描述的。</p>
<h4 id="objc-clear-deallocating"><a href="#objc-clear-deallocating" class="headerlink" title="objc_clear_deallocating"></a>objc_clear_deallocating</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <br>objc_object::clearDeallocating()<br>&#123;<br>    <span class="hljs-keyword">if</span> (slowpath(!isa.nonpointer)) &#123;<br>        <span class="hljs-comment">// Slow path for raw pointer isa.</span><br>        sidetable_clearDeallocating();<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (slowpath(isa.weakly_referenced  ||  isa.has_sidetable_rc)) &#123;<br>        <span class="hljs-comment">// Slow path for non-pointer isa with weak refs and/or side table data.</span><br>        clearDeallocating_slow();<br>    &#125;<br><br>    assert(!sidetable_present());<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这个方法也是根据<code>isa.nonpointer</code>判断：</p>
<ul>
<li>如果<code>isa.nonpointer = 0</code> 调用s<code>idetable_clearDeallocating</code> 执行<code>sidetable</code>相关的释放</li>
<li>如果<code>isa.nonpointer = 1</code> 调用<code>clearDeallocating_slow</code> 进行释放</li>
</ul>
<h4 id="sidetable-clearDeallocating"><a href="#sidetable-clearDeallocating" class="headerlink" title="sidetable_clearDeallocating"></a>sidetable_clearDeallocating</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">void</span> <br>objc_object::sidetable_clearDeallocating()<br>&#123;<br>    SideTable&amp; table = SideTables()[<span class="hljs-keyword">this</span>];<br><br>    <span class="hljs-comment">// clear any weak table items</span><br>    <span class="hljs-comment">// clear extra retain count and deallocating bit</span><br>    <span class="hljs-comment">// (fixme warn or abort if extra retain count == 0 ?)</span><br>    table.lock();<br>    RefcountMap::iterator it = table.refcnts.find(<span class="hljs-keyword">this</span>);<br>    <span class="hljs-keyword">if</span> (it != table.refcnts.end()) &#123;<br>        <span class="hljs-keyword">if</span> (it-&gt;second &amp; SIDE_TABLE_WEAKLY_REFERENCED) &#123;<br>            weak_clear_no_lock(&amp;table.weak_table, (<span class="hljs-keyword">id</span>)<span class="hljs-keyword">this</span>);<br>        &#125;<br>        table.refcnts.erase(it);<br>    &#125;<br>    table.unlock();<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>根据<code>this</code>取出对象对应的<code>sidetable</code> 如果有弱引用指针指向这个对象 则这里进行置nil 调用的是<code>weak_clear_no_lock</code>方法</li>
<li>调用<code>erase</code>方法将<code>table.refcnts</code>置为空</li>
</ul>
<h4 id="clearDeallocating-slow"><a href="#clearDeallocating-slow" class="headerlink" title="clearDeallocating_slow"></a>clearDeallocating_slow</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs objc">NEVER_INLINE <span class="hljs-keyword">void</span><br>objc_object::clearDeallocating_slow()<br>&#123;<br>    ASSERT(isa.nonpointer  &amp;&amp;  (isa.weakly_referenced || isa.has_sidetable_rc));<br><br>    SideTable&amp; table = SideTables()[<span class="hljs-keyword">this</span>];<br>    table.lock();<br>    <span class="hljs-keyword">if</span> (isa.weakly_referenced) &#123;<br>        weak_clear_no_lock(&amp;table.weak_table, (<span class="hljs-keyword">id</span>)<span class="hljs-keyword">this</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (isa.has_sidetable_rc) &#123;<br>        table.refcnts.erase(<span class="hljs-keyword">this</span>);<br>    &#125;<br>    table.unlock();<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>实际上这个方法和<code>sidetable_clearDeallocating</code>方法的实现高度相似，只是标志位一个是从<code>it-&gt;second</code>通过按位与方法判断一个是直接从isa中获取。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇文章我们从对象的创建以及赋值销毁等方面分析了Runtime的实现，尤其是对于引用计数器的操作。让我们对内存管理有了更清晰的认识。</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u013378438/article/details/86508575">OC对象从创建到销毁</a><br><a target="_blank" rel="noopener" href="https://halfrost.com/objc_life/">Objc 对象的今生今世</a></p>

    </div>
     
    <div class="post-footer__meta"><p>更新于 2020-12-05</p></div> 
    <div class="post-meta__cats"><a href="/categories/Runtime/" class="post-cats__link button">Runtime</a><a href="/tags/Runtime-Retain-Release/" class="post-tags__link button"># Runtime Retain Release</a></div> 
</article>


    <div class="nav">
        <div class="nav__prev">
            
        </div>
        <div class="nav__next">
            
                <a href="/2020/11/15/runtime-msgsend/" class="nav__link">
                    <div>
                        <div class="nav__label">
                            Next Post
                        </div>
                        <div class="nav__title">
                            Runtime之消息转发
                        </div>
                    </div>
                    <div>
                        <svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" width="24" height="24"><path d="M434.944 790.624l-45.248-45.248L623.04 512l-233.376-233.376 45.248-45.248L713.568 512z" fill="#808080"></path></svg>
                    </div>
                </a>
            
        </div>
    </div>





</main>

            <footer class="footer">
    


    
    
    
        <span id="busuanzi_container_site_uv" hidden>
            <span></span>
            <span id="busuanzi_value_site_uv"></span>
            <span>Viewers</span>
            
                <span>&amp;nbsp;&amp;nbsp;&amp;nbsp;|</span>
            
        </span>
    
    
        <span id="busuanzi_container_site_pv" hidden>
            <span></span>
            <span id="busuanzi_value_site_pv"></span>
            <span>Views</span>
            
        </span>
    
 
 

 
    
        
        <p class="footer-copyright">
            Copyright © 2015&nbsp;-&nbsp;2020 <a href="/">LeeWong</a>
        </p>
    
    
    <p>Powered by <a href="https://hexo.io" target="_blank">Hexo</a> | Theme - <a href="https://github.com/ChrAlpha/hexo-theme-cards" target="_blank">Cards</a></p>
</footer>

        </div>
         

 
    <script>
        window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
        ga('create', '4NmLVard-jFEKaV6857m9tKb41Tpo4FiKj8L1TJg7lU', 'auto');
        ga('send', 'pageview');
    </script>
    <script async src="https://www.google-analytics.com/analytics.js"></script>
 

 

 
    <script>
        var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement('script');
            hm.src = 'https://hm.baidu.com/hm.js?DR81zbdrQ3';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(hm, s);
        })();
    </script>
 

  



 


    
 


    
<script src="https://cdn.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.min.js"></script>

    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.4.1/dist/jquery.fancybox.min.css">

    
<script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.4.1/dist/jquery.fancybox.min.js"></script>

    <script>
        let lazyloadT = Boolean('false'),
            auto_fancybox = Boolean('false')
        if (auto_fancybox) {
            $(".post__content").find('img').each(function () {
                var element = document.createElement("a");
                $(element).attr("data-fancybox", "gallery");
                $(element).attr("href", $(this).attr("src"));
                if (lazyloadT) {
                    $(element).attr("href", $(this).attr("data-srcset"));
                }
                $(this).wrap(element);
            });
        } else {
            $(".post__content").find("fancybox").find('img').each(function () {
                var element = document.createElement("a");
                $(element).attr("data-fancybox", "gallery");
                $(element).attr("href", $(this).attr("src"));
                if (lazyloadT) {
                    $(element).attr("href", $(this).attr("data-srcset"));
                }
                $(this).wrap(element);
            });
        }
    </script>
 

 

 

 




    </body>
</html>
