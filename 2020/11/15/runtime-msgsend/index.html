<!DOCTYPE html>
<html lang="zh-CN">
    <head>
    <meta charset="utf-8">

    

    <!-- 渲染优化 -->
    <meta name="renderer" content="webkit">
    <meta name="force-rendering" content="webkit">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="HandheldFriendly" content="True" >
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <!--icon-->

    
        <link rel="shortcut icon" href="https://tva1.sinaimg.cn/large/0081Kckwly1glcsnw2jatj303k03k748.jpg">
    
    
    
    
    


    <!-- meta -->


<title>Runtime之消息转发 | LeeWong</title>


    <meta name="keywords" content="Runtime msgSend, iOS">




    <!-- OpenGraph -->
 
    <meta name="description" content="我们都知道，在iOS开发中方法的调用实现实际上是通过消息发送的机制实现的，我们可以简单的理解为： [A a];调用A类的a方法，实际上就是给类A的a方法发消息。 在这个过程中又会经历：方法查找、方法调用、方法转发这几个阶段，下面我们来通过这几个阶段来看下Runtime在这几个环境是如何实现的。">
<meta property="og:type" content="article">
<meta property="og:title" content="Runtime之消息转发">
<meta property="og:url" content="https://www.leewong.cn/2020/11/15/runtime-msgsend/index.html">
<meta property="og:site_name" content="LeeWong">
<meta property="og:description" content="我们都知道，在iOS开发中方法的调用实现实际上是通过消息发送的机制实现的，我们可以简单的理解为： [A a];调用A类的a方法，实际上就是给类A的a方法发消息。 在这个过程中又会经历：方法查找、方法调用、方法转发这几个阶段，下面我们来通过这几个阶段来看下Runtime在这几个环境是如何实现的。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/0081Kckwly1glcudcqxexj31400mcabn.jpg">
<meta property="article:published_time" content="2020-11-15T06:14:57.000Z">
<meta property="article:modified_time" content="2020-12-05T04:02:07.170Z">
<meta property="article:author" content="LeeWong">
<meta property="article:tag" content="Runtime msgSend">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://tva1.sinaimg.cn/large/0081Kckwly1glcudcqxexj31400mcabn.jpg">


    
<link rel="stylesheet" href="/css/style/main.css">
 


    
<link rel="stylesheet" href="/css/style/dark.css">

    
<script src="/js/darkmode.js"></script>



    
    
    
        <link rel="stylesheet" id="hl-default-theme" href="https://cdn.jsdelivr.net/npm/highlight.js@10.1.2/styles/default.min.css" media="none" onload="if(getComputedStyle(document.documentElement).getPropertyValue('--color-mode').indexOf('dark')===-1)this.media='all'">
        
            <link rel="stylesheet" id="hl-dark-theme" href="https://cdn.jsdelivr.net/npm/highlight.js@10.1.2/styles/dark.min.css" media="none" onload="if(getComputedStyle(document.documentElement).getPropertyValue('--color-mode').indexOf('dark')!==-1)this.media='all'">
        
    

    

     
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
 

    <!-- custom head -->

    
        <meta name="google-site-verification" content="4NmLVard-jFEKaV6857m9tKb41Tpo4FiKj8L1TJg7lU" /> 
    

<meta name="generator" content="Hexo 5.1.1"></head>

    <body>
        <div id="app">
            <header class="header">
    <div class="header__left">
        <a href="/" class="button">
            <span class="logo__text">LeeWong</span>
        </a>
    </div>
    <div class="header__right">
        
            <div class="navbar__menus">
                
                    <a href="/" class="navbar-menu button">首页</a>
                
                    <a href="/tags/" class="navbar-menu button">标签</a>
                
                    <a href="/archives/" class="navbar-menu button">归档</a>
                
                    <a href="/about/" class="navbar-menu button">关于我</a>
                
            </div>
        
        
        

        
        
    <a href="javaScript:void(0);" id="btn-toggle-dark">
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path></svg>
    </a>


         
    <a href="#" class="button" id="b2t" aria-label="回到顶部" title="回到顶部">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1024 1024" width="32" height="32">
            <path d="M233.376 722.752L278.624 768 512 534.624 745.376 768l45.248-45.248L512 444.128zM192 352h640V288H192z" fill="currentColor"></path>
        </svg>
    </a>


        
            <a class="dropdown-icon button" id="btn-dropdown" tabindex="0"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" width='24' height='24' fill="none" stroke="currentColor" stroke-width="0.7" stroke-linecap="round" stroke-linejoin="round"><path fill="currentColor" d="M3.314,4.8h13.372c0.41,0,0.743-0.333,0.743-0.743c0-0.41-0.333-0.743-0.743-0.743H3.314c-0.41,0-0.743,0.333-0.743,0.743C2.571,4.467,2.904,4.8,3.314,4.8z M16.686,15.2H3.314c-0.41,0-0.743,0.333-0.743,0.743s0.333,0.743,0.743,0.743h13.372c0.41,0,0.743-0.333,0.743-0.743S17.096,15.2,16.686,15.2z M16.686,9.257H3.314c-0.41,0-0.743,0.333-0.743,0.743s0.333,0.743,0.743,0.743h13.372c0.41,0,0.743-0.333,0.743-0.743S17.096,9.257,16.686,9.257z"></path></svg></a>
            <div class="dropdown-menus" id="dropdown-menus">
                
                    <a href="/" class="dropdown-menu button">首页</a>
                
                    <a href="/tags/" class="dropdown-menu button">标签</a>
                
                    <a href="/archives/" class="dropdown-menu button">归档</a>
                
                    <a href="/about/" class="dropdown-menu button">关于我</a>
                
            </div>
        
    </div>
</header>


            <main class="main">
    

<div class="post-title">
    <h1 class="post-title__text">
        Runtime之消息转发
    </h1>
    <div class="post-title__meta">
        <a href="/archives/2020/11/" class="post-meta__date button">2020-11-15</a>
        
    <span class="separate-dot"></span><a href="/categories/Runtime/" class="button">Runtime</a>

 
        
    
     
    <span id="busuanzi_container_page_pv" hidden>
        <span class="separate-dot"></span>
        <span></span>
        <span id="busuanzi_value_page_pv"></span>
        <span>Views</span>
    </span>



 

 
    </div>
</div>


    <aside class="post-side">
        <div class="post-side__toc">
            <ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#Method"><span class="toc-number">1.</span> <span class="toc-text">Method</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#SEL"><span class="toc-number">1.1.</span> <span class="toc-text">SEL</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#types"><span class="toc-number">1.2.</span> <span class="toc-text">types</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#MethodListIMP"><span class="toc-number">1.3.</span> <span class="toc-text">MethodListIMP</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8"><span class="toc-number">2.</span> <span class="toc-text">方法调用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#objc-msgSend"><span class="toc-number">2.1.</span> <span class="toc-text">objc_msgSend</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#objc-msgSendSuper"><span class="toc-number">2.2.</span> <span class="toc-text">objc_msgSendSuper</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#objc-msgSend-1"><span class="toc-number">2.3.</span> <span class="toc-text">objc_msgSend</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#lookUpImpOrForward"><span class="toc-number">2.3.1.</span> <span class="toc-text">lookUpImpOrForward</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#checkIsKnownClass"><span class="toc-number">2.3.2.</span> <span class="toc-text">checkIsKnownClass</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#realizeClass"><span class="toc-number">2.3.3.</span> <span class="toc-text">realizeClass</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#class-initialize"><span class="toc-number">2.3.4.</span> <span class="toc-text">_class_initialize</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#getMethodNoSuper-nolock"><span class="toc-number">2.3.5.</span> <span class="toc-text">getMethodNoSuper_nolock</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#log-and-fill-cache%E5%92%8Ccache-getImp"><span class="toc-number">2.3.6.</span> <span class="toc-text">log_and_fill_cache和cache_getImp</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#class-resolveMethod"><span class="toc-number">2.4.</span> <span class="toc-text">_class_resolveMethod</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#class-resolveClassMethod"><span class="toc-number">2.4.1.</span> <span class="toc-text">_class_resolveClassMethod</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#lookUpImpOrNil"><span class="toc-number">2.4.2.</span> <span class="toc-text">lookUpImpOrNil</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#objc-msgForward-impcache"><span class="toc-number">2.5.</span> <span class="toc-text">_objc_msgForward_impcache</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#objc-forward-handler"><span class="toc-number">2.5.1.</span> <span class="toc-text">__objc_forward_handler</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91"><span class="toc-number">3.</span> <span class="toc-text">消息转发</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#forwarding"><span class="toc-number">3.0.1.</span> <span class="toc-text">forwarding</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B"><span class="toc-number"></span> <span class="toc-text">示例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%A3%E6%9E%90"><span class="toc-number">1.</span> <span class="toc-text">动态解析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91-1"><span class="toc-number">2.</span> <span class="toc-text">消息转发</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E6%96%87%E7%AB%A0"><span class="toc-number"></span> <span class="toc-text">参考文章</span></a>
        </div>
    </aside>
    <a class="btn-toc button" id="btn-toc" tabindex="0">
        <svg viewBox="0 0 1024 1024" width="32" height="32" xmlns="http://www.w3.org/2000/svg">
            <path d="M128 256h64V192H128zM320 256h576V192H320zM128 544h64v-64H128zM320 544h576v-64H320zM128 832h64v-64H128zM320 832h576v-64H320z" fill="currentColor"></path>
        </svg>
    </a>
    <div class="toc-menus" id="toc-menus">
        <div class="toc-title">文章目录</div>
        <ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#Method"><span class="toc-number">1.</span> <span class="toc-text">Method</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#SEL"><span class="toc-number">1.1.</span> <span class="toc-text">SEL</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#types"><span class="toc-number">1.2.</span> <span class="toc-text">types</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#MethodListIMP"><span class="toc-number">1.3.</span> <span class="toc-text">MethodListIMP</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8"><span class="toc-number">2.</span> <span class="toc-text">方法调用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#objc-msgSend"><span class="toc-number">2.1.</span> <span class="toc-text">objc_msgSend</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#objc-msgSendSuper"><span class="toc-number">2.2.</span> <span class="toc-text">objc_msgSendSuper</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#objc-msgSend-1"><span class="toc-number">2.3.</span> <span class="toc-text">objc_msgSend</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#lookUpImpOrForward"><span class="toc-number">2.3.1.</span> <span class="toc-text">lookUpImpOrForward</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#checkIsKnownClass"><span class="toc-number">2.3.2.</span> <span class="toc-text">checkIsKnownClass</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#realizeClass"><span class="toc-number">2.3.3.</span> <span class="toc-text">realizeClass</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#class-initialize"><span class="toc-number">2.3.4.</span> <span class="toc-text">_class_initialize</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#getMethodNoSuper-nolock"><span class="toc-number">2.3.5.</span> <span class="toc-text">getMethodNoSuper_nolock</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#log-and-fill-cache%E5%92%8Ccache-getImp"><span class="toc-number">2.3.6.</span> <span class="toc-text">log_and_fill_cache和cache_getImp</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#class-resolveMethod"><span class="toc-number">2.4.</span> <span class="toc-text">_class_resolveMethod</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#class-resolveClassMethod"><span class="toc-number">2.4.1.</span> <span class="toc-text">_class_resolveClassMethod</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#lookUpImpOrNil"><span class="toc-number">2.4.2.</span> <span class="toc-text">lookUpImpOrNil</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#objc-msgForward-impcache"><span class="toc-number">2.5.</span> <span class="toc-text">_objc_msgForward_impcache</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#objc-forward-handler"><span class="toc-number">2.5.1.</span> <span class="toc-text">__objc_forward_handler</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91"><span class="toc-number">3.</span> <span class="toc-text">消息转发</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#forwarding"><span class="toc-number">3.0.1.</span> <span class="toc-text">forwarding</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B"><span class="toc-number"></span> <span class="toc-text">示例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%A3%E6%9E%90"><span class="toc-number">1.</span> <span class="toc-text">动态解析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91-1"><span class="toc-number">2.</span> <span class="toc-text">消息转发</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E6%96%87%E7%AB%A0"><span class="toc-number"></span> <span class="toc-text">参考文章</span></a>
    </div>


<article class="post content-card">
    <div class="post__header">
    
        <div class="post-thumbnail" style="background-image: url('https://tva1.sinaimg.cn/large/0081Kckwly1glcudcqxexj31400mcabn.jpg');"></div>
    
</div>
    <div class="post__content">
        <p>我们都知道，在iOS开发中方法的调用实现实际上是通过消息发送的机制实现的，我们可以简单的理解为：</p>
<p>[A a];调用A类的a方法，实际上就是给类A的a方法发消息。</p>
<p>在这个过程中又会经历：方法查找、方法调用、方法转发这几个阶段，下面我们来通过这几个阶段来看下Runtime在这几个环境是如何实现的。</p>
<a id="more"></a>


<p>在研究方法调用之前，我们先看几个方法调用先关的结构，了解这些结构之后会方便我们后续了解消息的调用流程。</p>
<h4 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h4><p>在我们上文介绍方法交换时，我们利用class_getInstanceMethod方法获取某个方法时，返回的结构体都是Method，我们先来看下这个结构体包含的内容：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> method_t *Method;<br><br><span class="hljs-comment">// OC实例方法或类方法结构体</span><br><span class="hljs-keyword">struct</span> method_t &#123;<br>    <span class="hljs-comment">// 方法名</span><br>    SEL name;<br>    <span class="hljs-comment">// 记录方法返回值和方法参数</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *types;<br>    <span class="hljs-comment">// 方法实现</span><br>    MethodListIMP imp;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>从上面的结构中我们看到一个方法的结构体中包含三个属性：方法名 name SEL 类型；types 方法编码方式包含该方法的返回值类型和参数类型；方法实现地址；</p>
<p>下面我们先从一个简单的例子来看下这三个值分别是什么样的，然后我们在进行深入的研究：</p>
<p>首先我们有一个方法，如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs objc">- (<span class="hljs-built_in">BOOL</span>)canSayHi:(<span class="hljs-built_in">NSString</span> *)name &#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;can say hi to %@&quot;</span>,name);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">YES</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>然后我们尝试获取这个方法的方法名，编码方式，以及方法实现：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs objc">- (<span class="hljs-keyword">void</span>)getMethodStructure &#123;<br>    Method method = class_getInstanceMethod([<span class="hljs-keyword">self</span> <span class="hljs-keyword">class</span>], <span class="hljs-keyword">@selector</span>(canSayHi:));<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;method sel %@&quot;</span>,<span class="hljs-built_in">NSStringFromSelector</span>(method_getName(method)));<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;method types %@&quot;</span>,[<span class="hljs-built_in">NSString</span> stringWithFormat:<span class="hljs-string">@&quot;%s&quot;</span>,method_getTypeEncoding(method)]);<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;method imp %p&quot;</span>,method_getImplementation(method));<br>&#125;<br></code></pre></td></tr></table></figure>

<p>然后我们看下打印结果：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-number">2020</span><span class="hljs-number">-10</span><span class="hljs-number">-31</span> <span class="hljs-number">17</span>:<span class="hljs-number">32</span>:<span class="hljs-number">26.711510</span>+<span class="hljs-number">0800</span> Runtime_MsgSend[<span class="hljs-number">24686</span>:<span class="hljs-number">737212</span>] method sel canSayHi:<br><span class="hljs-number">2020</span><span class="hljs-number">-10</span><span class="hljs-number">-31</span> <span class="hljs-number">17</span>:<span class="hljs-number">32</span>:<span class="hljs-number">26.711697</span>+<span class="hljs-number">0800</span> Runtime_MsgSend[<span class="hljs-number">24686</span>:<span class="hljs-number">737212</span>] method types B24@<span class="hljs-number">0</span>:<span class="hljs-number">8</span>@<span class="hljs-number">16</span><br><span class="hljs-number">2020</span><span class="hljs-number">-10</span><span class="hljs-number">-31</span> <span class="hljs-number">17</span>:<span class="hljs-number">32</span>:<span class="hljs-number">26.711830</span>+<span class="hljs-number">0800</span> Runtime_MsgSend[<span class="hljs-number">24686</span>:<span class="hljs-number">737212</span>] method imp <span class="hljs-number">0x100725c20</span><br></code></pre></td></tr></table></figure>

<p>打印结果非常清晰这个方法的方法名为<code>canSayHi:</code>，方法编码方式为<code>B24@0:8@16</code>,方法实现地址为<code>0x100725c20</code>。</p>
<p>下面我们来仔细看下这三个属性的意义：</p>
<h5 id="SEL"><a href="#SEL" class="headerlink" title="SEL"></a>SEL</h5><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">/// An opaque type that represents a method selector.</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> objc_selector *SEL;<br></code></pre></td></tr></table></figure>
<p>从定义我们可以看出SEL 实际上是一个<code>objc_selector</code>类型的结构体，但是这个结构体在Runtime中我们并没有找到定义。</p>
<p>我们先来看下官方文档给出的解释：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs objc">A selector is the name used to select a method to execute <span class="hljs-keyword">for</span> an object, or the <br>unique identifier that replaces the name when the source code is compiled. A <br>selector by itself doesn’t <span class="hljs-keyword">do</span> anything. It simply identifies a method. The only <br>thing that makes the selector method name different from a plain string is that<br> the compiler makes sure that selectors are unique. What makes a selector useful <br> is that (<span class="hljs-keyword">in</span> conjunction with the runtime) it acts like a dynamic function pointer <br> that, <span class="hljs-keyword">for</span> a given name, automatically points to the implementation of a method <br> appropriate <span class="hljs-keyword">for</span> whichever <span class="hljs-keyword">class</span> it’s used with. Suppose you had a selector <span class="hljs-keyword">for</span> <br> the method run, and classes Dog, Athlete, and ComputerSimulation (each of which <br> implemented a method run). The selector could be used with an instance of each of <br> the classes to invoke its run method—even though the implementation might be <br> different <span class="hljs-keyword">for</span> each.<br></code></pre></td></tr></table></figure>

<p>大概的意思是：selector表示某个对象的某个方法的名字，selector跟一个普通字符串的唯一区别是selector用来在编译时保证方法名的唯一。</p>
<p>因此在绝大多数情况下，我们可以直接把SEL当做一个字符串看待。下面我们来验证下：</p>
<p>在一个类中我们有同名(参数和返回值也相同)的类方法和对象方法</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs objc">- (<span class="hljs-built_in">BOOL</span>)canSayHi:(<span class="hljs-built_in">NSString</span> *)name &#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;can say hi to %@&quot;</span>,name);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">YES</span>;<br>&#125;<br><br>+ (<span class="hljs-built_in">BOOL</span>)canSayHi:(<span class="hljs-built_in">NSString</span> *)name &#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;can say hi to %@&quot;</span>,name);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">YES</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>下面我们来打印下这两个方法的实现：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs objc">- (<span class="hljs-keyword">void</span>)getMethodStructure &#123;<br>    Method method = class_getInstanceMethod([<span class="hljs-keyword">self</span> <span class="hljs-keyword">class</span>], <span class="hljs-keyword">@selector</span>(canSayHi:));<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;method sel %@&quot;</span>,<span class="hljs-built_in">NSStringFromSelector</span>(method_getName(method)));<br><br>    Method method1 = class_getClassMethod([<span class="hljs-keyword">self</span> <span class="hljs-keyword">class</span>], <span class="hljs-keyword">@selector</span>(canSayHi:));<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;method sel %@&quot;</span>,<span class="hljs-built_in">NSStringFromSelector</span>(method_getName(method1)));<br><br>    <span class="hljs-built_in">BOOL</span> isEqual = sel_isEqual(method_getName(method), method_getName(method1));<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;isEqual %@&quot;</span>,@(isEqual));<br>&#125;<br></code></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-number">2020</span><span class="hljs-number">-10</span><span class="hljs-number">-31</span> <span class="hljs-number">17</span>:<span class="hljs-number">54</span>:<span class="hljs-number">22.838428</span>+<span class="hljs-number">0800</span> Runtime_MsgSend[<span class="hljs-number">24985</span>:<span class="hljs-number">752267</span>] method sel canSayHi:<br><span class="hljs-number">2020</span><span class="hljs-number">-10</span><span class="hljs-number">-31</span> <span class="hljs-number">17</span>:<span class="hljs-number">54</span>:<span class="hljs-number">22.838743</span>+<span class="hljs-number">0800</span> Runtime_MsgSend[<span class="hljs-number">24985</span>:<span class="hljs-number">752267</span>] method sel canSayHi:<br><span class="hljs-number">2020</span><span class="hljs-number">-10</span><span class="hljs-number">-31</span> <span class="hljs-number">17</span>:<span class="hljs-number">54</span>:<span class="hljs-number">22.839079</span>+<span class="hljs-number">0800</span> Runtime_MsgSend[<span class="hljs-number">24985</span>:<span class="hljs-number">752267</span>] isEqual <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>
<p>首先我们通过打印发现这两个方法的方法名是相同的都是<code>canSayHi:</code>,但是鉴于我们上面看到在runtime中SEL的定义实际上是一个objc_selector结构体，因此我们还是使用sel_isEqual方法来判断这两个方法是否相等，从打印结果来看，显而易见两者是相等的。鉴于系统并未开放objc_selector结构体，我们大多数情况下将SEL看做方法名标识的字符串也是没问题的。</p>
<h5 id="types"><a href="#types" class="headerlink" title="types"></a>types</h5><p>方法的type实际上是个字符串，从上面的打印我们看到<code>canSayHi:</code>方法的值为<code>B24@0:8@16</code>这又该怎么解析呢？</p>
<p>实际苹果官方文档专门有针对这个字段的解释具体可以看<a target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html">这里</a></p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gk8otsc5unj30rs0h075z.jpg"></p>
<p>下面我们对<code>B24@0:8@16</code>进行拆解解析：</p>
<table>
<thead>
<tr>
<th>B</th>
<th>24</th>
<th>@</th>
<th>0</th>
<th>:</th>
<th>8</th>
<th>@</th>
<th>16</th>
</tr>
</thead>
<tbody><tr>
<td>返回值类型为bool</td>
<td>占用总空间为24字节</td>
<td>id(SEL)</td>
<td>从0开始存储</td>
<td>SEL</td>
<td>从第0位开始占8位空间</td>
<td>id(NSString)</td>
<td>从8位开始占16位空间</td>
</tr>
</tbody></table>
<p>这个位置研究的不是太明白，有比较了解的可以回复我，或者贴下文档地址，感激！！！</p>
<h5 id="MethodListIMP"><a href="#MethodListIMP" class="headerlink" title="MethodListIMP"></a>MethodListIMP</h5><p>我们来看下MethodListIMP的定义：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs objc">using MethodListIMP = IMP;<br></code></pre></td></tr></table></figure>
<p>IMP的定义如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">/// A pointer to the function of a method implementation. </span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> !OBJC_OLD_DISPATCH_PROTOTYPES</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">void</span> (*IMP)(<span class="hljs-keyword">void</span> <span class="hljs-comment">/* id, SEL, ... */</span> ); <br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">id</span> _Nullable (*IMP)(<span class="hljs-keyword">id</span> _Nonnull, SEL _Nonnull, ...); <br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br></code></pre></td></tr></table></figure>

<p>实际上MethodListIMP就是IMP。</p>
<p>而从我们上面打印的结果看IMP实际就是一个指针，指向方法实现的函数，IMP和SEL是一一对应的。</p>
<p>那是否意味着，我们拿到方法的地址之后可以直接调用这个方法？？？ 下面我们来验证下，当然为了方便我们先简单的定义一个没有参数也没有返回值的方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs objc">- (<span class="hljs-keyword">void</span>)test &#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;test&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>然后我们调用下面这个方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs objc">- (<span class="hljs-keyword">void</span>)exeIMP &#123;<br>    Method method = class_getInstanceMethod([<span class="hljs-keyword">self</span> <span class="hljs-keyword">class</span>], <span class="hljs-keyword">@selector</span>(test));<br>    IMP imp = method_getImplementation(method);<br>    imp();<br>&#125;<br></code></pre></td></tr></table></figure>
<p>我们看下结果：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-number">2020</span><span class="hljs-number">-10</span><span class="hljs-number">-31</span> <span class="hljs-number">18</span>:<span class="hljs-number">39</span>:<span class="hljs-number">18.334411</span>+<span class="hljs-number">0800</span> Runtime_MsgSend[<span class="hljs-number">25510</span>:<span class="hljs-number">782591</span>] test<br></code></pre></td></tr></table></figure>

<p>方法调用成功！</p>
<p>上述就是Method结构体的介绍，接下来我们来看下消息的调用流程。</p>
<h4 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h4><p>我们都知道方法调用的实现实际上是通过objc_msgSend方法，下面我们来看下这个方法：</p>
<h5 id="objc-msgSend"><a href="#objc-msgSend" class="headerlink" title="objc_msgSend"></a>objc_msgSend</h5><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">/** </span><br><span class="hljs-comment"> * Sends a message with a simple return value to an instance of a class.</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * @param self A pointer to the instance of the class that is to receive the message.</span><br><span class="hljs-comment"> * @param op The selector of the method that handles the message.</span><br><span class="hljs-comment"> * @param ... </span><br><span class="hljs-comment"> *   A variable argument list containing the arguments to the method.</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * @return The return value of the method.</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * @note When it encounters a method call, the compiler generates a call to one of the</span><br><span class="hljs-comment"> *  functions \c objc_msgSend, \c objc_msgSend_stret, \c objc_msgSendSuper, or \c objc_msgSendSuper_stret.</span><br><span class="hljs-comment"> *  Messages sent to an object’s superclass (using the \c super keyword) are sent using \c objc_msgSendSuper; </span><br><span class="hljs-comment"> *  other messages are sent using \c objc_msgSend. Methods that have data structures as return values</span><br><span class="hljs-comment"> *  are sent using \c objc_msgSendSuper_stret and \c objc_msgSend_stret.</span><br><span class="hljs-comment"> */</span><br>OBJC_EXPORT <span class="hljs-keyword">id</span> _Nullable<br>objc_msgSend(<span class="hljs-keyword">id</span> _Nullable <span class="hljs-keyword">self</span>, SEL _Nonnull op, ...)<br>    OBJC_AVAILABLE(<span class="hljs-number">10.0</span>, <span class="hljs-number">2.0</span>, <span class="hljs-number">9.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">2.0</span>);<br></code></pre></td></tr></table></figure>

<p>参数介绍：</p>
<table>
<thead>
<tr>
<th>self</th>
<th>op</th>
<th>…</th>
</tr>
</thead>
<tbody><tr>
<td>表示指向类的实例(类是元类的实例)的指针用来接收消息</td>
<td>SEL 类型 表示调用的方法的方法名</td>
<td>方法的参数</td>
</tr>
</tbody></table>
<p>注意：当这个方法被调用时，实际上编译器会调用<code>objc_msgSend</code>、<code>objc_msgSend_stret</code>、<code>objc_msgSendSuper</code>、<code>objc_msgSendSuper_stret</code>。当给对象的superclass发送消息时(使用super关键词)调用<code>objc_msgSendSuper</code>方法；当方法有返回值时调用的是<code>objc_msgSendSuper_stret</code>或者<code>objc_msgSend_stret</code></p>
<h5 id="objc-msgSendSuper"><a href="#objc-msgSendSuper" class="headerlink" title="objc_msgSendSuper"></a>objc_msgSendSuper</h5><p>我们来看下这个方法的实现：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">/** </span><br><span class="hljs-comment"> * Sends a message with a simple return value to the superclass of an instance of a class.</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * @param super A pointer to an \c objc_super data structure. Pass values identifying the</span><br><span class="hljs-comment"> *  context the message was sent to, including the instance of the class that is to receive the</span><br><span class="hljs-comment"> *  message and the superclass at which to start searching for the method implementation.</span><br><span class="hljs-comment"> * @param op A pointer of type SEL. Pass the selector of the method that will handle the message.</span><br><span class="hljs-comment"> * @param ...</span><br><span class="hljs-comment"> *   A variable argument list containing the arguments to the method.</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * @return The return value of the method identified by \e op.</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * @see objc_msgSend</span><br><span class="hljs-comment"> */</span><br>OBJC_EXPORT <span class="hljs-keyword">id</span> _Nullable<br>objc_msgSendSuper(<span class="hljs-keyword">struct</span> objc_super * _Nonnull <span class="hljs-keyword">super</span>, SEL _Nonnull op, ...)<br>    OBJC_AVAILABLE(<span class="hljs-number">10.0</span>, <span class="hljs-number">2.0</span>, <span class="hljs-number">9.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">2.0</span>);<br></code></pre></td></tr></table></figure>

<p>我们看到这个方法的第一个参数是objc_super类型，我们在进一步看下这个类型：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">/// Specifies the superclass of an instance. </span><br><span class="hljs-keyword">struct</span> objc_super &#123;<br>    <span class="hljs-comment">/// Specifies an instance of a class.</span><br>    __<span class="hljs-keyword">unsafe_unretained</span> _Nonnull <span class="hljs-keyword">id</span> receiver;<br><br>    <span class="hljs-comment">/// Specifies the particular superclass of the instance to message. </span><br>    __<span class="hljs-keyword">unsafe_unretained</span> _Nonnull Class super_class;<br>    <span class="hljs-comment">/* super_class is the first class to search */</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<p>结合上面对objc_msgSendSuper注释的理解，我们可以看出objc_super结构体中两个属性的含义：</p>
<ul>
<li>receiver: 调用super方法的子类，用于方法发送后消息的接收</li>
<li>super_class：子类 receiver的父类 方法查找会先从这个类开始</li>
</ul>
<h5 id="objc-msgSend-1"><a href="#objc-msgSend-1" class="headerlink" title="objc_msgSend"></a>objc_msgSend</h5><p>objc_msgSend方法的实现，在runtime中实际是用汇编语言实现的，下面我们来看下实现，顺便猜想实现原理：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs objc">	ENTRY _objc_msgSend<br>	<span class="hljs-comment">//cbz 比较（Compare），如果结果为零（Zero）就转移（只能跳到后面的指令）</span><br>    <span class="hljs-comment">//在汇编代码中 r0 表示函数的第一个参数，所以 r0 代表消息的接受者，</span><br>    <span class="hljs-comment">// 判断 r0 (消息接受者)是否为空，如果为空跳转到 标签 `LNilReceiver_f`</span><br>	cbz	r0, LNilReceiver_f<br>    <span class="hljs-comment">// 将 [r0] 的值加载到r9寄存器</span><br>	ldr	r9, [r0]		<span class="hljs-comment">// r9 = self-&gt;isa</span><br>    <span class="hljs-comment">// 调用GetClassFromIsa方法 根据isa获取到对应的类</span><br>	GetClassFromIsa			<span class="hljs-comment">// r9 = class</span><br>    <span class="hljs-comment">// 调用CacheLookup方法 查找方法缓存</span><br>	CacheLookup NORMAL<br>	<span class="hljs-comment">// cache hit, IMP in r12, eq already set for nonstret forwarding</span><br>    <span class="hljs-comment">// 如果缓存命中 IMP 放到r12中 调用imp方法</span><br>	bx	r12			<span class="hljs-comment">// call imp</span><br><br><br>    <span class="hljs-comment">// 没有找到缓存的方法</span><br>	CacheLookup2 NORMAL<br>	<span class="hljs-comment">// cache miss r0的内容加载到r9中</span><br>	ldr	r9, [r0]		<span class="hljs-comment">// r9 = self-&gt;isa</span><br>    <span class="hljs-comment">// 调用GetClassFromIsa方法 根据isa获取到对应的类</span><br>	GetClassFromIsa			<span class="hljs-comment">// r9 = class</span><br>    <span class="hljs-comment">// b 跳转指令，可带条件跳转与cmp配合使用</span><br>    <span class="hljs-comment">// 跳转去执行 __objc_msgSend_uncached 既然没有找到方法,就去从类,父类,元类中查找</span><br>	b	__objc_msgSend_uncached<br><br>LNilReceiver:<br>	<span class="hljs-comment">// r0 is already zero</span><br>    <span class="hljs-comment">// 消息接受者为空 表示r0为空</span><br>	mov	r1, #<span class="hljs-number">0</span><br>	mov	r2, #<span class="hljs-number">0</span><br>	mov	r3, #<span class="hljs-number">0</span><br>    <span class="hljs-comment">// return 0</span><br>	FP_RETURN_ZERO<br>    <span class="hljs-comment">// 直接调用lr方法</span><br>	bx	lr	<br><br>	END_ENTRY _objc_msgSend<br></code></pre></td></tr></table></figure>

<p>从上面的调用流程中我们看到，首先会判断这条消息的接收者是否为nil,如果为nil直接调用LNilReceiver_f方法，如果不为nil，先根据isa获取到对应的类，然后在方法调用的缓存中查找是否有缓存如果有直接调用，如果没有则去调用__objc_msgSend_uncached方法。</p>
<p>下面我们在来看下这个方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs objc">STATIC_ENTRY __objc_msgSend_uncached<br><br>	<span class="hljs-comment">// THIS IS NOT A CALLABLE C FUNCTION</span><br>	<span class="hljs-comment">// Out-of-band r9 is the class to search</span><br>	<br>	MethodTableLookup NORMAL	<span class="hljs-comment">// returns IMP in r12</span><br>	<br>	bx	r12<br><br>	END_ENTRY __objc_msgSend_uncached<br></code></pre></td></tr></table></figure>
<p>从上图我们看出__objc_msgSend_uncached方法主要是调用了MethodTableLookup方法，而在这个方法中，主要又是调用了_class_lookupMethodAndLoadCache3方法，那么我们来看下这个方法的实现：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">// 查找IMP</span><br>IMP _class_lookupMethodAndLoadCache3(<span class="hljs-keyword">id</span> obj, SEL sel, Class cls)<br>&#123;<br>    <span class="hljs-keyword">return</span> lookUpImpOrForward(cls, sel, obj, <br>                              <span class="hljs-literal">YES</span><span class="hljs-comment">/*initialize*/</span>, <span class="hljs-literal">NO</span><span class="hljs-comment">/*cache*/</span>, <span class="hljs-literal">YES</span><span class="hljs-comment">/*resolver*/</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>实际上就是调用了lookUpImpOrForward，对于这个方法我们就比较熟悉了。</p>
<h6 id="lookUpImpOrForward"><a href="#lookUpImpOrForward" class="headerlink" title="lookUpImpOrForward"></a>lookUpImpOrForward</h6><p>我们先来看下这个方法的实现：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">// 当方法调用的缓存中找不到对应的方法时就会调用这个方法</span><br><span class="hljs-comment">// cls 消息的接受者</span><br><span class="hljs-comment">// sel 要调用的方法</span><br><span class="hljs-comment">// initialize 是否已经初始化</span><br><span class="hljs-comment">// cache 是否需要查找缓存 但是只是在当前类使用 在父类统一都会先查找缓存在查找方法列表</span><br><span class="hljs-comment">// resolver 是否需要动态解析</span><br>IMP lookUpImpOrForward(Class cls, SEL sel, <span class="hljs-keyword">id</span> inst, <br>                       <span class="hljs-keyword">bool</span> initialize, <span class="hljs-keyword">bool</span> cache, <span class="hljs-keyword">bool</span> resolver)<br>&#123;<br>    IMP imp = <span class="hljs-literal">nil</span>;<br>    <span class="hljs-keyword">bool</span> triedResolver = <span class="hljs-literal">NO</span>;<br><br>    runtimeLock.assertUnlocked();<br><br>    <span class="hljs-comment">// Optimistic cache lookup</span><br>    <span class="hljs-comment">// 如果在缓存中找到对应的方法 则直接返回</span><br>    <span class="hljs-keyword">if</span> (cache) &#123; <span class="hljs-comment">//从汇编过来是NO</span><br>        imp = cache_getImp(cls, sel);<br>        <span class="hljs-keyword">if</span> (imp) <span class="hljs-keyword">return</span> imp;<br>    &#125;<br><br>    runtimeLock.lock();<br>	<span class="hljs-comment">//检查是否是已知的 项目的所有类都是从镜像加载出来的 这里是在镜像加载出的类中查找 如果不是则返回false</span><br>    <span class="hljs-comment">// 但是这里并没有使用返回值</span><br>    checkIsKnownClass(cls);<br><br>    <span class="hljs-comment">// 这个类的内容还没有被加载 会通过镜像加载这个类先关的内容 比如 属性 方法列表</span><br>    <span class="hljs-keyword">if</span> (!cls-&gt;isRealized()) &#123;<br>        realizeClass(cls);<br>    &#125;<br>    <span class="hljs-comment">// 如果类需要被initialize但是目前还没有初始化</span><br>    <span class="hljs-keyword">if</span> (initialize  &amp;&amp;  !cls-&gt;isInitialized()) &#123;<br>		<span class="hljs-comment">//当cls需要初始化和没有初始化的时候 进行cls初始化，</span><br>		<span class="hljs-comment">//初始化会加入到一个线程，同步执行，先初始化父类，再初始化子类</span><br>		<span class="hljs-comment">//数据的大小最小是4，扩容规则是：n*2+1;</span><br>        runtimeLock.unlock();<br>        _class_initialize (_class_getNonMetaClass(cls, inst));<br>        runtimeLock.lock();<br>    &#125;<br><br>    <br> retry:    <br>    runtimeLock.assertLocked();<br><br>    <span class="hljs-comment">//再次获取imp</span><br>    imp = cache_getImp(cls, sel);<br>    <span class="hljs-keyword">if</span> (imp) <span class="hljs-keyword">goto</span> done;<br><br>    <span class="hljs-comment">// Try this class&#x27;s method lists.</span><br>    <span class="hljs-comment">//在本类中查找method</span><br>    &#123;<span class="hljs-comment">//从cls-&gt;data()-&gt;methods查找method</span><br>        Method meth = getMethodNoSuper_nolock(cls, sel);<br>        <span class="hljs-keyword">if</span> (meth) &#123;<span class="hljs-comment">//找到添加到cache中</span><br>            log_and_fill_cache(cls, meth-&gt;imp, sel, inst, cls);<br>            imp = meth-&gt;imp;<br>            <span class="hljs-keyword">goto</span> done;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// Try superclass caches and method lists.</span><br>	<span class="hljs-comment">//从cls-&gt;superclass-&gt;data()-&gt;methods查找methd，supercls没有查找出来，再查找父类的父类。</span><br>    &#123;<br>        <span class="hljs-keyword">unsigned</span> attempts = unreasonableClassCount();<br>        <span class="hljs-comment">// 递归查找父类 直到父类为nil</span><br>        <span class="hljs-keyword">for</span> (Class curClass = cls-&gt;superclass;<br>             curClass != <span class="hljs-literal">nil</span>;<br>             curClass = curClass-&gt;superclass)<br>        &#123;<br>            <span class="hljs-comment">// Halt if there is a cycle in the superclass chain.</span><br>            <span class="hljs-keyword">if</span> (--attempts == <span class="hljs-number">0</span>) &#123;<br>                _objc_fatal(<span class="hljs-string">&quot;Memory corruption in class list.&quot;</span>);<br>            &#125;<br>            <br>            <span class="hljs-comment">// Superclass cache.</span><br>            imp = cache_getImp(curClass, sel);<br>            <span class="hljs-keyword">if</span> (imp) &#123;<br>                <span class="hljs-keyword">if</span> (imp != (IMP)_objc_msgForward_impcache) &#123;<br>                    <span class="hljs-comment">// Found the method in a superclass. Cache it in this class.</span><br>					<span class="hljs-comment">//将父类添加到 子类的缓存中</span><br>                    log_and_fill_cache(cls, imp, sel, inst, curClass);<br>                    <span class="hljs-keyword">goto</span> done;<br>                &#125;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// Found a forward:: entry in a superclass.</span><br>                    <span class="hljs-comment">// Stop searching, but don&#x27;t cache yet; call method </span><br>                    <span class="hljs-comment">// resolver for this class first.</span><br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>            <br>            <span class="hljs-comment">// Superclass method list.</span><br>            Method meth = getMethodNoSuper_nolock(curClass, sel);<br>            <span class="hljs-keyword">if</span> (meth) &#123;<br>                log_and_fill_cache(cls, meth-&gt;imp, sel, inst, curClass);<br>                imp = meth-&gt;imp;<br>                <span class="hljs-keyword">goto</span> done;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// No implementation found. Try method resolver once.</span><br>	<span class="hljs-comment">//如果都没找到 动态方法解析阶段</span><br><br>    <span class="hljs-keyword">if</span> (resolver  &amp;&amp;  !triedResolver) &#123;<br>        runtimeLock.unlock();<br>        _class_resolveMethod(cls, sel, inst);<br>        runtimeLock.lock();<br>        <span class="hljs-comment">// Don&#x27;t cache the result; we don&#x27;t hold the lock so it may have </span><br>        <span class="hljs-comment">// changed already. Re-do the search from scratch instead.</span><br>        triedResolver = <span class="hljs-literal">YES</span>;<br>        <span class="hljs-keyword">goto</span> retry;<br>    &#125;<br><br>    <span class="hljs-comment">//如果没找到resolveInstanceMethod 和resolveClassMethod，</span><br><span class="hljs-comment">//	进行消息转发 阶段</span><br>    imp = (IMP)_objc_msgForward_impcache;<br>	<span class="hljs-comment">//填充 cache</span><br>    cache_fill(cls, sel, imp, inst);<br><br> done:<br>    runtimeLock.unlock();<br><br>    <span class="hljs-keyword">return</span> imp;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这个方法的实现比较长，下面我们从下图中来看下整个流程：</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gk9sd6lnxrj31100u0atm.jpg"></p>
<p>下面我们来看下lookUpImpOrForward方法执行内部的几个条件和关键方法</p>
<h6 id="checkIsKnownClass"><a href="#checkIsKnownClass" class="headerlink" title="checkIsKnownClass"></a>checkIsKnownClass</h6><p>我们来看下这个方法的实现,在这个方法的实现中主要是调用了isKnownClass方法，我们直接看这个方法的实现：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">// 判断一个类是否为已知类</span><br><span class="hljs-comment">// 在共享cache或者加载镜像的数据段或者通过obj_allocateClassPair方法创建的类</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> isKnownClass(Class cls) &#123;<br>    <span class="hljs-comment">// 查找的顺序是先查找共享缓存，然后是通过obj_allocateClassPair创建的类，最后才是从MACH-O的数据段进行查找</span><br>    <span class="hljs-keyword">return</span> (sharedRegionContains(cls) ||<br>            NXHashMember(allocatedClasses, cls) ||<br>            dataSegmentsContain(cls));<br>&#125;<br></code></pre></td></tr></table></figure>

<p>什么情况下会出现非已知的类呢？<br>当我们使用NSStringFromClass()方法创建一个类时，如果这个类的名字写错了这里就检测为一个未知类。</p>
<h6 id="realizeClass"><a href="#realizeClass" class="headerlink" title="realizeClass"></a>realizeClass</h6><p>递归初始化类(父类)的结构，对类的第一次初始化，包括配置类的读写空间（class_rw_t）并且返回类的正确的结构体，就相当于搭好了这个类的框架这里主要是为了后续可以从类的方法列表中查找方法。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">static</span> Class realizeClass(Class cls)<br>&#123;<br>    runtimeLock.assertLocked();<br><br>    <span class="hljs-keyword">if</span> (!cls) <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>;<br>    <span class="hljs-keyword">if</span> (cls-&gt;isRealized()) <span class="hljs-keyword">return</span> cls;<br>    assert(cls == remapClass(cls));<br><br>    <span class="hljs-comment">// fixme verify class is not in an un-dlopened part of the shared cache?</span><br>    <span class="hljs-comment">//首先将rw赋值给ro，因为数据结构一样可以直接强制转化</span><br>    ro = (<span class="hljs-keyword">const</span> class_ro_t *)cls-&gt;data();<br>    <span class="hljs-keyword">if</span> (ro-&gt;flags &amp; RO_FUTURE) &#123;<span class="hljs-comment">//是否已经初始化过，初始化过的哈 则 cls-&gt;rw 已经初始化过</span><br>        rw = cls-&gt;data();<br>        ro = cls-&gt;data()-&gt;ro;<br>        cls-&gt;changeInfo(RW_REALIZED|RW_REALIZING, RW_FUTURE);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 正常情况下 申请class_rw_t空间</span><br>        rw = (class_rw_t *)calloc(<span class="hljs-keyword">sizeof</span>(class_rw_t), <span class="hljs-number">1</span>);<br>        rw-&gt;ro = ro;<span class="hljs-comment">//cls-&gt;rw-&gt;ro 指向现在的ro</span><br>        rw-&gt;flags = RW_REALIZED|RW_REALIZING;<span class="hljs-comment">//realized = 1 and  realizing = 1</span><br>        cls-&gt;setData(rw);<span class="hljs-comment">//赋值</span><br>    &#125;<br><br>    isMeta = ro-&gt;flags &amp; RO_META;<span class="hljs-comment">//是否是元类</span><br><br>    rw-&gt;version = isMeta ? <span class="hljs-number">7</span> : <span class="hljs-number">0</span>;  <span class="hljs-comment">// 元类版本是7，旧版的6，否就是0</span><br><br>    <span class="hljs-comment">// Choose an index for this class.</span><br><span class="hljs-comment">//设置cls的索引</span><br>	cls-&gt;chooseClassArrayIndex();<br><br>    <span class="hljs-comment">// 如果父类没有初始化则进行初始化</span><br>    <span class="hljs-comment">// root_class 做完需要设置RW_REALIZED=1，</span><br>    <span class="hljs-comment">// root metaclasses 需要执行完.</span><br>	<span class="hljs-comment">//从NXMapTable 获取cls ，然后进行初始化</span><br>	<span class="hljs-comment">//从NXMapTable 获取cls-&gt;isa ，然后进行初始化</span><br>    supercls = realizeClass(remapClass(cls-&gt;superclass));<br>    metacls = realizeClass(remapClass(cls-&gt;ISA()));<br><br>    <span class="hljs-comment">// Update superclass and metaclass in case of remapping</span><br>    cls-&gt;superclass = supercls;<br>    cls-&gt;initClassIsa(metacls);<br><br>	<span class="hljs-comment">// 协调实例变量偏移/布局</span><br>	<span class="hljs-comment">//可能重新申请空间 class_ro_t,更新我们的class_ro_t</span><br>    <span class="hljs-keyword">if</span> (supercls  &amp;&amp;  !isMeta) reconcileInstanceVariables(cls, supercls, ro);<br><br>    <span class="hljs-comment">// 设置setInstanceSize 从ro-&gt;instanceSize</span><br>    cls-&gt;setInstanceSize(ro-&gt;instanceSize);<br><br>	<span class="hljs-comment">//拷贝flags 从ro到rw中</span><br>    <span class="hljs-keyword">if</span> (ro-&gt;flags &amp; RO_HAS_CXX_STRUCTORS) &#123;<br>        cls-&gt;setHasCxxDtor();<br>        <span class="hljs-keyword">if</span> (! (ro-&gt;flags &amp; RO_HAS_CXX_DTOR_ONLY)) &#123;<br>            cls-&gt;setHasCxxCtor();<br>        &#125;<br>    &#125;<br><span class="hljs-comment">//添加superclass指针</span><br>    <span class="hljs-keyword">if</span> (supercls) &#123;<br>        addSubclass(supercls, cls);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        addRootClass(cls);<br>    &#125;<br><br>    <span class="hljs-comment">// Attach categories</span><br>	<span class="hljs-comment">//类别的方法 在编译的时候没有添加到二进制文件中，在运行的时候添加进去的</span><br>    methodizeClass(cls);<br><br>    <span class="hljs-keyword">return</span> cls;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这个方法主要操作是：</p>
<ul>
<li>将class-&gt;data指向的数据强制转化为class_ro_t结构体，因为编译期间class-&gt;data指向的就是class_ro_t结构体，所以这一步的转化是没有问题的</li>
<li>生成一个class_rw_t结构体</li>
<li>将class_rw_t的ro指针指向上一步转化出的class_ro_t结构体</li>
<li>设置class_rw_t的flags值</li>
<li>设置class-&gt;data指向class_rw_t结构体</li>
<li>调用methodizeClass函数</li>
</ul>
<p>因为这里不是我们本次介绍的主角，所以我们不在进一步的详细介绍。</p>
<h6 id="class-initialize"><a href="#class-initialize" class="headerlink" title="_class_initialize"></a>_class_initialize</h6><p>上一步在realizeClass中我们完成了类的初始化，_class_initialize这个方法主要是调用我们OC中的+ (void)initialize方法，在_class_initialize中主要是调用了callInitialize方法，我们看下这个方法的实现</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">// 调用类中的+ (void)initialize方法</span><br><span class="hljs-keyword">void</span> callInitialize(Class cls)<br>&#123;<br>    ((<span class="hljs-keyword">void</span>(*)(Class, SEL))objc_msgSend)(cls, SEL_initialize);<br>    <span class="hljs-keyword">asm</span>(<span class="hljs-string">&quot;&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>而调用规则</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">void</span> _class_initialize(Class cls) &#123;<br>    supercls = cls-&gt;superclass;<br>    <span class="hljs-keyword">if</span> (supercls  &amp;&amp;  !supercls-&gt;isInitialized()) &#123;<br>        _class_initialize(supercls);<br>    &#125;<br>    <span class="hljs-comment">// 调用+initialize方法</span><br>    callInitialize(cls);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>从上面的调用顺序上我们可以看出类的+initialize方法的调用顺序是先调用父类在调用子类。且子类不会覆盖父类。如果子类没有实现这个方法那么会调用父类的方法，也就是说父类的方法会调用多次。</p>
<h6 id="getMethodNoSuper-nolock"><a href="#getMethodNoSuper-nolock" class="headerlink" title="getMethodNoSuper_nolock"></a>getMethodNoSuper_nolock</h6><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">// 在类的方法列表中查找对应的方法实现</span><br><span class="hljs-keyword">static</span> method_t *<br>getMethodNoSuper_nolock(Class cls, SEL sel)<br>&#123;<br>    runtimeLock.assertLocked();<br><br>    assert(cls-&gt;isRealized());<br>    <span class="hljs-comment">// fixme nil cls? </span><br>    <span class="hljs-comment">// fixme nil sel?</span><br><br>    <span class="hljs-comment">// 方法列表的遍历</span><br>    <span class="hljs-keyword">for</span> (auto mlists = cls-&gt;data()-&gt;methods.beginLists(),<br>              end = cls-&gt;data()-&gt;methods.endLists(); <br>         mlists != end;<br>         ++mlists)<br>    &#123;<br>        <span class="hljs-comment">// 在mlists中查找sel</span><br>        method_t *m = search_method_list(*mlists, sel);<br>        <span class="hljs-keyword">if</span> (m) <span class="hljs-keyword">return</span> m;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>;<br>&#125;<br></code></pre></td></tr></table></figure>


<h6 id="log-and-fill-cache和cache-getImp"><a href="#log-and-fill-cache和cache-getImp" class="headerlink" title="log_and_fill_cache和cache_getImp"></a>log_and_fill_cache和cache_getImp</h6><p>cache_getImp的实现在Runtime中并未找到实现，不过我们可以从log_and_fill_cache的实现反推cache_getImp的实现，所以我们先看下log_and_fill_cache的实现</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">// 方法缓存</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> cache_fill_nolock(Class cls, SEL sel, IMP imp, <span class="hljs-keyword">id</span> receiver)<br>&#123;<br>    cacheUpdateLock.assertLocked();<br><br>    <span class="hljs-comment">// 获取到类对应的缓存</span><br>    cache_t *cache = getCache(cls);<br>    <span class="hljs-comment">// 从类对应的缓存中找到方法缓存的key</span><br>    cache_key_t key = getKey(sel);<br><br>    <span class="hljs-comment">// 在cache中根据key和receiver查找bucket</span><br>    bucket_t *bucket = cache-&gt;find(key, receiver);<br>    <span class="hljs-comment">// 如果key==0 k++</span><br>    <span class="hljs-keyword">if</span> (bucket-&gt;key() == <span class="hljs-number">0</span>) cache-&gt;incrementOccupied();<br>    <span class="hljs-comment">// 存储缓存</span><br>    bucket-&gt;set(key, imp);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>从上面的代码中我们可以看出，我们可以通过类名获取到类对应的方法缓存cache，然后根据方法名获取到缓存的cache的key,然后根据key和receiver获取到对应缓存的bucket，然后将要缓存方法添加到缓存中，这里我们注意bucket是通过key和receiver获取而不是cls。所以这里我们添加的缓存是子类的缓存中。</p>
<p>下面我们来看下bucket_t的结构:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">struct</span> bucket_t &#123;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> __arm64__</span><br>    MethodCacheIMP _imp;<br>    cache_key_t _key;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><br>    <span class="hljs-comment">// unsigned long 的指针，其实是一个被 hash 化的一串数值，就是方法的 sel</span><br>    cache_key_t _key;<br>    <span class="hljs-comment">// 保存着对应的函数地址</span><br>    MethodCacheIMP _imp;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="class-resolveMethod"><a href="#class-resolveMethod" class="headerlink" title="_class_resolveMethod"></a>_class_resolveMethod</h5><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">// 动态解析方法</span><br><span class="hljs-keyword">void</span> _class_resolveMethod(Class cls, SEL sel, <span class="hljs-keyword">id</span> inst)<br>&#123;<br>    <span class="hljs-comment">// 不是元类 则调用动态解析实例方法</span><br>    <span class="hljs-keyword">if</span> (! cls-&gt;isMetaClass()) &#123;<br>        <span class="hljs-comment">//首先调用</span><br>		_class_resolveInstanceMethod(cls, sel, inst);<br>    &#125; <br>    <span class="hljs-keyword">else</span> &#123;<br>		<span class="hljs-comment">//如果是元类 则应该动态解析类方法</span><br>        _class_resolveClassMethod(cls, sel, inst);<br>        <span class="hljs-comment">// 查找这个类的方法列表中是否有这个方法对应的IMP</span><br>        <span class="hljs-keyword">if</span> (!lookUpImpOrNil(cls, sel, inst, <br>                            <span class="hljs-literal">NO</span><span class="hljs-comment">/*initialize*/</span>, <span class="hljs-literal">YES</span><span class="hljs-comment">/*cache*/</span>, <span class="hljs-literal">NO</span><span class="hljs-comment">/*resolver*/</span>)) <br>        &#123;<br>            <span class="hljs-comment">// 如果方法列表中没有找到IMP 则调用_class_resolveInstanceMethod方法？？？？？ 为什么</span><br>            _class_resolveInstanceMethod(cls, sel, inst);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>看完了上面的方法，我们有个疑问：为什么在元类的情况下，在调用了_class_resolveClassMethod方法后，我们仍然要判断lookUpImpOrNil如果没有找到方法则调用_class_resolveInstanceMethod？？？</p>
<p>下面我们来先看下_class_resolveClassMethod方法</p>
<h6 id="class-resolveClassMethod"><a href="#class-resolveClassMethod" class="headerlink" title="_class_resolveClassMethod"></a>_class_resolveClassMethod</h6><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">// 动态解析类方法</span><br><span class="hljs-comment">// 调用_class_resolveClassMethod 查找一个要被添加到cls的方法</span><br><span class="hljs-comment">// cls 应该是元类</span><br><span class="hljs-comment">// 如果方法已经存在了就不需要检查了</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> _class_resolveClassMethod(Class cls, SEL sel, <span class="hljs-keyword">id</span> inst)<br>&#123;<br>    assert(cls-&gt;isMetaClass());<br><br>    <span class="hljs-comment">// 先判断resolveClassMethod方法是否实现 如果没实现则直接return</span><br>    <span class="hljs-keyword">if</span> (! lookUpImpOrNil(cls, SEL_resolveClassMethod, inst, <br>                         <span class="hljs-literal">NO</span><span class="hljs-comment">/*initialize*/</span>, <span class="hljs-literal">YES</span><span class="hljs-comment">/*cache*/</span>, <span class="hljs-literal">NO</span><span class="hljs-comment">/*resolver*/</span>)) <br>    &#123;<br>        <span class="hljs-comment">// Resolver not implemented.</span><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// resolveClassMethod在cls中实现了</span><br>    <span class="hljs-built_in">BOOL</span> (*msg)(Class, SEL, SEL) = (<span class="hljs-keyword">typeof</span>(msg))objc_msgSend;<br>    <span class="hljs-comment">// 调用_class_getNonMetaClass(cls, inst)的SEL_resolveClassMethod方法参数为SEL</span><br>    <span class="hljs-keyword">bool</span> resolved = msg(_class_getNonMetaClass(cls, inst), <br>                        SEL_resolveClassMethod, sel);<br><br>    <span class="hljs-comment">// Cache the result (good or bad) so the resolver doesn&#x27;t fire next time.</span><br>    <span class="hljs-comment">// +resolveClassMethod adds to self-&gt;ISA() a.k.a. cls</span><br>    <span class="hljs-comment">// 在cls类中再次查找sel是否实现</span><br>    IMP imp = lookUpImpOrNil(cls, sel, inst, <br>                             <span class="hljs-literal">NO</span><span class="hljs-comment">/*initialize*/</span>, <span class="hljs-literal">YES</span><span class="hljs-comment">/*cache*/</span>, <span class="hljs-literal">NO</span><span class="hljs-comment">/*resolver*/</span>);<br><br>    <span class="hljs-keyword">if</span> (resolved  &amp;&amp;  PrintResolving) &#123;<br>        <span class="hljs-keyword">if</span> (imp) &#123;<br>            _objc_inform(<span class="hljs-string">&quot;RESOLVE: method %c[%s %s] &quot;</span><br>                         <span class="hljs-string">&quot;dynamically resolved to %p&quot;</span>, <br>                         cls-&gt;isMetaClass() ? <span class="hljs-string">&#x27;+&#x27;</span> : <span class="hljs-string">&#x27;-&#x27;</span>, <br>                         cls-&gt;nameForLogging(), sel_getName(sel), imp);<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// Method resolver didn&#x27;t add anything?</span><br>            _objc_inform(<span class="hljs-string">&quot;RESOLVE: +[%s resolveClassMethod:%s] returned YES&quot;</span><br>                         <span class="hljs-string">&quot;, but no new implementation of %c[%s %s] was found&quot;</span>,<br>                         cls-&gt;nameForLogging(), sel_getName(sel), <br>                         cls-&gt;isMetaClass() ? <span class="hljs-string">&#x27;+&#x27;</span> : <span class="hljs-string">&#x27;-&#x27;</span>, <br>                         cls-&gt;nameForLogging(), sel_getName(sel));<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>从上面的代码我们可以看出_class_resolveClassMethod方法首先是查找SEL_resolveClassMethod在cls中是否有实现IMP，如果没有那么我们也不需要进行动态解析 直接返回。如果实现了，那么调用SEL_resolveClassMethod这个方法根据这个方法的返回值判断这个方法是否需要动态解析。然后我们在根据方法名在cls中查找对应的IMP，这里获取到IMP后纯粹是为了打日志。</p>
<p>下面我们看下lookUpImpOrNil这个方法</p>
<h6 id="lookUpImpOrNil"><a href="#lookUpImpOrNil" class="headerlink" title="lookUpImpOrNil"></a>lookUpImpOrNil</h6><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">// 与lookUpImpOrForward方法类似 但是如果imp是_objc_msgForward_impcache时返回nil</span><br>IMP lookUpImpOrNil(Class cls, SEL sel, <span class="hljs-keyword">id</span> inst, <br>                   <span class="hljs-keyword">bool</span> initialize, <span class="hljs-keyword">bool</span> cache, <span class="hljs-keyword">bool</span> resolver)<br>&#123;<br>    <span class="hljs-comment">// 获取cls中sel方法的实现IMP 如果没有找到返回_objc_msgForward_impcache 表示需要转发</span><br>    IMP imp = lookUpImpOrForward(cls, sel, inst, initialize, cache, resolver);<br>    <span class="hljs-comment">// 如果需要转发那么返回nil</span><br>    <span class="hljs-keyword">if</span> (imp == _objc_msgForward_impcache) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>;<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> imp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>实际上lookUpImpOrNil方法是对lookUpImpOrForward进行了一次包装，当找不到对应方法时直接返回nil而不是_objc_msgForward_impcache。</p>
<p>从上面实现我们看出实际上在_class_resolveClassMethod方法中我们并没有做什么时机操作，只是判断了cls中的SEL_resolveClassMethod方法是否实现，如果实现了那么返回的是true还是false。</p>
<p>那么接下来我们继续看下动态解析类方法后面做了什么？</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">// 查找这个类的方法列表中是否有这个方法对应的IMP</span><br>        <span class="hljs-keyword">if</span> (!lookUpImpOrNil(cls, sel, inst, <br>                            <span class="hljs-literal">NO</span><span class="hljs-comment">/*initialize*/</span>, <span class="hljs-literal">YES</span><span class="hljs-comment">/*cache*/</span>, <span class="hljs-literal">NO</span><span class="hljs-comment">/*resolver*/</span>)) <br>        &#123;<br>            <span class="hljs-comment">// 如果方法列表中没有找到IMP 则调用_class_resolveInstanceMethod方法？？？？？ 为什么</span><br>            _class_resolveInstanceMethod(cls, sel, inst);<br>        &#125;<br></code></pre></td></tr></table></figure>

<p>我们看到这里判断 如果当前类没有动态解析这个方法那么我们直接调用_class_resolveInstanceMethod方法。</p>
<p>那么我们先看下_class_resolveInstanceMethod这个方法里到底做了什么，然后再去思考上面提出的问题。</p>
<p>####### _class_resolveInstanceMethod</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> _class_resolveInstanceMethod(Class cls, SEL sel, <span class="hljs-keyword">id</span> inst)<br>&#123;<br>    <span class="hljs-keyword">if</span> (! lookUpImpOrNil(cls-&gt;ISA(), SEL_resolveInstanceMethod, cls, <br>                         <span class="hljs-literal">NO</span><span class="hljs-comment">/*initialize*/</span>, <span class="hljs-literal">YES</span><span class="hljs-comment">/*cache*/</span>, <span class="hljs-literal">NO</span><span class="hljs-comment">/*resolver*/</span>)) <br>    &#123;<br>        <span class="hljs-comment">// Resolver not implemented.</span><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><span class="hljs-comment">//如果找到SEL_resolveInstanceMethod 则使用objc_msgSend函数</span><br>    <span class="hljs-built_in">BOOL</span> (*msg)(Class, SEL, SEL) = (<span class="hljs-keyword">typeof</span>(msg))objc_msgSend;<br>    <span class="hljs-keyword">bool</span> resolved = msg(cls, SEL_resolveInstanceMethod, sel);<br><br>    <span class="hljs-comment">// Cache the result (good or bad) so the resolver doesn&#x27;t fire next time.</span><br>    <span class="hljs-comment">// +resolveInstanceMethod adds to self a.k.a. cls</span><br>    IMP imp = lookUpImpOrNil(cls, sel, inst, <br>                             <span class="hljs-literal">NO</span><span class="hljs-comment">/*initialize*/</span>, <span class="hljs-literal">YES</span><span class="hljs-comment">/*cache*/</span>, <span class="hljs-literal">NO</span><span class="hljs-comment">/*resolver*/</span>);<br><br>    <span class="hljs-keyword">if</span> (resolved  &amp;&amp;  PrintResolving) &#123;<br>        <span class="hljs-keyword">if</span> (imp) &#123;<br>            _objc_inform(<span class="hljs-string">&quot;RESOLVE: method %c[%s %s] &quot;</span><br>                         <span class="hljs-string">&quot;dynamically resolved to %p&quot;</span>, <br>                         cls-&gt;isMetaClass() ? <span class="hljs-string">&#x27;+&#x27;</span> : <span class="hljs-string">&#x27;-&#x27;</span>, <br>                         cls-&gt;nameForLogging(), sel_getName(sel), imp);<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// Method resolver didn&#x27;t add anything?</span><br>            _objc_inform(<span class="hljs-string">&quot;RESOLVE: +[%s resolveInstanceMethod:%s] returned YES&quot;</span><br>                         <span class="hljs-string">&quot;, but no new implementation of %c[%s %s] was found&quot;</span>,<br>                         cls-&gt;nameForLogging(), sel_getName(sel), <br>                         cls-&gt;isMetaClass() ? <span class="hljs-string">&#x27;+&#x27;</span> : <span class="hljs-string">&#x27;-&#x27;</span>, <br>                         cls-&gt;nameForLogging(), sel_getName(sel));<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>实际上_class_resolveInstanceMethod方法和_class_resolveClassMethod的实现基本一致，只不过将SEL_resolveClassMethod改成了SEL_resolveInstanceMethod。</p>
<p>但是实际上在_class_resolveInstanceMethod和_class_resolveClassMethod方法中我们并没有做什么事情，只是调用了SEL_resolveClassMethod和SEL_resolveInstanceMethod这两个方法。 然后重新走了一次lookUpImpOrForward方法。因此这相当于给我们一次机会让我们在SEL_resolveClassMethod或者SEL_resolveInstanceMethod方法中给方法添加一个默认实现。</p>
<p>比如下面的代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs objc">+ (<span class="hljs-built_in">BOOL</span>)resolveInstanceMethod:(SEL)sel &#123;<br>    <span class="hljs-keyword">if</span> (sel == <span class="hljs-keyword">@selector</span>(resolveThisMethodDynamically)) &#123;<br>          class_addMethod([<span class="hljs-keyword">self</span> <span class="hljs-keyword">class</span>], sel, (IMP) dynamicMethodIMP, <span class="hljs-string">&quot;v@:&quot;</span>);<br>          <span class="hljs-keyword">return</span> <span class="hljs-literal">YES</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> [<span class="hljs-keyword">super</span> resolveInstanceMethod:sel];<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这样我们再次调用lookUpImpOrForward方法是就可以查找到对应的方法和实现IMP了。</p>
<p>但是如果我们并没有实现resolveInstanceMethod这个方法那么接下来就走到了方法转发的流程。我们看到在lookUpImpOrForward方法的最后 如果没有做动态解析，那么我们就会走到下面这段代码中</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">//如果没找到resolveInstanceMethod 和resolveClassMethod，</span><br><span class="hljs-comment">//	进行消息转发 阶段</span><br>    imp = (IMP)_objc_msgForward_impcache;<br>	<span class="hljs-comment">//填充 cache</span><br>    cache_fill(cls, sel, imp, inst);<br></code></pre></td></tr></table></figure>
<p>我们看到 直接返回了一个固定的IMP_objc_msgForward_impcache 然后将其放到子类的缓存中。</p>
<h5 id="objc-msgForward-impcache"><a href="#objc-msgForward-impcache" class="headerlink" title="_objc_msgForward_impcache"></a>_objc_msgForward_impcache</h5><p>我们先来看下_objc_msgForward_impcache的调用位置</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs objc">STATIC_ENTRY __objc_msgForward_impcache <span class="hljs-comment">//进入 _objc_msgForward_impcache</span><br>	<span class="hljs-comment">// Method cache version</span><br><br>	<span class="hljs-comment">// 这是一个不能调用的c函数</span><br>	<span class="hljs-comment">// Out-of-band Z is 0 (EQ) for normal, 1 (NE) for stret</span><br><br>	beq	__objc_msgForward <span class="hljs-comment">// 标志寄存器中Z标志位等于零时, 跳转到BEQ后标签__objc_msgForward处</span><br>	b	__objc_msgForward_stret <span class="hljs-comment">//否则跳转  __objc_msgForward_stret</span><br>	<br>	END_ENTRY __objc_msgForward_impcache <span class="hljs-comment">//结束 _objc_msgForward_impcache</span><br>	<br><br>	ENTRY __objc_msgForward<br>	<span class="hljs-comment">// Non-stret version</span><br><br>	MI_GET_EXTERN(r12, __objc_forward_handler)<br>	ldr	r12, [r12]<br>	bx	r12<br><br>	END_ENTRY __objc_msgForward<br><br><br>	ENTRY __objc_msgForward_stret	<br></code></pre></td></tr></table></figure>

<p>这也是通过汇编进行调用的，从上面我们看出实际上是调用的__objc_msgForward或者__objc_msgForward_stret方法，而这两个方法实际都是调用了__objc_forward_handler方法，下面我们重点看下这个方法</p>
<h6 id="objc-forward-handler"><a href="#objc-forward-handler" class="headerlink" title="__objc_forward_handler"></a>__objc_forward_handler</h6><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs objc">__attribute__((noreturn)) <span class="hljs-keyword">struct</span> stret <br>objc_defaultForwardStretHandler(<span class="hljs-keyword">id</span> <span class="hljs-keyword">self</span>, SEL sel)<br>&#123;<br>    objc_defaultForwardHandler(<span class="hljs-keyword">self</span>, sel);<br>&#125;<br><span class="hljs-keyword">void</span> *_objc_forward_stret_handler = (<span class="hljs-keyword">void</span>*)objc_defaultForwardStretHandler;<br></code></pre></td></tr></table></figure>

<p>进而我们在看下objc_defaultForwardHandler方法的实现：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs objc">__attribute__((noreturn)) <span class="hljs-keyword">void</span> <br>objc_defaultForwardHandler(<span class="hljs-keyword">id</span> <span class="hljs-keyword">self</span>, SEL sel)<br>&#123;<br>    _objc_fatal(<span class="hljs-string">&quot;%c[%s %s]: unrecognized selector sent to instance %p &quot;</span><br>                <span class="hljs-string">&quot;(no message forward handler is installed)&quot;</span>, <br>                class_isMetaClass(object_getClass(<span class="hljs-keyword">self</span>)) ? <span class="hljs-string">&#x27;+&#x27;</span> : <span class="hljs-string">&#x27;-&#x27;</span>, <br>                object_getClassName(<span class="hljs-keyword">self</span>), sel_getName(sel), <span class="hljs-keyword">self</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>看到这里我们一脸懵逼，因为我们知道后续是有一个消息转发的过程的 为何在这里我们只是看到了_objc_forward_stret_handler的实现 且实现为objc_defaultForwardHandler。消息转发的过程是如何被触发的呢？</p>
<p>我们看到在objc-runtime.mm类中实际上下面这个方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">void</span> objc_setForwardHandler(<span class="hljs-keyword">void</span> *fwd, <span class="hljs-keyword">void</span> *fwd_stret)<br>&#123;<br>    _objc_forward_handler = fwd;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> SUPPORT_STRET</span><br>    _objc_forward_stret_handler = fwd_stret;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>也就是说 实际上系统给我们提供了一个默认的实现方法，但是这个方法是可以改变的，因此这里我猜想可能是因为系统在其他位置重新设置了_objc_forward_handler的值所以我们在调用的时候才有转发的流程。</p>
<h4 id="消息转发"><a href="#消息转发" class="headerlink" title="消息转发"></a>消息转发</h4><p>这里我们先来看下如果我调用了一个不存在的方法时错误的堆栈的样子：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-number">2020</span><span class="hljs-number">-11</span><span class="hljs-number">-15</span> <span class="hljs-number">00</span>:<span class="hljs-number">14</span>:<span class="hljs-number">55.738458</span>+<span class="hljs-number">0800</span> Runtime_MsgSend[<span class="hljs-number">72610</span>:<span class="hljs-number">1510129</span>] -[SubClass aaa]: unrecognized selector sent to instance <span class="hljs-number">0x6000034780a0</span><br><span class="hljs-number">2020</span><span class="hljs-number">-11</span><span class="hljs-number">-15</span> <span class="hljs-number">00</span>:<span class="hljs-number">14</span>:<span class="hljs-number">55.748137</span>+<span class="hljs-number">0800</span> Runtime_MsgSend[<span class="hljs-number">72610</span>:<span class="hljs-number">1510129</span>] *** Terminating app due to uncaught exception <span class="hljs-string">&#x27;NSInvalidArgumentException&#x27;</span>, reason: <span class="hljs-string">&#x27;-[SubClass aaa]: unrecognized selector sent to instance 0x6000034780a0&#x27;</span><br>*** First throw call stack:<br>(<br>	<span class="hljs-number">0</span>   CoreFoundation                      <span class="hljs-number">0x00007fff2043a126</span> __exceptionPreprocess + <span class="hljs-number">242</span><br>	<span class="hljs-number">1</span>   libobjc.A.dylib                     <span class="hljs-number">0x00007fff20177f78</span> objc_exception_throw + <span class="hljs-number">48</span><br>	<span class="hljs-number">2</span>   CoreFoundation                      <span class="hljs-number">0x00007fff20448c6f</span> +[<span class="hljs-built_in">NSObject</span>(<span class="hljs-built_in">NSObject</span>) instanceMethodSignatureForSelector:] + <span class="hljs-number">0</span><br>	<span class="hljs-number">3</span>   CoreFoundation                      <span class="hljs-number">0x00007fff2043e666</span> ___forwarding___ + <span class="hljs-number">1489</span><br>	<span class="hljs-number">4</span>   CoreFoundation                      <span class="hljs-number">0x00007fff20440698</span> _CF_forwarding_prep_0 + <span class="hljs-number">120</span><br></code></pre></td></tr></table></figure>

<p>从上面的log中我们看出在给出错误之前实际上是调用了<a target="_blank" rel="noopener" href="https://github.com/opensource-apple/CF">CoreFoundation</a>的_CF_forwarding_prep_0和___forwarding___方法。那么这两个方法时何时被调用的呢？</p>
<p>我们打开CoreFoundation的源码发现有一个跟运行时相关的类：CFRuntime.h 但是类中我们并没法发现调用objc_setForwardHandler的位置也没有发现直接调用_CF_forwarding_prep_0或者___forwarding___的地方。</p>
<p>那么究竟在什么时机调用的这些方法呢？</p>
<p>在查找这个问题的时候我们看到有使用Hoop Disassemble反编译方法时可以看到下面的调用关系：</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gkpndkm14yj31c10u04qp.jpg"></p>
<p>图中红框圈出来的方法是__CFInitialize方法。</p>
<p>但是很显然，我们在CFRuntime.h的__CFInitialize方法中并没有找到调用图中方法的位置：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">void</span> __CFInitialize(<span class="hljs-keyword">void</span>) &#123;<br><br>    <span class="hljs-keyword">if</span> (!__CFInitialized &amp;&amp; !__CFInitializing) &#123;<br>        __CFInitializing = <span class="hljs-number">1</span>;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> DEPLOYMENT_TARGET_WINDOWS || DEPLOYMENT_TARGET_IPHONESIMULATOR</span><br>        <span class="hljs-keyword">if</span> (!pthread_main_np()) HALT;   <span class="hljs-comment">// CoreFoundation must be initialized on the main thread</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>	<span class="hljs-comment">// move this next line up into the #if above after Foundation gets off this symbol</span><br>        _CFMainPThread = pthread_self();<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> DEPLOYMENT_TARGET_WINDOWS</span><br>        <span class="hljs-comment">// Must not call any CF functions</span><br>        __CFTSDWindowsInitialize();<br><span class="hljs-meta">#<span class="hljs-meta-keyword">elif</span> DEPLOYMENT_TARGET_LINUX</span><br>        __CFTSDLinuxInitialize();<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>        <br>        __CFProphylacticAutofsAccess = <span class="hljs-literal">true</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">CFIndex</span> idx = <span class="hljs-number">0</span>; idx &lt; <span class="hljs-keyword">sizeof</span>(__CFEnv) / <span class="hljs-keyword">sizeof</span>(__CFEnv[<span class="hljs-number">0</span>]); idx++) &#123;<br>            __CFEnv[idx].value = __CFEnv[idx].name ? getenv(__CFEnv[idx].name) : <span class="hljs-literal">NULL</span>;<br>        &#125;<br>          <br>          <span class="hljs-comment">// --------------此处没有找到调用相关的方法</span><br>          <br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> !defined(kCFUseCollectableAllocator)</span><br>        kCFUseCollectableAllocator = objc_collectingEnabled();<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>        <span class="hljs-keyword">if</span> (kCFUseCollectableAllocator) &#123;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> !defined(__CFObjCIsCollectable)</span><br>            __CFObjCIsCollectable = (<span class="hljs-keyword">bool</span> (*)(<span class="hljs-keyword">void</span> *))objc_isAuto;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>        &#125;<br>        <span class="hljs-comment">//........ 省略部分代码</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>所以这里我们猜测苹果在开源时删除了这部分方法调用。</p>
<p>由于对汇编熟悉，这里我们也不再进行更加深入的解读，但是在<a target="_blank" rel="noopener" href="http://www.arigrant.com/blog/2013/12/13/a-selector-left-unhandled">Hmmm, What’s that Selector?</a> 文章中作者进行了介绍并猜想___forwarding___的实现：</p>
<h6 id="forwarding"><a href="#forwarding" class="headerlink" title="forwarding"></a><strong><em>forwarding</em></strong></h6><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">int</span> __forwarding__(<span class="hljs-keyword">void</span> *frameStackPointer, <span class="hljs-keyword">int</span> isStret) &#123;<br>  <span class="hljs-keyword">id</span> receiver = *(<span class="hljs-keyword">id</span> *)frameStackPointer;<br>  SEL sel = *(SEL *)(frameStackPointer + <span class="hljs-number">8</span>);<br>  <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *selName = sel_getName(sel);<br>  Class receiverClass = object_getClass(receiver);<br><br>  <span class="hljs-comment">// 调用 forwardingTargetForSelector:</span><br>  <span class="hljs-keyword">if</span> (class_respondsToSelector(receiverClass, <span class="hljs-keyword">@selector</span>(forwardingTargetForSelector:))) &#123;<br>    <span class="hljs-keyword">id</span> forwardingTarget = [receiver forwardingTargetForSelector:sel];<br>    <span class="hljs-keyword">if</span> (forwardingTarget &amp;&amp; forwarding != receiver) &#123;<br>    	<span class="hljs-keyword">if</span> (isStret == <span class="hljs-number">1</span>) &#123;<br>    		<span class="hljs-keyword">int</span> ret;<br>    		objc_msgSend_stret(&amp;ret,forwardingTarget, sel, ...);<br>    		<span class="hljs-keyword">return</span> ret;<br>    	&#125;<br>      <span class="hljs-keyword">return</span> objc_msgSend(forwardingTarget, sel, ...);<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// 僵尸对象</span><br>  <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *className = class_getName(receiverClass);<br>  <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *zombiePrefix = <span class="hljs-string">&quot;_NSZombie_&quot;</span>;<br>  size_t prefixLen = strlen(zombiePrefix); <span class="hljs-comment">// 0xa</span><br>  <span class="hljs-keyword">if</span> (strncmp(className, zombiePrefix, prefixLen) == <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-built_in">CFLog</span>(kCFLogLevelError,<br>          <span class="hljs-string">@&quot;*** -[%s %s]: message sent to deallocated instance %p&quot;</span>,<br>          className + prefixLen,<br>          selName,<br>          receiver);<br>    &lt;breakpoint-interrupt&gt;<br>  &#125;<br><br>  <span class="hljs-comment">// 调用 methodSignatureForSelector 获取方法签名后再调用 forwardInvocation</span><br>  <span class="hljs-keyword">if</span> (class_respondsToSelector(receiverClass, <span class="hljs-keyword">@selector</span>(methodSignatureForSelector:))) &#123;<br>    <span class="hljs-built_in">NSMethodSignature</span> *methodSignature = [receiver methodSignatureForSelector:sel];<br>    <span class="hljs-keyword">if</span> (methodSignature) &#123;<br>      <span class="hljs-built_in">BOOL</span> signatureIsStret = [methodSignature _frameDescriptor]-&gt;returnArgInfo.flags.isStruct;<br>      <span class="hljs-keyword">if</span> (signatureIsStret != isStret) &#123;<br>        <span class="hljs-built_in">CFLog</span>(kCFLogLevelWarning ,<br>              <span class="hljs-string">@&quot;*** NSForwarding: warning: method signature and compiler disagree on struct-return-edness of &#x27;%s&#x27;.  Signature thinks it does%s return a struct, and compiler thinks it does%s.&quot;</span>,<br>              selName,<br>              signatureIsStret ? <span class="hljs-string">&quot;&quot;</span> : not,<br>              isStret ? <span class="hljs-string">&quot;&quot;</span> : not);<br>      &#125;<br>      <span class="hljs-keyword">if</span> (class_respondsToSelector(receiverClass, <span class="hljs-keyword">@selector</span>(forwardInvocation:))) &#123;<br>        <span class="hljs-built_in">NSInvocation</span> *invocation = [<span class="hljs-built_in">NSInvocation</span> _invocationWithMethodSignature:methodSignature frame:frameStackPointer];<br><br>        [receiver forwardInvocation:invocation];<br><br>        <span class="hljs-keyword">void</span> *returnValue = <span class="hljs-literal">NULL</span>;<br>        [invocation getReturnValue:&amp;value];<br>        <span class="hljs-keyword">return</span> returnValue;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">CFLog</span>(kCFLogLevelWarning ,<br>              <span class="hljs-string">@&quot;*** NSForwarding: warning: object %p of class &#x27;%s&#x27; does not implement forwardInvocation: -- dropping message&quot;</span>,<br>              receiver,<br>              className);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>      &#125;<br>    &#125;<br>  &#125;<br><br>  SEL *registeredSel = sel_getUid(selName);<br><br>  <span class="hljs-comment">// selector 是否已经在 Runtime 注册过</span><br>  <span class="hljs-keyword">if</span> (sel != registeredSel) &#123;<br>    <span class="hljs-built_in">CFLog</span>(kCFLogLevelWarning ,<br>          <span class="hljs-string">@&quot;*** NSForwarding: warning: selector (%p) for message &#x27;%s&#x27; does not match selector known to Objective C runtime (%p)-- abort&quot;</span>,<br>          sel,<br>          selName,<br>          registeredSel);<br>  &#125; <span class="hljs-comment">// doesNotRecognizeSelector</span><br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (class_respondsToSelector(receiverClass,<span class="hljs-keyword">@selector</span>(doesNotRecognizeSelector:))) &#123;<br>    [receiver doesNotRecognizeSelector:sel];<br>  &#125; <br>  <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-built_in">CFLog</span>(kCFLogLevelWarning ,<br>          <span class="hljs-string">@&quot;*** NSForwarding: warning: object %p of class &#x27;%s&#x27; does not implement doesNotRecognizeSelector: -- abort&quot;</span>,<br>          receiver,<br>          className);<br>  &#125;<br><br>  <span class="hljs-comment">// The point of no return.</span><br>  kill(getpid(), <span class="hljs-number">9</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面的方法实际上分了三步：</p>
<ul>
<li>先调用 forwardingTargetForSelector 方法获取新的 target 作为 receiver 重新执行 selector，如果返回的内容不合法（为 nil 或者跟旧 receiver 一样），那就进入第二步</li>
<li>调用 methodSignatureForSelector 获取方法签名后，判断返回类型信息是否正确，再调用 forwardInvocation 执行 NSInvocation 对象，并将结果返回。如果对象没实现 methodSignatureForSelector 方法，进入第三步。</li>
<li>调用 doesNotRecognizeSelector 方法。</li>
</ul>
<p>最终消息的发送就完成了。</p>
<p>下面我们来汇总下消息发送的流程：</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gkppwpitnvj30vs0u0als.jpg"></p>
<p>看完了实现原理 下面我们通过一个demo来验证下我们上面的结论：</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><h4 id="动态解析"><a href="#动态解析" class="headerlink" title="动态解析"></a>动态解析</h4><p>我们都知道，如果在类的方法列表中无法找到对应的方法，我们首先进行动态解析，即调用resolveInstanceMethod方法判断是否需要动态解析，我们可以在这个方法里动态的为这个类新增一个方法，实现可调用到对应方法的目的。</p>
<p> MessageForward.h</p>
 <figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs objc"> <span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">MessageForward</span> : <span class="hljs-title">NSObject</span></span><br><br>- (<span class="hljs-keyword">void</span>)testMethod;<br><br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure>

<p>MessageForward.m</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">MessageForward</span></span><br><br>+ (<span class="hljs-built_in">BOOL</span>)resolveInstanceMethod:(SEL)sel &#123;<br>    <span class="hljs-keyword">if</span> ([<span class="hljs-built_in">NSStringFromSelector</span>(sel) isEqualToString:<span class="hljs-string">@&quot;testMethod&quot;</span>]) &#123;<br>        Method testmethod = class_getInstanceMethod(<span class="hljs-keyword">self</span>, <span class="hljs-keyword">@selector</span>(test));<br>        IMP testIMP = method_getImplementation(testmethod);<br>        class_addMethod(<span class="hljs-keyword">self</span>, sel, testIMP, method_getTypeEncoding(testmethod));<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">YES</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NO</span>;<br>&#125;<br><br>- (<span class="hljs-keyword">void</span>)test &#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;MessageForward %s&quot;</span>,__func__);<br>&#125;<br><br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure>

<p>当外部调用MessageForward的testMethod方法时，发现方法列表中无法找到对应的方法实现，那么就会判断是否需要动态解析，我们看到我们在resolveInstanceMethod方法中当sel为testMethod时我们返回了yes，这样就会导致方法调用位置会重新查找一次类中的方法列表，我们在返回值之前动态的通过class_addMethod方法给类添加了testMethod方法的实现。</p>
<p>这样外部在调用testMethod时，我们会动态解析为test方法进行调用。</p>
<h4 id="消息转发-1"><a href="#消息转发-1" class="headerlink" title="消息转发"></a>消息转发</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs objc">- (<span class="hljs-built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)aSelector &#123;<br>    <span class="hljs-keyword">if</span> ([<span class="hljs-built_in">NSStringFromSelector</span>(aSelector) isEqualToString:<span class="hljs-string">@&quot;testMethod&quot;</span>]) &#123;<br>        <span class="hljs-built_in">NSMethodSignature</span> *signature = [<span class="hljs-built_in">NSMethodSignature</span> signatureWithObjCTypes:<span class="hljs-string">&quot;v@:&quot;</span>];<br>        <span class="hljs-keyword">return</span> signature;<br>    &#125;<br>    <span class="hljs-keyword">return</span> [<span class="hljs-keyword">super</span> methodSignatureForSelector:aSelector];<br>&#125;<br><br>- (<span class="hljs-keyword">void</span>)forwardInvocation:(<span class="hljs-built_in">NSInvocation</span> *)anInvocation &#123;<br>    <span class="hljs-keyword">if</span> ([<span class="hljs-built_in">NSStringFromSelector</span>(anInvocation.selector) isEqualToString:<span class="hljs-string">@&quot;testMethod&quot;</span>]) &#123;<br>        [<span class="hljs-keyword">self</span> test];<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        [<span class="hljs-keyword">super</span> forwardInvocation:anInvocation];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>同样当外部调用testMethod方法时，由于我们并没有实现动态解析的方法，因此默认是走转发的逻辑，在转发的逻辑中我们实现了methodSignatureForSelector和forwardInvocation方法，如果要实现消息的转发逻辑这两个方法是必须全部实现的，在forwardInvocation方法中，我们判断如果当前调用的是testMethod方法，我们会直接调用test方法。</p>
<p>至此 消息发送和消息转发的逻辑就整理完成了，后面我们会继续看下Runtime中关联属性相关的实现逻辑。</p>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a target="_blank" rel="noopener" href="http://www.arigrant.com/blog/2013/12/13/a-selector-left-unhandled">Hmmm, What’s that Selector?</a><br><a target="_blank" rel="noopener" href="http://yulingtianxia.com/blog/2016/06/15/Objective-C-Message-Sending-and-Forwarding/">Objective-C 消息发送与转发机制原理</a></p>

    </div>
     
    <div class="post-footer__meta"><p>更新于 2020-12-05</p></div> 
    <div class="post-meta__cats"><a href="/categories/Runtime/" class="post-cats__link button">Runtime</a><a href="/tags/Runtime-msgSend/" class="post-tags__link button"># Runtime msgSend</a></div> 
</article>


    <div class="nav">
        <div class="nav__prev">
            
                <a href="/2020/11/29/runtime-objectlifetime/" class="nav__link">
                    <div>
                        <svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" width="24" height="24"><path d="M589.088 790.624L310.464 512l278.624-278.624 45.248 45.248L400.96 512l233.376 233.376z" fill="#808080"></path></svg>
                    </div>
                    <div>
                        <div class="nav__label">
                            Previous Post
                        </div>
                        <div class="nav__title">
                            Runtime之对象的一生
                        </div>
                    </div>
                </a>
            
        </div>
        <div class="nav__next">
            
                <a href="/2020/10/25/runtime-methodswizzle/" class="nav__link">
                    <div>
                        <div class="nav__label">
                            Next Post
                        </div>
                        <div class="nav__title">
                            Runtime之方法交换
                        </div>
                    </div>
                    <div>
                        <svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" width="24" height="24"><path d="M434.944 790.624l-45.248-45.248L623.04 512l-233.376-233.376 45.248-45.248L713.568 512z" fill="#808080"></path></svg>
                    </div>
                </a>
            
        </div>
    </div>





</main>

            <footer class="footer">
    


    
    
    
        <span id="busuanzi_container_site_uv" hidden>
            <span></span>
            <span id="busuanzi_value_site_uv"></span>
            <span>Viewers</span>
            
                <span>|</span>
            
        </span>
    
    
        <span id="busuanzi_container_site_pv" hidden>
            <span></span>
            <span id="busuanzi_value_site_pv"></span>
            <span>Views</span>
            
        </span>
    
 
 

 
    
        
        <p class="footer-copyright">
            Copyright © 2015&nbsp;-&nbsp;2022 <a href="/">LeeWong</a>
        </p>
    
    
    <p>Powered by <a href="https://hexo.io" target="_blank">Hexo</a> | Theme - <a href="https://github.com/ChrAlpha/hexo-theme-cards" target="_blank">Cards</a></p>
</footer>

        </div>
         

 
    <script>
        window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
        ga('create', '4NmLVard-jFEKaV6857m9tKb41Tpo4FiKj8L1TJg7lU', 'auto');
        ga('send', 'pageview');
    </script>
    <script async src="https://www.google-analytics.com/analytics.js"></script>
 

 

 
    <script>
        var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement('script');
            hm.src = 'https://hm.baidu.com/hm.js?DR81zbdrQ3';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(hm, s);
        })();
    </script>
 

  



 


    
 


    
<script src="https://cdn.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.min.js"></script>

    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.4.1/dist/jquery.fancybox.min.css">

    
<script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.4.1/dist/jquery.fancybox.min.js"></script>

    <script>
        let lazyloadT = Boolean('false'),
            auto_fancybox = Boolean('false')
        if (auto_fancybox) {
            $(".post__content").find('img').each(function () {
                var element = document.createElement("a");
                $(element).attr("data-fancybox", "gallery");
                $(element).attr("href", $(this).attr("src"));
                if (lazyloadT) {
                    $(element).attr("href", $(this).attr("data-srcset"));
                }
                $(this).wrap(element);
            });
        } else {
            $(".post__content").find("fancybox").find('img').each(function () {
                var element = document.createElement("a");
                $(element).attr("data-fancybox", "gallery");
                $(element).attr("href", $(this).attr("src"));
                if (lazyloadT) {
                    $(element).attr("href", $(this).attr("data-srcset"));
                }
                $(this).wrap(element);
            });
        }
    </script>
 

 

 

 




    </body>
</html>
