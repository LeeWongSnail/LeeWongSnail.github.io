<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.1.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.14.0/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.leewong.cn","root":"/","scheme":"Mist","version":"8.0.0-rc.5","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"},"path":"search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}};
  </script>

  <meta name="description" content="最近在看iOS的一些基础原理,看到涂耀辉的这篇关于Runloop的,感觉原理+代码的这种讲解方式非常好,特地转过来，由于简书后半部分排版有点乱,这里特地按照我的思路重新整理一下！">
<meta property="og:type" content="article">
<meta property="og:title" content="runloop 的那些事儿(转)">
<meta property="og:url" content="https://www.leewong.cn/2018/02/28/runloop-detail/index.html">
<meta property="og:site_name" content="LeeWong">
<meta property="og:description" content="最近在看iOS的一些基础原理,看到涂耀辉的这篇关于Runloop的,感觉原理+代码的这种讲解方式非常好,特地转过来，由于简书后半部分排版有点乱,这里特地按照我的思路重新整理一下！">
<meta property="og:locale">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/2702646-08d6e834e337387d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/2702646-6364a8544aa941b3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/2702646-532788b8b08ec601.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/2702646-60d6d86082e68ce0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://blog.ibireme.com/wp-content/uploads/2015/05/RunLoop_0.png">
<meta property="article:published_time" content="2018-02-28T09:37:54.000Z">
<meta property="article:modified_time" content="2020-07-19T14:14:47.384Z">
<meta property="article:author" content="LeeWong">
<meta property="article:tag" content="Runloop">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://upload-images.jianshu.io/upload_images/2702646-08d6e834e337387d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700">


<link rel="canonical" href="https://www.leewong.cn/2018/02/28/runloop-detail/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-Hans'
  };
</script>

  <title>runloop 的那些事儿(转) | LeeWong</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=4NmLVard-jFEKaV6857m9tKb41Tpo4FiKj8L1TJg7lU"></script>
    <script>
      if (CONFIG.hostname === location.hostname) {
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', '4NmLVard-jFEKaV6857m9tKb41Tpo4FiKj8L1TJg7lU');
      }
    </script>


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?DR81zbdrQ3";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">LeeWong</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">What is Life But One Chanllege After Another</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-首页">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-关于">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-分类">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-归档">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <section class="post-toc-wrap sidebar-panel">
          <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%88%E7%9C%8BAFN%E7%9A%84%E4%B8%80%E6%AE%B5%E7%BB%8F%E5%85%B8%E4%BB%A3%E7%A0%81%EF%BC%9A"><span class="nav-number">1.</span> <span class="nav-text">先看AFN的一段经典代码：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%8D%E7%9C%8B%E7%9C%8BAFN3-X"><span class="nav-number">2.</span> <span class="nav-text">再看看AFN3.X</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RAC%E4%B8%AD%E7%9A%84RunLoop"><span class="nav-number">3.</span> <span class="nav-text">RAC中的RunLoop</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RunLoop%E6%A6%82%E5%BF%B5"><span class="nav-number">4.</span> <span class="nav-text">RunLoop概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#OS%E4%B8%8BRun-Loop%E7%9A%84%E4%B8%BB%E8%A6%81%E8%BF%90%E8%A1%8C%E6%A8%A1%E5%BC%8Fmode%E6%9C%89%EF%BC%9A"><span class="nav-number">4.1.</span> <span class="nav-text">OS下Run Loop的主要运行模式mode有：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93%E4%B8%80%E4%B8%8B%EF%BC%9A"><span class="nav-number">4.2.</span> <span class="nav-text">总结一下：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Run-Loop%E8%BF%90%E8%A1%8C%E6%8E%A5%E5%8F%A3"><span class="nav-number">5.</span> <span class="nav-text">Run Loop运行接口</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#NSRunLoop%E7%9A%84%E8%BF%90%E8%A1%8C%E6%8E%A5%E5%8F%A3%EF%BC%9A"><span class="nav-number">5.1.</span> <span class="nav-text">NSRunLoop的运行接口：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8B%E9%9D%A2%E5%88%86%E7%B1%BB%E8%BF%9B%E8%A1%8C%E8%AF%A6%E8%A7%A3"><span class="nav-number">5.2.</span> <span class="nav-text">下面分类进行详解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E7%BB%93%E6%9D%9F%E5%91%A2%EF%BC%9F"><span class="nav-number">5.3.</span> <span class="nav-text">线程为什么会结束呢？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Core-Foundation%E4%B8%AD%E8%BF%90%E8%A1%8Crunloop%E7%9A%84%E6%8E%A5%E5%8F%A3"><span class="nav-number">5.4.</span> <span class="nav-text">Core Foundation中运行runloop的接口</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%8B%E9%9D%A2%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%EF%BC%9A"><span class="nav-number">5.4.1.</span> <span class="nav-text">下面详细介绍一下：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">6.</span> <span class="nav-text">总结</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#RunLoop%E5%81%9C%E6%AD%A2%E5%92%8C%E5%8F%96%E6%B6%88%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">6.1.</span> <span class="nav-text">RunLoop停止和取消的方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8Erunloop%E7%9A%84%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1"><span class="nav-number">7.</span> <span class="nav-text">基于runloop的线程通信</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E7%AB%AF%E5%8F%A3%E7%9A%84%E8%BE%93%E5%85%A5%E6%BA%90"><span class="nav-number">7.1.</span> <span class="nav-text">基于端口的输入源:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Cocoa-%E6%89%A7%E8%A1%8C-Selector-%E7%9A%84%E6%BA%90"><span class="nav-number">7.2.</span> <span class="nav-text">Cocoa 执行 Selector 的源:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BE%93%E5%85%A5%E6%BA%90"><span class="nav-number">7.3.</span> <span class="nav-text">自定义输入源:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E6%97%B6%E6%BA%90"><span class="nav-number">7.4.</span> <span class="nav-text">定时源:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Core-Foundation-%E5%88%9B%E5%BB%BA%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="nav-number">7.5.</span> <span class="nav-text">Core Foundation 创建定时器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Run-Loop%E7%9A%84Observer"><span class="nav-number">7.6.</span> <span class="nav-text">Run Loop的Observer</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RunLoop-%E4%B8%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-number">8.</span> <span class="nav-text">RunLoop 与线程的关系</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RunLoop-%E5%AF%B9%E5%A4%96%E7%9A%84%E6%8E%A5%E5%8F%A3"><span class="nav-number">9.</span> <span class="nav-text">RunLoop 对外的接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RunLoop-%E7%9A%84-Mode"><span class="nav-number">10.</span> <span class="nav-text">RunLoop 的 Mode</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%8B%B9%E6%9E%9C%E7%94%A8-RunLoop-%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="nav-number">11.</span> <span class="nav-text">苹果用 RunLoop 实现的功能</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#AutoreleasePool"><span class="nav-number">11.1.</span> <span class="nav-text">AutoreleasePool</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6%E5%93%8D%E5%BA%94"><span class="nav-number">11.2.</span> <span class="nav-text">事件响应</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%8B%E5%8A%BF%E8%AF%86%E5%88%AB"><span class="nav-number">11.3.</span> <span class="nav-text">手势识别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%95%8C%E9%9D%A2%E6%9B%B4%E6%96%B0"><span class="nav-number">11.4.</span> <span class="nav-text">界面更新</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="nav-number">11.5.</span> <span class="nav-text">定时器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#PerformSelecter"><span class="nav-number">11.6.</span> <span class="nav-text">PerformSelecter</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B3%E4%BA%8EGCD"><span class="nav-number">11.7.</span> <span class="nav-text">关于GCD</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%80%E5%90%8E"><span class="nav-number">12.</span> <span class="nav-text">最后</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E6%96%87%E7%AB%A0"><span class="nav-number">13.</span> <span class="nav-text">参考文章</span></a></li></ol></div>
      </section>
      <!--/noindex-->

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="LeeWong"
      src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gi7obtinvfj30hq0hqgme.jpg">
  <p class="site-author-name" itemprop="name">LeeWong</p>
  <div class="site-description" itemprop="description">What is Life But One Chanllege After Another</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">71</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">19</span>
        <span class="site-state-item-name">categories</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">79</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/LeeWongSnail" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;LeeWongSnail" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/wangli_0632@163.com" title="E-Mail → wangli_0632@163.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </section>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">
      

      

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://www.leewong.cn/2018/02/28/runloop-detail/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://tva1.sinaimg.cn/large/007S8ZIlgy1gi7obtinvfj30hq0hqgme.jpg">
      <meta itemprop="name" content="LeeWong">
      <meta itemprop="description" content="What is Life But One Chanllege After Another">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LeeWong">
    </span>

    
    
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          runloop 的那些事儿(转)
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2018-02-28 17:37:54" itemprop="dateCreated datePublished" datetime="2018-02-28T17:37:54+08:00">2018-02-28</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2020-07-19 22:14:47" itemprop="dateModified" datetime="2020-07-19T22:14:47+08:00">2020-07-19</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/iOS%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">iOS基础</span></a>
        </span>
    </span>

  
    <span id="/2018/02/28/runloop-detail/" class="post-meta-item leancloud_visitors" data-flag-title="runloop 的那些事儿(转)" title="Views">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">Views: </span>
      <span class="leancloud-visitors-count"></span>
    </span>
    <span class="post-meta-item" title="Views" id="busuanzi_container_page_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">Views: </span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>最近在看iOS的一些基础原理,看到<a target="_blank" rel="noopener" href="https://www.jianshu.com/u/14431e509ae8">涂耀辉</a>的这篇关于Runloop的,感觉原理+代码的这种讲解方式非常好,特地转过来，由于简书后半部分排版有点乱,这里特地按照我的思路重新整理一下！</p>
<a id="more"></a>

<h2 id="先看AFN的一段经典代码："><a href="#先看AFN的一段经典代码：" class="headerlink" title="先看AFN的一段经典代码："></a>先看AFN的一段经典代码：</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">NSThread</span> *)networkRequestThread &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">NSThread</span> *_networkRequestThread = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> oncePredicate;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;oncePredicate, ^&#123;</span><br><span class="line">        _networkRequestThread = [[<span class="built_in">NSThread</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(networkRequestThreadEntryPoint:) object:<span class="literal">nil</span>];</span><br><span class="line">        [_networkRequestThread start];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> _networkRequestThread;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)networkRequestThreadEntryPoint:(<span class="keyword">id</span>)__unused object &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        [[<span class="built_in">NSThread</span> currentThread] setName:<span class="string">@&quot;AFNetworking&quot;</span>];</span><br><span class="line">        <span class="built_in">NSRunLoop</span> *runLoop = [<span class="built_in">NSRunLoop</span> currentRunLoop];</span><br><span class="line">        [runLoop addPort:[<span class="built_in">NSMachPort</span> port] forMode:<span class="built_in">NSDefaultRunLoopMode</span>];</span><br><span class="line">        [runLoop run];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>1、首先我们要明确一个概念，线程一般都是一次执行完任务，就销毁了。</li>
<li>2、而添加了runloop，并运行起来，实际上是添加了一个do,while循环，这样这个线程的程序一直卡在这个do,while循环上，这样相当于线程的任务一直没有执行完，所以线程一直不会销毁。</li>
<li>3、所以，一旦我们添加了一个runloop，并run了，我们如果要销毁这个线程，必须停止runloop，至于停止的方式，我们接下去往下看。</li>
</ul>
<p><code>注</code>:这里创建的名为<code>AFNetworking</code>的线程,由于其被添加到Runloop上 所以除非Runloop被销毁,否则线程也不会被销毁</p>
<p>1、添加监听事件的端口</p>
<p><code>[runLoop addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode]; </code></p>
<p>2、Runloop跑起来</p>
<p><code>[runLoop run];</code></p>
<p>不过以这种方式启动Runloop后只有一种方式可以终止该Runloop：<br>移除之前添加的端口 这样Runloop中没有事件了，所以可以直接退出。<br><code>[NSRunLoop currentRunLoop]removePort:&lt;#(nonnull NSPort *)#&gt; forMode:&lt;#(nonnull NSRunLoopMode)#&gt;</code></p>
<p>因此 我们可以得出<code>AFN中并没有记录该port,所以压根就不会退出Runloop,所以这是一个常驻线程</code></p>
<h2 id="再看看AFN3-X"><a href="#再看看AFN3-X" class="headerlink" title="再看看AFN3.X"></a>再看看AFN3.X</h2><p>开启RunLoop:</p>
<p><code>CFRunLoopRun();</code></p>
<p>终止RunLoop:</p>
<p><code>CFRunLoopStop(CFRunLoopGetCurrent());</code></p>
<h2 id="RAC中的RunLoop"><a href="#RAC中的RunLoop" class="headerlink" title="RAC中的RunLoop"></a>RAC中的RunLoop</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自己用一个Bool值done去控制runloop的运行，每次只运行这</span></span><br><span class="line"><span class="comment">//个模式的runloop，0.1秒。0.1秒后开启runloop的下一次运行</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    [<span class="built_in">NSRunLoop</span>.mainRunLoop runMode:<span class="built_in">NSDefaultRunLoopMode</span> beforeDate:[<span class="built_in">NSDate</span> dateWithTimeIntervalSinceNow:<span class="number">0.1</span>]];</span><br><span class="line">&#125; <span class="keyword">while</span> (!done);</span><br></pre></td></tr></table></figure>

<h2 id="RunLoop概念"><a href="#RunLoop概念" class="headerlink" title="RunLoop概念"></a>RunLoop概念</h2><p><img src="https://upload-images.jianshu.io/upload_images/2702646-08d6e834e337387d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt="RunLoop官方图"></p>
<p>Runloop，顾名思义就是跑圈，他的本质就是一个do,while循环，当有事做时做事，没事做时睡眠。至于怎么做事，怎么睡眠，这个是由系统内核来调度的，我们后面会讲到</p>
<p>每个线程都有一个Run Loop，主线程的Run Loop会在App运行时自动运行，子线程中需要手动获取运行，第一次获取时，才会去创建。</p>
<p>每个Run Loop都会以一个模式mode来运行，可以使用NSRunLoop的</p>
<p><code>-(BOOL)runMode:(NSString *)mode beforeDate:(NSDate *)limitDate  </code><br>方法来设置运行在那个特定的mode</p>
<ul>
<li><p>1 Run Loop的处理两大类事件源：<code>Timer Source</code>和<code>Input Source</code>(包括<code>performSelector***</code>方法簇,<code>Port</code>或者自定义<code>Input Source</code>)，每个事件源都会绑定在Run Loop的某个特定模式mode上，<code>而且只有RunLoop在这个模式运行的时候才会触发该Timer和Input Source</code>。</p>
</li>
<li><p>2、如果没有任何事件源添加到RunLoop上，RunLoop就会立刻exit，这也是一开始的AF例子，为什么需要绑定一个Port的原因。</p>
</li>
</ul>
<h3 id="OS下Run-Loop的主要运行模式mode有："><a href="#OS下Run-Loop的主要运行模式mode有：" class="headerlink" title="OS下Run Loop的主要运行模式mode有："></a>OS下Run Loop的主要运行模式mode有：</h3><blockquote>
<p>1、NSDefaultRunLoopMode: 默认的运行模式，除了NSConnection对象的事件。<br>2、NSRunLoopCommonModes: 是一组常用的模式集合，将一个input source关联到这个模式集合上，等于将input source关联到这个模式集合中的所有模式上。在iOS系统中NSRunLoopCommonMode包含NSDefaultRunLoopMode、NSTaskDeathCheckMode、UITrackingRunLoopMode。</p>
</blockquote>
<p>假如我有个timer要关联到这些模式上，一个个注册很麻烦，我可以用</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[<span class="built_in">NSRunLoop</span> currentRunLoop] addTimer:timer forMode:<span class="built_in">NSRunLoopCommonModes</span>];</span><br></pre></td></tr></table></figure>
<p>将UITrackingRunLoopMode或者其他模式添加到这个NSRunLoopCommonModes模式中，然后只需要将Timer关联到NSRunLoopCommonModes，即可以实现Run Loop运行在这个模式集合中任何一个模式时，这个Timer都可以被触发</p>
<p>当然，默认情况下NSRunLoopCommonModes包含了NSDefaultRunLoopMode和UITrackingRunLoopMode。我指的是如果有其他自定义Mode。</p>
<blockquote>
<p>3、UITrackingRunLoopMode: 用于跟踪触摸事件触发的模式（例如UIScrollView上下滚动），主线程当触摸事件触发时会设置为这个模式，可以用来在控件事件触发过程中设置Timer。<br>4、GSEventReceiveRunLoopMode: 用于接受系统事件，属于内部的Run Loop模式。<br>5、自定义Mode：可以设置自定义的运行模式Mode，你也可以用CFRunLoopAddCommonMode添加到NSRunLoopCommonModes中</p>
</blockquote>
<h3 id="总结一下："><a href="#总结一下：" class="headerlink" title="总结一下："></a>总结一下：</h3><p>Run Loop运行时只能以一种固定的模式运行，如果我们需要它切换模式，只有停掉它，再重新开启它。</p>
<p>运行时它只会监控这个模式下添加的Timer Source和Input Source，如果这个模式下没有相应的事件源，Run Loop的运行也会立刻返回的。</p>
<p>注意Run Loop不能在运行在NSRunLoopCommonModes模式，因为NSRunLoopCommonModes其实是个模式集合，而不是一个具体的模式，我可以在添加事件源的时候使用NSRunLoopCommonModes，只要Run Loop运行在NSRunLoopCommonModes中任何一个模式，这个事件源都可以被触发</p>
<h2 id="Run-Loop运行接口"><a href="#Run-Loop运行接口" class="headerlink" title="Run Loop运行接口"></a>Run Loop运行接口</h2><p>Foundation层和CoreFoundation层都有对应的接口可以操作RunLoop：</p>
<p>Foundation层对应的是NSRunLoop，Core Foundation层对应的是CFRunLoopRef；</p>
<p>两组接口差不多，不过功能上还是有许多区别的：<br>例如CF层可以添加自定义Input Source事件源、(CFRunLoopSourceRef)Run Loop观察者Observer(CFRunLoopObserverRef)，很多类似功能的接口特性也是不一样的。</p>
<h3 id="NSRunLoop的运行接口："><a href="#NSRunLoop的运行接口：" class="headerlink" title="NSRunLoop的运行接口："></a>NSRunLoop的运行接口：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;运行 NSRunLoop，运行模式为默认的NSDefaultRunLoopMode模式，没有超时限制</span><br><span class="line">- (void)run;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;运行 NSRunLoop: 参数为运时间期限，运行模式为默认的NSDefaultRunLoopMode模式 </span><br><span class="line">- (void)runUntilDate:(NSDate *)limitDate;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;运行 NSRunLoop: 参数为运行模式、时间期限，返回值为YES表示是处理事件后返回的，NO表示是超时或者停止运行导致返回的</span><br><span class="line">- (BOOL)runMode:(NSString *)mode beforeDate:(NSDate *)limitDate;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>CFRunLoopRef的运行接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;运行 CFRunLoopRef</span><br><span class="line">void CFRunLoopRun();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;运行 CFRunLoopRef: 参数为运行模式、时间和是否在处理Input Source后退出标志，返回值是exit原因</span><br><span class="line">SInt32 CFRunLoopRunInMode (mode, seconds, returnAfterSourceHandled);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;停止运行 CFRunLoopRef</span><br><span class="line">void CFRunLoopStop( CFRunLoopRef rl );</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;唤醒CFRunLoopRef</span><br><span class="line">void CFRunLoopWakeUp ( CFRunLoopRef rl );</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="下面分类进行详解"><a href="#下面分类进行详解" class="headerlink" title="下面分类进行详解"></a>下面分类进行详解</h3><p><code>- (void)run; 无条件运行</code></p>
<ul>
<li>AFN2.X使用的方式</li>
<li>不建议使用，因为这个接口会导致Run Loop永久性的运行在NSDefaultRunLoopMode模式。</li>
<li>即使用CFRunLoopStop(runloopRef);也无法停止Run Loop的运行，除非能移除这个runloop上的所有事件源，包括定时器和source事件，不然这个子线程就无法停止，只能永久运行下去。</li>
</ul>
<p><code>- (void)runUntilDate:(NSDate *)limitDate;  有一个超时时间限制 </code><br>比上面的接口好点，有个超时时间，可以控制每次Run Loop的运行时间，也是运行在NSDefaultRunLoopMode模式。<br>这个方法运行Run Loop一段时间会退出给你检查运行条件的机会，如果需要可以再次运行Run Loop。<br>注意CFRunLoopStop(runloopRef),也无法停止Run Loop的运行</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!Done)</span><br><span class="line">&#123;</span><br><span class="line">    [[<span class="built_in">NSRunLoop</span> currentRunLoop] runUntilDate:[<span class="built_in">NSDate</span> dateWithTimeIntervalSinceNow:<span class="number">10</span>]];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;exiting runloop.........:&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意这个Done是我们自定义的一个Bool值，用来控制是否还需要开启下一次的runloop。</p>
<p>这个例子大概做了如下的事：这个Runloop会每10秒退出一次，然后输出exiting runloop………，然后下一次根据我们的Done值来判断是否再去运行runloop</p>
<p>`//有一个超时时间限制，而且设置运行模式</p>
<ul>
<li>(BOOL)runMode:(NSString *)mode beforeDate:(NSDate *)limitDate;`</li>
</ul>
<ul>
<li><p>这种运行方式是可以被CFRunLoopStop(runloopRef)所停止的(大家可以自己写个例子试试)。</p>
</li>
<li><p>这个方法和第二个方法还有一个很大的区别就是这样去运行runloop会多一种退出方式。这里我指的退出方式是除了timer触发以外的事件，都会导致runloop退出</p>
</li>
</ul>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">- (void)testDemo1</span><br><span class="line">&#123;</span><br><span class="line">    dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;</span><br><span class="line">        NSLog(@&quot;线程开始&quot;);</span><br><span class="line">        &#x2F;&#x2F;获取到当前线程</span><br><span class="line">        self.thread &#x3D; [NSThread currentThread];</span><br><span class="line">        </span><br><span class="line">        NSRunLoop *runloop &#x3D; [NSRunLoop currentRunLoop];</span><br><span class="line">        &#x2F;&#x2F;添加一个Port，同理为了防止runloop没事干直接退出</span><br><span class="line">        [runloop addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode];</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;运行一个runloop，[NSDate distantFuture]：很久很久以后才让它失效</span><br><span class="line">        [runloop runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]];</span><br><span class="line">        </span><br><span class="line">        NSLog(@&quot;线程结束&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        &#x2F;&#x2F;在我们开启的异步线程调用方法</span><br><span class="line">        [self performSelector:@selector(recieveMsg) onThread:self.thread withObject:nil waitUntilDone:NO];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)recieveMsg</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;收到消息了，在这个线程：%@&quot;,[NSThread currentThread]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2016-11-22 14:04:15.250 TestRunloop3[70591:1742754] 线程开始</span><br><span class="line">2016-11-22 14:04:17.250 TestRunloop3[70591:1742754] 收到消息了，在这个线程：&lt;NSThread: 0x600000263c80&gt;&#123;number &#x3D; 3, name &#x3D; (null)&#125;</span><br><span class="line">2016-11-22 14:04:17.250 TestRunloop3[70591:1742754] 线程结束</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在这里我们用了<code>performSelector: onThread...</code>这个方法去进行线程间通信，这只是其中一种最简单的方式。但是缺点也很明显，就是在去调用这个线程的时候，<code>如果线程已经不存在了</code>，程序就会<code>crash</code>。后面我们会仔细讲各种线程间的通信。</p>
<h3 id="线程为什么会结束呢？"><a href="#线程为什么会结束呢？" class="headerlink" title="线程为什么会结束呢？"></a>线程为什么会结束呢？</h3><p>我们先看一下RunLoop的源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; RunLoop的实现</span><br><span class="line">int CFRunLoopRunSpecific(runloop, modeName, seconds, stopAfterHandle) &#123;</span><br><span class="line">     </span><br><span class="line">    &#x2F;&#x2F;&#x2F; 首先根据modeName找到对应mode</span><br><span class="line">    CFRunLoopModeRef currentMode &#x3D; __CFRunLoopFindMode(runloop, modeName, false);</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 如果mode里没有source&#x2F;timer&#x2F;observer, 直接返回。</span><br><span class="line">    if (__CFRunLoopModeIsEmpty(currentMode)) return;</span><br><span class="line">     </span><br><span class="line">    &#x2F;&#x2F;&#x2F; 1. 通知 Observers: RunLoop 即将进入 loop。</span><br><span class="line">    __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopEntry);</span><br><span class="line">     </span><br><span class="line">    &#x2F;&#x2F;&#x2F; 内部函数，进入loop</span><br><span class="line">    __CFRunLoopRun(runloop, currentMode, seconds, returnAfterSourceHandled) &#123;</span><br><span class="line">         </span><br><span class="line">        Boolean sourceHandledThisLoop &#x3D; NO;</span><br><span class="line">        int retVal &#x3D; 0;</span><br><span class="line">        do &#123;</span><br><span class="line">  </span><br><span class="line">            &#x2F;&#x2F;&#x2F; 2. 通知 Observers: RunLoop 即将触发 Timer 回调。</span><br><span class="line">            __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeTimers);</span><br><span class="line">            &#x2F;&#x2F;&#x2F; 3. 通知 Observers: RunLoop 即将触发 Source0 (非port) 回调。</span><br><span class="line">            __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeSources);</span><br><span class="line">            &#x2F;&#x2F;&#x2F; 执行被加入的block</span><br><span class="line">            __CFRunLoopDoBlocks(runloop, currentMode);</span><br><span class="line">             </span><br><span class="line">            &#x2F;&#x2F;&#x2F; 4. RunLoop 触发 Source0 (非port) 回调。</span><br><span class="line">            sourceHandledThisLoop &#x3D; __CFRunLoopDoSources0(runloop, currentMode, stopAfterHandle);</span><br><span class="line">            &#x2F;&#x2F;&#x2F; 执行被加入的block</span><br><span class="line">            __CFRunLoopDoBlocks(runloop, currentMode);</span><br><span class="line">  </span><br><span class="line">            &#x2F;&#x2F;&#x2F; 5. 如果有 Source1 (基于port) 处于 ready 状态，直接处理这个 Source1 然后跳转去处理消息。</span><br><span class="line">            if (__Source0DidDispatchPortLastTime) &#123;</span><br><span class="line">                Boolean hasMsg &#x3D; __CFRunLoopServiceMachPort(dispatchPort, &amp;msg)</span><br><span class="line">                if (hasMsg) goto handle_msg;</span><br><span class="line">            &#125;</span><br><span class="line">             </span><br><span class="line">            &#x2F;&#x2F;&#x2F; 6.通知 Observers: RunLoop 的线程即将进入休眠(sleep)。</span><br><span class="line">            if (!sourceHandledThisLoop) &#123;</span><br><span class="line">                __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeWaiting);</span><br><span class="line">            &#125;</span><br><span class="line">             </span><br><span class="line">            &#x2F;&#x2F;&#x2F; 7. 调用 mach_msg 等待接受 mach_port 的消息。线程将进入休眠, 直到被下面某一个事件唤醒。</span><br><span class="line">            &#x2F;&#x2F;&#x2F; ? 一个基于 port 的Source 的事件。</span><br><span class="line">            &#x2F;&#x2F;&#x2F; ? 一个 Timer 到时间了</span><br><span class="line">            &#x2F;&#x2F;&#x2F; ? RunLoop 自身的超时时间到了</span><br><span class="line">            &#x2F;&#x2F;&#x2F; ? 被其他什么调用者手动唤醒</span><br><span class="line">            __CFRunLoopServiceMachPort(waitSet, &amp;msg, sizeof(msg_buffer), &amp;livePort) &#123;</span><br><span class="line">                mach_msg(msg, MACH_RCV_MSG, port); &#x2F;&#x2F; thread wait for receive msg</span><br><span class="line">            &#125;</span><br><span class="line">  </span><br><span class="line">            &#x2F;&#x2F;&#x2F; 8. 通知 Observers: RunLoop 的线程刚刚被唤醒了。</span><br><span class="line">            __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopAfterWaiting);</span><br><span class="line">             </span><br><span class="line">            &#x2F;&#x2F;&#x2F; 9.收到消息，处理消息。</span><br><span class="line">            handle_msg:</span><br><span class="line">  </span><br><span class="line">            &#x2F;&#x2F;&#x2F; 10.1 如果一个 Timer 到时间了，触发这个Timer的回调。</span><br><span class="line">            if (msg_is_timer) &#123;</span><br><span class="line">                __CFRunLoopDoTimers(runloop, currentMode, mach_absolute_time())</span><br><span class="line">            &#125; </span><br><span class="line">  </span><br><span class="line">            &#x2F;&#x2F;&#x2F; 10.2 如果有dispatch到main_queue的block，执行block。</span><br><span class="line">            else if (msg_is_dispatch) &#123;</span><br><span class="line">                __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg);</span><br><span class="line">            &#125; </span><br><span class="line">  </span><br><span class="line">            &#x2F;&#x2F;&#x2F; 10.3 如果一个 Source1 (基于port) 发出事件了，处理这个事件</span><br><span class="line">            else &#123;</span><br><span class="line">                CFRunLoopSourceRef source1 &#x3D; __CFRunLoopModeFindSourceForMachPort(runloop, currentMode, livePort);</span><br><span class="line">                sourceHandledThisLoop &#x3D; __CFRunLoopDoSource1(runloop, currentMode, source1, msg);</span><br><span class="line">                if (sourceHandledThisLoop) &#123;</span><br><span class="line">                    mach_msg(reply, MACH_SEND_MSG, reply);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">             </span><br><span class="line">            &#x2F;&#x2F;&#x2F; 执行加入到Loop的block</span><br><span class="line">            __CFRunLoopDoBlocks(runloop, currentMode);</span><br><span class="line">             </span><br><span class="line">  </span><br><span class="line">            if (sourceHandledThisLoop &amp;&amp; stopAfterHandle) &#123;</span><br><span class="line">                &#x2F;&#x2F;&#x2F; 进入loop时参数说处理完事件就返回。</span><br><span class="line">                retVal &#x3D; kCFRunLoopRunHandledSource;</span><br><span class="line">            &#125; else if (timeout) &#123;</span><br><span class="line">                &#x2F;&#x2F;&#x2F; 超出传入参数标记的超时时间了</span><br><span class="line">                retVal &#x3D; kCFRunLoopRunTimedOut;</span><br><span class="line">            &#125; else if (__CFRunLoopIsStopped(runloop)) &#123;</span><br><span class="line">                &#x2F;&#x2F;&#x2F; 被外部调用者强制停止了</span><br><span class="line">                retVal &#x3D; kCFRunLoopRunStopped;</span><br><span class="line">            &#125; else if (__CFRunLoopModeIsEmpty(runloop, currentMode)) &#123;</span><br><span class="line">                &#x2F;&#x2F;&#x2F; source&#x2F;timer&#x2F;observer一个都没有了</span><br><span class="line">                retVal &#x3D; kCFRunLoopRunFinished;</span><br><span class="line">            &#125;</span><br><span class="line">             </span><br><span class="line">            &#x2F;&#x2F;&#x2F; 如果没超时，mode里没空，loop也没被停止，那继续loop。</span><br><span class="line">        &#125; while (retVal &#x3D;&#x3D; 0);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    &#x2F;&#x2F;&#x2F; 11. 通知 Observers: RunLoop 即将退出。</span><br><span class="line">    __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>大概流程是这样的：</p>
<blockquote>
<p>1、函数的主体是一个do,while循环，用一个变量retVal，来控制循环的执行。默认为0，无限循环。<br>2、刚进入循环1，2，3，4，5在做一件事，就是检查是否有事件需要处理，如果有的话，就直接跳到9去处理事件。<br>3、处理完事件之后，到第10，会去判断4种是否应该跳出循环的情况，给变量retVal赋一个不为0的值，来跳出循环。<br>4、如果走到6，则判断没有事做，那么runloop就睡眠了，停在第7行，这一行</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">__CFRunLoopServiceMachPort(waitSet, &amp;msg, <span class="keyword">sizeof</span>(msg_buffer), &amp;livePort)</span><br><span class="line"> &#123; </span><br><span class="line">      <span class="comment">// thread wait for receive msg </span></span><br><span class="line">      mach_msg(msg, MACH_RCV_MSG, port); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">这一行类似sync这样的一个同步机制（其实不是，举个例子。。）</span><br><span class="line">，把程序阻塞在这一行，直到有消息返回值，才继续往下进行。</span><br><span class="line">这一阻塞操作是系统内核来挂起的，阻塞了当前的线程，</span><br><span class="line">当有消息返回时，因为当前线程是被阻塞的，</span><br><span class="line">系统内核会再开辟一个新的线程去返回这个消息。</span><br><span class="line">然后程序继续往下进行。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>5、走到第8、9，通知Observers，然后处理事件。<br>6、到10，去判断是否退出循环的条件，如果满足条件退出循环，runloop结束。反之，又从新开始循环，从2开始。</p>
</blockquote>
<p>那为什么执行完之后RunLoop会退出呢？</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (sourceHandledThisLoop &amp;&amp; stopAfterHandle)</span><br><span class="line">&#123; </span><br><span class="line">    <span class="comment">/// 进入loop时参数说处理完事件就返回。 </span></span><br><span class="line">    retVal = kCFRunLoopRunHandledSource; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种形式开启的runloop, stopAfterHandle这个参数为YES，<br>而sourceHandledThisLoop这个参数在如下代码中被赋值为YES：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 10.3 如果一个 Source1 (基于port) 发出事件了，处理这个事件</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">CFRunLoopSourceRef</span> source1 = __CFRunLoopModeFindSourceForMachPort(runloop, currentMode, livePort);</span><br><span class="line">    sourceHandledThisLoop = __CFRunLoopDoSource1(runloop, currentMode, source1, msg);</span><br><span class="line">    <span class="keyword">if</span> (sourceHandledThisLoop) &#123;</span><br><span class="line">        mach_msg(reply, MACH_SEND_MSG, reply);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>所以在这里我们触发了事件之后，runloop被退出了，这时候我们也明白了为什么timer并不会导致runloop的退出。</p>
<h3 id="Core-Foundation中运行runloop的接口"><a href="#Core-Foundation中运行runloop的接口" class="headerlink" title="Core Foundation中运行runloop的接口"></a>Core Foundation中运行runloop的接口</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;运行 CFRunLoopRef</span><br><span class="line">void CFRunLoopRun();</span><br><span class="line">&#x2F;&#x2F;运行 CFRunLoopRef: 参数为运行模式、时间和是否在处理Input Source后退出标志，返回值是exit原因</span><br><span class="line">SInt32 CFRunLoopRunInMode (mode, seconds, returnAfterSourceHandled);</span><br><span class="line">&#x2F;&#x2F;停止运行 CFRunLoopRef</span><br><span class="line">void CFRunLoopStop( CFRunLoopRef rl );</span><br><span class="line">&#x2F;&#x2F;唤醒 CFRunLoopRef</span><br><span class="line">void CFRunLoopWakeUp ( CFRunLoopRef rl );</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="下面详细介绍一下："><a href="#下面详细介绍一下：" class="headerlink" title="下面详细介绍一下："></a>下面详细介绍一下：</h4><p><code>void CFRunLoopRun();</code></p>
<ul>
<li>运行在默认的kCFRunLoopDefaultMode模式下，直到使用CFRunLoopStop接口停止这个Run Loop，或者Run Loop的所有事件源都被删除。</li>
<li>NSRunloop是基于CFRunloop来封装的，NSRunloop是线程不安全的，而CFRunloop则是线程安全的。</li>
</ul>
<p><code>注意</code>:在这里我们可以看到和上面<code>NSRunloop</code>有一个直观的区别就是，<code>CFRunLoopStop</code>能直接停止掉所有用<code>CFRunloop</code>运行起<code>runloop</code></p>
<p>现在回忆一下上面<br><code>- (BOOL)runMode:(NSString *)mode beforeDate:(NSDate *)limitDate;</code><br>这个方法也是可以用<code>CFRunLoopStop</code>来停止 其实这是因为上面的方法是依据：<br><code>SInt32 CFRunLoopRunInMode (mode, seconds, returnAfterSourceHandled); </code><br>这个方法实现的,可以明显的看出参数是一模一样的,前者默认returnAfterSourceHandled参数为YES，当触发一个非timer事件后，runloop就终止了</p>
<p><code>SInt32 CFRunLoopRunInMode (mode, seconds, returnAfterSourceHandled); </code><br>其中</p>
<ul>
<li>第一个参数是指RunLoop运行的模式（例如kCFRunLoopDefaultMode或者kCFRunLoopCommonModes），</li>
<li>第二个参数是运行时间，第三个参数是是否在处理事件后让Run Loop退出返回，NSRunloop的第三种开启runloop的方法，综上述，我们知道，实际上就是设置stopAfterHandle这个参数为YES</li>
<li>我们知道调用runloop运行，代码是停在这一行不返回的，当返回的时候runloop就结束了，所以这个返回值就是runloop结束原因的返回，为一个枚举值，具体原因如下</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">    kCFRunLoopRunFinished = <span class="number">1</span>, <span class="comment">//Run Loop结束，没有Timer或者其他Input Source</span></span><br><span class="line">    kCFRunLoopRunStopped = <span class="number">2</span>, <span class="comment">//Run Loop被停止，使用CFRunLoopStop停止Run Loop</span></span><br><span class="line">    kCFRunLoopRunTimedOut = <span class="number">3</span>, <span class="comment">//Run Loop超时</span></span><br><span class="line">    kCFRunLoopRunHandledSource = <span class="number">4</span> <span class="comment">////Run Loop处理完事件，注意Timer事件的触发是不会让Run Loop退出返回的，即使CFRunLoopRunInMode的第三个参数是YES也不行</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>看到这，我们发现我们忽略了NSRunloop第三种开启方式的返回值。<br><code>- (BOOL)runMode:(NSString *)mode beforeDate:(NSDate *)limitDate;</code></p>
<p>它其实就是基于<code>CFRunLoopRunInMode</code>封装的，它的返回值为一个Bool值，如果是<code>PerfromSelector***</code>事件或者其他<code>Input Source</code>事件触发处理后，<code>RunLoop</code>会退出返回YES，其他返回NO。</p>
<p>下面举个例子来验证这个问题：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)testDemo2</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;starting thread.......&quot;</span>);</span><br><span class="line">        <span class="built_in">NSTimer</span> *timer = [<span class="built_in">NSTimer</span> timerWithTimeInterval:<span class="number">1</span> target:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(doTimerTask1:) userInfo:remotePort repeats:<span class="literal">YES</span>];</span><br><span class="line">        [[<span class="built_in">NSRunLoop</span> currentRunLoop] addTimer:timer forMode:<span class="built_in">NSDefaultRunLoopMode</span>];</span><br><span class="line">            </span><br><span class="line">        <span class="comment">//最后一个参数，是否处理完事件返回,结束runLoop</span></span><br><span class="line">        SInt32 result = <span class="built_in">CFRunLoopRunInMode</span>(kCFRunLoopDefaultMode, <span class="number">100</span>, <span class="literal">YES</span>);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         kCFRunLoopRunFinished = 1, //Run Loop结束，没有Timer或者其他Input Source</span></span><br><span class="line"><span class="comment">         kCFRunLoopRunStopped = 2, //Run Loop被停止，使用CFRunLoopStop停止Run Loop</span></span><br><span class="line"><span class="comment">         kCFRunLoopRunTimedOut = 3, //Run Loop超时</span></span><br><span class="line"><span class="comment">         kCFRunLoopRunHandledSource = 4 ////Run Loop处理完事件，注意Timer事件的触发是不会让Run Loop退出返回的，即使CFRunLoopRunInMode的第三个参数是YES也不行</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">switch</span> (result) &#123;</span><br><span class="line">            <span class="keyword">case</span> kCFRunLoopRunFinished:</span><br><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@&quot;kCFRunLoopRunFinished&quot;</span>);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> kCFRunLoopRunStopped:</span><br><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@&quot;kCFRunLoopRunStopped&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> kCFRunLoopRunTimedOut:</span><br><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@&quot;kCFRunLoopRunTimedOut&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> kCFRunLoopRunHandledSource:</span><br><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@&quot;kCFRunLoopRunHandledSource&quot;</span>);</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;end thread.......&quot;</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)doTimerTask1:(<span class="built_in">NSTimer</span> *)timer</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    count++;</span><br><span class="line">    <span class="keyword">if</span> (count == <span class="number">2</span>) &#123;</span><br><span class="line">        [timer invalidate];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;do timer task count:%d&quot;</span>,count);</span><br></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">2016-11-23 09:19:28.342 TestRunloop3[88598:1971412] starting thread.......</span><br><span class="line">2016-11-23 09:19:29.347 TestRunloop3[88598:1971412] do timer task count:1</span><br><span class="line">2016-11-23 09:19:30.345 TestRunloop3[88598:1971412] do timer task count:2</span><br><span class="line">2016-11-23 09:19:30.348 TestRunloop3[88598:1971412] kCFRunLoopRunFinished</span><br><span class="line">2016-11-23 09:19:30.348 TestRunloop3[88598:1971412] end thread.......</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>很清楚的可以看到，当timer被置无效的时候，runloop里面没有了任何的事件源，所以退出了，退出原因为：kCFRunLoopRunFinished，线程也就结束了。</code></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="RunLoop停止和取消的方法"><a href="#RunLoop停止和取消的方法" class="headerlink" title="RunLoop停止和取消的方法"></a>RunLoop停止和取消的方法</h3><blockquote>
<p>1、移除掉runloop中的所有事件源（timer和source）<br>2、设置一个超时时间。<br>3、只要CFRunloop运行起来就可以用：<br>    <code>void CFRunLoopStop( CFRunLoopRef rl );</code>去停止。<br>4、除此之外用NSRunLoop下面这个方法运行也能使用<br>     <code>void CFRunLoopStop( CFRunLoopRef rl );</code>停止：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[NSRunLoop currentRunLoop]runMode:&lt;#(nonnull</span><br><span class="line"> NSRunLoopMode)#&gt; beforeDate:&lt;#(nonnull NSDate *)#&gt;</span><br></pre></td></tr></table></figure>

<p>实际过程中，可以根据需求，我们可以设置一个自己的Bool值，<br>  来控制runloop的开始与停止,类似下面这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  while (!cancel) &#123;</span><br><span class="line">CFRunLoopRunInMode(kCFRunLoopDefaultMode, 1, YES);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>每次runloop只运行1秒就停止，然后开始下一次的runloop。</li>
<li>这里最后一个参数设置为YES，当有非timer事件进来，也会立即开始下一次runloop。</li>
<li>当然每次进来我们都可以去修改Mode的值，这样我们可以让runloop每次都运行在不同的模式下。</li>
<li>当我们不需要runloop的时候，直接将cancel置为YES即可</li>
</ul>
<h2 id="基于runloop的线程通信"><a href="#基于runloop的线程通信" class="headerlink" title="基于runloop的线程通信"></a>基于runloop的线程通信</h2><p>首先明确一个概念，线程间的通信（不仅限于通信，几乎所有iOS事件都是如此），实际上是各种输入源，触发runloop去处理对应的事件，所以我们先来讲讲输入源：</p>
<p>输入源异步的发送消息给你的线程。事件来源取决于输入源的种类：</p>
<ul>
<li>基于端口的输入源和自定义输入源。基于端口的输入源监听程序相应的端口。自定义输入源则监听自定义的事件源。</li>
</ul>
<p>至于run loop，它不关心输入源的是基于端口的输入源还是自定义的输入源。系统会实现两种输入源供你使用。两类输入源的区别在于：</p>
<ul>
<li>基于端口的输入源由内核自动发送，而自定义的则需要人工从其他线程发送。</li>
</ul>
<p>当你创建输入源，你需要将其分配给<code>RunLoop</code>中的一个或多个模式。模式只会在特定事件影响监听的源。大多数情况下，<code>RunLoop</code>运行在默认模式下，但是你也可以使其运行在自定义模式。若某一源在当前模式下不被监听，那么任何其生成的消息只在<code>RunLoop</code>运行在其关联的模式下才会被传递。</p>
<h3 id="基于端口的输入源"><a href="#基于端口的输入源" class="headerlink" title="基于端口的输入源:"></a>基于端口的输入源:</h3><p>在<code>RunLoop</code>中，被定义名为<code>souce1</code>。Cocoa和Core Foundation内置支持使用端口相关的对象和函数来创建的基于端口的源。例如，在Cocoa里面你从来不需要直接创建输入源。你只要简单的创建端口对象，并使用<code>NSPort</code>的方法把该端口添加到<code>Run Loop</code>。端口对象会自己处理创建和配置输入源。</p>
<p>在Core Foundation，你必须人工创建端口和它的<code>RunLoop</code>源.在两种情况下，你都可以使用端口相关的函数（CFMachPortRef，CFMessagePortRef，CFSocketRef）来创建合适的对象。</p>
<p>这里用Cocoa里的举个例子，Cocoa里用来线程间传值的是NSMachPort，它的父类是NSPort。<br>首先我们看下面：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NSPort *port1 &#x3D; [[NSPort alloc]init];</span><br><span class="line">NSPort *port2 &#x3D; [[NSMachPort alloc]init];</span><br><span class="line">NSPort *port3 &#x3D; [NSPort port];</span><br><span class="line">NSPort *port4 &#x3D; [NSMachPort port];</span><br></pre></td></tr></table></figure>
<p>我们打断点可以看到如下：<br><img src="http://upload-images.jianshu.io/upload_images/2702646-6364a8544aa941b3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="port图.png"></p>
<ul>
<li>发现我们怎么创建，都返回给我们的是NSMachPort的实例，这应该是NSPort内部做了一个消息的转发，这就有点像是一个抽象类了，它本身只是定义一些公有的属性和方法，然后利用集成它的子类去实现（只是我个人猜测。。）</li>
</ul>
<p>继续看我们写的一个利用NSMachPort来线程通信的实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">(void)testDemo3</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;&#x2F;声明两个端口 随便怎么写创建方法，返回的总是一个NSMachPort实例</span><br><span class="line">NSMachPort *mainPort &#x3D; [[NSMachPort alloc]init];</span><br><span class="line">NSPort *threadPort &#x3D; [NSMachPort port];</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;设置线程的端口的代理回调为自己</span><br><span class="line">threadPort.delegate &#x3D; self;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;给主线程runloop加一个端口</span><br><span class="line">[[NSRunLoop currentRunLoop]addPort:mainPort forMode:NSDefaultRunLoopMode];</span><br><span class="line"></span><br><span class="line">dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;添加一个Port</span><br><span class="line">  [[NSRunLoop currentRunLoop]addPort:threadPort forMode:NSDefaultRunLoopMode];</span><br><span class="line">  [[NSRunLoop currentRunLoop]runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]];</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">NSString *s1 &#x3D; @&quot;hello&quot;;</span><br><span class="line"></span><br><span class="line">NSData *data &#x3D; [s1 dataUsingEncoding:NSUTF8StringEncoding];</span><br><span class="line"></span><br><span class="line">dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">NSMutableArray *array &#x3D; [NSMutableArray arrayWithArray:@[mainPort,data]];</span><br><span class="line">&#x2F;&#x2F;过2秒向threadPort发送一条消息，第一个参数：发送时间。msgid 消息标识。</span><br><span class="line">&#x2F;&#x2F;components，发送消息附带参数。reserved：为头部预留的字节数（从官方文档上看到的，猜测可能是类似请求头的东西...）</span><br><span class="line">[threadPort sendBeforeDate:[NSDate date] msgid:1000 components:array from:mainPort reserved:0];</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个NSMachPort收到消息的回调，注意这个参数，可以先给一个id。如果用文档里的NSPortMessage会发现无法取值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">(void)handlePortMessage:(id)message</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;收到消息了，线程为：%@&quot;,[NSThread currentThread]);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;只能用KVC的方式取值</span><br><span class="line">NSArray *array &#x3D; [message valueForKeyPath:@&quot;components&quot;];</span><br><span class="line"></span><br><span class="line">NSData *data &#x3D; array[1];</span><br><span class="line">NSString *s1 &#x3D; [[NSString alloc]initWithData:data encoding:NSUTF8StringEncoding];</span><br><span class="line">NSLog(@&quot;%@&quot;,s1);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; NSMachPort *localPort &#x3D; [message valueForKeyPath:@&quot;localPort&quot;];</span><br><span class="line">&#x2F;&#x2F; NSMachPort *remotePort &#x3D; [message valueForKeyPath:@&quot;remotePort&quot;];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>结果打印如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2016-11-23 16:50:20.604 TestRunloop3[1322:120162] 收到消息了，线程为：&lt;NSThread: 0x60800026d700&gt;&#123;number &#x3D; 3, name &#x3D; (null)&#125;</span><br><span class="line">2016-11-23 16:50:26.551 TestRunloop3[1322:120162] hello</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p>1、我们跨越线程，确实从主线程往另一个线程发送了消息。</p>
</li>
<li><p>2、这里要注意几个点：</p>
<blockquote>
<p>1、<code>- (void)handlePortMessage:(id)message</code>这里这个代理的参数，从.h里去复制过来的为NSPortMessage类型的一个对象，但是我们发现苹果只是在.h中@class进来，我们无法调用它的任何方法。所以我们用id声明，然后通过KVC去取它的属性。</p>
</blockquote>
<blockquote>
<p>2、关于下面这个传值类型的问题：</p>
</blockquote>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSMutableArray *array &#x3D; [NSMutableArray  </span><br><span class="line">arrayWithArray:@[mainPort,data]];</span><br></pre></td></tr></table></figure>


</li>
</ul>
<p>作者在这困惑了好一会。。之前我是往数组里添加的是String或者其他类型的对象，但是发现参数传过去之后，变成nil了。于是去百度查了半天，然后没有结果。。于是去翻官方文档，终于在方法描述里看到（其实很醒目。。然而作者英文水平实在有限。。）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">The components array consists of a series of instances of some subclass of NSData, </span><br><span class="line">and instances of some subclass of NSPort; </span><br><span class="line">since one subclass of NSPort does not necessarily know  how to transport an instance of another subclass of NSPort (or could do it even if it</span><br><span class="line"></span><br><span class="line">knew about the other subclass), all of the instancesof NSPort in the components array and the</span><br><span class="line"> &#39;receivePort&#39;argument MUST be of the same subclass of NSPort that receives this message.  If </span><br><span class="line"> multiple DO transports are being used in the same program, this requires some care.</span><br></pre></td></tr></table></figure>

<p>  从这段描述中我们可以看出，<strong>这个传参数组里面只能装两种类型的数据，一种是NSPort的子类，一种是NSData的子类。</strong>所以我们如果要用这种方式传值必须得先把数据转成NSData类型的才行。</p>
<h3 id="Cocoa-执行-Selector-的源"><a href="#Cocoa-执行-Selector-的源" class="headerlink" title="Cocoa 执行 Selector 的源:"></a>Cocoa 执行 Selector 的源:</h3><p>  除了基于端口的源，Cocoa定义了自定义输入源，允许你在任何线程执行selector。它被称为source0,和基于端口的源一样，执行selector请求会在目标线程上序列化，减缓许多在线程上允许多个方法容易引起的同步问题。不像基于端口的源，一个selector执行完后会自动从run loop里面移除。</p>
<p>有方法如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[self performSelectorOnMainThread:&lt;#(nonnull SEL)#&gt; withObject:&lt;#(nullable id)#&gt; waitUntilDone:&lt;#(BOOL)#&gt;]</span><br><span class="line"></span><br><span class="line">[self performSelectorOnMainThread:&lt;#(nonnull SEL)#&gt; withObject:&lt;#(nullable id)#&gt; waitUntilDone:&lt;#(BOOL)#&gt; modes:&lt;#(nullable NSArray&lt;NSString *&gt; *)#&gt;]</span><br><span class="line"></span><br><span class="line">[self performSelector:&lt;#(nonnull SEL)#&gt; onThread:&lt;#(nonnull NSThread *)#&gt; withObject:&lt;#(nullable id)#&gt; waitUntilDone:&lt;#(BOOL)#&gt;]</span><br><span class="line"></span><br><span class="line">[self performSelector:&lt;#(nonnull SEL)#&gt; onThread:&lt;#(nonnull NSThread *)#&gt; withObject:&lt;#(nullable id)#&gt; waitUntilDone:&lt;#(BOOL)#&gt; modes:&lt;#(nullable NSArray&lt;NSString *&gt; *)#&gt;]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>这四个方法很类似，一个是在主线程去掉，一个可以指定一个线程。然后一个带Mode，一个不带。</li>
<li>大概讲一下 waitUntilDone 这个参数，顾名思义，就是是否等到结束。<br>1）如果这个值设为YES，那么就需要等到这个方法执行完，线程才能继续往下去执行。它会阻塞提交的线程。<br>2）如果为NO的话，这个调用的方法会异步的实行，不会阻塞提交线程。</li>
</ul>
<h3 id="自定义输入源"><a href="#自定义输入源" class="headerlink" title="自定义输入源:"></a>自定义输入源:</h3><p> 为了自定义输入源，必须使用 Core Foundation里面的 CGRunLoopSourceRef类型相关的函数来创建。你可以使用回调函数来配置自定义输入源。Corefondation 会在配置源的不同地方调用回调函数，处理输入时间，在源从 runloop 移除的时候清理它。<br>除了定义在事件到达时自定义输入源的行为，你也必须定义消息传递机制。源的这部分运行在单独的线程里面，并负责在数据等待处理的时候传递数据给源并源并通知它处理数据。消息传递机制的定义取决于你，但是最好不要过于复杂。<br>创建自定义的输入源包括定义以下内容：<br>1.输入源要处理的信息。<br>2.使感兴趣的客户端知道如何和输入源交互的调度例程。<br>3.处理其他任何客户端发送请求的例程。<br>4.使输入源失效的取消例程。</p>
<p>由于创建输入源来处理自定义消息，实际配置选是灵活配置的。调度<br>例程，处理例程和取消例程都是创建自定义输入源是最关键的例程。<br>二输入源其他的大部分行为都发生在这些例程的外部。比如，由于你决定数据传输到输入源的机制，还有输入源和其他线程的通信机制也<br>是由你决定。</p>
<p>下图中，程序的主线程维护了一个输入源的引用，输入源所需的自定义命令缓冲区和输入源所在的 runloop。当主线程有任务需要分发<br>给工作线程时候，**<em>主线程会给命令缓冲区发送命令和必须的信息来通知工作线程开始执行任务。（因为主线程和输入源所在工作线程<br>都可以访问命令缓冲区，因此这些访问必须是同步的）**</em>一旦命令<br>传送出去，主线程会通知输入源并且唤醒工作线程的 runloop。而一收到唤醒命令，runloop 会调用输入源的处理程序，由它来执行<br>命令缓冲区中响应的命令。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CFRunLoopRef _runLoopRef;</span><br><span class="line">CFRunLoopSourceRef _source;</span><br><span class="line">CFRunLoopSourceContext _source_context;</span><br></pre></td></tr></table></figure>

<p><img src="http://upload-images.jianshu.io/upload_images/2702646-532788b8b08ec601.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="自定义输入源.png"></p>
<p>还是一样，我们来写一个实例来讲讲自定义的输入源（注：自定义输入源，只有用CF来实现）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CFRunLoopRef _runLoopRef;</span><br><span class="line">CFRunLoopSourceRef _source;</span><br><span class="line">CFRunLoopSourceContext _source_context;</span><br></pre></td></tr></table></figure>
<p>首先我们声明3个成员变量，这是我们自定义输入源所需要的3个参数。具体我们举完例子之后再说。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">(void)testDemo4</span><br><span class="line">&#123;</span><br><span class="line">dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;</span><br><span class="line"></span><br><span class="line">  NSLog(@&quot;starting thread.......&quot;);</span><br><span class="line">  </span><br><span class="line">  _runLoopRef &#x3D; CFRunLoopGetCurrent();</span><br><span class="line">  &#x2F;&#x2F;初始化_source_context。</span><br><span class="line">  bzero(&amp;_source_context, sizeof(_source_context));</span><br><span class="line">  &#x2F;&#x2F;这里创建了一个基于事件的源，绑定了一个函数</span><br><span class="line">  _source_context.perform &#x3D; fire;</span><br><span class="line">  &#x2F;&#x2F;参数</span><br><span class="line">  _source_context.info &#x3D; &quot;hello&quot;;</span><br><span class="line">  &#x2F;&#x2F;创建一个source</span><br><span class="line">  _source &#x3D; CFRunLoopSourceCreate(NULL, 0, &amp;_source_context);</span><br><span class="line">  &#x2F;&#x2F;将source添加到当前RunLoop中去</span><br><span class="line">  CFRunLoopAddSource(_runLoopRef, _source, kCFRunLoopDefaultMode);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;开启runloop 第三个参数设置为YES，执行完一次事件后返回</span><br><span class="line">  CFRunLoopRunInMode(kCFRunLoopDefaultMode, 9999999, YES);</span><br><span class="line">  </span><br><span class="line">  NSLog(@&quot;end thread.......&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">    </span><br><span class="line">    if (CFRunLoopIsWaiting(_runLoopRef)) &#123;</span><br><span class="line">        NSLog(@&quot;RunLoop 正在等待事件输入&quot;);</span><br><span class="line">        &#x2F;&#x2F;添加输入事件</span><br><span class="line">        CFRunLoopSourceSignal(_source);</span><br><span class="line">        &#x2F;&#x2F;唤醒线程，线程唤醒后发现由事件需要处理，于是立即处理事件</span><br><span class="line">        CFRunLoopWakeUp(_runLoopRef);</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        NSLog(@&quot;RunLoop 正在处理事件&quot;);</span><br><span class="line">        &#x2F;&#x2F;添加输入事件，当前正在处理一个事件，当前事件处理完成后，立即处理当前新输入的事件</span><br><span class="line">        CFRunLoopSourceSignal(_source);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>此输入源需要处理的后台事件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static void fire(void* info)&#123;</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;我现在正在处理后台任务&quot;);</span><br><span class="line"></span><br><span class="line">printf(&quot;%s&quot;,info);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">2016-11-24 10:42:24.045 TestRunloop3[4683:238183] starting thread.......</span><br><span class="line">2016-11-24 10:42:26.045 TestRunloop3[4683:238082] RunLoop 正在等待事件输入</span><br><span class="line">2016-11-24 10:42:31.663 TestRunloop3[4683:238183] 我现在正在处理后台任务</span><br><span class="line">hello</span><br><span class="line">2016-11-24 10:42:31.663 TestRunloop3[4683:238183] end thread.......</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>例中可见我们创建一个自定义的输入源，绑定了一个函数，一个参数，并且用这个输入源，实现了线程间的通信。</p>
<p>大概讲一下：</p>
<blockquote>
<p>1、<code>CFRunLoopRef _runLoopRef;</code>就不用说了，就是CF的runloop。</p>
</blockquote>
<blockquote>
<p>2、<code>CFRunLoopSourceContext _source_context;</code>注意到例中用了一个c函数<code>bzero(&amp;_source_context, sizeof(_source_context));</code>来初始化。</p>
</blockquote>
<p>其实它本质是一个结构体如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&gt;version</span><br><span class="line">Version number of the structure. Must be 0.</span><br><span class="line">info</span><br><span class="line">An arbitrary pointer to program-defined data, which can be associated with the CFRunLoopSource</span><br><span class="line"> at creation time. This pointer is passed to all the callbacks defined in the context.</span><br><span class="line">retain</span><br><span class="line">A retain callback for your program-defined info </span><br><span class="line">pointer. Can be NULL.</span><br><span class="line">release</span><br><span class="line">A release callback for your program-defined info </span><br><span class="line">pointer. Can be NULL.</span><br><span class="line">copyDescription</span><br><span class="line">A copy description callback for your program-</span><br><span class="line">defined info pointer. Can be NULL.</span><br><span class="line">equal</span><br><span class="line">An equality test callback for your program-defined </span><br><span class="line">info pointer. Can be NULL.</span><br><span class="line">hash</span><br><span class="line">A hash calculation callback for your program-</span><br><span class="line">defined info pointer. Can be NULL.</span><br><span class="line">schedule</span><br><span class="line">A scheduling callback for the run loop source. </span><br><span class="line">This callback is called when the source is added to a run loop mode. Can be NULL.</span><br><span class="line">cancel</span><br><span class="line">A cancel callback for the run loop source. This </span><br><span class="line">callback is called when the source is removed from a run loop mode. Can be NULL.</span><br><span class="line">perform</span><br><span class="line">A perform callback for the run loop source. This </span><br><span class="line">callback is called when the source has fired.</span><br><span class="line"></span><br><span class="line">typedef struct &#123;</span><br><span class="line">CFIndex version;</span><br><span class="line">void * info;</span><br><span class="line">const void (retain)(const void info);</span><br><span class="line">void (release)(const void info);</span><br><span class="line">CFStringRef (copyDescription)(const void info);</span><br><span class="line">Boolean (equal)(const void *info1, const void info2);</span><br><span class="line">CFHashCode (hash)(const void info);</span><br><span class="line">void (schedule)(void info, CFRunLoopRef rl, CFRunLoopMode mode);</span><br><span class="line">void (cancel)(void info, CFRunLoopRef rl, CFRunLoopMode mode);</span><br><span class="line">void (perform)(void *info);</span><br><span class="line">&#125; CFRunLoopSourceContext;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p> <code>bzero(&amp;_source_context, sizeof(_source_context));</code>所以这个函数其实就是把所有内容先置为0。</p>
<p><code>CFRunLoopSourceRef _source;</code>这个是自定义输入源中最重要的一个参数。它用来连接runloop与<br>CFRunLoopSourceContext中的一些配置项，<strong>注意我们自定义的输入源，必须由我们手动来触发</strong>。需要先<br><code>CFRunLoopSourceSignal(_source);</code>在看当前runloop是否在休眠中，来看是否需要调用<br><code>CFRunLoopWakeUp(_runLoopRef);</code>(一般都是要调用的)。</p>
<h3 id="定时源"><a href="#定时源" class="headerlink" title="定时源:"></a>定时源:</h3><ul>
<li>定时源在预设的时间点同步方式传递消息。定时器是线程通知自己做某事的一种方法。</li>
<li>尽管定时器可以产生基于时间的通知，但它并不是实时机制。和输入源一样，定时器也和 runloop 的特定模式相关。如果定时器所在的模式当前未被 runloop 监视，那么定时器将不会开始知道 runloop 运行在响应的模式下。类似的。如果定时器在 runloop 处理某一事件期间开始，定时器会一直等待直到下次 runloop 开始响应的处理程序。如果 runloop 不运行了，那么定时器也永远不启动。</li>
<li>配置定时源:<br>Cocoa 中可以使用以下 NSTimer 类方法来创建并调配一个定时器:􏰂</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[NSTimer scheduledTimerWithTimeInterval:&lt;#(NSTimeInterval)#&gt; target:&lt;#(nonnull id)#&gt; selector:&lt;#(nonnull SEL)#&gt; userInfo:&lt;#(nullable id)#&gt; repeats:&lt;#(BOOL)#&gt;</span><br><span class="line"></span><br><span class="line">[NSTimer timerWithTimeInterval:&lt;#(NSTimeInterval)#&gt; target:&lt;#(nonnull id)#&gt; selector:&lt;#(nonnull SEL)#&gt; userInfo:&lt;#(nullable id)#&gt; repeats:&lt;#(BOOL)#&gt;]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当然还有Block ,invocation的形式，就不做赘述了。<br>第一种timer默认是把加到了NSDefaultRunLoopMode模式下。<br>第二种timer没有默认值，我们使用的使用必须调用<br><code>[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSDefaultRunLoopMode];</code>去给它指定一个mode。</p>
<h3 id="Core-Foundation-创建定时器"><a href="#Core-Foundation-创建定时器" class="headerlink" title="Core Foundation 创建定时器"></a>Core Foundation 创建定时器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CFRunLoopRef runLoop &#x3D; CFRunLoopGetCurrent();</span><br><span class="line">CFRunLoopTimerContext context &#x3D; &#123;0, NULL, NULL, NULL, NULL&#125;;</span><br><span class="line">CFRunLoopTimerRef timer &#x3D; CFRunLoopTimerCreate(kCFAllocatorDefault, 0.1, 0.3, 0, 0,</span><br><span class="line">&amp;myCFTimerCallback, &amp;context);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>最后用一张runloop运行时的流程图来梳理一下我们这些源触发的顺序<br><img src="http://upload-images.jianshu.io/upload_images/2702646-60d6d86082e68ce0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="RunLoop_1.png"></p>
<p>如图所示，首先我要明确一个知识点：<strong>runloop跑一圈，只能执行一个事件。</strong></p>
<p><strong>timer和source0进入runloop中，都只是通知Observer我要处理，但是还是会有 678睡眠唤醒这一步。但是source1如果有，就会直接跳到第9步去执行。</strong></p>
<p>我们前面也讲过第7步，这里再提一下。它是一直阻塞在这一行的，直到：</p>
<ul>
<li><p>a.soruce1来了。</p>
</li>
<li><p>b.定时器启动。 </p>
</li>
<li><p>c.runloop超时。</p>
</li>
<li><p>d.runloop被显示唤醒CFRunLoopWakeUp(runloop) (也就是source0来了)。</p>
<p>这里可能大家会奇怪了，之前不是说source1有的话就直接跳到第9步去执行了么？但是仔细想想，如果runloop正处在睡眠状态下，这时候有个soruce1来了，是不是也需要唤醒runloop~</p>
</li>
</ul>
<h3 id="Run-Loop的Observer"><a href="#Run-Loop的Observer" class="headerlink" title="Run Loop的Observer"></a>Run Loop的Observer</h3><p>上图提到了Observer，顺带简单讲讲吧：<br>Core Foundation层的接口可以定义一个Run Loop的观察者在— Run Loop进入以下某个状态时得到通知：</p>
<ul>
<li>Run loop的进入</li>
<li>Run loop处理一个Timer的时刻</li>
<li>Run loop处理一个Input Source的时刻</li>
<li>Run loop进入睡眠的时刻</li>
<li>Run loop被唤醒的时刻，但在唤醒它的事件被处理之前</li>
<li>Run loop的终止</li>
<li>Observer的创建以及添加到Run Loop中需要使用Core Foundation的接口：<br>方法很简单如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 创建observer</span><br><span class="line">CFRunLoopObserverRef observer &#x3D; CFRunLoopObserverCreateWithHandler(CFAllocatorGetDefault(), kCFRunLoopAllActivities, YES, 0, ^(CFRunLoopObserverRef observer, CFRunLoopActivity activity) &#123;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 添加观察者：监听RunLoop的状态</span><br><span class="line">CFRunLoopAddObserver(CFRunLoopGetCurrent(), observer, kCFRunLoopDefaultMode);</span><br><span class="line">&#x2F;&#x2F; 释放Observer</span><br><span class="line">CFRelease(observer);</span><br></pre></td></tr></table></figure>

<p> 方法就是创建一个observer，绑定一个runloop和模式，而block回调就是监听到runloop每种状态的时候会触发。</p>
<p>  其中<code>CFRunLoopActivity</code>是一枚举值，与每种状态对应：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123;</span><br><span class="line">kCFRunLoopEntry &#x3D; (1UL &lt;&lt; 0), &#x2F;&#x2F; 1 &#x2F;&#x2F; 即将进入Loop</span><br><span class="line">kCFRunLoopBeforeTimers &#x3D; (1UL &lt;&lt; 1), &#x2F;&#x2F; 2 &#x2F;&#x2F; 即将处理 Timer</span><br><span class="line">kCFRunLoopBeforeSources &#x3D; (1UL &lt;&lt; 2), &#x2F;&#x2F; 4 即将处理 Source</span><br><span class="line">kCFRunLoopBeforeWaiting &#x3D; (1UL &lt;&lt; 5), &#x2F;&#x2F; 32 &#x2F;&#x2F; 即将进入休眠</span><br><span class="line">kCFRunLoopAfterWaiting &#x3D; (1UL &lt;&lt; 6), &#x2F;&#x2F; 64</span><br><span class="line">&#x2F;&#x2F; 刚从休眠中唤醒</span><br><span class="line">kCFRunLoopExit &#x3D; (1UL &lt;&lt; 7), &#x2F;&#x2F; 128 &#x2F;&#x2F; 即将退出Loop</span><br><span class="line">kCFRunLoopAllActivities &#x3D; 0x0FFFFFFFU &#x2F;&#x2F; 可以监听以上所有状态</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="RunLoop-与线程的关系"><a href="#RunLoop-与线程的关系" class="headerlink" title="RunLoop 与线程的关系"></a>RunLoop 与线程的关系</h2><p>iOS 开发中能遇到两个线程对象: pthread_t 和 NSThread,过去苹果有份文档标明了 NSThread 只是 pthread_t 的封装，但那份文档已经失效了，现在它们也有可能都是直接包装自最底层的 mach thread。</p>
<p>苹果并没有提供这两个对象相互转换的接口，但不管怎么样，可以肯定的是 pthread_t 和 NSThread 是一一对应的。比如，你可以通过 pthread_main_thread_np() 或 [NSThread mainThread] 来获取主线程；也可以通过 pthread_self() 或 [NSThread currentThread] 来获取当前线程。CFRunLoop 是基于 pthread 来管理的。</p>
<p>苹果不允许直接创建 RunLoop，它只提供了两个自动获取的函数：CFRunLoopGetMain() 和 CFRunLoopGetCurrent()。 这两个函数内部的逻辑大概是下面这样:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; 全局的Dictionary，key 是 pthread_t， value 是 CFRunLoopRef</span><br><span class="line">static CFMutableDictionaryRef loopsDic;</span><br><span class="line">&#x2F;&#x2F;&#x2F; 访问 loopsDic 时的锁</span><br><span class="line">static CFSpinLock_t loopsLock;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;&#x2F; 获取一个 pthread 对应的 RunLoop。</span><br><span class="line">CFRunLoopRef _CFRunLoopGet(pthread_t thread) &#123;</span><br><span class="line">    OSSpinLockLock(&amp;loopsLock);</span><br><span class="line">    </span><br><span class="line">    if (!loopsDic) &#123;</span><br><span class="line">        &#x2F;&#x2F; 第一次进入时，初始化全局Dic，并先为主线程创建一个 RunLoop。</span><br><span class="line">        loopsDic &#x3D; CFDictionaryCreateMutable();</span><br><span class="line">        CFRunLoopRef mainLoop &#x3D; _CFRunLoopCreate();</span><br><span class="line">        CFDictionarySetValue(loopsDic, pthread_main_thread_np(), mainLoop);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;&#x2F; 直接从 Dictionary 里获取。</span><br><span class="line">    CFRunLoopRef loop &#x3D; CFDictionaryGetValue(loopsDic, thread));</span><br><span class="line">    </span><br><span class="line">    if (!loop) &#123;</span><br><span class="line">        &#x2F;&#x2F;&#x2F; 取不到时，创建一个</span><br><span class="line">        loop &#x3D; _CFRunLoopCreate();</span><br><span class="line">        CFDictionarySetValue(loopsDic, thread, loop);</span><br><span class="line">        &#x2F;&#x2F;&#x2F; 注册一个回调，当线程销毁时，顺便也销毁其对应的 RunLoop。</span><br><span class="line">        _CFSetTSD(..., thread, loop, __CFFinalizeRunLoop);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    OSSpinLockUnLock(&amp;loopsLock);</span><br><span class="line">    return loop;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">CFRunLoopRef CFRunLoopGetMain() &#123;</span><br><span class="line">    return _CFRunLoopGet(pthread_main_thread_np());</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">CFRunLoopRef CFRunLoopGetCurrent() &#123;</span><br><span class="line">    return _CFRunLoopGet(pthread_self());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的代码可以看出，线程和 RunLoop 之间是一一对应的，其关系是保存在一个全局的 Dictionary 里。线程刚创建时并没有 RunLoop，如果你不主动获取，那它一直都不会有。RunLoop 的创建是发生在第一次获取时，RunLoop 的销毁是发生在线程结束时。你只能在一个线程的内部获取其 RunLoop（<code>主线程除外</code>）。</p>
<h2 id="RunLoop-对外的接口"><a href="#RunLoop-对外的接口" class="headerlink" title="RunLoop 对外的接口"></a>RunLoop 对外的接口</h2><p>在 CoreFoundation 里面关于 RunLoop 有5个类:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CFRunLoopRef</span><br><span class="line">CFRunLoopModeRef</span><br><span class="line">CFRunLoopSourceRef</span><br><span class="line">CFRunLoopTimerRef</span><br><span class="line">CFRunLoopObserverRef</span><br></pre></td></tr></table></figure>

<p>其中 CFRunLoopModeRef 类并没有对外暴露，只是通过 CFRunLoopRef 的接口进行了封装。他们的关系如下:<br><img src="https://blog.ibireme.com/wp-content/uploads/2015/05/RunLoop_0.png"></p>
<p>一个 RunLoop 包含若干个 Mode，每个 Mode 又包含若干个 Source/Timer/Observer。每次调用 RunLoop 的主函数时，只能指定其中一个 Mode，这个Mode被称作 CurrentMode。如果需要切换 Mode，只能退出 Loop，再重新指定一个 Mode 进入。这样做主要是为了分隔开不同组的 Source/Timer/Observer，让其互不影响。</p>
<p><code>CFRunLoopSourceRef</code> 是事件产生的地方。Source有两个版本：<code>Source0</code> 和 <code>Source1</code>。</p>
<blockquote>
<p>Source0 只包含了一个回调（函数指针），它并不能主动触发事件。使用时，你需要先调用 <code>CFRunLoopSourceSignal(source)</code>，将这个 Source 标记为待处理，然后手动调用 <code>CFRunLoopWakeUp(runloop)</code> 来唤醒 RunLoop，让其处理这个事件。<br>Source1 包含了一个 <code>mach_port</code> 和一个回调（函数指针），被用于通过内核和其他线程相互发送消息。这种 Source 能主动唤醒 RunLoop 的线程，其原理在下面会讲到。</p>
</blockquote>
<p><code>CFRunLoopTimerRef</code> 是基于时间的触发器，它和 NSTimer 是<code>toll-free bridged</code> 的，可以混用。其包含一个时间长度和一个回调（函数指针）。当其加入到 RunLoop 时，RunLoop会注册对应的时间点，当时间点到时，RunLoop会被唤醒以执行那个回调。</p>
<p><code>CFRunLoopObserverRef</code> 是观察者，每个 Observer 都包含了一个回调（函数指针），当 RunLoop 的状态发生变化时，观察者就能通过回调接受到这个变化。可以观测的时间点有以下几个：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123;</span><br><span class="line">    kCFRunLoopEntry         &#x3D; (1UL &lt;&lt; 0), &#x2F;&#x2F; 即将进入Loop</span><br><span class="line">    kCFRunLoopBeforeTimers  &#x3D; (1UL &lt;&lt; 1), &#x2F;&#x2F; 即将处理 Timer</span><br><span class="line">    kCFRunLoopBeforeSources &#x3D; (1UL &lt;&lt; 2), &#x2F;&#x2F; 即将处理 Source</span><br><span class="line">    kCFRunLoopBeforeWaiting &#x3D; (1UL &lt;&lt; 5), &#x2F;&#x2F; 即将进入休眠</span><br><span class="line">    kCFRunLoopAfterWaiting  &#x3D; (1UL &lt;&lt; 6), &#x2F;&#x2F; 刚从休眠中唤醒</span><br><span class="line">    kCFRunLoopExit          &#x3D; (1UL &lt;&lt; 7), &#x2F;&#x2F; 即将退出Loop</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面的 <code>Source/Timer/Observer</code> 被统称为 <code>mode item</code>，一个 item 可以被同时加入多个 mode。但一个 item 被重复加入同一个 mode 时是不会有效果的。如果一个 mode 中一个 item 都没有，则 RunLoop 会直接退出，不进入循环。</p>
<h2 id="RunLoop-的-Mode"><a href="#RunLoop-的-Mode" class="headerlink" title="RunLoop 的 Mode"></a>RunLoop 的 Mode</h2><p><code>CFRunLoopMode</code> 和 <code>CFRunLoop</code> 的结构大致如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">struct __CFRunLoopMode &#123;</span><br><span class="line">    CFStringRef _name;            &#x2F;&#x2F; Mode Name, 例如 @&quot;kCFRunLoopDefaultMode&quot;</span><br><span class="line">    CFMutableSetRef _sources0;    &#x2F;&#x2F; Set</span><br><span class="line">    CFMutableSetRef _sources1;    &#x2F;&#x2F; Set</span><br><span class="line">    CFMutableArrayRef _observers; &#x2F;&#x2F; Array</span><br><span class="line">    CFMutableArrayRef _timers;    &#x2F;&#x2F; Array</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">struct __CFRunLoop &#123;</span><br><span class="line">    CFMutableSetRef _commonModes;     &#x2F;&#x2F; Set</span><br><span class="line">    CFMutableSetRef _commonModeItems; &#x2F;&#x2F; Set&lt;Source&#x2F;Observer&#x2F;Timer&gt;</span><br><span class="line">    CFRunLoopModeRef _currentMode;    &#x2F;&#x2F; Current Runloop Mode</span><br><span class="line">    CFMutableSetRef _modes;           &#x2F;&#x2F; Set</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里有个概念叫 “CommonModes”：一个 Mode 可以将自己标记为”Common”属性（通过将其 ModeName 添加到 RunLoop 的 “commonModes” 中）。每当 RunLoop 的内容发生变化时，RunLoop 都会自动将 <code>_commonModeItems</code> 里的 <code>Source/Observer/Timer</code> 同步到具有 “Common” 标记的所有Mode里。</p>
<p>应用场景举例：主线程的 RunLoop 里有两个预置的 Mode：<code>kCFRunLoopDefaultMode</code> 和 <code>UITrackingRunLoopMode</code>。这两个 Mode 都已经被标记为”Common”属性。DefaultMode 是 App 平时所处的状态，<code>TrackingRunLoopMode</code> 是追踪 ScrollView 滑动时的状态。当你创建一个 Timer 并加到 DefaultMode 时，Timer 会得到重复回调，但此时滑动一个TableView时，RunLoop 会将 mode 切换为 <code>TrackingRunLoopMode</code>，这时 Timer 就不会被回调，并且也不会影响到滑动操作。</p>
<p>有时你需要一个 Timer，在两个 Mode 中都能得到回调，一种办法就是将这个 Timer 分别加入这两个 Mode。还有一种方式，就是将 Timer 加入到顶层的 RunLoop 的 “commonModeItems” 中。”commonModeItems” 被 RunLoop 自动更新到所有具有”Common”属性的 Mode 里去。</p>
<ul>
<li>CFRunLoop对外暴露的管理 Mode 接口只有下面2个:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CFRunLoopAddCommonMode(CFRunLoopRef runloop, CFStringRef modeName);</span><br><span class="line">CFRunLoopRunInMode(CFStringRef modeName, ...);</span><br></pre></td></tr></table></figure>

<ul>
<li>Mode 暴露的管理 mode item 的接口有下面几个：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">CFRunLoopAddSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFStringRef modeName);</span><br><span class="line"></span><br><span class="line">CFRunLoopAddObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFStringRef modeName);</span><br><span class="line"></span><br><span class="line">CFRunLoopAddTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFStringRef mode);</span><br><span class="line"></span><br><span class="line">CFRunLoopRemoveSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFStringRef modeName);</span><br><span class="line"></span><br><span class="line">CFRunLoopRemoveObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFStringRef modeName);</span><br><span class="line"></span><br><span class="line">CFRunLoopRemoveTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFStringRef mode);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>你只能通过 mode name 来操作内部的 mode，当你传入一个新的 mode name 但 RunLoop 内部没有对应 mode 时，RunLoop会自动帮你创建对应的 <code>CFRunLoopModeRef</code>。对于一个 RunLoop 来说，其内部的 mode 只能增加不能删除。</p>
<p>苹果公开提供的 Mode 有两个：<code>kCFRunLoopDefaultMode (NSDefaultRunLoopMode)</code> 和 <code>UITrackingRunLoopMode</code>，你可以用这两个 Mode Name 来操作其对应的 Mode。</p>
<p>同时苹果还提供了一个操作 Common 标记的字符串：<code>kCFRunLoopCommonModes (NSRunLoopCommonModes)</code>，你可以用这个字符串来操作 Common Items，或标记一个 Mode 为 “Common”。使用时注意区分这个字符串和其他 mode name。</p>
<h2 id="苹果用-RunLoop-实现的功能"><a href="#苹果用-RunLoop-实现的功能" class="headerlink" title="苹果用 RunLoop 实现的功能"></a>苹果用 RunLoop 实现的功能</h2><h3 id="AutoreleasePool"><a href="#AutoreleasePool" class="headerlink" title="AutoreleasePool"></a>AutoreleasePool</h3><p>App启动后，苹果在主线程 RunLoop 里注册了两个 Observer，其回调都是 <code>_wrapRunLoopWithAutoreleasePoolHandler()</code>。</p>
<p>第一个 Observer 监视的事件是 <code>Entry</code>(即将进入Loop)，其回调内会调用 <code>_objc_autoreleasePoolPush()</code> 创建自动释放池。其 order 是-2147483647，优先级最高，保证创建释放池发生在其他所有回调之前。</p>
<p>第二个 Observer 监视了两个事件： <code>BeforeWaiting</code>(准备进入休眠) 时调用<code>_objc_autoreleasePoolPop()</code> 和 <code>_objc_autoreleasePoolPush()</code> 释放旧的池并创建新池；Exit(即将退出Loop) 时调用 <code>_objc_autoreleasePoolPop()</code> 来释放自动释放池。这个 Observer 的 order 是 2147483647，优先级最低，保证其释放池子发生在其他所有回调之后。</p>
<p>在主线程执行的代码，通常是写在诸如事件回调、Timer回调内的。这些回调会被 RunLoop 创建好的 AutoreleasePool 环绕着，所以不会出现内存泄漏，开发者也不必显示创建 Pool 了。</p>
<h3 id="事件响应"><a href="#事件响应" class="headerlink" title="事件响应"></a>事件响应</h3><p>苹果注册了一个 Source1 (基于 mach port 的) 用来接收系统事件，其回调函数为 <code>__IOHIDEventSystemClientQueueCallback()。</code></p>
<p>当一个硬件事件(触摸/锁屏/摇晃等)发生后，首先由 <code>IOKit.framework</code> 生成一个 <code>IOHIDEvent</code> 事件并由 <code>SpringBoard</code> 接收。这个过程的详细情况可以参考<a target="_blank" rel="noopener" href="http://iphonedevwiki.net/index.php/IOHIDFamily">这里</a>。<code>SpringBoard</code> 只接收按键(锁屏/静音等)，触摸，加速，接近传感器等几种 Event，随后用 <code>mach port</code> 转发给需要的App进程。随后苹果注册的那个 Source1 就会触发回调，并调用 <code>_UIApplicationHandleEventQueue()</code> 进行应用内部的分发。</p>
<p><code>_UIApplicationHandleEventQueue()</code> 会把 <code>IOHIDEvent</code> 处理并包装成 UIEvent 进行处理或分发，其中包括识别 UIGesture/处理屏幕旋转/发送给 UIWindow 等。通常事件比如 UIButton 点击、touchesBegin/Move/End/Cancel 事件都是在这个回调中完成的。</p>
<h3 id="手势识别"><a href="#手势识别" class="headerlink" title="手势识别"></a>手势识别</h3><p>当上面的 <code>_UIApplicationHandleEventQueue() </code>识别了一个手势时，其首先会调用 <code>Cancel</code> 将当前的 <code>touchesBegin/Move/End </code>系列回调打断。随后系统将对应的 <code>UIGestureRecognizer</code> 标记为待处理。</p>
<p>苹果注册了一个 Observer 监测 <code>BeforeWaiting</code> (Loop即将进入休眠) 事件，这个Observer的回调函数是 <code>_UIGestureRecognizerUpdateObserver()</code>，其内部会获取所有刚被标记为待处理的 GestureRecognizer，并执行GestureRecognizer的回调。</p>
<p>当有 UIGestureRecognizer 的变化(创建/销毁/状态改变)时，这个回调都会进行相应处理</p>
<h3 id="界面更新"><a href="#界面更新" class="headerlink" title="界面更新"></a>界面更新</h3><p>当在操作 UI 时，比如改变了 Frame、更新了 <code>UIView/CALayer </code>的层次时，或者手动调用了 <code>UIView/CALayer</code> 的 <code>setNeedsLayout/setNeedsDisplay</code>方法后，这个 <code>UIView/CALayer</code> 就被标记为待处理，并被提交到一个全局的容器去。</p>
<p>苹果注册了一个 Observer 监听 <code>BeforeWaiting</code>(即将进入休眠) 和 <code>Exit</code> (即将退出Loop) 事件，回调去执行一个很长的函数：<br><code>_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()</code>。这个函数里会遍历所有待处理的 <code>UIView/CAlayer</code> 以执行实际的绘制和调整，并更新 UI 界面。</p>
<h3 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h3><p>NSTimer 其实就是 <code>CFRunLoopTimerRef</code>，他们之间是 toll-free bridged 的。一个 NSTimer 注册到 RunLoop 后，RunLoop 会为其重复的时间点注册好事件。例如 10:00, 10:10, 10:20 这几个时间点。RunLoop为了节省资源，并不会在非常准确的时间点回调这个Timer。Timer 有个属性叫做 Tolerance (宽容度)，标示了当时间点到后，容许有多少最大误差。</p>
<p>如果某个时间点被错过了，例如执行了一个很长的任务，则那个时间点的回调也会跳过去，不会延后执行。就比如等公交，如果 10:10 时我忙着玩手机错过了那个点的公交，那我只能等 10:20 这一趟了。</p>
<p><code>CADisplayLink</code> 是一个和屏幕刷新率一致的定时器（但实际实现原理更复杂，和 NSTimer 并不一样，其内部实际是操作了一个 Source）。如果在两次屏幕刷新之间执行了一个长任务，那其中就会有一帧被跳过去（和 NSTimer 相似），造成界面卡顿的感觉。在快速滑动TableView时，即使一帧的卡顿也会让用户有所察觉。Facebook 开源的 AsyncDisplayLink 就是为了解决界面卡顿的问题，其内部也用到了 RunLoop，这个稍后我会再单独写一页博客来分析。</p>
<h3 id="PerformSelecter"><a href="#PerformSelecter" class="headerlink" title="PerformSelecter"></a>PerformSelecter</h3><p>当调用 NSObject 的 <code>performSelecter:afterDelay:</code> 后，实际上其内部会创建一个 Timer 并添加到当前线程的 RunLoop 中。所以如果当前线程没有 RunLoop，则这个方法会失效。</p>
<p>当调用 <code>performSelector:onThread:</code> 时，实际上其会创建一个 Timer 加到对应的线程去，同样的，如果对应线程没有 RunLoop 该方法也会失效。</p>
<h3 id="关于GCD"><a href="#关于GCD" class="headerlink" title="关于GCD"></a>关于GCD</h3><p>实际上 RunLoop 底层也会用到 GCD 的东西</p>
<p>当调用 dispatch_async(dispatch_get_main_queue(), block) 时，libDispatch 会向主线程的 RunLoop 发送消息，RunLoop会被唤醒，并从消息中取得这个 block，并在回调 <strong>CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE</strong>() 里执行这个 block。但这个逻辑仅限于 dispatch 到主线程，dispatch 到其他线程仍然是由 libDispatch 处理的。</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>至此 本次关于RunLoop的所有内容总结完成,主要是汇总下面的两篇文章,看那么长的文章其实很大程度锻炼耐心呀！</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/4d5b6fc33519">基于runloop的线程保活、销毁与通信</a><br><a target="_blank" rel="noopener" href="http://blog.ibireme.com/2015/05/18/runloop/">深入理解RunLoop</a></p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Runloop/" rel="tag"># Runloop</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2018/02/27/block-something/" rel="prev" title="block的那些事">
                  <i class="fa fa-chevron-left"></i> block的那些事
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2018/03/02/runtime-common-method/" rel="next" title="RunTime的那些事儿">
                  RunTime的那些事儿 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
  
  
  



      
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

    </div>
  </main>

  <footer class="footer">
    <div class="footer-inner">
      

      

<div class="copyright">
  
  &copy; 2015 – 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">LeeWong</span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a>
  </div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.0/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  




  <script src="/js/local-search.js"></script>












  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>






<script>
  (function() {
    function leancloudSelector(url) {
      url = encodeURI(url);
      return document.getElementById(url).querySelector('.leancloud-visitors-count');
    }

    function addCount(Counter) {
      const visitors = document.querySelector('.leancloud_visitors');
      const url = decodeURI(visitors.id);
      const title = visitors.dataset.flagTitle;

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url })))
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length > 0) {
            const counter = results[0];
            leancloudSelector(url).innerText = counter.time + 1;
            Counter('put', '/classes/Counter/' + counter.objectId, { time: { '__op': 'Increment', 'amount': 1 } })
              .catch(error => {
                console.error('Failed to save visitor count', error);
              });
          } else {
              leancloudSelector(url).innerText = 'Counter not initialized! More info at console err msg.';
              console.error('ATTENTION! LeanCloud counter has security bug, see how to solve it here: https://github.com/theme-next/hexo-leancloud-counter-security. \n However, you can still use LeanCloud without security, by setting `security` option to `false`.');
            
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    function showTime(Counter) {
      const visitors = document.querySelectorAll('.leancloud_visitors');
      const entries = [...visitors].map(element => {
        return decodeURI(element.id);
      });

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url: { '$in': entries } })))
        .then(response => response.json())
        .then(({ results }) => {
          for (let url of entries) {
            const target = results.find(item => item.url === url);
            leancloudSelector(url).innerText = target ? target.time : 0;
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    const { app_id, app_key, server_url } = {"enable":true,"app_id":"yUUAHzIjEn8fksXaNEX9VAe4-gzGzoHsz","app_key":"BVLeqEOea57puJUuekMXSvtL","server_url":null,"security":true};
    function fetchData(api_server) {
      const Counter = (method, url, data) => {
        return fetch(`${api_server}/1.1${url}`, {
          method,
          headers: {
            'X-LC-Id'     : app_id,
            'X-LC-Key'    : app_key,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };
      if (CONFIG.page.isPost) {
        if (CONFIG.hostname !== location.hostname) return;
        addCount(Counter);
      } else if (document.querySelectorAll('.post-title-link').length >= 1) {
        showTime(Counter);
      }
    }

    const api_server = app_id.slice(-9) !== '-MdYXbMMI' ? server_url : `https://${app_id.slice(0, 8).toLowerCase()}.api.lncldglobal.com`;

    if (api_server) {
      fetchData(api_server);
    } else {
      fetch('https://app-router.leancloud.cn/2/route?appId=' + app_id)
        .then(response => response.json())
        .then(({ api_server }) => {
          fetchData('https://' + api_server);
        });
    }
  })();
</script>


  

  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1.6.2/dist/gitalk.css">

<script>
NexT.utils.loadComments('#gitalk-container', () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1.6.2/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : '5f882cde7fcb86a5d699',
      clientSecret: '0d812b90fe7a94b3599b62e61b2bbaaa8134baa6',
      repo        : 'BlogComment',
      owner       : 'LeeWongSnail',
      admin       : ['LeeWongSnail'],
      id          : '7932d86c4f0b1bb70ba4734577f27586',
        language: 'zh-CN',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>

</body>
</html>
