<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.1.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.14.0/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.leewong.cn","root":"/","scheme":"Mist","version":"8.0.0-rc.5","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}};
  </script>

  <meta name="description" content="本文是系列文章《SDWebImage源码解析》中的图片下载部分，本文详细的介绍了SDWebImage在图片下载过程中所做的一些处理和对于下载操作的管理。">
<meta property="og:type" content="article">
<meta property="og:title" content="SDWebImage - 图片下载">
<meta property="og:url" content="https://www.leewong.cn/2016/01/27/SDWebImage-2/index.html">
<meta property="og:site_name" content="LeeWong">
<meta property="og:description" content="本文是系列文章《SDWebImage源码解析》中的图片下载部分，本文详细的介绍了SDWebImage在图片下载过程中所做的一些处理和对于下载操作的管理。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://images2015.cnblogs.com/blog/715314/201512/715314-20151204161948408-1934962430.png">
<meta property="og:image" content="http://images2015.cnblogs.com/blog/715314/201512/715314-20151226140749593-1190538283.png">
<meta property="article:published_time" content="2016-01-27T06:40:28.000Z">
<meta property="article:modified_time" content="2020-07-19T14:16:14.050Z">
<meta property="article:author" content="LeeWong">
<meta property="article:tag" content="SDWebImage">
<meta property="article:tag" content="下载">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://images2015.cnblogs.com/blog/715314/201512/715314-20151204161948408-1934962430.png">


<link rel="canonical" href="https://www.leewong.cn/2016/01/27/SDWebImage-2/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>SDWebImage - 图片下载 | LeeWong</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">LeeWong</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">What is Life But One Chanllege After Another</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <section class="post-toc-wrap sidebar-panel">
          <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%96%E5%B1%82%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8"><span class="nav-number">1.</span> <span class="nav-text">外层方法调用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%80%E5%A4%96%E5%B1%82%E6%96%B9%E6%B3%95%E7%9A%84%E8%B0%83%E7%94%A8"><span class="nav-number">1.1.</span> <span class="nav-text">最外层方法的调用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%9E%E5%BF%85%E8%A6%81%E5%8F%82%E6%95%B0%E7%9A%84%E5%8C%85%E8%A3%85"><span class="nav-number">1.2.</span> <span class="nav-text">非必要参数的包装</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%80%E5%A7%8B%E4%B8%8B%E8%BD%BD%E6%93%8D%E4%BD%9C%EF%BC%88%E5%8C%85%E6%8B%AC%E7%BC%93%E5%AD%98%E7%9A%84%E6%9F%A5%E6%89%BE%EF%BC%89"><span class="nav-number">2.</span> <span class="nav-text">开始下载操作（包括缓存的查找）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%96%E6%B6%88%E7%8E%B0%E6%9C%89%E7%9A%84%E5%9B%BE%E7%89%87%E7%9A%84%E4%B8%8B%E8%BD%BD%EF%BC%9A"><span class="nav-number">2.1.</span> <span class="nav-text">取消现有的图片的下载：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%A0%E4%BD%8D%E5%9B%BE%E7%89%87%E7%9A%84%E8%AE%BE%E7%BD%AE"><span class="nav-number">2.2.</span> <span class="nav-text">占位图片的设置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84%E4%B8%8B%E8%BD%BD%E6%93%8D%E4%BD%9C"><span class="nav-number">2.3.</span> <span class="nav-text">创建一个新的下载操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E7%9A%84%E6%89%A7%E8%A1%8C"><span class="nav-number">2.4.</span> <span class="nav-text">操作的执行</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BF%85%E8%A6%81%E7%9A%84%E5%8F%82%E6%95%B0completedBlock"><span class="nav-number">2.5.</span> <span class="nav-text">必要的参数completedBlock</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%B9URL%E5%81%9A%E7%89%B9%E6%AE%8A%E5%A4%84%E7%90%86"><span class="nav-number">2.6.</span> <span class="nav-text">对URL做特殊处理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%8D%E6%AC%A1%E6%96%B0%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%93%8D%E4%BD%9C"><span class="nav-number">2.7.</span> <span class="nav-text">再次新建一个操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%BB%91%E5%90%8D%E5%8D%95%E5%A4%84%E7%90%86"><span class="nav-number">2.8.</span> <span class="nav-text">黑名单处理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#URL%E6%98%AF%E5%90%A6%E5%90%88%E6%B3%95"><span class="nav-number">2.9.</span> <span class="nav-text">URL是否合法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B0%86%E6%93%8D%E4%BD%9C%E6%B7%BB%E5%8A%A0%E5%88%B0%E6%AD%A3%E5%9C%A8%E8%BF%9B%E8%A1%8C%E7%9A%84%E9%98%9F%E5%88%97%E4%B8%AD"><span class="nav-number">2.10.</span> <span class="nav-text">将操作添加到正在进行的队列中</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96cachekey"><span class="nav-number">2.11.</span> <span class="nav-text">获取cachekey</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9B%BE%E7%89%87%E7%BC%93%E5%AD%98"><span class="nav-number">2.12.</span> <span class="nav-text">图片缓存</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9B%BE%E7%89%87%E4%B8%8B%E8%BD%BD"><span class="nav-number">2.13.</span> <span class="nav-text">图片下载</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9B%BE%E7%89%87%E8%A6%81%E4%BB%8E%E7%BD%91%E7%BB%9C%E8%8E%B7%E5%8F%96%E7%9A%84%E6%9D%A1%E4%BB%B6"><span class="nav-number">2.14.</span> <span class="nav-text">图片要从网络获取的条件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9B%BE%E7%89%87%E4%B8%8B%E8%BD%BD%E7%9A%84%E6%9D%A1%E4%BB%B6"><span class="nav-number">2.15.</span> <span class="nav-text">图片下载的条件</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B0%8F%E6%8F%92%E6%9B%B2"><span class="nav-number">2.15.1.</span> <span class="nav-text">小插曲</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%98%AF%E5%90%A6%E9%9C%80%E8%A6%81%E6%9B%B4%E6%96%B0%E7%BC%93%E5%AD%98"><span class="nav-number">2.16.</span> <span class="nav-text">是否需要更新缓存</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9B%BE%E7%89%87%E4%B8%8B%E8%BD%BD%E7%9A%84%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE"><span class="nav-number">2.17.</span> <span class="nav-text">图片下载的参数设置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%80%E5%A7%8B%E4%B8%8B%E8%BD%BD"><span class="nav-number">2.18.</span> <span class="nav-text">开始下载</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B7%BB%E5%8A%A0%E8%BF%9B%E5%BA%A6%E7%9B%91%E5%90%AC"><span class="nav-number">2.19.</span> <span class="nav-text">添加进度监听</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#createCallback%E5%9B%9E%E8%B0%83%E5%86%85%E5%AE%B9"><span class="nav-number">2.20.</span> <span class="nav-text">createCallback回调内容</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%9B%BE%E7%89%87%E4%B8%8B%E8%BD%BD%E7%9A%84%E8%AF%B7%E6%B1%82"><span class="nav-number">2.20.1.</span> <span class="nav-text">创建图片下载的请求</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B7%E6%B1%82%E7%9A%84%E5%85%B6%E4%BB%96%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE"><span class="nav-number">2.20.2.</span> <span class="nav-text">请求的其他参数设置</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Header%E7%9A%84%E8%AE%BE%E7%BD%AE"><span class="nav-number">2.20.3.</span> <span class="nav-text">Header的设置</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9B%BE%E7%89%87%E4%B8%8B%E8%BD%BD%E5%AE%8C%E6%88%90%E5%90%8E%E6%98%AF%E5%90%A6%E9%9C%80%E8%A6%81%E8%A7%A3%E7%A0%81"><span class="nav-number">2.20.4.</span> <span class="nav-text">图片下载完成后是否需要解码</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81"><span class="nav-number">2.20.5.</span> <span class="nav-text">身份验证</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%8B%E8%BD%BD%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7"><span class="nav-number">2.20.6.</span> <span class="nav-text">下载的优先级</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B7%BB%E5%8A%A0%E5%88%B0%E4%B8%8B%E8%BD%BD%E9%98%9F%E5%88%97"><span class="nav-number">2.20.7.</span> <span class="nav-text">添加到下载队列</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AE%E6%93%8D%E4%BD%9C%E9%98%9F%E5%88%97%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F"><span class="nav-number">2.20.8.</span> <span class="nav-text">设置操作队列的执行顺序</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%8B%E8%BD%BD%E8%AF%B7%E6%B1%82"><span class="nav-number">2.21.</span> <span class="nav-text">下载请求</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9B%BE%E7%89%87%E4%B8%8B%E8%BD%BDprogressBlock"><span class="nav-number">2.22.</span> <span class="nav-text">图片下载progressBlock</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9B%BE%E7%89%87%E4%B8%8B%E8%BD%BD%E5%AE%8C%E6%88%90%EF%BC%88%E5%8C%85%E5%90%AB%E6%88%90%E5%8A%9F%E6%88%96%E8%80%85%E5%A4%B1%E8%B4%A5%EF%BC%89%EF%BC%9A"><span class="nav-number">2.22.1.</span> <span class="nav-text">图片下载完成（包含成功或者失败）：</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9B%BE%E7%89%87%E4%B8%8B%E8%BD%BD%E5%A4%B1%E8%B4%A5%E5%A4%84%E7%90%86"><span class="nav-number">2.23.</span> <span class="nav-text">图片下载失败处理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9B%BE%E7%89%87%E4%B8%8B%E8%BD%BD%E6%88%90%E5%8A%9F"><span class="nav-number">2.24.</span> <span class="nav-text">图片下载成功</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9B%BE%E7%89%87%E4%B8%8B%E8%BD%BD%E5%AE%8C%E6%88%90%E6%9C%80%E5%90%8E%E7%A7%BB%E9%99%A4"><span class="nav-number">2.24.1.</span> <span class="nav-text">图片下载完成最后移除</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E7%9A%84%E5%8F%96%E6%B6%88"><span class="nav-number">2.25.</span> <span class="nav-text">操作的取消</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B2%A1%E6%89%BE%E5%88%B0%E5%9B%BE%E7%89%87%EF%BC%9A"><span class="nav-number">2.26.</span> <span class="nav-text">没找到图片：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9B%BE%E7%89%87%E5%9C%A8%E6%9F%A5%E6%89%BE%E5%88%B0%E6%88%96%E8%80%85%E4%B8%8B%E8%BD%BD%E5%AE%8C%E6%88%90%E4%B9%8B%E5%90%8E%E5%9B%BE%E7%89%87%E7%9A%84%E6%98%BE%E7%A4%BA"><span class="nav-number">2.27.</span> <span class="nav-text">图片在查找到或者下载完成之后图片的显示</span></a></li></ol></li></ol></div>
      </section>
      <!--/noindex-->

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="LeeWong"
      src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gi7obtinvfj30hq0hqgme.jpg">
  <p class="site-author-name" itemprop="name">LeeWong</p>
  <div class="site-description" itemprop="description">What is Life But One Chanllege After Another</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">71</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">19</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">79</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/LeeWongSnail" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;LeeWongSnail" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/wangli_0632@163.com" title="E-Mail → wangli_0632@163.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </section>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">
      

      

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.leewong.cn/2016/01/27/SDWebImage-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://tva1.sinaimg.cn/large/007S8ZIlgy1gi7obtinvfj30hq0hqgme.jpg">
      <meta itemprop="name" content="LeeWong">
      <meta itemprop="description" content="What is Life But One Chanllege After Another">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LeeWong">
    </span>

    
    
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          SDWebImage - 图片下载
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2016-01-27 14:40:28" itemprop="dateCreated datePublished" datetime="2016-01-27T14:40:28+08:00">2016-01-27</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-07-19 22:16:14" itemprop="dateModified" datetime="2020-07-19T22:16:14+08:00">2020-07-19</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" itemprop="url" rel="index"><span itemprop="name">源码分析</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>本文是系列文章《SDWebImage源码解析》中的图片下载部分，本文详细的介绍了SDWebImage在图片下载过程中所做的一些处理和对于下载操作的管理。</p>
<a id="more"></a>


<h3 id="外层方法调用"><a href="#外层方法调用" class="headerlink" title="外层方法调用"></a>外层方法调用</h3><h4 id="最外层方法的调用"><a href="#最外层方法的调用" class="headerlink" title="最外层方法的调用"></a>最外层方法的调用</h4><p>首先，看一下使用SD进行图片下载时，调用的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[cell.imageView sd_setImageWithURL:</span><br><span class="line">			[NSURL URLWithString:</span><br><span class="line">						[_objects objectAtIndex:indexPath.row]]</span><br><span class="line">            placeholderImage:[UIImage imageNamed:@&quot;placeholder&quot;] </span><br><span class="line">            options:indexPath.row &#x3D;&#x3D; 0 ?</span><br><span class="line">				SDWebImageRefreshCached : 0];</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>很简单，需要的参数只有URL、placeholderImage和options三个,从字面的意思就可以看到<br>URL:要下载图片的URL<br>placeholderImage：要显示的占位图<br>options:下载时候的一些条件设置</p>
<h4 id="非必要参数的包装"><a href="#非必要参数的包装" class="headerlink" title="非必要参数的包装"></a>非必要参数的包装</h4><p>方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (void)sd_setImageWithURL:(NSURL *)url placeholderImage:(UIImage *)placeholder options:(SDWebImageOptions)options progress:(SDWebImageDownloaderProgressBlock)progressBlock completed:(SDWebImageCompletionBlock)completedBlock</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在最外面调用的基础上增加了两个参数<br>progress:下载进度跟进的回调<br>completed:下载完成的进度的回调</p>
<p>下面从这个方法开始，对于图片的下载过程做一个详细的分析</p>
<h3 id="开始下载操作（包括缓存的查找）"><a href="#开始下载操作（包括缓存的查找）" class="headerlink" title="开始下载操作（包括缓存的查找）"></a>开始下载操作（包括缓存的查找）</h3><h4 id="取消现有的图片的下载："><a href="#取消现有的图片的下载：" class="headerlink" title="取消现有的图片的下载："></a>取消现有的图片的下载：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[self sd_cancelCurrentImageLoad];</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>看一下具体实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">- (void)sd_cancelImageLoadOperationWithKey:(NSString *)key &#123;</span><br><span class="line">    &#x2F;&#x2F; 取消下载队列中正在进行的操作 这个方法后面会介绍</span><br><span class="line">    NSMutableDictionary *operationDictionary &#x3D; </span><br><span class="line">    								[self operationDictionary];</span><br><span class="line">    &#x2F;&#x2F;防止重复下载							</span><br><span class="line">    id operations &#x3D; [operationDictionary objectForKey:key];</span><br><span class="line">    </span><br><span class="line">    if (operations) &#123;</span><br><span class="line">        if ([operations isKindOfClass:[NSArray class]]) &#123;</span><br><span class="line">            for (id &lt;SDWebImageOperation&gt; operation</span><br><span class="line">                                               in operations)</span><br><span class="line">             &#123;</span><br><span class="line">                if (operation) &#123;</span><br><span class="line">                    [operation cancel];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else if ([operations  conformsToProtocol:</span><br><span class="line">        						@protocol(SDWebImageOperation)])</span><br><span class="line">        &#123;</span><br><span class="line">            [(id&lt;SDWebImageOperation&gt;) operations cancel];</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;将这个任务移除</span><br><span class="line">        [operationDictionary removeObjectForKey:key];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个方法是在每一次图片下载开始之前，如果存在正在下载的任务，那么现将这个任务取消，目的是为了防止重复下载。</p>
<p>获取当前的操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (NSMutableDictionary *)operationDictionary &#123;</span><br><span class="line">    NSMutableDictionary *operations &#x3D; </span><br><span class="line">    		objc_getAssociatedObject(self, &amp;loadOperationKey);</span><br><span class="line">    		</span><br><span class="line">    if (operations) &#123;</span><br><span class="line">        return operations;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    operations &#x3D; [NSMutableDictionary dictionary];</span><br><span class="line">    </span><br><span class="line">    objc_setAssociatedObject(self, &amp;loadOperationKey,</span><br><span class="line">    		 operations, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">    		 </span><br><span class="line">    return operations;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p><code>问题</code>：这里为啥非要operations是一个遵守的SDWebImageOperation的对象？</p>
<p><font color = red>这里希望大家指导一下</font></p>
<p><code>问题</code>:operations对象什么情况下会是一个数组？</p>
<p><font color = red>这里希望大家指导一下</font></p>
<p><code>问题：</code></p>
<p>每次下载之前，都把原来的下载给暂停了，是不是以为这一次只能下载一张图片？</p>
<p>解答：并不是这样的，这个方法首先是写在了UIView的分类中的，每一个UIView以及他的子类（UIButton或者UIImageView）都拥有一个operationDictionary，每次之前取消，可以理解为一个UIImageview保证对应一个URL</p>
<p>与取消对应的添加操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (void)sd_setImageLoadOperation:(id)operation forKey:(NSString *)key &#123;</span><br><span class="line">    [self sd_cancelImageLoadOperationWithKey:key];</span><br><span class="line">    NSMutableDictionary *operationDictionary &#x3D; [self </span><br><span class="line">    									operationDictionary];</span><br><span class="line">    [operationDictionary setObject:operation forKey:key];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="占位图片的设置"><a href="#占位图片的设置" class="headerlink" title="占位图片的设置"></a>占位图片的设置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">if (!(options &amp; SDWebImageDelayPlaceholder)) &#123;</span><br><span class="line">    dispatch_main_async_safe(^&#123;</span><br><span class="line">        self.image &#x3D; placeholder;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * By default, placeholder images are loaded while the image is loading. This flag will delay the loading</span><br><span class="line"> * of the placeholder image until after the image has finished loading.</span><br><span class="line"> *&#x2F;</span><br><span class="line">&#x2F;&#x2F;默认情况，占位图片在图片加载过程中会显示</span><br><span class="line">&#x2F;&#x2F;如果设置了这个属性，将会延迟占位图片的加载时间（图片加载完成之后）</span><br><span class="line"></span><br><span class="line">SDWebImageDelayPlaceholder &#x3D; 1 &lt;&lt; 9,</span><br><span class="line">主要是设置占位图片显示的时机</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果没有设置为SDWebImageDelayPlaceholder那么立即设置图片的占位图，那么如果设置了SDWebImageDelayPlaceholder这个属性之后什么时间设置占位图片呢</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if ((options &amp; SDWebImageDelayPlaceholder)) &#123;</span><br><span class="line">     wself.image &#x3D; placeholder;</span><br><span class="line">     [wself setNeedsLayout];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在图片下载完成之后，如果下载失败image = nil 时，会将占位图片设置</p>
<p>占位图片设置完成后，就开始了图片的加载，也就是本片文章的重头戏，图片缓存中查找或者图片的下载</p>
<h4 id="创建一个新的下载操作"><a href="#创建一个新的下载操作" class="headerlink" title="创建一个新的下载操作"></a>创建一个新的下载操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">id &lt;SDWebImageOperation&gt; operation &#x3D; 			</span><br><span class="line">		[SDWebImageManager.sharedManager downloadImageWithURL:url </span><br><span class="line">		options:options </span><br><span class="line">		progress:progressBlock </span><br><span class="line">		completed:^(UIImage *image, NSError *error, </span><br><span class="line">					SDImageCacheType cacheType, </span><br><span class="line">					BOOL finished, NSURL *imageURL)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>创建一个新的下载操作，并将下载操作添加到下载队列中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;添加到下载队列中</span><br><span class="line">[self sd_setImageLoadOperation:operation </span><br><span class="line">							forKey:@&quot;UIImageViewImageLoad&quot;];</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>下面的代码是在</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">id &lt;SDWebImageOperation&gt; operation &#x3D;</span><br><span class="line">	 	[SDWebImageManager.sharedManager 		</span><br><span class="line">	 					downloadImageWithURL:url </span><br><span class="line">	 					options:options</span><br><span class="line">	 					progress:progressBlock </span><br><span class="line">	 					completed:^(UIImage *image, NSError</span><br><span class="line">	 					 *error, SDImageCacheType cacheType, BOOL</span><br><span class="line">	 					 finished, NSURL *imageURL)</span><br><span class="line">&#123;</span><br><span class="line">	&#x2F;&#x2F;图片下载完成之后的操作</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="操作的执行"><a href="#操作的执行" class="headerlink" title="操作的执行"></a>操作的执行</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 如果缓存中没有给定URL对应的图片，下载这张图片，否则返回缓存的图片</span><br><span class="line"> *</span><br><span class="line"> * @param url            要下载图片的URL</span><br><span class="line"> * @param options        图片下载的request的选项设置</span><br><span class="line"> * @param progressBlock  下载进度监听的回调</span><br><span class="line"> * @param completedBlock 下载完成的回调（必要的参数不可为nil）</span><br><span class="line"> *</span><br><span class="line"> *   completedBlock</span><br><span class="line"> *   </span><br><span class="line"> *&#x2F;</span><br><span class="line">	当使用SDWebImageProgressiveDownload时，参数finished被设置为NO，图片下载的过程中这个回调将会被调用很多次返回的是一个部分图片，当图片完整下载完成的时候这个回调会在最后调用一下，设置一个完整的图片，同事将参数finished设置为YES</span><br><span class="line"></span><br><span class="line">- (id &lt;SDWebImageOperation&gt;)downloadImageWithURL:(NSURL *)url</span><br><span class="line">                                         options:(SDWebImageOptions)options</span><br><span class="line">                                        progress:(SDWebImageDownloaderProgressBlock)progressBlock</span><br><span class="line">                                       completed:(SDWebImageCompletionWithFinishedBlock)completedBlock;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>两个补充的参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">completedBlock的类型</span><br><span class="line"></span><br><span class="line">typedef void(^SDWebImageCompletionWithFinishedBlock)</span><br><span class="line"> 				(UIImage *image, NSError *error, </span><br><span class="line"> 				SDImageCacheType cacheType,</span><br><span class="line"> 	 			BOOL finished, NSURL *imageURL);</span><br><span class="line"></span><br><span class="line">SDImageCacheType类型：</span><br><span class="line"></span><br><span class="line">	typedef NS_ENUM(NSInteger, SDImageCacheType) &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * The image wasn&#39;t available the SDWebImage caches, but was</span><br><span class="line">     	 downloaded from the web.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    SDImageCacheTypeNone,</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * The image was obtained from the disk cache.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    SDImageCacheTypeDisk,</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * The image was obtained from the memory cache.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    SDImageCacheTypeMemory</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="必要的参数completedBlock"><a href="#必要的参数completedBlock" class="headerlink" title="必要的参数completedBlock"></a>必要的参数completedBlock</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Invoking this method without a completedBlock is </span><br><span class="line">	pointless</span><br><span class="line">NSAssert(completedBlock !&#x3D; nil,</span><br><span class="line">		 @&quot;If you mean to prefetch the image, use -</span><br><span class="line">		 [SDWebImagePrefetcher prefetchURLs] instead&quot;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果传入的completedBlock是nil,将会报错！！！！！<br>解释：如果没有completedBlock，将没办法给imageview设置图片，所以下面的代码就没有意义了</p>
<p><a target="_blank" rel="noopener" href="http://www.cnblogs.com/moondark/archive/2012/03/12/2392315.html">断言学习入门</a></p>
<h4 id="对URL做特殊处理"><a href="#对URL做特殊处理" class="headerlink" title="对URL做特殊处理"></a>对URL做特殊处理</h4><p>由于在某些时候，出于某些特殊的原因，Xcode不会对这里的类型匹配做出警告的提示，所以作者在这里增加了一个容错处理，允许这里传递一个字符串类型的URL</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if ([url isKindOfClass:NSString.class]) &#123;</span><br><span class="line">    url &#x3D; [NSURL URLWithString:(NSString *)url];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Prevents app crashing on argument type error like sending NSNull instead of NSURL</span><br><span class="line">if (![url isKindOfClass:NSURL.class]) &#123;</span><br><span class="line">    url &#x3D; nil;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="再次新建一个操作"><a href="#再次新建一个操作" class="headerlink" title="再次新建一个操作"></a>再次新建一个操作</h4><p> 新建了一个SDWebImageCombinedOperation对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">__block SDWebImageCombinedOperation *operation &#x3D; </span><br><span class="line">    				[SDWebImageCombinedOperation new];</span><br><span class="line">    				</span><br><span class="line">__weak SDWebImageCombinedOperation *weakOperation &#x3D; operation;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里看一下SDWebImageCombinedOperation:这是一个遵守了SDWebImageOperation协议的对象继承自NSObject，包含了一个属性cacheOperation为NSOperation类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@interface SDWebImageCombinedOperation : NSObject </span><br><span class="line">										&lt;SDWebImageOperation&gt;</span><br><span class="line"></span><br><span class="line">@property (assign, nonatomic, getter &#x3D; isCancelled) BOOL </span><br><span class="line">												     cancelled;</span><br><span class="line">												     </span><br><span class="line">@property (copy, nonatomic) SDWebImageNoParamsBlock cancelBlock;</span><br><span class="line"></span><br><span class="line">@property (strong, nonatomic) NSOperation *cacheOperation;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>注意</code>：downloadImageWithURL返回的这个id类型（遵守SDWebImageOperation协议）的对象</p>
<h4 id="黑名单处理"><a href="#黑名单处理" class="headerlink" title="黑名单处理"></a>黑名单处理</h4><p>判断当前要下载的图片的URL是否存在于黑名单中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BOOL isFailedUrl &#x3D; NO;</span><br><span class="line">  @synchronized (self.failedURLs) &#123;</span><br><span class="line">      isFailedUrl &#x3D; [self.failedURLs containsObject:url];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="URL是否合法"><a href="#URL是否合法" class="headerlink" title="URL是否合法"></a>URL是否合法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">if (url.absoluteString.length &#x3D;&#x3D; 0 </span><br><span class="line">				|| (!(options &amp; SDWebImageRetryFailed)</span><br><span class="line"> 				&amp;&amp; isFailedUrl)) </span><br><span class="line">&#123;</span><br><span class="line">    dispatch_main_sync_safe(^&#123;</span><br><span class="line">        NSError *error &#x3D; [NSError </span><br><span class="line">        	errorWithDomain:NSURLErrorDomain </span><br><span class="line">        	code:NSURLErrorFileDoesNotExist </span><br><span class="line">        	userInfo:nil];</span><br><span class="line">        completedBlock(nil, error, SDImageCacheTypeNone, YES, url);</span><br><span class="line">    &#125;);</span><br><span class="line">    return operation;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="http://blog.sina.com.cn/s/blog_71715bf801019ymq.html">如何自定义错误</a></p>
<h4 id="将操作添加到正在进行的队列中"><a href="#将操作添加到正在进行的队列中" class="headerlink" title="将操作添加到正在进行的队列中"></a>将操作添加到正在进行的队列中</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@synchronized (self.runningOperations) &#123;</span><br><span class="line">    [self.runningOperations addObject:operation];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>@synchronized</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">　　@synchronized，代表这个方法加锁, 相当于不管哪一个线程（例如线程A），运行到这个方法时,都要检查有没有其它线程例如B正在用这个方法，有的话要等正在使用synchronized方法的线程B运行完这个方法后再运行此线程A,没有的话,直接运行。它包括两种用法：synchronized 方法和 synchronized 块。</span><br><span class="line"></span><br><span class="line">@synchronized 方法控制对类（一般在IOS中用在单例中）的访问：每个类实例对应一把锁，每个 synchronized 方法都必须获得调用该方法锁方能执行，否则所属就会发生线程阻塞，方法一旦执行，就独占该锁，直到从该方法返回时才将锁释放，此后被阻塞的线程方能获得该锁，重新进入可执行状态。这种机制确保了同一时刻对于每一个类，至多只有一个处于可执行状态，从而有效避免了类成员变量的访问冲突（只要所有可能访问类的方法均被声明为 synchronized）</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="获取cachekey"><a href="#获取cachekey" class="headerlink" title="获取cachekey"></a>获取cachekey</h4><p>NSString *key = [self cacheKeyForURL:url];</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (NSString *)cacheKeyForURL:(NSURL *)url &#123;</span><br><span class="line">    if (self.cacheKeyFilter) &#123;</span><br><span class="line">        return self.cacheKeyFilter(url);</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        return [url absoluteString];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>self.cacheKeyFilter</code>是什么东西?</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;cache filter 在SDWebImageManager每次将URL转换为cache key的时候调用，功能是去掉图片URL中的动态部分</span><br><span class="line">[[SDWebImageManager sharedManager] setCacheKeyFilter:^(NSURL *url) &#123;</span><br><span class="line">    url &#x3D; [[NSURL alloc] initWithScheme:url.scheme host:url.host path:url.path];</span><br><span class="line">    return [url absoluteString];</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"> * @endcode</span><br><span class="line"> *&#x2F;</span><br><span class="line"> </span><br><span class="line"> @property (nonatomic, copy) SDWebImageCacheKeyFilterBlock cacheKeyFilter;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>cache filter 是一个SDWebImageManager每次需要讲一个URL转换为cachekey时会调用的一个方法，用来去掉图片URL中的动态部分</p>
<h4 id="图片缓存"><a href="#图片缓存" class="headerlink" title="图片缓存"></a>图片缓存</h4><p>查找这张图片有没有被缓存过，具体的缓存查找策略会在后面单独写一篇文章</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (NSOperation *)queryDiskCacheForKey:(NSString *)key done:(SDWebImageQueryCompletedBlock)doneBlock</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="图片下载"><a href="#图片下载" class="headerlink" title="图片下载"></a>图片下载</h4><p><code>下面就开始了正式的“下载” 根据第一部分的介绍，我们知道，在每次下载之前，我们都会先去缓存中查找一下，看是否存在，所以这里可以先跳到缓存看一下</code></p>
<p>如果，这张图片没有被缓存过，那么就要开始下载这张图片</p>
<h4 id="图片要从网络获取的条件"><a href="#图片要从网络获取的条件" class="headerlink" title="图片要从网络获取的条件"></a>图片要从网络获取的条件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if (operation.isCancelled) &#123;</span><br><span class="line">    @synchronized (self.runningOperations) &#123;</span><br><span class="line">    	[self.runningOperations removeObject:operation];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里的operation是一个SDWebImageCombinedOperation，具体内容跟上面的那个差不多，就不赘述了</p>
<h4 id="图片下载的条件"><a href="#图片下载的条件" class="headerlink" title="图片下载的条件"></a>图片下载的条件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if ((!image || options &amp; SDWebImageRefreshCached) </span><br><span class="line">&amp;&amp; (![self.delegate respondsToSelector:</span><br><span class="line">			@selector(imageManager:shouldDownloadImageForURL:)] || [self.delegate imageManager:self </span><br><span class="line">			shouldDownloadImageForURL:url]))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>下面来好好分析一下这个条件：<br>!image 图片存在 即缓存中没有找到<br>options &amp; SDWebImageRefreshCached:图片找到了是否需要跟新缓存（重新下载）</p>
<p>是否实现了imageManager:shouldDownloadImageForURL:方法<br>[self.delegate respondsToSelector:<br>            @selector(imageManager:shouldDownloadImageForURL:)<br>如果实现了 就执行这个方法<br>[self.delegate imageManager:self shouldDownloadImageForURL:url]</p>
<h5 id="小插曲"><a href="#小插曲" class="headerlink" title="小插曲"></a>小插曲</h5><p>imageManager:shouldDownloadImageForURL:是干啥的？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Controls which image should be downloaded when the image is not found in the cache.</span><br><span class="line"> *</span><br><span class="line"> * @param imageManager The current &#96;SDWebImageManager&#96;</span><br><span class="line"> * @param imageURL     The url of the image to be downloaded</span><br><span class="line"> *</span><br><span class="line"> * @return Return NO to prevent the downloading of the image on cache misses. If not implemented, YES is implied.</span><br><span class="line"> *&#x2F;</span><br><span class="line"> &#x2F;&#x2F;当缓存中图片不存在的时候，用这个方法来判断是否需要下载这张图片</span><br><span class="line"> &#x2F;&#x2F;返回NO来阻止图片的下载，如果没实现默认返回yes（始终下载）</span><br><span class="line">- (BOOL)imageManager:(SDWebImageManager *)imageManager shouldDownloadImageForURL:(NSURL *)imageURL;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里 我们队这整个的判断做一下分析：<br>如果图片没有缓存或者需要更新缓存 || 如果没实现代理方法则下载，实现代理方法则根据代理方法的返回值进行判断</p>
<p>判断好条件，接下来我们继续看</p>
<h4 id="是否需要更新缓存"><a href="#是否需要更新缓存" class="headerlink" title="是否需要更新缓存"></a>是否需要更新缓存</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if (image &amp;&amp; options &amp; SDWebImageRefreshCached) &#123;</span><br><span class="line">   dispatch_main_sync_safe(^&#123;</span><br><span class="line">		&#x2F;&#x2F;缓存中已经有这张图片了，但是因为要更新缓存，所以会有重新下载</span><br><span class="line">		&#x2F;&#x2F;这样是NSURLCache有机会从服务器端刷新自身缓存。</span><br><span class="line">       completedBlock(image, nil, cacheType, YES, url);</span><br><span class="line">   &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果缓存中有这张图片，但是用户设置了需要更新缓存，那么因为已经有这种图片了，所以直接调用completedBlock去显示图片，同时也会继续往后走去下载图片来更新缓存</p>
<h4 id="图片下载的参数设置"><a href="#图片下载的参数设置" class="headerlink" title="图片下载的参数设置"></a>图片下载的参数设置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">if (options &amp; SDWebImageProgressiveDownload) </span><br><span class="line">downloaderOptions |&#x3D; SDWebImageDownloaderProgressiveDownload;</span><br><span class="line"></span><br><span class="line">if (options &amp; SDWebImageRefreshCached)</span><br><span class="line"> downloaderOptions |&#x3D; SDWebImageDownloaderUseNSURLCache;</span><br><span class="line"> </span><br><span class="line">if (options &amp; SDWebImageContinueInBackground)</span><br><span class="line"> downloaderOptions |&#x3D; SDWebImageDownloaderContinueInBackground;</span><br><span class="line"> </span><br><span class="line">if (options &amp; SDWebImageHandleCookies)</span><br><span class="line"> downloaderOptions |&#x3D; SDWebImageDownloaderHandleCookies;</span><br><span class="line"> </span><br><span class="line">if (options &amp; SDWebImageAllowInvalidSSLCertificates) </span><br><span class="line">	downloaderOptions |&#x3D; 		</span><br><span class="line">			SDWebImageDownloaderAllowInvalidSSLCertificates;</span><br><span class="line">			</span><br><span class="line">if (options &amp; SDWebImageHighPriority) </span><br><span class="line">		downloaderOptions |&#x3D; SDWebImageDownloaderHighPriority;</span><br><span class="line">		</span><br><span class="line">if (image &amp;&amp; options &amp; SDWebImageRefreshCached) &#123;</span><br><span class="line">     &#x2F;&#x2F;如果设置了SDWebImageRefreshCached就不能设置SDWebImageDownloaderProgressiveDownload属性，因为，SDWebImageRefreshCached说明缓存中存在了，图片会理解执行completion方法</span><br><span class="line">     downloaderOptions &amp;&#x3D; </span><br><span class="line">     					~SDWebImageDownloaderProgressiveDownload;</span><br><span class="line"></span><br><span class="line">     &#x2F;&#x2F;如果图片下载设置了SDWebImageRefreshCached就必须设置SDWebImageDownloaderIgnoreCachedResponse 为了保证更新NSURLCache</span><br><span class="line">     downloaderOptions |&#x3D; </span><br><span class="line">     			SDWebImageDownloaderIgnoreCachedResponse;</span><br><span class="line">&#125;</span><br><span class="line">            </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="开始下载"><a href="#开始下载" class="headerlink" title="开始下载"></a>开始下载</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">id &lt;SDWebImageOperation&gt; subOperation &#x3D; [self.imageDownloader downloadImageWithURL:url options:downloaderOptions progress:progressBlock completed:^(UIImage *downloadedImage, NSData *data, NSError *error, BOOL finished)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里又新起了一个遵守SDWebImageOperation协议的subOperation</p>
<p>下面，我们到这个方法里面去看一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">__block SDWebImageDownloaderOperation *operation;</span><br><span class="line">__weak __typeof(self)wself &#x3D; self;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里创建的operation是我们图片下载的主力SDWebImageDownloaderOperation</p>
<h4 id="添加进度监听"><a href="#添加进度监听" class="headerlink" title="添加进度监听"></a>添加进度监听</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">  - (void)addProgressCallback:(SDWebImageDownloaderProgressBlock)progressBlock completedBlock:(SDWebImageDownloaderCompletedBlock)completedBlock forURL:(NSURL *)url createCallback:(SDWebImageNoParamsBlock)createCallback &#123;</span><br><span class="line">    &#x2F;&#x2F;URL不能为nil，因为在URLCallbacks中URL要作为key值，所以URL不可以为nil,如果为nil那么立即调用completedBlock返回土片数据为nil</span><br><span class="line">    if (url &#x3D;&#x3D; nil) &#123;</span><br><span class="line">        if (completedBlock !&#x3D; nil) &#123;</span><br><span class="line">            completedBlock(nil, nil, nil, NO);</span><br><span class="line">        &#125;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;一个图片的下载progressBlock可能会被执行很多次，而且很多次的执行可能并不是在同一个线程中，所以这里使用一个数组来保存</span><br><span class="line">    dispatch_barrier_sync(self.barrierQueue, ^&#123;</span><br><span class="line">        BOOL first &#x3D; NO;</span><br><span class="line">        &#x2F;&#x2F;数组保存</span><br><span class="line">        if (!self.URLCallbacks[url]) &#123;</span><br><span class="line">            self.URLCallbacks[url] &#x3D; [NSMutableArray new];</span><br><span class="line">            first &#x3D; YES;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        NSMutableArray *callbacksForURL &#x3D; </span><br><span class="line">        							self.URLCallbacks[url];</span><br><span class="line">        NSMutableDictionary *callbacks &#x3D;</span><br><span class="line">        						 [NSMutableDictionary new];</span><br><span class="line">        						 </span><br><span class="line">        if (progressBlock)</span><br><span class="line">         callbacks[kProgressCallbackKey] &#x3D; [progressBlock copy];</span><br><span class="line">         </span><br><span class="line">        if (completedBlock)</span><br><span class="line">       callbacks[kCompletedCallbackKey] &#x3D; [completedBlock copy];</span><br><span class="line">       </span><br><span class="line">        [callbacksForURL addObject:callbacks];</span><br><span class="line">        self.URLCallbacks[url] &#x3D; callbacksForURL;</span><br><span class="line">		&#x2F;&#x2F;每张图片只有在第一次回调的时候会执行createCallback（）；</span><br><span class="line">        if (first) &#123;</span><br><span class="line">            createCallback();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以通过下面这张图片来了解结构层次：<br><img src="http://images2015.cnblogs.com/blog/715314/201512/715314-20151204161948408-1934962430.png" alt="层次结构"></p>
<p><code>问题</code>：</p>
<p>同一个URL,为什么在self.URLCallbacks中对应的是一个数组？有没有可能会造成控件的浪费？<br>解答：暂时还不太清楚 先往后面看看</p>
<h4 id="createCallback回调内容"><a href="#createCallback回调内容" class="headerlink" title="createCallback回调内容"></a>createCallback回调内容</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NSTimeInterval timeoutInterval &#x3D; wself.downloadTimeout;</span><br><span class="line">if (timeoutInterval &#x3D;&#x3D; 0.0) &#123;</span><br><span class="line">     timeoutInterval &#x3D; 15.0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果用户没有主动设置下载超时timeoutInterval，则默认为15</p>
<h5 id="创建图片下载的请求"><a href="#创建图片下载的请求" class="headerlink" title="创建图片下载的请求"></a>创建图片下载的请求</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">NSMutableURLRequest *request &#x3D; [[NSMutableURLRequest alloc] </span><br><span class="line">					initWithURL:url</span><br><span class="line"> 					cachePolicy:</span><br><span class="line"> 				  (options &amp; SDWebImageDownloaderUseNSURLCache ?</span><br><span class="line">					NSURLRequestUseProtocolCachePolicy : </span><br><span class="line">					NSURLRequestReloadIgnoringLocalCacheData) </span><br><span class="line">					timeoutInterval:timeoutInterval];</span><br><span class="line"> 				  </span><br></pre></td></tr></table></figure>
<p>这里主要是设置了缓存策略和超时的时长，其中缓存策略：<br>options &amp; SDWebImageDownloaderUseNSURLCache ?<br>                    NSURLRequestUseProtocolCachePolicy :<br>                    NSURLRequestReloadIgnoringLocalCacheData</p>
<p>是否设置了SDWebImageDownloaderUseNSURLCache属性，并根据这个属性的设置设置NSURLRequest的缓存策略</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;默认情况下不使用NSURLCache，可以通过设置这个属性使用NSURLCache</span><br><span class="line"> SDWebImageDownloaderUseNSURLCache &#x3D; 1 &lt;&lt; 2,</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>三种策略关系的简述：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SDWebImageDownloaderUseNSURLCache：在SDWebImage中，缺省情况下，request是不使用NSURLCache的，但是若使用该选项，就默认使用NSURLCache默认的缓存策略：NSURLRequestUseProtocolCachePolicy。</span><br><span class="line"></span><br><span class="line">NSURLRequestUseProtocolCachePolicy：对特定的 URL 请求使用网络协议（如HTTP）中实现的缓存逻辑。这是默认的策略。该策略表示如果缓存不存在，直接从服务端获取。</span><br><span class="line">如果缓存存在，会根据response中的Cache-Control字段判断 下一步操作，如: Cache-Control字段为must-revalidata, 则 询问服务端该数据是否有更新，无更新话 直接返回给用户缓存数据，若已更新，则请求服务端.</span><br><span class="line">NSURLRequestReloadIgnoringLocalCacheData：数据需要从原始地址(一般就是重新从服务器获取)加载。不使用现有缓存</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="请求的其他参数设置"><a href="#请求的其他参数设置" class="headerlink" title="请求的其他参数设置"></a>请求的其他参数设置</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">request.HTTPShouldHandleCookies &#x3D; (options &amp;</span><br><span class="line">						 SDWebImageDownloaderHandleCookies);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 如果设置HTTPShouldHandleCookies为YES，就处理存储在</span><br><span class="line">	NSHTTPCookieStore中的cookies。</span><br><span class="line">&#x2F;&#x2F; HTTPShouldHandleCookies表示是否应该给request设置cookie并随</span><br><span class="line">	request一起发送出去。</span><br><span class="line">   SDWebImageDownloaderHandleCookies &#x3D; 1 &lt;&lt; 5,</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; HTTPShouldUsePipelining表示receiver(理解为iOS客户端)的下一个信息是否必须等到上一个请求回复才能发送。</span><br><span class="line">&#x2F;&#x2F; 如果为YES表示可以，NO表示必须等receiver收到先前的回复才能发送下个信息。</span><br><span class="line"></span><br><span class="line">request.HTTPShouldUsePipelining &#x3D; YES;</span><br></pre></td></tr></table></figure>

<h5 id="Header的设置"><a href="#Header的设置" class="headerlink" title="Header的设置"></a>Header的设置</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if (wself.headersFilter) &#123;</span><br><span class="line">    request.allHTTPHeaderFields &#x3D; wself.headersFilter(url,</span><br><span class="line">    								 [wself.HTTPHeaders copy]);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">            request.allHTTPHeaderFields &#x3D; wself.HTTPHeaders;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> &#x2F;&#x2F;设置一个过滤器来设置每一个下载图片的HTTP请求的请求头</span><br><span class="line"> &#x2F;&#x2F;这个代码块在每一个图片的下载请求中都会被调用，返回一个可以用作HTTP请求header的字典</span><br><span class="line">@property (nonatomic, copy) </span><br><span class="line">		SDWebImageDownloaderHeadersFilterBlock headersFilter;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 简单看下HTTPHeader的初始化部分（如果下载webp图片，需要的header不一样）：</span><br><span class="line">&#x2F;&#x2F; #ifdef SD_WEBP</span><br><span class="line">&#x2F;&#x2F; _HTTPHeaders &#x3D; [@&#123;@&quot;Accept&quot;: @&quot;image&#x2F;webp,image&#x2F;*;q&#x3D;0.8&quot;&#125; </span><br><span class="line">	mutableCopy];</span><br><span class="line">&#x2F;&#x2F; #else</span><br><span class="line">&#x2F;&#x2F; _HTTPHeaders &#x3D; [@&#123;@&quot;Accept&quot;: @&quot;image&#x2F;*;q&#x3D;0.8&quot;&#125; mutableCopy];</span><br><span class="line">&#x2F;&#x2F; #endif</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="图片下载完成后是否需要解码"><a href="#图片下载完成后是否需要解码" class="headerlink" title="图片下载完成后是否需要解码"></a>图片下载完成后是否需要解码</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shouldDecompressImages:图片下载完成是否需要解码</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>注意</code>：解压缩已经下载的图片或者在缓存中的图片，可以提高性能，但是会耗费很多空间，缺省情况下是要解压缩图片。</p>
<h5 id="身份验证"><a href="#身份验证" class="headerlink" title="身份验证"></a>身份验证</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">urlCredential:</span><br><span class="line"></span><br><span class="line">	web 服务可以在返回 http 响应时附带认证要求的challenge，作用是询问 http 请求的发起方是谁，这时发起方应提供正确的用户名和密码（即认证信息），然后 web 服务才会返回真正的 http 响应。</span><br><span class="line"></span><br><span class="line">	收到认证要求时，NSURLConnection 的委托对象会收到相应的消息并得到一个 NSURLAuthenticationChallenge 实例。该实例的发送方遵守 </span><br><span class="line">	</span><br><span class="line">	NSURLAuthenticationChallengeSender 协议。为了继续收到真实的数据，需要向该发送方向发回一个 NSURLCredential 实例</span><br><span class="line"></span><br><span class="line">if (wself.urlCredential) &#123;</span><br><span class="line">     operation.credential &#x3D; wself.urlCredential;</span><br><span class="line">&#125; else if (wself.username &amp;&amp; wself.password) &#123;</span><br><span class="line">     operation.credential &#x3D; [NSURLCredential </span><br><span class="line">     						credentialWithUser:wself.username</span><br><span class="line">      								   password:wself.password 			persistence:NSURLCredentialPersistenceForSession];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>NSURLCredentialPersistenceForSession表示在应用终止时，丢弃相应的 credential 。</p>
<p><a target="_blank" rel="noopener" href="http://blog.csdn.net/majiakun1/article/details/17013379">urlCredential详情参考这里</a></p>
<h5 id="下载的优先级"><a href="#下载的优先级" class="headerlink" title="下载的优先级"></a>下载的优先级</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if (options &amp; SDWebImageDownloaderHighPriority) &#123;</span><br><span class="line">    operation.queuePriority &#x3D; NSOperationQueuePriorityHigh;</span><br><span class="line">  &#125; else if (options &amp; SDWebImageDownloaderLowPriority) &#123;</span><br><span class="line">    operation.queuePriority &#x3D; NSOperationQueuePriorityLow;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个就不做过多的解释了，一看就能明白</p>
<h5 id="添加到下载队列"><a href="#添加到下载队列" class="headerlink" title="添加到下载队列"></a>添加到下载队列</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[wself.downloadQueue addOperation:operation];</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里的downloadQueue是一个NSOperationQueue</p>
<h5 id="设置操作队列的执行顺序"><a href="#设置操作队列的执行顺序" class="headerlink" title="设置操作队列的执行顺序"></a>设置操作队列的执行顺序</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if (wself.executionOrder &#x3D;&#x3D; </span><br><span class="line">					SDWebImageDownloaderLIFOExecutionOrder) &#123;</span><br><span class="line">    &#x2F;&#x2F; Emulate LIFO execution order by systematically adding new </span><br><span class="line">    	operations as last operation&#39;s dependency</span><br><span class="line">    [wself.lastAddedOperation addDependency:operation];</span><br><span class="line">     wself.lastAddedOperation &#x3D; operation;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果是先进先出，队列的结构，后来新加入的队列自然后在后面执行，如果是后进先出，栈结构 需要设置操作的依赖</p>
<p>说到这里，下面就剩下正式的发送请求</p>
<h4 id="下载请求"><a href="#下载请求" class="headerlink" title="下载请求"></a>下载请求</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">这里的参数应该是都比较清楚了，不在赘述</span><br><span class="line">- (id)initWithRequest:(NSURLRequest *)request</span><br><span class="line">              options:(SDWebImageDownloaderOptions)options</span><br><span class="line">             progress:(SDWebImageDownloaderProgressBlock)progressBlock</span><br><span class="line">            completed:(SDWebImageDownloaderCompletedBlock)completedBlock</span><br><span class="line">            cancelled:(SDWebImageNoParamsBlock)cancelBlock</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个方法的返回值也是也operation用户可以定义，默认是SDWebImageDownloaderOperation</p>
<h4 id="图片下载progressBlock"><a href="#图片下载progressBlock" class="headerlink" title="图片下载progressBlock"></a>图片下载progressBlock</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">progress:^(NSInteger receivedSize, NSInteger expectedSize) &#123;</span><br><span class="line">                                                             	SDWebImageDownloader *sself &#x3D; wself;</span><br><span class="line">	if (!sself) return;</span><br><span class="line">                                                             	__block NSArray *callbacksForURL;</span><br><span class="line">                                                             	dispatch_sync(sself.barrierQueue, ^&#123;</span><br><span class="line">                                                                 		callbacksForURL &#x3D; [sself.URLCallbacks[url] copy];</span><br><span class="line">                                                            </span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">   for (NSDictionary *callbacks in callbacksForURL) &#123;</span><br><span class="line">                                                                 		dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                                                                     			SDWebImageDownloaderProgressBlock callback &#x3D; </span><br><span class="line">                                                                     							callbacks[kProgressCallbackKey];</span><br><span class="line">                                                         	if (callback) callback(receivedSize, expectedSize);</span><br><span class="line">                                                                 &#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>注意：</code><br>这里每一个URL对应的callbacksForURL是一个数组，数组中存放的是针对同一个URL的下载过程中的一些操作，这里对于同一个URL数组中的所有内容都做更新。</p>
<p>下载完成的回调(执行回调，删除回调的保存)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">                                                        completed:^(UIImage *image, NSData *data, NSError *error, BOOL finished) &#123;</span><br><span class="line">                                                            SDWebImageDownloader *sself &#x3D; wself;</span><br><span class="line">if (!sself) return;                                                     __block NSArray *callbacksForURL;                                                dispatch_barrier_sync(sself.barrierQueue, ^&#123;</span><br><span class="line">	callbacksForURL &#x3D; [sself.URLCallbacks[url] copy];</span><br><span class="line">	if (finished) &#123;</span><br><span class="line">		[sself.URLCallbacks removeObjectForKey:url];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br><span class="line">    for (NSDictionary *callbacks in callbacksForURL) &#123;</span><br><span class="line">		SDWebImageDownloaderCompletedBlock callback </span><br><span class="line">						&#x3D;callbacks[kCompletedCallbackKey];</span><br><span class="line">                                                                if (callback) callback(image, data, error, finished);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>下载操作被取消的回调：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">                                                                                                                cancelled:^&#123;</span><br><span class="line">                                                            SDWebImageDownloader *sself &#x3D; wself;</span><br><span class="line">if (!sself) return;                                             dispatch_barrier_async(sself.barrierQueue, ^&#123;</span><br><span class="line">	[sself.URLCallbacks removeObjectForKey:url];</span><br><span class="line">&#125;);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>到目前为止，除了具体的下载细节，图片下载就基本完成了！！！开始执行下载完成的回调</p>
<h5 id="图片下载完成（包含成功或者失败）："><a href="#图片下载完成（包含成功或者失败）：" class="headerlink" title="图片下载完成（包含成功或者失败）："></a>图片下载完成（包含成功或者失败）：</h5><p>这里要注意下，突然发现当前存在着好几个operation，先通过下面这张图片，理一下层次结构</p>
<p><img src="http://images2015.cnblogs.com/blog/715314/201512/715314-20151226140749593-1190538283.png" alt="icon"></p>
<p>现在回到了SDWebImageDownloader的downloadImageWithURL:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">__strong __typeof(weakOperation) strongOperation &#x3D;</span><br><span class="line">												 weakOperation;</span><br><span class="line">												 </span><br><span class="line">if (!strongOperation || strongOperation.isCancelled) &#123;</span><br><span class="line"> &#x2F;&#x2F; Do nothing if the operation was cancelled</span><br><span class="line"> &#x2F;&#x2F; See #699 for more details</span><br><span class="line"> &#x2F;&#x2F; if we would call the completedBlock, there could be a race</span><br><span class="line">  condition between this block and another completedBlock for</span><br><span class="line">   the same object, so if this one is called second, we will </span><br><span class="line">   overwrite the new data</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>问题</code>：</p>
<p>这里的解释是：如果操作被取消了，就不执行任何操作。如果我们调用了completedBlock，那么在同一个对象的另一个completedBlock之间就存在一个竞争关系，因此，如果这个方法被重复调用两次，我们会重写新的数据</p>
<h4 id="图片下载失败处理"><a href="#图片下载失败处理" class="headerlink" title="图片下载失败处理"></a>图片下载失败处理</h4><p>确定下载失败的原因，触发下载完成的回调（返回必要信息），同时加入黑名单</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">dispatch_main_sync_safe(^&#123;</span><br><span class="line">  if (strongOperation &amp;&amp; !strongOperation.isCancelled) &#123;</span><br><span class="line">      completedBlock(nil, error, SDImageCacheTypeNone,</span><br><span class="line">       finished, url);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;);</span><br><span class="line"></span><br><span class="line"> if (error.code !&#x3D; NSURLErrorNotConnectedToInternet</span><br><span class="line">     &amp;&amp; error.code !&#x3D; NSURLErrorCancelled</span><br><span class="line">     &amp;&amp; error.code !&#x3D; NSURLErrorTimedOut</span><br><span class="line">     &amp;&amp; error.code !&#x3D; NSURLErrorInternationalRoamingOff</span><br><span class="line">     &amp;&amp; error.code !&#x3D; NSURLErrorDataNotAllowed</span><br><span class="line">     &amp;&amp; error.code !&#x3D; NSURLErrorCannotFindHost</span><br><span class="line">     &amp;&amp; error.code !&#x3D; NSURLErrorCannotConnectToHost) &#123;</span><br><span class="line">     @synchronized (self.failedURLs) &#123;</span><br><span class="line">          [self.failedURLs addObject:url];</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>注意：这里不管用户是否设置，都会将这个下载失败的URL加入到黑名单中</code></p>
<h4 id="图片下载成功"><a href="#图片下载成功" class="headerlink" title="图片下载成功"></a>图片下载成功</h4><p>判断是否为下载失败后的重试,如果是重试，那么就将这个图片从黑名单中移除</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if ((options &amp; SDWebImageRetryFailed)) &#123;</span><br><span class="line">   @synchronized (self.failedURLs) &#123;</span><br><span class="line">       [self.failedURLs removeObject:url];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>是否设置了SDWebImageRefreshCached（相同的URL 图片改变之后是否更新缓存）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if (options &amp; SDWebImageRefreshCached &amp;&amp; </span><br><span class="line">							image &amp;&amp; !downloadedImage) &#123;</span><br><span class="line">   &#x2F;&#x2F; Image refresh hit the NSURLCache cache, do not call the</span><br><span class="line">    completion block</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>图片下载完成之后，是否需要对图片进行相应的处理（根据SDWebImageTransformAnimatedImage属性，用户可进行设置）：</p>
<p>先看一下图片下载成功之后判断条件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(downloadedImage &amp;&amp; (!downloadedImage.images || (options &amp; SDWebImageTransformAnimatedImage)) &amp;&amp; [self.delegate respondsToSelector:@selector(imageManager:transformDownloadedImage:withURL:)]) </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>downloadedImage:图片下载成功</p>
<p>图片不是gif且需要在图片下载完成之后，对图片进行其他操作<br>(!downloadedImage.images || (options &amp;<br>                SDWebImageTransformAnimatedImage))</p>
<p>是否实现了图片下载完成之后形变的代理方法</p>
<p>[self.delegate respondsToSelector:@selector(imageManager:transformDownloadedImage:withURL:)</p>
<p>如果满足了上面的三个条件，表明在图片下载完成之后需要对图片进行形变：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">如果要进行形变，这个代理方法需要开发者实现</span><br><span class="line">UIImage *transformedImage &#x3D; [self.delegate imageManager:self </span><br><span class="line">		transformDownloadedImage:downloadedImage withURL:url];</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">  &#x2F;&#x2F;完成形变操作，且图片下载完成（图片没下载完成回到用这个方法吗）</span><br><span class="line"> if (transformedImage &amp;&amp; finished) &#123;</span><br><span class="line">     BOOL imageWasTransformed &#x3D;</span><br><span class="line">     			 ![transformedImage isEqual:downloadedImage];</span><br><span class="line">     &#x2F;&#x2F;图片保存</span><br><span class="line">     [self.imageCache storeImage:transformedImage </span><br><span class="line">     		 recalculateFromImage:imageWasTransformed</span><br><span class="line">      				imageData:(imageWasTransformed ? nil : data)</span><br><span class="line">      				forKey:key toDisk:cacheOnDisk];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>调用下载完成的回调</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">dispatch_main_sync_safe(^&#123;</span><br><span class="line">	&#x2F;&#x2F;operation 没有被取消</span><br><span class="line">    if (strongOperation &amp;&amp; !strongOperation.isCancelled) &#123;</span><br><span class="line">		completedBlock(transformedImage, nil, 	</span><br><span class="line">						SDImageCacheTypeNone, finished, url);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>如果不需要再图片下载完成之后，对图片进行其他的处理,那么就做一下图片的缓存同时调用图片下载完成的回调即可</code></p>
<h5 id="图片下载完成最后移除"><a href="#图片下载完成最后移除" class="headerlink" title="图片下载完成最后移除"></a>图片下载完成最后移除</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if (finished) &#123;</span><br><span class="line">   @synchronized (self.runningOperations) &#123;</span><br><span class="line">   if (strongOperation) &#123;</span><br><span class="line">     [self.runningOperations removeObject:strongOperation];</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h4 id="操作的取消"><a href="#操作的取消" class="headerlink" title="操作的取消"></a>操作的取消</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">operation.cancelBlock &#x3D; ^&#123;</span><br><span class="line">	&#x2F;&#x2F;首先取消SDWebImageDownloaderOperation</span><br><span class="line">   [subOperation cancel];</span><br><span class="line">                </span><br><span class="line">   @synchronized (self.runningOperations) &#123;</span><br><span class="line">    __strong __typeof(weakOperation) strongOperation &#x3D; </span><br><span class="line">    											weakOperation;</span><br><span class="line">    if (strongOperation) &#123;</span><br><span class="line">    	&#x2F;&#x2F;移除这一操作</span><br><span class="line">        [self.runningOperations removeObject:strongOperation];</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>注意</code>：这里取消的是operation而不是subOperation</p>
<p>operation:是一个NSOperation类型的<br>subOperation：是一个SDWebImageDownloaderOperation类型的</p>
<p>下面我们来仔细的看一下取消操作：</p>
<p> [subOperation cancel];</p>
<p>这是SDWebImageDownloaderOperation种重写的取消</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (void)cancel &#123;</span><br><span class="line">    @synchronized (self) &#123;</span><br><span class="line">        if (self.thread) &#123;</span><br><span class="line">            [self </span><br><span class="line">            performSelector:@selector(cancelInternalAndStop) </span><br><span class="line">            onThread:self.thread withObject:nil </span><br><span class="line">            					  waitUntilDone:NO];</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            [self cancelInternal];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>仔细观察一下这里的取消操作，会根据是否存在self.thread执行两个方法：</p>
<p>cancelInternalAndStop和cancelInternal</p>
<p>比较一下这两个方法可以看到cancelInternalAndStop只是比多了一句：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CFRunLoopStop(CFRunLoopGetCurrent());</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>用来停止当前线程的运行循环。</p>
<h4 id="没找到图片："><a href="#没找到图片：" class="headerlink" title="没找到图片："></a>没找到图片：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">dispatch_main_sync_safe(^&#123;</span><br><span class="line">   __strong __typeof(weakOperation) strongOperation &#x3D; </span><br><span class="line">   												weakOperation;</span><br><span class="line">   if (strongOperation &amp;&amp; !weakOperation.isCancelled) &#123;</span><br><span class="line">       completedBlock(nil, nil, SDImageCacheTypeNone, YES, url);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;);</span><br><span class="line">@synchronized (self.runningOperations) &#123;</span><br><span class="line">    [self.runningOperations removeObject:operation];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="图片在查找到或者下载完成之后图片的显示"><a href="#图片在查找到或者下载完成之后图片的显示" class="headerlink" title="图片在查找到或者下载完成之后图片的显示"></a>图片在查找到或者下载完成之后图片的显示</h4><p>SDWebImageAvoidAutoSetImage 图片下载完成之后是否立即设置给ImageView<br>在这里如果想要对图片的显示添加一些动画，我们可以从这里着手</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;下载完成之后是否自动设置图片</span><br><span class="line">   SDWebImageAvoidAutoSetImage &#x3D; 1 &lt;&lt; 11</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>图片显示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">dispatch_main_sync_safe(^&#123;</span><br><span class="line">  if (!wself) return;</span><br><span class="line">  &#x2F;&#x2F;用户是否设置了需要手动设置图片的显示</span><br><span class="line">  if (image </span><br><span class="line">  		&amp;&amp; (options &amp; SDWebImageAvoidAutoSetImage)</span><br><span class="line">   		&amp;&amp; completedBlock)</span><br><span class="line">  &#123;</span><br><span class="line">      completedBlock(image, error, cacheType, url);</span><br><span class="line">      return;</span><br><span class="line">  &#125;</span><br><span class="line">   else if (image) &#123;</span><br><span class="line">      wself.image &#x3D; image;</span><br><span class="line">      [wself setNeedsLayout];</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">   	  &#x2F;&#x2F;图片下载失败延时显示占位图片</span><br><span class="line">      if ((options &amp; SDWebImageDelayPlaceholder)) &#123;</span><br><span class="line">            wself.image &#x3D; placeholder;</span><br><span class="line">            [wself setNeedsLayout];</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F;图片下载成功之后的回调</span><br><span class="line">  if (completedBlock &amp;&amp; finished) &#123;</span><br><span class="line">       completedBlock(image, error, cacheType, url);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>



    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/SDWebImage/" rel="tag"># SDWebImage</a>
              <a href="/tags/%E4%B8%8B%E8%BD%BD/" rel="tag"># 下载</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2016/01/26/SDWebImage-1/" rel="prev" title="SDWebImage解析">
                  <i class="fa fa-chevron-left"></i> SDWebImage解析
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2016/01/27/SDWebImage-3/" rel="next" title="SDWebImage - 缓存">
                  SDWebImage - 缓存 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
  
  
  



      

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

    </div>
  </main>

  <footer class="footer">
    <div class="footer-inner">
      

      

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">LeeWong</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.0/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  















  








  

  

</body>
</html>
