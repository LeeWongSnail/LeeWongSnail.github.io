<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.1.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.14.0/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.leewong.cn","root":"/","scheme":"Muse","version":"8.0.0-rc.5","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}};
  </script>

  <meta name="description" content="最近工作，相对来说没那么忙了。自认为网络和多线程是我比较弱的模块，所以趁这段时间有空，找了一些网络多线程相关的视频看了一下，这里做一下总结。 这是第一篇，主要介绍了线程的基本概念、队列 的相关知识">
<meta property="og:type" content="article">
<meta property="og:title" content="多线程">
<meta property="og:url" content="http://www.leewong.cn/2016/03/16/multithread/index.html">
<meta property="og:site_name" content="LeeWong">
<meta property="og:description" content="最近工作，相对来说没那么忙了。自认为网络和多线程是我比较弱的模块，所以趁这段时间有空，找了一些网络多线程相关的视频看了一下，这里做一下总结。 这是第一篇，主要介绍了线程的基本概念、队列 的相关知识">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://i.niupic.com/images/2016/03/21/Kgi9Ow.png">
<meta property="og:image" content="http://i.niupic.com/images/2016/03/21/gghbm4.png">
<meta property="article:published_time" content="2016-03-15T22:19:41.000Z">
<meta property="article:modified_time" content="2020-07-19T14:12:11.066Z">
<meta property="article:author" content="LeeWong">
<meta property="article:tag" content="多线程">
<meta property="article:tag" content="队列">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://i.niupic.com/images/2016/03/21/Kgi9Ow.png">


<link rel="canonical" href="http://www.leewong.cn/2016/03/16/multithread/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>多线程 | LeeWong</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">LeeWong</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">What is Life But One Chanllege After Another</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <section class="post-toc-wrap sidebar-panel">
          <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-number">1.</span> <span class="nav-text">线程的基本概念</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95"><span class="nav-number">1.1.</span> <span class="nav-text">1、创建线程的三种方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B8%B8%E7%94%A8%E5%B1%9E%E6%80%A7"><span class="nav-number">1.2.</span> <span class="nav-text">2、线程的常用属性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%E3%80%81%E7%BA%BF%E7%A8%8B%E5%B8%B8%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">1.3.</span> <span class="nav-text">3、线程常用的方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4%E3%80%81%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E8%AF%A6%E8%A7%A3"><span class="nav-number">1.4.</span> <span class="nav-text">4、线程状态详解</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5%E3%80%81%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E6%B3%A8%E6%84%8F%E7%82%B9"><span class="nav-number">1.5.</span> <span class="nav-text">5、线程相关注意点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6%E3%80%81%E9%94%81"><span class="nav-number">1.6.</span> <span class="nav-text">6、锁</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#7%E3%80%81%E8%B5%84%E6%BA%90%E6%8A%A2%E5%A4%BA"><span class="nav-number">1.7.</span> <span class="nav-text">7、资源抢夺</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E9%98%9F%E5%88%97"><span class="nav-number">2.</span> <span class="nav-text">2、队列</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E9%98%9F%E5%88%97%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="nav-number">2.1.</span> <span class="nav-text">1、队列的类型</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E9%98%9F%E5%88%97%E7%9A%84%E6%89%A7%E8%A1%8C%E6%96%B9%E5%BC%8F"><span class="nav-number">2.2.</span> <span class="nav-text">2、队列的执行方式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%E3%80%81%E9%98%9F%E5%88%97%E7%9A%84%E9%80%89%E6%8B%A9"><span class="nav-number">2.3.</span> <span class="nav-text">3、队列的选择</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4%E3%80%81GCD"><span class="nav-number">2.4.</span> <span class="nav-text">4、GCD</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1%E3%80%81%E5%BB%B6%E6%97%B6"><span class="nav-number">2.4.1.</span> <span class="nav-text">1、延时</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2%E3%80%81%E8%B0%83%E5%BA%A6%E7%BB%84"><span class="nav-number">2.4.2.</span> <span class="nav-text">2、调度组</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3%E3%80%81%E4%B8%80%E6%AC%A1%E6%80%A7"><span class="nav-number">2.4.3.</span> <span class="nav-text">3、一次性</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#4%E3%80%81GCD%E7%9A%84%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88"><span class="nav-number">2.4.4.</span> <span class="nav-text">4、GCD的排列组合</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#5%E3%80%81%E5%85%A8%E5%B1%80%E9%98%9F%E5%88%97%E4%B8%8E%E4%B8%B2%E8%A1%8C%E9%98%9F%E5%88%97%E7%9A%84%E9%80%89%E6%8B%A9"><span class="nav-number">2.4.5.</span> <span class="nav-text">5、全局队列与串行队列的选择</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5%E3%80%81NSOperation"><span class="nav-number">2.5.</span> <span class="nav-text">5、NSOperation</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1%E3%80%81NSInvocationOperation%E5%92%8CNSBlockOperation"><span class="nav-number">2.5.1.</span> <span class="nav-text">1、NSInvocationOperation和NSBlockOperation</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2%E3%80%81%E9%98%9F%E5%88%97%E7%9A%84%E5%8F%96%E6%B6%88%E6%93%8D%E4%BD%9C"><span class="nav-number">2.5.2.</span> <span class="nav-text">2、队列的取消操作</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3%E3%80%81%E6%93%8D%E4%BD%9C%E7%9A%84%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB"><span class="nav-number">2.5.3.</span> <span class="nav-text">3、操作的依赖关系</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#4%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89Operation%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">2.5.4.</span> <span class="nav-text">4、自定义Operation的实现</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#5%E3%80%81NSOperation%E5%92%8CGCD%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">2.5.5.</span> <span class="nav-text">5、NSOperation和GCD的区别</span></a></li></ol></li></ol></li></ol></div>
      </section>
      <!--/noindex-->

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">LeeWong</p>
  <div class="site-description" itemprop="description">What is Life But One Chanllege After Another</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">71</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">19</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">79</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </section>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">
      

      

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.leewong.cn/2016/03/16/multithread/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="LeeWong">
      <meta itemprop="description" content="What is Life But One Chanllege After Another">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LeeWong">
    </span>

    
    
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          多线程
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2016-03-16 06:19:41" itemprop="dateCreated datePublished" datetime="2016-03-16T06:19:41+08:00">2016-03-16</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-07-19 22:12:11" itemprop="dateModified" datetime="2020-07-19T22:12:11+08:00">2020-07-19</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/iOS%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">iOS基础</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>最近工作，相对来说没那么忙了。自认为网络和多线程是我比较弱的模块，所以<br>趁这段时间有空，找了一些网络多线程相关的视频看了一下，这里做一下总结。</p>
<p>这是第一篇，主要介绍了线程的基本概念、队列 的相关知识</p>
<a id="more"></a>


<h4 id="线程的基本概念"><a href="#线程的基本概念" class="headerlink" title="线程的基本概念"></a>线程的基本概念</h4><h5 id="1、创建线程的三种方法"><a href="#1、创建线程的三种方法" class="headerlink" title="1、创建线程的三种方法"></a>1、创建线程的三种方法</h5><ul>
<li>1、alloc init</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NSThread *thread &#x3D; [[NSThread alloc]</span><br><span class="line"> 			initWithTarget:self selector:@selector(demo:)</span><br><span class="line"> 			 		object:@&quot;Thread&quot;]</span><br><span class="line"> 			 		</span><br><span class="line">[thread start];</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>2、detachNewThreadSelector</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[NSThread detachNewThreadSelector:@selector(demo:) 		toTarget:self withObject:@&quot;Detach&quot;];</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>3、performSelectorInBackground</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[self performSelectorInBackground:@selector(demo:) withObject:@&quot;background&quot;];</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="2、线程的常用属性"><a href="#2、线程的常用属性" class="headerlink" title="2、线程的常用属性"></a>2、线程的常用属性</h5><ul>
<li>1、name </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">线程的名字，在多个线程开发时，可以判断到底是谁在执行任务</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>2、threadPriority</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">线程优先级（0~1递增）默认优先级是0.5</span><br><span class="line"></span><br><span class="line">注意：优先级高并不意味着会先被调用，只是表示CUP调用的频	率相对较高</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>3、state</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">isExecuting(只读属性，是否正在执行)</span><br><span class="line">isFinished（只读属性，线程是否完成）</span><br><span class="line">isCancelled（只读属性，线程是否被取消）</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>4、stackSize</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">堆栈的大小，线程执行前，堆栈大小为512k，线程执行完毕之后，堆栈大小为0k 内存空间被释放，注意，线程执行完毕之后，由于内存空间已经被释放，不能再次启动</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="3、线程常用的方法"><a href="#3、线程常用的方法" class="headerlink" title="3、线程常用的方法"></a>3、线程常用的方法</h5><ul>
<li>1、currentThread</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">当前线程（1表示主线程，非1表示其他线程）</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>2、阻塞方法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sleepUntilDate:休眠到指定时间</span><br><span class="line"></span><br><span class="line">sleepForTimeInterval:休眠指定时长</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>3、exit</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">终止当前线程的执行（注意不要再主线程中执行这个方法）</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>4、其他方法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+isMainThread 是否为主线程</span><br><span class="line">+mainThread 返回主线程对象</span><br><span class="line">+isMultiThreaded 是否是多线程</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="4、线程状态详解"><a href="#4、线程状态详解" class="headerlink" title="4、线程状态详解"></a>4、线程状态详解</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">新建：实例化线程对象</span><br><span class="line"></span><br><span class="line">就绪：向对象发送start消息，将线程添加到“可调度线程池”等待CUP的调度，其他两种线程的创建方法，都是直接实例化一个线程对象，并将其加入“可调度线程池中”</span><br><span class="line"></span><br><span class="line">运行：CUP负责调度“可调度线程池”中的内容，在线程执行完成前可能会进行多次的运行和就绪的转换，这个转换由CPU负责，程序员不干预</span><br><span class="line"></span><br><span class="line">阻塞：满足某一个预定条件时，可以使用休眠或者锁阻塞线程，具体可以使用下面的几个方法：sleepForTimeInterval、sleepUntilDate、@synchronized(self)</span><br><span class="line"></span><br><span class="line">死亡：死亡方式：1、正常死亡  2、非正常死亡</span><br><span class="line">		1、正常死亡  :线程执行完毕 </span><br><span class="line">    	2、线程内死亡 :  [NSThread exit]</span><br><span class="line">    	   线程外死亡 :[threadObj cancel]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="5、线程相关注意点"><a href="#5、线程相关注意点" class="headerlink" title="5、线程相关注意点"></a>5、线程相关注意点</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">1、不要使用exit方法杀死主线程</span><br><span class="line"></span><br><span class="line">2、一旦强行终止线程后续的所有代码都不会被执行，因此，在线程终止之前，</span><br><span class="line">应该注意释放之前分配的对象，如果是ARC开发，需要注意，清理C语言框架创建的对象，否则会出现内存泄露</span><br><span class="line"></span><br><span class="line">3、多线程的目的：将耗时操作放在后台，不阻塞主线程和用户之间的交互，线</span><br><span class="line">程的优先级不要修改，多线程开发要尽量简单，多线程的优点是通过并发提高程</span><br><span class="line">序的执行效率</span><br><span class="line"></span><br><span class="line">4、在大型的商业项目中，通常会给线程起名字，因为他们希望如果程序崩溃可</span><br><span class="line">以准确的定位到，是哪一个线程出现了问题</span><br><span class="line"></span><br><span class="line">5、多线程的优缺点：</span><br><span class="line">优点：能适当提高程序的执行效率，能适当的提高资源利用率（CPU、内存利用</span><br><span class="line">率）；</span><br><span class="line">缺点：开启线程要占用一定的内存空间，默认情况下一条县城占用512KB，因此</span><br><span class="line">如果开启大量的线程，会占用大量的内存空间，降低程序性能</span><br><span class="line"></span><br><span class="line">7、线程安全：在多线程进行读写操作时，仍然能保证数据正确</span><br><span class="line"></span><br><span class="line">8、线程间通讯：performSelectorOnMainThread &quot;线程间通讯&quot;</span><br><span class="line"> 1. 在主线程执行的方法 </span><br><span class="line"> 2. 传递给方法的参数  </span><br><span class="line"> 3. 是否等待被调用方法执行完成，有可能也会等待调用方法的执行完成！几率</span><br><span class="line"> 	极少！</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="6、锁"><a href="#6、锁" class="headerlink" title="6、锁"></a>6、锁</h5><ul>
<li>1、互斥锁</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">同时时间内，只有一个线程能够执行锁定的代码</span><br><span class="line"></span><br><span class="line">在锁定的时候，其他线程会睡眠，等待条件满足后，再被唤醒</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>2、自旋锁</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">同时时间内，只有一个线程能够执行锁定的代码</span><br><span class="line"></span><br><span class="line">在锁定的时候，其他线程会做死循环，一直等待条件满足，性能会好（适合执行非常快，非常短的代码）</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="7、资源抢夺"><a href="#7、资源抢夺" class="headerlink" title="7、资源抢夺"></a>7、资源抢夺</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">现象：多个线程访问同一块资源 进行读写操作 </span><br><span class="line">解决方法： 加锁</span><br><span class="line"></span><br><span class="line">1、加互斥锁</span><br><span class="line"></span><br><span class="line">@synchronized(self):</span><br><span class="line"></span><br><span class="line">- 使用互斥锁，在同一个时间，只允许一条线程执行锁中的代码</span><br><span class="line">- 互斥锁的代价非常昂贵</span><br><span class="line">- 互斥锁的代码范围应该尽可能的小，只要锁住资源读写部分的代码即可</span><br><span class="line">- 使用互斥锁会影响并发性能</span><br><span class="line"></span><br><span class="line">2、使用原子属性</span><br><span class="line"></span><br><span class="line">能够实现“单写多读”的数据保护</span><br><span class="line"></span><br><span class="line">- 同一时间只允许一个线程修改属性值，但允许多个线程读取</span><br><span class="line">- 有可能出现脏数据--读取数据的值可能会不正确</span><br><span class="line">- 原子属性是默认属性，如果不需要考虑线程安全，指定nonatomic</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="2、队列"><a href="#2、队列" class="headerlink" title="2、队列"></a>2、队列</h4><h5 id="1、队列的类型"><a href="#1、队列的类型" class="headerlink" title="1、队列的类型"></a>1、队列的类型</h5><ul>
<li>1、串行队列</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_create(&quot;leewong&quot;, NULL);</span><br><span class="line">一次只调度一个任务执行，一个任务执行完成后，在调度下一个任务</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>2、并发队列</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_create(&quot;LeeWong&quot;,DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">可以同时调度多个任务</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>3、主队列</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">负责在主线程上调度任务，用于线程间通讯（所有的UI更新都应该在主线程上进行）</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>4、全局队列</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dispatch_get_global_queue(0, 0);与并发队列相比：调度任务的方式相同，全局队列没有队列名称，在MRC开发中，全局队列不需要释放</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="2、队列的执行方式"><a href="#2、队列的执行方式" class="headerlink" title="2、队列的执行方式"></a>2、队列的执行方式</h5><ul>
<li>1、同步 dispatch_sync</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">串行队列：会在当前线程上同步执行</span><br><span class="line">并发队列：会在当前线程上同步执行</span><br><span class="line">主 队列 ：在主线程上添加同步任务会造成死锁，利用同步任务，可以建立任务</span><br><span class="line">		之间的“依赖”关系</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>2、异步 dispatch_async</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">串行队列：会开启新的线程调度任务</span><br><span class="line">并发队列：会开启新的线程调度任务</span><br><span class="line">主队列：等待主线程空闲时调度任务</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="3、队列的选择"><a href="#3、队列的选择" class="headerlink" title="3、队列的选择"></a>3、队列的选择</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">串行队列：对执行效率要求不高，对执行顺序要求高，性能消耗小；</span><br><span class="line">并发队列：对执行效率要求高，对执行顺序要求不高，性能消耗大</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="4、GCD"><a href="#4、GCD" class="headerlink" title="4、GCD"></a>4、GCD</h5><h6 id="1、延时"><a href="#1、延时" class="headerlink" title="1、延时"></a>1、延时</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dispatch_after(when, queue, block);</span><br><span class="line"></span><br><span class="line">参数：从现在起经过多少纳秒；调度任务的队列；异步执行任务</span><br><span class="line"></span><br><span class="line">注意：dispatch_after中的参数是保留dispatch_after这句话执行的时候的参数，如果之后再代码块中语句执行之前，之中包含的参数发生变化，在之后代码块执行的时候，其值不改变</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h6 id="2、调度组"><a href="#2、调度组" class="headerlink" title="2、调度组"></a>2、调度组</h6><p>使用场景：需要在多个耗时操作执行完毕之后，在统一做后续处理</p>
<p>创建调度组：<br>dispatch_group_t group = dispatch_group_create();</p>
<ul>
<li>1、dispatch_group_leave、dispatch_group_enter<br><img src="http://i.niupic.com/images/2016/03/21/Kgi9Ow.png" alt="icon"></li>
</ul>
<ul>
<li>2、dispatch_group_notify</li>
</ul>
<p><img src="http://i.niupic.com/images/2016/03/21/gghbm4.png" alt="icon"></p>
<h6 id="3、一次性"><a href="#3、一次性" class="headerlink" title="3、一次性"></a>3、一次性</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">保证某段代码在程序运行过程中只被执行一次，在单例设计模式中被广泛使用</span><br><span class="line">dispatch_once是线程安全的</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h6 id="4、GCD的排列组合"><a href="#4、GCD的排列组合" class="headerlink" title="4、GCD的排列组合"></a>4、GCD的排列组合</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">- 1、串行队列，同步执行：不会开线程，顺序执行</span><br><span class="line"> </span><br><span class="line">- 2、串行队列，异步执行：会开线程(1条)，顺序执行</span><br><span class="line"></span><br><span class="line">- 3、并发队列，异步执行：会开线程，不会顺序执行，具体开几条线程取决于</span><br><span class="line">	队列</span><br><span class="line">	</span><br><span class="line">- 4、并发队列，同步执行：和串行队列同步执行效果一样</span><br><span class="line"></span><br><span class="line">- 5、主队列，异步执行:不开线程，异步任务必须等待主线程上的任务完成之后</span><br><span class="line">	才会被调用</span><br><span class="line">	</span><br><span class="line">- 6、主队列、同步执行：会发生死锁，因为，同步任务要求必须顺序执行，但</span><br><span class="line">	是同步任务必须等待主队列中没有任务可以被调用的时候才会被执行，因此</span><br><span class="line">	这两方会造成死锁的情况</span><br><span class="line">	</span><br><span class="line">- 7、同步任务的特点：可以再多个异步任务调度前，指定一个同步任务，让所</span><br><span class="line">	有的异步任务，等待同步任务执行完成，这就是所谓的依赖关系</span><br><span class="line">	</span><br><span class="line">- 8、全局队列，系统提供给程序员，方便程序员使用的全局队列，有关服务质</span><br><span class="line">	量的问题，使用下面的代码能够做到IOS7&amp;IOS8的适配，全局队列本质上</span><br><span class="line">	就是一个异步队列</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h6 id="5、全局队列与串行队列的选择"><a href="#5、全局队列与串行队列的选择" class="headerlink" title="5、全局队列与串行队列的选择"></a>5、全局队列与串行队列的选择</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">全局队列：并发，能够调度多个线程，执行效率高    但是费电</span><br><span class="line"></span><br><span class="line">串行队列：一个接一个，只能够开启一条县城，执行效率地</span><br><span class="line">    	但是如果任务之间有依赖关系，可以使用串行队列</span><br><span class="line">    	省电，省钱，省流量</span><br><span class="line">判断的依据：用户的上网方式</span><br><span class="line">    	  -WIFI 可以开多条线程 6条</span><br><span class="line">    	  -3G&#x2F;4G 尽量少开线程2~3条</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h5 id="5、NSOperation"><a href="#5、NSOperation" class="headerlink" title="5、NSOperation"></a>5、NSOperation</h5><h6 id="1、NSInvocationOperation和NSBlockOperation"><a href="#1、NSInvocationOperation和NSBlockOperation" class="headerlink" title="1、NSInvocationOperation和NSBlockOperation"></a>1、NSInvocationOperation和NSBlockOperation</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">NSInvocationOperation:</span><br><span class="line"></span><br><span class="line">NSOperationQueue *q &#x3D; [[NSOperationQueue alloc] init];</span><br><span class="line"></span><br><span class="line">    for (int i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">        NSInvocationOperation *op &#x3D; [[NSInvocationOperation</span><br><span class="line">       alloc] initWithTarget:self </span><br><span class="line">        			selector:@selector(downloadImage:) </span><br><span class="line">        			  object:@(i)];</span><br><span class="line">        			  </span><br><span class="line">        [q addOperation:op];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">   </span><br><span class="line">NSBlockOperation:</span><br><span class="line">   </span><br><span class="line">NSOperationQueue *q &#x3D; [[NSOperationQueue alloc] init];</span><br><span class="line">    	for (int i &#x3D; 0; i&lt;10; i++) &#123;</span><br><span class="line">        NSBlockOperation *op &#x3D; [NSBlockOperation 		blockOperationWithBlock:^&#123;</span><br><span class="line">            NSLog(@&quot;%@ ---- %d &quot;, [NSThread currentThread], i);</span><br><span class="line">        &#125;];</span><br><span class="line">        [q addOperation:op];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>执行结果：开启多个线程，不会顺序执行-&gt;GCD并发队列，异步执行任务</p>
<h6 id="2、队列的取消操作"><a href="#2、队列的取消操作" class="headerlink" title="2、队列的取消操作"></a>2、队列的取消操作</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">判断队列是否挂起： isSuspended</span><br><span class="line"></span><br><span class="line">在暂停的时候，队列中的操作数，是包含正在执行的操作的</span><br><span class="line"></span><br><span class="line">再次继续的时候，如果之前执行的操作已经完成，队列中的操作数就只有没有调</span><br><span class="line">度的操作</span><br><span class="line"></span><br><span class="line">在设置度列的挂起属性的时候，并不会判断队列中是否有操作，如果不希望用户产生困惑，可以提前判断，判断队列中当前是否有操作</span><br><span class="line"></span><br><span class="line">取消所有操作cancelAllOperations，不会取消正在执行的操作</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h6 id="3、操作的依赖关系"><a href="#3、操作的依赖关系" class="headerlink" title="3、操作的依赖关系"></a>3、操作的依赖关系</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">NSOperation 提供了依赖关系,NSOperation的所有操作都是异步执行的，但</span><br><span class="line">是为了建立任务之间的依赖，提供了dependency的功能,GCD中，可以直接通过</span><br><span class="line">同步任务来实现，可以通过串行队列</span><br><span class="line"></span><br><span class="line">[op2 addDependency:op1]; op1执行完毕之后才可以执行op2</span><br><span class="line"></span><br><span class="line">添加依赖关系之后可以调用 waitUntilFinished 来决定是否等待所有操作完</span><br><span class="line">成，但是这种等待是阻塞式的，类似于</span><br><span class="line"></span><br><span class="line">   		dispatch_group_wait(g, DISPATCH_TIME_FOREVER);</span><br><span class="line">   		</span><br><span class="line">依赖关系可以跨队列指定</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>但是要注意不要指定循环依赖，一旦指定了循环依赖，队列就不工作了</code></p>
<h6 id="4、自定义Operation的实现"><a href="#4、自定义Operation的实现" class="headerlink" title="4、自定义Operation的实现"></a>4、自定义Operation的实现</h6><p>目的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1、将操作部分的代码重构到一个单独的子类完成工作</span><br><span class="line"></span><br><span class="line">2、主要是在开发第三方框架时，会使用，日常开发直接使用operation会比较</span><br><span class="line">	方便</span><br><span class="line">	</span><br><span class="line">3、自定义操作，可以支持队列的取消操作</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>自定义NSOperation的子类的步骤：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">-重写main方法</span><br><span class="line">-添加自动释放池，因为子线程运行循环默认不工作</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>重要提示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NSOperation默认提供了一个completionBlock的参数，一旦设置了，就会在操作执行完毕之后自动执行</span><br><span class="line"></span><br><span class="line">completionBlock 会在后台线程执行，不会再主线程执行，所以如果需要更新UI，需要注意线程</span><br><span class="line"></span><br><span class="line">completionBlock 不能接受参数，没有返回值，因此在使用的时候，会有很多限制</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注意：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">作为所有c语言程序的入口，自定义操作也需要有自己的main函数，同时子线程</span><br><span class="line">的运行循环默认是不开启的，因此也不会主动的区创建自动释放池，因此自定义</span><br><span class="line">NSOperation的子类的时候，需要自己添加自动释放池</span><br><span class="line"></span><br><span class="line">		- (void)main &#123;</span><br><span class="line">    		@autoreleasepool &#123;&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">   </span><br><span class="line">每一次运行循环的开启，都会创建一个自动释放池，当对象出了他们的作用域之</span><br><span class="line">后就会被添加到自动释放池中，在运行循环即将结束的时候，会被销毁（每一个</span><br><span class="line">线程都有自己的runloop但是之后主线程的默认被开启）</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h6 id="5、NSOperation和GCD的区别"><a href="#5、NSOperation和GCD的区别" class="headerlink" title="5、NSOperation和GCD的区别"></a>5、NSOperation和GCD的区别</h6><ul>
<li>1、GCD</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- GCD在iOS4.0推出，主要针对多核处理器做了优化的并发计数，是C语言的</span><br><span class="line"></span><br><span class="line">- 将任务[block]添加到度列[串行&#x2F;并发&#x2F;主队列&#x2F;全局队列],并且制定执行任</span><br><span class="line">	务的函数[同步&#x2F;异步]</span><br><span class="line">	</span><br><span class="line">- 线程间通讯dispatch_get_main_queue</span><br><span class="line"></span><br><span class="line">- 提供了一些NSOperation不具备的功能</span><br><span class="line">		- 一次性执行</span><br><span class="line"> 		- 延迟执行</span><br><span class="line"> 		- 调度组（在op中也可以做到，就是有点麻烦）</span><br><span class="line">	</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>2、NSOperation</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- NSOperation在iOS2.0之后推出，苹果推出GCD之后，对NSOperation底</span><br><span class="line">	层重写了一遍</span><br><span class="line">- 将操作[异步执行的任务]添加到队列[并发队列]，就会立即异步执行</span><br><span class="line">- mainQueue</span><br><span class="line">- 提供了一些GCD实现起来比较困难的功能</span><br><span class="line">		- 最大并发操作数</span><br><span class="line">		- 队列的暂停&#x2F;继续</span><br><span class="line">		- 取消所有的操作</span><br><span class="line">		- 制定操作之间的依赖关系（GCD用同步实现）</span><br><span class="line"></span><br></pre></td></tr></table></figure>


    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" rel="tag"># 多线程</a>
              <a href="/tags/%E9%98%9F%E5%88%97/" rel="tag"># 队列</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2016/03/07/ios-multiVc-manager/" rel="prev" title="iOS 多控制器管理">
                  <i class="fa fa-chevron-left"></i> iOS 多控制器管理
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2016/03/17/multThread-concept/" rel="next" title="多线程 相关概念">
                  多线程 相关概念 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
  
  
  



      

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

    </div>
  </main>

  <footer class="footer">
    <div class="footer-inner">
      

      

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">LeeWong</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.0/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  















  








  

  

</body>
</html>
