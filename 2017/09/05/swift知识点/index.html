<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.1.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.14.0/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.leewong.cn","root":"/","scheme":"Mist","version":"8.0.0-rc.5","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"},"path":"search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}};
  </script>

  <meta name="description" content="近期在学习swift,本篇文章是在网络上看到的一些知识和总结,非原创文章">
<meta property="og:type" content="article">
<meta property="og:title" content="swift知识点(网络搜集)">
<meta property="og:url" content="https://www.leewong.cn/2017/09/05/swift%E7%9F%A5%E8%AF%86%E7%82%B9/index.html">
<meta property="og:site_name" content="LeeWong111">
<meta property="og:description" content="近期在学习swift,本篇文章是在网络上看到的一些知识和总结,非原创文章">
<meta property="og:locale">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1721232-dd65f5d099b64955.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240/format/jpg">
<meta property="article:published_time" content="2017-09-05T02:48:18.000Z">
<meta property="article:modified_time" content="2020-07-19T14:17:26.261Z">
<meta property="article:author" content="LeeWong">
<meta property="article:tag" content="基础知识">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://upload-images.jianshu.io/upload_images/1721232-dd65f5d099b64955.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240/format/jpg">


<link rel="canonical" href="https://www.leewong.cn/2017/09/05/swift%E7%9F%A5%E8%AF%86%E7%82%B9/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-Hans'
  };
</script>

  <title>swift知识点(网络搜集) | LeeWong111</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=4NmLVard-jFEKaV6857m9tKb41Tpo4FiKj8L1TJg7lU"></script>
    <script>
      if (CONFIG.hostname === location.hostname) {
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', '4NmLVard-jFEKaV6857m9tKb41Tpo4FiKj8L1TJg7lU');
      }
    </script>


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?DR81zbdrQ3";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">LeeWong111</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">What is Life But One Chanllege After Another</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section">Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section">About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section">Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section">Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section">Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger">Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <section class="post-toc-wrap sidebar-panel">
          <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E3%80%81Swift-%E5%B8%B8%E8%AF%86"><span class="nav-number">1.</span> <span class="nav-text">一、Swift 常识</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%B0%E7%9A%84%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6fileprivate%E5%92%8Copen"><span class="nav-number">2.</span> <span class="nav-text">新的访问控制fileprivate和open</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Swift%E4%B8%AD%E8%A2%AB%E5%BF%BD%E7%95%A5%E7%9A%84-noescape"><span class="nav-number">3.</span> <span class="nav-text">Swift中被忽略的@noescape</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#struct%E5%92%8Cclass%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">4.</span> <span class="nav-text">struct和class的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="nav-number">5.</span> <span class="nav-text">介绍一下观察者模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9C%A8%E4%B8%80%E4%B8%AAapp%E4%B8%AD%E9%97%B4%E6%9C%89%E4%B8%80%E4%B8%AAbutton%EF%BC%8C%E5%9C%A8%E4%BD%A0%E6%89%8B%E8%A7%A6%E6%91%B8%E5%B1%8F%E5%B9%95%E7%82%B9%E5%87%BB%E5%90%8E%EF%BC%8C%E5%88%B0%E8%BF%99%E4%B8%AAbutton%E6%94%B6%E5%88%B0%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6%EF%BC%8C%E4%B8%AD%E9%97%B4%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88"><span class="nav-number">6.</span> <span class="nav-text">在一个app中间有一个button，在你手触摸屏幕点击后，到这个button收到点击事件，中间发生了什么</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#swiftTip-String%E8%BF%98%E6%98%AFNSString"><span class="nav-number">7.</span> <span class="nav-text">swiftTip String还是NSString?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%8E%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E4%BA%86%E8%A7%A3GCD%E6%96%B0API"><span class="nav-number">8.</span> <span class="nav-text">从使用场景了解GCD新API</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#dispatch-async"><span class="nav-number">8.1.</span> <span class="nav-text">dispatch_async</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sync"><span class="nav-number">8.2.</span> <span class="nav-text">sync</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E9%98%9F%E5%88%97"><span class="nav-number">8.3.</span> <span class="nav-text">创建队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A8%E8%BF%9F%E6%97%B6%E9%97%B4%E5%90%8E%E6%89%A7%E8%A1%8C"><span class="nav-number">8.4.</span> <span class="nav-text">推迟时间后执行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DispatchGroup"><span class="nav-number">8.5.</span> <span class="nav-text">DispatchGroup</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#dispatch-once%E8%A2%AB%E5%BA%9F%E5%BC%83"><span class="nav-number">8.6.</span> <span class="nav-text">dispatch_once被废弃</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Swift%E5%87%BD%E6%95%B0%E7%BC%96%E7%A8%8B%E4%B9%8BMap%E3%80%81Filter%E3%80%81Reduce"><span class="nav-number">9.</span> <span class="nav-text">Swift函数编程之Map、Filter、Reduce</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Swift%E5%87%BD%E6%95%B0%E7%BC%96%E7%A8%8B%E4%B9%8BMap"><span class="nav-number">9.1.</span> <span class="nav-text">Swift函数编程之Map</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Swift%E5%87%BD%E6%95%B0%E7%BC%96%E7%A8%8B%E4%B9%8BFilter"><span class="nav-number">9.2.</span> <span class="nav-text">Swift函数编程之Filter</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Swift%E5%87%BD%E6%95%B0%E7%BC%96%E7%A8%8B%E4%B9%8BReduce"><span class="nav-number">9.3.</span> <span class="nav-text">Swift函数编程之Reduce</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Swift%E5%87%BD%E6%95%B0%E7%BC%96%E7%A8%8B%E4%B9%8BFlatMap"><span class="nav-number">9.4.</span> <span class="nav-text">Swift函数编程之FlatMap</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Swift%E5%87%BD%E6%95%B0%E7%BC%96%E7%A8%8B-%E9%93%BE%E5%BC%8F%E7%BB%84%E5%90%88"><span class="nav-number">9.5.</span> <span class="nav-text">Swift函数编程 链式组合</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86"><span class="nav-number">10.</span> <span class="nav-text">错误处理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A1%A8%E7%A4%BA%E5%92%8C%E6%8A%9B%E5%87%BA%E9%94%99%E8%AF%AF"><span class="nav-number">10.1.</span> <span class="nav-text">表示和抛出错误</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%84%E7%90%86%E9%94%99%E8%AF%AF"><span class="nav-number">10.2.</span> <span class="nav-text">处理错误</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%8A%9B%E5%87%BA%E5%87%BD%E6%95%B0%E4%BC%A0%E9%80%92%E9%94%99%E8%AF%AF"><span class="nav-number">10.3.</span> <span class="nav-text">使用抛出函数传递错误</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-Do-Catch-%E5%A4%84%E7%90%86%E9%94%99%E8%AF%AF"><span class="nav-number">10.4.</span> <span class="nav-text">使用 Do-Catch 处理错误</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BD%AC%E6%8D%A2%E9%94%99%E8%AF%AF%E4%B8%BA%E5%8F%AF%E9%80%89%E9%A1%B9"><span class="nav-number">10.5.</span> <span class="nav-text">转换错误为可选项</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%96%E6%B6%88%E9%94%99%E8%AF%AF%E4%BC%A0%E9%80%92"><span class="nav-number">10.6.</span> <span class="nav-text">取消错误传递</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%87%E5%AE%9A%E6%B8%85%E7%90%86%E6%93%8D%E4%BD%9C"><span class="nav-number">10.7.</span> <span class="nav-text">指定清理操作</span></a></li></ol></li></ol></div>
      </section>
      <!--/noindex-->

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="LeeWong"
      src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gi7obtinvfj30hq0hqgme.jpg">
  <p class="site-author-name" itemprop="name">LeeWong</p>
  <div class="site-description" itemprop="description">What is Life But One Chanllege After Another</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">71</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">19</span>
        <span class="site-state-item-name">categories</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">79</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/LeeWongSnail" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;LeeWongSnail" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="/wangli_0632@163.com" title="E-Mail → wangli_0632@163.com"><i class="fa fa-envelope fa-fw"></i></a>
      </span>
  </div>



      </section>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">
      

      

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://www.leewong.cn/2017/09/05/swift%E7%9F%A5%E8%AF%86%E7%82%B9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://tva1.sinaimg.cn/large/007S8ZIlgy1gi7obtinvfj30hq0hqgme.jpg">
      <meta itemprop="name" content="LeeWong">
      <meta itemprop="description" content="What is Life But One Chanllege After Another">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LeeWong111">
    </span>

    
    
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          swift知识点(网络搜集)
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2017-09-05 10:48:18" itemprop="dateCreated datePublished" datetime="2017-09-05T10:48:18+08:00">2017-09-05</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2020-07-19 22:17:26" itemprop="dateModified" datetime="2020-07-19T22:17:26+08:00">2020-07-19</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Swift/" itemprop="url" rel="index"><span itemprop="name">Swift</span></a>
        </span>
    </span>

  
    <span id="/2017/09/05/swift%E7%9F%A5%E8%AF%86%E7%82%B9/" class="post-meta-item leancloud_visitors" data-flag-title="swift知识点(网络搜集)" title="Views">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">Views: </span>
      <span class="leancloud-visitors-count"></span>
    </span>
    <span class="post-meta-item" title="Views" id="busuanzi_container_page_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">Views: </span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>近期在学习swift,本篇文章是在网络上看到的一些知识和总结,非原创文章</p>
<a id="more"></a>


<h2 id="一、Swift-常识"><a href="#一、Swift-常识" class="headerlink" title="一、Swift 常识"></a>一、Swift 常识</h2><h2 id="新的访问控制fileprivate和open"><a href="#新的访问控制fileprivate和open" class="headerlink" title="新的访问控制fileprivate和open"></a>新的访问控制fileprivate和open</h2><p>在原有的swift中的 private其实并不是真正的私有，如果一个变量定义为private，在<code>同一个文件</code>中的<code>其他类</code>依然是可以访问到的。这</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class User &#123;</span><br><span class="line">    private var name &#x3D; &quot;private&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extension User&#123;</span><br><span class="line">    var accessPrivate: String &#123;</span><br><span class="line">        return name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样带来了两个问题：</p>
<ul>
<li>1、当我们标记为private时，意为真的私有还是文件内可共享呢？</li>
<li>2、当我们如果意图为真正的私有时，必须保证这个类或者结构体在一个单独的文件里。否则可能同文件里其他的代码访问到。</li>
</ul>
<p>由此，在swift 3中，新增加了一个 fileprivate来显式的表明，这个元素的访问权限为文件内私有。过去的private对应现在的fileprivate。现在的private则是真正的私有，离开了这个类或者结构体的作用域外面就无法访问。</p>
<p>open则是弥补public语义上的不足。</p>
<p>现在的pubic有两层含义：</p>
<ul>
<li>1、这个元素可以在其他作用域被访问</li>
<li>2、这个元素可以在其他作用域被继承或者override</li>
</ul>
<p>继承是一件危险的事情。尤其对于一个framework或者module的设计者而言。在自身的module内，类或者属性对于作者而言是清晰的，能否被继承或者override都是可控的。但是对于使用它的人，作者有时会希望传达出这个类或者属性不应该被继承或者修改。这个对应的就是 <code>final</code>。</p>
<p> <code>final</code>的问题在于在标记之后，在任何地方都不能override。而对于lib的设计者而言，希望得到的是在module内可以被override，在被import到其他地方后其他用户使用的时候不能被override。</p>
<p>这就是 <code>open</code>产生的初衷。通过open和public标记区别一个元素在其他module中是只能被访问还是可以被override。</p>
<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; ModuleA:</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 这个类在ModuleA的范围外是不能被继承的，只能被访问</span><br><span class="line">public class NonSubclassableParentClass &#123;</span><br><span class="line"></span><br><span class="line">    public func foo() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 这是错误的写法，因为class已经不能被继承，</span><br><span class="line">    &#x2F;&#x2F; 所以他的方法的访问权限不能大于类的访问权限</span><br><span class="line">    open func bar() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; final的含义保持不变</span><br><span class="line">    public final func baz() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 在ModuleA的范围外可以被继承</span><br><span class="line">open class SubclassableParentClass &#123;</span><br><span class="line">    &#x2F;&#x2F; 这个属性在ModuleA的范围外不能被override</span><br><span class="line">    public var size : Int</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 这个方法在ModuleA的范围外不能被override</span><br><span class="line">    public func foo() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 这个方法在任何地方都可以被override</span><br><span class="line">    open func bar() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;&#x2F;final的含义保持不变</span><br><span class="line">    public final func baz() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x2F; final的含义保持不变</span><br><span class="line">public final class FinalClass &#123; &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; ModuleB:</span><br><span class="line"></span><br><span class="line">import ModuleA</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 这个写法是错误的，编译会失败</span><br><span class="line">&#x2F;&#x2F; 因为NonSubclassableParentClass类访问权限标记的是public，只能被访问不能被继承</span><br><span class="line">class SubclassA : NonSubclassableParentClass &#123; &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 这样写法可以通过，因为SubclassableParentClass访问权限为 &#96;open&#96;.</span><br><span class="line">class SubclassB : SubclassableParentClass &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 这样写也会编译失败</span><br><span class="line">    &#x2F;&#x2F; 因为这个方法在SubclassableParentClass 中的权限为public，不是&#96;open&#39;.</span><br><span class="line">    override func foo() &#123; &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 这个方法因为在SubclassableParentClass中标记为open，所以可以这样写</span><br><span class="line">    &#x2F;&#x2F; 这里不需要再声明为open，因为这个类是internal的</span><br><span class="line">    override func bar() &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">open class SubclassC : SubclassableParentClass &#123;</span><br><span class="line">    &#x2F;&#x2F; 这种写法会编译失败，因为这个类已经标记为open</span><br><span class="line">    &#x2F;&#x2F; 这个方法override是一个open的方法，则也需要表明访问权限</span><br><span class="line">    override func bar() &#123; &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">open class SubclassD : SubclassableParentClass &#123;</span><br><span class="line">    &#x2F;&#x2F; 正确的写法，方法也需要标记为open</span><br><span class="line">    open override func bar() &#123; &#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">open class SubclassE : SubclassableParentClass &#123;</span><br><span class="line">    &#x2F;&#x2F; 也可以显式的指出这个方法不能在被override</span><br><span class="line">    public final override func bar() &#123; &#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>现在的访问权限则依次为：open，public，internal，fileprivate，private。<br>有的人会觉得访问权限选择的增加加大了语言的复杂度。但是如果我们思考swift语言的设计目标之一就是一门安全的语言（“Designed for Safety”）就能理解这次的改动。更加明确清晰的访问权限控制可以使程序员表达出更准确的意图，当然也迫使在编码时思考的更加深入。</p>
<h2 id="Swift中被忽略的-noescape"><a href="#Swift中被忽略的-noescape" class="headerlink" title="Swift中被忽略的@noescape"></a>Swift中被忽略的@noescape</h2><p>这里需要先介绍一下escape的概念。当一个闭包当做一个参数传进函数里，这个闭包是在这个函数执行完后执行的，这个时候我们就说这个闭包从函数逃出来了（escape）。这种场景很常见，比如我们进行一个异步的请求，请求时会传入一个handler，比如当请求成功后执行达到回调的目的。</p>
<p>众所周知swift的内存管理是引用计数。闭包里用到的数据都需要捕捉到闭包里，保证闭包执行时这些数据不会被释放还在内存里。Xcode为了让我们意识到闭包里用到的对象其实已经被retain了，就要求我们访问当前属性时显示声明self。</p>
<p>这个时候如果新手就很容易犯引用循环的错误。闭包retain了self，self如果又持有retain了闭包。最后就谁都释放不了，内存就泄露了。</p>
<p>这是swift中默认闭包的使用场景。<br>但是这里是有另外一种可能，假设有一个闭包是传入用于sort用的，或者比如作为map参数的闭包。当这行代码执行完成时，这个闭包也就使用完了，之后不会再被执行。这个情况下，闭包就不必再持有里面用到的对象。<br>这就是非escape闭包。</p>
<p>swift里针对非escape用@noescape表示。<br>比如map函数就使用了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">func map&lt;T&gt;(@noescape transform: (Self.Generator.Element) throws -&gt; T) rethrows -&gt; [T]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这样标记之后能看到的好处就是这个闭包里如果再使用self的属性不需要加self.了。对于编译器而言，在知道是noescape闭包后可以进行一些内存的优化。</p>
<h2 id="struct和class的区别"><a href="#struct和class的区别" class="headerlink" title="struct和class的区别"></a>struct和class的区别</h2><p>swift中，class是引用类型，struct是值类型。值类型在传递和赋值时将进行复制，而引用类型则只会使用引用对象的一个”指向”。所以他们两者之间的区别就是两个类型的区别。</p>
<p>class有这几个功能struct没有的：</p>
<p>class可以继承，这样子类可以使用父类的特性和方法<br>类型转换可以在runtime的时候检查和解释一个实例的类型<br>可以用deinit来释放资源<br>一个类可以被多次引用</p>
<p>struct也有这样几个优势：</p>
<p>结构较小，适用于复制操作，相比于一个class的实例被多次引用更加安全。<br>无须担心内存memory leak或者多线程冲突问题</p>
<p>顺便提一下，array在swift中是用struct实现的。Apple重写过一次array，然后复制就是深度拷贝了。猜测复制是类似参照那样，通过栈上指向堆上位置的指针来实现的。而对于它的复制操作，也是在相对空间较为宽裕的堆上来完成的，所以性能上还是不错的。</p>
<p>下面引用猫神OneV的博客：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var arr &#x3D; [0,0,0]</span><br><span class="line">var newArr &#x3D; arr</span><br><span class="line">arr[0] &#x3D; 1</span><br><span class="line">&#x2F;&#x2F;Check arr and newArr</span><br><span class="line">arr &#x2F;&#x2F;[1, 0, 0]</span><br><span class="line">newArr &#x2F;&#x2F; before beta3:[1, 0, 0], after beta3:[0, 0, 0]</span><br></pre></td></tr></table></figure>

<p>所以可以猜测其实在背后 Array和 Dictionary的行为并不是像其他 struct 那样简单的在栈上分配，而是类似参照那样，通过栈上指向堆上位置的指针来实现的。而对于它的复制操作，也是在相对空间较为宽裕的堆上来完成的。当然，现在还无法（或者说很难）拿到最后的汇编码，所以这只是一个猜测而已。<br>补充：<br>C语言中，struct与的class的区别：<br>struct只是作为一种复杂数据类型定义，不能用于面向对象编程。</p>
<p>C++中，struct和class的区别：<br>对于成员访问权限以及继承方式，class中默认的是private的，而struct中则是public的。class还可以用于表示模板类型，struct则不行</p>
<h2 id="介绍一下观察者模式"><a href="#介绍一下观察者模式" class="headerlink" title="介绍一下观察者模式"></a>介绍一下观察者模式</h2><p>观察者模式(Observer Pattern)：定义对象间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新。<br>在IOS中典型的推模型实现方式为NSNotificationCenter和KVO。</p>
<p>NSNotificationCenter</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1721232-dd65f5d099b64955.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240/format/jpg" alt="observe"></p>
<p>NSNotificationCenter</p>
<p>观察者Observer，通过NSNotificationCenter的addObserver:selector:name:object接口来注册对某一类型通知感兴趣。在注册时候一定要注意，NSNotificationCenter不会对观察者进行引用计数+1的操作，我们在程序中释放观察者的时候，一定要去报从center中将其注销了。<br>通知中心NSNotificationCenter，通知的枢纽。<br>被观察的对象，通过postNotificationName:object:userInfo:发送某一类型通知，广播改变。<br>通知对象NSNotification，当有通知来的时候，Center会调用观察者注册的接口来广播通知，同时传递存储着更改内容的NSNotification对象。</p>
<p>KVO</p>
<p>KVO的全称是Key-Value Observer，即键值观察。是一种没有中心枢纽的观察者模式的实现方式。一个主题对象管理所有依赖于它的观察者对象，并且在自身状态发生改变的时候主动通知观察者对象。</p>
<p>注册观察者<br>[object addObserver:self forKeyPath:property options:NSKeyValueObservingOptionNew context:]。<br>更改主题对象属性的值，即触发发送更改的通知。<br>在制定的回调函数中，处理收到的更改通知。<br>注销观察者 [object removeObserver:self forKeyPath:property]。</p>
<h2 id="在一个app中间有一个button，在你手触摸屏幕点击后，到这个button收到点击事件，中间发生了什么"><a href="#在一个app中间有一个button，在你手触摸屏幕点击后，到这个button收到点击事件，中间发生了什么" class="headerlink" title="在一个app中间有一个button，在你手触摸屏幕点击后，到这个button收到点击事件，中间发生了什么"></a>在一个app中间有一个button，在你手触摸屏幕点击后，到这个button收到点击事件，中间发生了什么</h2><p>响应链大概有以下几个步骤</p>
<ul>
<li>1、设备将touch到的UITouch和UIEvent对象打包, 放到当前活动的Application的事件队列中</li>
<li>2、单例的UIApplication会从事件队列中取出触摸事件并传递给单例UIWindow</li>
<li>3、UIWindow使用hitTest:withEvent:方法查找touch操作的所在的视图view</li>
</ul>
<h2 id="swiftTip-String还是NSString"><a href="#swiftTip-String还是NSString" class="headerlink" title="swiftTip String还是NSString?"></a>swiftTip String还是NSString?</h2><p>建议尽可能使用原生的String类型，原因有三：</p>
<ul>
<li>1、Cocoa所有的API都接受和返回String类型的参数</li>
<li>2、Swift中String是基于struct，更切合于String <code>不变</code>的特性，这种不变的特性在多线程编程时非常重要，他从原理上将程序员从内存访问和操作顺序的担忧中解放出来,另外在不触及NSString特有的操作和动态特性的时候String性能也有一定提升</li>
<li>3、Swift 实现了像CollectionType这样的接口 因此一些语法特性只有String才有</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let levels &#x3D; &quot;ABCDE&quot;</span><br><span class="line">for level in levels &#123;</span><br><span class="line">    print(level)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用String的唯一比较麻烦的地方在于他和Range的配合</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">“let levels &#x3D; &quot;ABCDE&quot;</span><br><span class="line"></span><br><span class="line">let nsRange &#x3D; NSMakeRange(1, 4)</span><br><span class="line">&#x2F;&#x2F; 编译错误</span><br><span class="line">&#x2F;&#x2F; &#39;NSRange&#39; is not convertible to &#39;Range&lt;String.Index&gt;&#39;</span><br><span class="line">levels.stringByReplacingCharactersInRange(nsRange, withString: &quot;AAAA&quot;)</span><br><span class="line"></span><br><span class="line">let indexPositionOne &#x3D; levels.startIndex.successor()</span><br><span class="line">let swiftRange &#x3D; indexPositionOne..&lt;advance(indexPositionOne, 4)</span><br><span class="line">levels.stringByReplacingCharactersInRange(swiftRange, withString: &quot;AAAA&quot;)</span><br><span class="line">&#x2F;&#x2F; 输出：</span><br><span class="line">&#x2F;&#x2F; AAAAA”</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这种情况下可以将String转换为NSString使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">“let nsRange &#x3D; NSMakeRange(1, 4)</span><br><span class="line">(levels as NSString).stringByReplacingCharactersInRange(</span><br><span class="line">    nsRange, withString: &quot;AAAA&quot;)”</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="从使用场景了解GCD新API"><a href="#从使用场景了解GCD新API" class="headerlink" title="从使用场景了解GCD新API"></a>从使用场景了解GCD新API</h2><p>参考:<a target="_blank" rel="noopener" href="http://www.jianshu.com/p/fc78dab5736f">原文</a></p>
<h3 id="dispatch-async"><a href="#dispatch-async" class="headerlink" title="dispatch_async"></a>dispatch_async</h3><p>一个常见的场景就是在一个全局队列进行一些操作后切换到主线程配置UI。现在是这么写</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DispatchQueue.global().async &#123;</span><br><span class="line">    &#x2F;&#x2F; code</span><br><span class="line">    DispatchQueue.main.async &#123;</span><br><span class="line">        &#x2F;&#x2F; 主线程中</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="sync"><a href="#sync" class="headerlink" title="sync"></a>sync</h3><p>如果想同步执行操作，和async类似，调用sync就可以了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DispatchQueue.global().sync &#123;</span><br><span class="line">    &#x2F;&#x2F; 同步执行</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="创建队列"><a href="#创建队列" class="headerlink" title="创建队列"></a>创建队列</h3><p>DispatchQueue的默认初始化方法创建的就是一个同步队列，如果要创建并发的队列，在attributes中声明concurrent。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 同步队列</span><br><span class="line">let serialQueue &#x3D; DispatchQueue(label: &quot;queuename&quot;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 并发队列</span><br><span class="line">let concurrentQueue &#x3D; DispatchQueue(label: &quot;queuename&quot;, attributes: .concurrent)</span><br></pre></td></tr></table></figure>

<h3 id="推迟时间后执行"><a href="#推迟时间后执行" class="headerlink" title="推迟时间后执行"></a>推迟时间后执行</h3><p>原先的dispatch_time_t现在由DispatchTime对象表示。可以用静态方法now获得当前时间，然后再通过加上一个DispatchTimeInterval枚举来获得一个需要延迟的时间。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let delay &#x3D; DispatchTime.now() + DispatchTimeInterval.seconds(60)</span><br><span class="line">DispatchQueue.main.asyncAfter(deadline: delay) &#123; </span><br><span class="line">    &#x2F;&#x2F; 延迟执行</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里也可以直接加上一个秒数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let three &#x3D; DispatchTime.now() + 3.0</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>因为DispatchTime中自定义了+号。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public func +(time: DispatchTime, seconds: Double) -&gt; DispatchTime</span><br></pre></td></tr></table></figure>

<h3 id="DispatchGroup"><a href="#DispatchGroup" class="headerlink" title="DispatchGroup"></a>DispatchGroup</h3><p>如果想在dispatch_queue中所有的任务执行完成后再做某种操作可以使用DispatchGroup。原先的dispatch_group_t由现在的DispatchGroup对象代替。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">let group &#x3D; DispatchGroup()</span><br><span class="line"></span><br><span class="line">let queueBook &#x3D; DispatchQueue(label: &quot;book&quot;)</span><br><span class="line">queueBook.async(group: group) &#123;</span><br><span class="line">    &#x2F;&#x2F; 下载图书</span><br><span class="line">&#125;</span><br><span class="line">let queueVideo &#x3D; DispatchQueue(label: &quot;video&quot;)</span><br><span class="line">queueVideo.async(group: group) &#123;</span><br><span class="line">    &#x2F;&#x2F; 下载视频</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">group.notify(queue: DispatchQueue.main) &#123; </span><br><span class="line">    &#x2F;&#x2F; 下载完成</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>DispatchGroup会在组里的操作都完成后执行notify。<br>如果有多个并发队列在一个组里，我们想在这些操作执行完了再继续，调用wait</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">group.wait()</span><br></pre></td></tr></table></figure>


<h3 id="dispatch-once被废弃"><a href="#dispatch-once被废弃" class="headerlink" title="dispatch_once被废弃"></a>dispatch_once被废弃</h3><p>在swift 3中已经被废弃了。<br>简单的建议就是一些初始化场景就用懒加载吧。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Examples of dispatch_once replacements with global or static constants and variables. </span><br><span class="line">&#x2F;&#x2F; In all three, the initialiser is called only once. </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Static properties (useful for singletons).</span><br><span class="line">class Object &#123;</span><br><span class="line">    static let sharedInstance &#x3D; Object()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Global constant.</span><br><span class="line">let constant &#x3D; Object()</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Global variable.</span><br><span class="line">var variable: Object &#x3D; &#123;</span><br><span class="line">    let variable &#x3D; Object()</span><br><span class="line">    variable.doSomething()</span><br><span class="line">    return variable</span><br><span class="line">&#125;()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Swift函数编程之Map、Filter、Reduce"><a href="#Swift函数编程之Map、Filter、Reduce" class="headerlink" title="Swift函数编程之Map、Filter、Reduce"></a>Swift函数编程之Map、Filter、Reduce</h2><h3 id="Swift函数编程之Map"><a href="#Swift函数编程之Map" class="headerlink" title="Swift函数编程之Map"></a>Swift函数编程之Map</h3><p>在Swift语言中使用Map、Filter、Reduce对Array、Dictionary等集合类型（collection type）进行操作可能对一部分人来说还不是那么的习惯。对于没有接触过函数式编程的开发者来说，对集合类型中的数据进行处理的时候第一反应可能就是采用for in遍历。本文将介绍一些Swift中可以采用的新方法</p>
<p>Map函数会遍历集合类型并对其中的每一个元素进行同一种的操作。Map的返回值是一个所得结果的数组。例如：我们要对一个数组里面的数据进行平方操作，常见的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let values: [Double]&#x3D; [2.0,4.0,6.0,8.0]</span><br><span class="line">var squares: [Double] &#x3D; []</span><br><span class="line">for value in values &#123;</span><br><span class="line">    squares.append(value * value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码中，我们使用了常规的for in遍历操作对其中的元素进行了平方操作，然后将计算的结果追加到一个变量数组里面。虽然该部分的代码很好的完成了要求，但是在Swift中我们还有更简洁和安全的代码（上面的squaers是一个变量可能出现无意的数据修改）。下面来看看使用Map进行操作的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let values: [Double]&#x3D; [2.0,4.0,6.0,8.0]</span><br><span class="line">let squares: [Double] &#x3D; values.map&#123;$0 * $0&#125;</span><br></pre></td></tr></table></figure>

<p>该段代码不仅更加简洁而且squares是一个不可变的常量。</p>
<p>上面代码中的map函数的闭包语法可能对于新手比较难以理解，该闭包中只有一行对集合中数据进行处理的代码并且最终返回了结果数组。为了大家更好的理解map的操作上面的代码可以改写为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let values: [Double]&#x3D; [2.0,4.0,6.0,8.0]</span><br><span class="line">let squares: [Double] &#x3D; values.map(&#123;</span><br><span class="line">    (value: Double)-&gt; Double in</span><br><span class="line">    return value * value</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><code>上面这段改写的代码中闭包里面传入了一个Double类型的参数，并且返回了一个相同类型的处理结果。因为map只需要一个闭包最为参数，所以我们可以使用尾随闭包的特性去除()，而且闭包里面的代码也只有一行我们可以利用单表达式的隐式返回省略return：</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let squares: [Double] &#x3D; values.map&#123;value in value * value&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面value也可以直接使用闭包的参数缩写功能给替换掉：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let squares: [Double] &#x3D; values.map&#123;$0 * $0&#125;</span><br></pre></td></tr></table></figure>

<p>map操作返回的结果数组中元素的类型并不要求与原来的元素类型一致，例如我们可以将一个常见的数字数组转为对应的单词数组：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let scores &#x3D; [0,28,124]</span><br><span class="line">let words &#x3D; scores.map &#123; NSNumberFormatter.localizedStringFromNumber($0, numberStyle: .SpellOutStyle) &#125;</span><br><span class="line">&#x2F;&#x2F;[&quot;zero&quot;, &quot;twenty-eight&quot;, &quot;one hundred twenty-four&quot;]</span><br></pre></td></tr></table></figure>
<p><code>当然除了上面的Array，Set和Dictionary也能应用map操作。</code></p>
<h3 id="Swift函数编程之Filter"><a href="#Swift函数编程之Filter" class="headerlink" title="Swift函数编程之Filter"></a>Swift函数编程之Filter</h3><p>Filter函数操作会对集合类型进行遍历并将其中的满足条件的元素作为结果数组中的元素进行返回。该函数里面只有一个作为条件判断的语句，闭包会遍历集合里面的元素并将满足条件的结果放在一起：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let digits &#x3D; [1,4,10,15] let even &#x3D; digits.filter &#123; $0 % 2 &#x3D;&#x3D; 0 &#125; </span><br><span class="line">&#x2F;&#x2F; [4, 10]</span><br></pre></td></tr></table></figure>

<h3 id="Swift函数编程之Reduce"><a href="#Swift函数编程之Reduce" class="headerlink" title="Swift函数编程之Reduce"></a>Swift函数编程之Reduce</h3><p>Reduce函数操作会将集合类型里面的所有元素组合成一个新值并返回。reduce中的参数为两个：一个初始值、一个combine闭包。例如下面的代码将数组中的元素相加并且其中的初始值为10：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let items &#x3D; [2.0,4.0,5.0,7.0] </span><br><span class="line">let total &#x3D; items.reduce(10.0,combine: +) </span><br><span class="line">&#x2F;&#x2F;28.0</span><br></pre></td></tr></table></figure>

<p>除了上面的数字类型之外也可以对字符串进行处理：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let codes &#x3D; [&quot;Big&quot;,&quot;nerd&quot;,&quot;coding&quot;] </span><br><span class="line">let text &#x3D; codes.reduce(&quot;&quot;, combine: +) </span><br><span class="line">&#x2F;&#x2F;  &quot;Bignerdcoding&quot;</span><br></pre></td></tr></table></figure>

<p>reduce中第二个参数是一个闭包，所有你可以使用尾随闭包来自我特定操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let codes &#x3D; [&quot;Big&quot;,&quot;nerd&quot;,&quot;coding&quot;] </span><br><span class="line">let text &#x3D; codes.reduce(&quot;v2ex&quot;) &#123;text, name in &quot;\(text),\(name)&quot;&#125;</span><br><span class="line">&#x2F;&#x2F;  &quot;v2ex,Big,nerd,coding&quot;</span><br></pre></td></tr></table></figure>

<h3 id="Swift函数编程之FlatMap"><a href="#Swift函数编程之FlatMap" class="headerlink" title="Swift函数编程之FlatMap"></a>Swift函数编程之FlatMap</h3><p>该函数会将那些多维集合类型转换为一维集合类型，实例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let collections &#x3D; [[5,2,7],[4,8],[9,1,3]] let flat &#x3D; collections.flatMap &#123; $0 &#125; </span><br><span class="line">&#x2F;&#x2F; [5, 2, 7, 4, 8, 9, 1, 3]</span><br></pre></td></tr></table></figure>

<p>另外对于可选类型的集合类型来说该函数还能将其中的空值移除掉：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let codes: [String?] &#x3D; [&quot;Big&quot;,nil,&quot;nerd&quot;,nil,&quot;coding&quot;] </span><br><span class="line">let values &#x3D; codes.flatMap &#123;$0&#125; </span><br><span class="line">&#x2F;&#x2F; [&quot;Big&quot;,&quot;nerd&quot;,&quot;coding&quot;]</span><br></pre></td></tr></table></figure>

<p>正在体现flatMap强大功能的地方是与上面一个函数进行组合操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let collections &#x3D; [[5,2,7],[4,8],[9,1,3]] </span><br><span class="line">let onlyEven &#x3D; collections.flatMap &#123; </span><br><span class="line">    intArray in intArray.filter &#123; $0 % 2 &#x3D;&#x3D; 0 &#125; </span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; [2, 4, 8]</span><br></pre></td></tr></table></figure>

<p>上面的代码实现了将多维整形数组里面的偶数筛选出来并且组合成了一个一位数组。flatMap操作的参数是一个以[Int]数组作为参数的闭包。当然我们也可以使用隐含参数对其进行简写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let collections &#x3D; [[5,2,7],[4,8],[9,1,3]] </span><br><span class="line">let onlyEven &#x3D; collections.flatMap &#123; </span><br><span class="line">   $0 in $0.filter &#123; $0 % 2 &#x3D;&#x3D; 0 &#125; </span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; [2, 4, 8]</span><br></pre></td></tr></table></figure>
<p><code>注意：上面简写中第一个和第二个$0表示collections中类似[5,2,7]的字数组，而第三个则表示子数组里面的每个整数</code></p>
<p>与其它操作进行组合的实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;与map操作的组合以及简写</span><br><span class="line">let allSquared &#x3D; collections.flatMap &#123; </span><br><span class="line">    intArray in intArray.map &#123; $0 * $0 &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; [25, 4, 49, 16, 64, 81, 1, 9]</span><br><span class="line"></span><br><span class="line">let allSquared &#x3D; collections.flatMap &#123; </span><br><span class="line">    $0.map &#123; $0 * $0 &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;与reduce操作的组合以及对等的组合操作</span><br><span class="line">let sums &#x3D; collections.flatMap &#123; $0.reduce(0, combine: +) &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;对应的组合操作，两者结果是一样的</span><br><span class="line">let sums &#x3D; collections.map &#123; $0.reduce(0, combine: +) &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Swift函数编程-链式组合"><a href="#Swift函数编程-链式组合" class="headerlink" title="Swift函数编程 链式组合"></a>Swift函数编程 链式组合</h3><p>我们在上面已经看到了flatMap的闭包里面可以与另一操作的组合。我们还可以在闭包的外面对这些操作进行合理的组合来实现我们的目标。例如将数组中大于某个数字的所有数字进行求和操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let marks &#x3D; [4,5,8,2,9,7] </span><br><span class="line">let totalPass &#x3D; marks.filter&#123;$0 &gt;&#x3D; 7&#125;.reduce(0,combine: +) </span><br><span class="line">&#x2F;&#x2F; 24</span><br></pre></td></tr></table></figure>

<p>或者对某一个数组里面的数字进行平方操作然后在进行筛选：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let numbers &#x3D; [20,17,35,4,12] </span><br><span class="line">let evenSquares &#x3D; numbers.map&#123;$0 * $0&#125;.filter&#123;$0 % 2 &#x3D;&#x3D; 0&#125; </span><br><span class="line">&#x2F;&#x2F; [400, 16, 144]</span><br></pre></td></tr></table></figure>

<h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><h3 id="表示和抛出错误"><a href="#表示和抛出错误" class="headerlink" title="表示和抛出错误"></a>表示和抛出错误</h3><p>错误处理是相应和接收来自你程序中错误条件的过程。Swift 给运行时可恢复错误的抛出、捕获、传递和操纵提供了一类支持</p>
<p>在 Swift 中，错误表示为遵循 Error协议类型的值。这个空的协议明确了一个类型可以用于错误处理。<br>Swift 枚举是典型的为一组相关错误条件建模的完美配适类型，关联值还允许错误错误通讯携带额外的信息。比如说，这是你可能会想到的游戏里自动售货机会遇到的错误条件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">enum VendingMachineError: Error &#123;</span><br><span class="line">    case invalidSelection</span><br><span class="line">    case insufficientFunds(coinsNeeded: Int)</span><br><span class="line">    case outOfStock</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>抛出一个错误允许你明确某些意外的事情发生了并且正常的执行流不能继续下去。你可以使用 throw 语句来抛出一个错误。比如说，下面的代码通过抛出一个错误来明确自动售货机需要五个额外的金币：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">throw VendingMachineError.insufficientFunds(coinsNeeded: 5)</span><br></pre></td></tr></table></figure>

<h3 id="处理错误"><a href="#处理错误" class="headerlink" title="处理错误"></a>处理错误</h3><p>当一个错误被抛出，周围的某些代码必须为处理错误响应——比如说，为了纠正错误，尝试替代方案，或者把错误通知用户。</p>
<p>在 Swift 中有四种方式来处理错误。你可以将来自函数的错误传递给调用函数的代码中，使用 do-catch 语句来处理错误，把错误作为可选项的值，或者错误不会发生的断言。每一种方法都在下边的章节中有详细叙述。</p>
<p>当函数抛出一个错误，它就改变了你程序的流，所以能够快速定位错误就显得格外重要。要定位你代码中的这些位置，使用 try 关键字——或者 <code>try?</code> 或 <code>try!</code> 变体——放在调用函数、方法或者会抛出错误的初始化器代码之前。这些关键字在下面的章节中有详细的描述</p>
<p><code>注意：Swift 中的错误处理， try, catch  和 throw 的使用与其他语言中的异常处理很相仿。不同于许多语言中的异常处理——包括 Objective-C ——Swift 中的错误处理并不涉及调用堆栈展开，一个高占用过程。因此， throw 语句的性能特征与 return 比不差多少。</code></p>
<h3 id="使用抛出函数传递错误"><a href="#使用抛出函数传递错误" class="headerlink" title="使用抛出函数传递错误"></a>使用抛出函数传递错误</h3><p>为了明确一个函数或者方法可以抛出错误，你要在它的声明当中的形式参数后边写上 <code>throws</code>关键字。使用 <code>throws</code>标记的函数叫做抛出函数。如果它明确了一个返回类型，那么 throws关键字要在返回箭头 ( -&gt;)之前。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func canThrowErrors() throws -&gt; String</span><br><span class="line"> </span><br><span class="line">func cannotThrowErrors() -&gt; String</span><br></pre></td></tr></table></figure>

<p>抛出函数可以把它内部抛出的错误传递到它被调用的生效范围之内。<br><code>注意：只有抛出函数可以传递错误。任何在非抛出函数中抛出的错误都必须在该函数内部处理。 </code></p>
<p>在抛出函数体内的任何地方，你都可以用 throw语句来抛出错误。</p>
<p>在下边的栗子中， <code>VendingMachine</code>类拥有一个如果请求的物品不存在、卖光了或者比押金贵了就会抛出对应的 <code>VendingMachineError</code>错误的 <code>vend(itemNamed:)</code>方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">struct Item &#123;</span><br><span class="line">    var price: Int</span><br><span class="line">    var count: Int</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">class VendingMachine &#123;</span><br><span class="line">    var inventory &#x3D; [</span><br><span class="line">        &quot;Candy Bar&quot;: Item(price: 12, count: 7),</span><br><span class="line">        &quot;Chips&quot;: Item(price: 10, count: 4),</span><br><span class="line">        &quot;Pretzels&quot;: Item(price: 7, count: 11)</span><br><span class="line">    ]</span><br><span class="line">    var coinsDeposited &#x3D; 0</span><br><span class="line">    </span><br><span class="line">    func vend(itemNamed name: String) throws &#123;</span><br><span class="line">        guard let item &#x3D; inventory[name] else &#123;</span><br><span class="line">            throw VendingMachineError.invalidSelection</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        guard item.count &gt; 0 else &#123;</span><br><span class="line">            throw VendingMachineError.outOfStock</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        guard item.price &lt;&#x3D; coinsDeposited else &#123;</span><br><span class="line">            throw VendingMachineError.insufficientFunds(coinsNeeded: item.price - coinsDeposited)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        coinsDeposited -&#x3D; item.price</span><br><span class="line">        </span><br><span class="line">        var newItem &#x3D; item</span><br><span class="line">        newItem.count -&#x3D; 1</span><br><span class="line">        inventory[name] &#x3D; newItem</span><br><span class="line">        </span><br><span class="line">        print(&quot;Dispensing \(name)&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>vend(itemNamed:)方法的实现使用了 guard语句来提前退出并抛出错误，如果购买零食的条件不符合的话。因为 throw语句立即传送程序控制，所以只有所有条件都达到，物品才会售出。</p>
<p>由于 vend(itemNamed:)方法传递它抛出的任何错误，所以你调用它的代码要么直接处理错误——使用 do-catch语句， try?或者 try!——要么继续传递它们。比如说，下边栗子中的 buyFavoriteSnack(person:vendingMachine:)同样是一个抛出函数，任何 vend(itemNamed:)方法抛出的函数都会向上传递给调用 buyFavoriteSnack(person:vendingMachine:)函数的地方。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">let favoriteSnacks &#x3D; [</span><br><span class="line">    &quot;Alice&quot;: &quot;Chips&quot;,</span><br><span class="line">    &quot;Bob&quot;: &quot;Licorice&quot;,</span><br><span class="line">    &quot;Eve&quot;: &quot;Pretzels&quot;,</span><br><span class="line">]</span><br><span class="line">func buyFavoriteSnack(person: String, vendingMachine: VendingMachine) throws &#123;</span><br><span class="line">    let snackName &#x3D; favoriteSnacks[person] ?? &quot;Candy Bar&quot;</span><br><span class="line">    try vendingMachine.vend(itemNamed: snackName)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; Dispensing Chips</span><br></pre></td></tr></table></figure>

<p>在这个栗子中， <code>buyFavoriteSnack(person:vendingMachine:)</code>函数查找给定人的最爱零食并且尝试通过调用 <code>vend(itemNamed:)</code>方法来购买它们。由于 <code>vend(itemNamed:)</code> 方法会抛出错误，调用的时候要在前边用 try关键字。</p>
<h3 id="使用-Do-Catch-处理错误"><a href="#使用-Do-Catch-处理错误" class="headerlink" title="使用 Do-Catch 处理错误"></a>使用 Do-Catch 处理错误</h3><p>使用 do-catch语句来通过运行一段代码处理错误。如果do分句中抛出了一个错误，它就会与 catch分句匹配，以确定其中之一可以处理错误。</p>
<p>这是 do-catch语句的通常使用姿势：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">do &#123;</span><br><span class="line">    try expression</span><br><span class="line">    statements</span><br><span class="line">&#125; catch pattern 1 &#123;</span><br><span class="line">    statements</span><br><span class="line">&#125; catch pattern 2 where condition &#123;</span><br><span class="line">    statements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 catch后写一个模式来明确分句可以处理哪个错误。如果一个 catch分句没有模式，这个分句就可以匹配所有错误并且绑定这个错误到本地常量 error上。更多关于模式匹配的信息，见模式。<br>catch分句没有处理 do分句可能抛出的所有错误。如果没有 catch分句能处理这个错误，那错误就会传递到周围的生效范围当中。总之，错误总得在周围某个范围内被处理。举例来说，接下来的代码处理了 VendingMachineError枚举里的所有三个错误，但其他所有错误得通过范围内其他代码处理：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var vendingMachine &#x3D; VendingMachine()</span><br><span class="line">vendingMachine.coinsDeposited &#x3D; 8</span><br><span class="line">do &#123;</span><br><span class="line">    try buyFavoriteSnack(&quot;Alice&quot;, vendingMachine: vendingMachine)</span><br><span class="line">    &#x2F;&#x2F; Enjoy delicious snack</span><br><span class="line">&#125; catch VendingMachineError.invalidSelection &#123;</span><br><span class="line">    print(&quot;Invalid Selection.&quot;)</span><br><span class="line">&#125; catch VendingMachineError.outOfStock &#123;</span><br><span class="line">    print(&quot;Out of Stock.&quot;)</span><br><span class="line">&#125; catch VendingMachineError.insufficientFunds(let coinsNeeded) &#123;</span><br><span class="line">    print(&quot;Insufficient funds. Please insert an additional \(coinsNeeded) coins.&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; prints &quot;Insufficient funds. Please insert an additional 2 coins.&quot;</span><br></pre></td></tr></table></figure>

<p>在上面的栗子当中，函数 <code>buyFavoriteSnack(person:vendingMachine:)</code>在 try表达式中被调用，因为它会抛出错误。如果抛出错误，执行会立即切换到 catch分句，它决定是否传递来继续。如果没有错误抛出， do语句中剩下的语句将会被执行。</p>
<h3 id="转换错误为可选项"><a href="#转换错误为可选项" class="headerlink" title="转换错误为可选项"></a>转换错误为可选项</h3><p>使用 <code>try?</code>通过将错误转换为可选项来处理一个错误。如果一个错误在 <code>try?</code>表达式中抛出，则表达式的值为 nil。比如说下面的代码x和y拥有同样的值和行为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">func someThrowingFunction() throws -&gt; Int &#123;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">let x &#x3D; try? someThrowingFunction()</span><br><span class="line"> </span><br><span class="line">let y: Int?</span><br><span class="line">do &#123;</span><br><span class="line">    y &#x3D; try someThrowingFunction()</span><br><span class="line">&#125; catch &#123;</span><br><span class="line">    y &#x3D; nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果 someThrowingFunction()抛出一个错误， x和 y的值就是 nil。另一方面，x和y的值是函数返回的值。注意 x和 y是可选的无论 someThrowingFunction()返回什么类型，这里函数返回了一个整数，所以x和y是可选整数。<br>当你想要在同一句里处理所有错误时，使用 try?能让你的错误处理代码更加简洁。比如，下边的代码使用了一些方法来获取数据，或者在所有方式都失败后返回 nil。    </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func fetchData() -&gt; Data? &#123;</span><br><span class="line">    if let data &#x3D; try? fetchDataFromDisk() &#123; return data &#125;</span><br><span class="line">    if let data &#x3D; try? fetchDataFromServer() &#123; return data &#125;</span><br><span class="line">    return nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="取消错误传递"><a href="#取消错误传递" class="headerlink" title="取消错误传递"></a>取消错误传递</h3><p>事实上有时你已经知道一个抛出错误或者方法不会在运行时抛出错误。在这种情况下，你可以在表达式前写 try!来取消错误传递并且把调用放进不会有错误抛出的运行时断言当中。如果错误真的抛出了，你会得到一个运行时错误。</p>
<p>比如说，下面的代码使用了 loadImage(_:)函数，它在给定路径下加载图像资源，如果图像不能被加载则抛出一个错误。在这种情况下，由于图像跟着应用走，运行时不会有错误抛出，所以取消错误传递是合适的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">	</span><br><span class="line">let photo &#x3D; try! loadImage(&quot;.&#x2F;Resources&#x2F;John Appleseed.jpg&quot;)</span><br></pre></td></tr></table></figure>

<h3 id="指定清理操作"><a href="#指定清理操作" class="headerlink" title="指定清理操作"></a>指定清理操作</h3><p>使用 defer语句来在代码离开当前代码块前执行语句合集。这个语句允许你在以任何方式离开当前代码块前执行必须要的清理工作——无论是因为抛出了错误还是因为 return或者 break这样的语句。比如，你可以使用 defer语句来保证文件描述符都关闭并且手动指定的内存到被释放。</p>
<p>defer语句延迟执行直到当前范围退出。这个语句由 defer关键字和需要稍后执行的语句组成。被延迟执行的语句可能不会包含任何会切换控制出语句的代码，比如 break或 return语句，或者通过抛出一个错误。延迟的操作与其指定的顺序相反执行——就是说，第一个 defer语句中的代码会在第二个中代码执行完毕后执行，以此类推。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">func processFile(filename: String) throws &#123;</span><br><span class="line">    if exists(filename) &#123;</span><br><span class="line">        let file &#x3D; open(filename)</span><br><span class="line">        defer &#123;</span><br><span class="line">            close(file)</span><br><span class="line">        &#125;</span><br><span class="line">        while let line &#x3D; try file.readline() &#123;</span><br><span class="line">            &#x2F;&#x2F; Work with the file.</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; close(file) is called here, at the end of the scope.</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面的离子使用 defer语句来保证 open(<em>:)函数能调用 close(</em>:)。</p>
<p><code>注意：就算没有涉及错误处理代码，你也可以使用 defer语句。</code></p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" rel="tag"># 基础知识</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2017/09/01/view%E7%BB%93%E6%9E%84/" rel="prev" title="iOS 控制器 代码结构规范">
                  <i class="fa fa-chevron-left"></i> iOS 控制器 代码结构规范
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2017/09/10/%E8%BD%AC-Swift-%E5%88%A9%E7%94%A8Enum%E7%81%B5%E6%B4%BB%E6%98%A0%E5%B0%84%E5%A4%9A%E9%87%8D%E7%B1%BB%E5%9E%8BData-model/" rel="next" title="[转]Swift:利用Enum灵活映射多重类型Data model">
                  [转]Swift:利用Enum灵活映射多重类型Data model <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
  
  
  



      
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

    </div>
  </main>

  <footer class="footer">
    <div class="footer-inner">
      

      

<div class="copyright">
  
  &copy; 2015 – 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">LeeWong</span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a>
  </div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.0/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  




  <script src="/js/local-search.js"></script>












  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>






<script>
  (function() {
    function leancloudSelector(url) {
      url = encodeURI(url);
      return document.getElementById(url).querySelector('.leancloud-visitors-count');
    }

    function addCount(Counter) {
      const visitors = document.querySelector('.leancloud_visitors');
      const url = decodeURI(visitors.id);
      const title = visitors.dataset.flagTitle;

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url })))
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length > 0) {
            const counter = results[0];
            leancloudSelector(url).innerText = counter.time + 1;
            Counter('put', '/classes/Counter/' + counter.objectId, { time: { '__op': 'Increment', 'amount': 1 } })
              .catch(error => {
                console.error('Failed to save visitor count', error);
              });
          } else {
              leancloudSelector(url).innerText = 'Counter not initialized! More info at console err msg.';
              console.error('ATTENTION! LeanCloud counter has security bug, see how to solve it here: https://github.com/theme-next/hexo-leancloud-counter-security. \n However, you can still use LeanCloud without security, by setting `security` option to `false`.');
            
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    function showTime(Counter) {
      const visitors = document.querySelectorAll('.leancloud_visitors');
      const entries = [...visitors].map(element => {
        return decodeURI(element.id);
      });

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url: { '$in': entries } })))
        .then(response => response.json())
        .then(({ results }) => {
          for (let url of entries) {
            const target = results.find(item => item.url === url);
            leancloudSelector(url).innerText = target ? target.time : 0;
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    const { app_id, app_key, server_url } = {"enable":true,"app_id":"yUUAHzIjEn8fksXaNEX9VAe4-gzGzoHsz","app_key":"BVLeqEOea57puJUuekMXSvtL","server_url":null,"security":true};
    function fetchData(api_server) {
      const Counter = (method, url, data) => {
        return fetch(`${api_server}/1.1${url}`, {
          method,
          headers: {
            'X-LC-Id'     : app_id,
            'X-LC-Key'    : app_key,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };
      if (CONFIG.page.isPost) {
        if (CONFIG.hostname !== location.hostname) return;
        addCount(Counter);
      } else if (document.querySelectorAll('.post-title-link').length >= 1) {
        showTime(Counter);
      }
    }

    const api_server = app_id.slice(-9) !== '-MdYXbMMI' ? server_url : `https://${app_id.slice(0, 8).toLowerCase()}.api.lncldglobal.com`;

    if (api_server) {
      fetchData(api_server);
    } else {
      fetch('https://app-router.leancloud.cn/2/route?appId=' + app_id)
        .then(response => response.json())
        .then(({ api_server }) => {
          fetchData('https://' + api_server);
        });
    }
  })();
</script>


  

  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1.6.2/dist/gitalk.css">

<script>
NexT.utils.loadComments('#gitalk-container', () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1.6.2/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : '5f882cde7fcb86a5d699',
      clientSecret: '0d812b90fe7a94b3599b62e61b2bbaaa8134baa6',
      repo        : 'BlogComment',
      owner       : 'LeeWongSnail',
      admin       : ['LeeWongSnail'],
      id          : '4696b93265c5dc989f8c2c924fc83b74',
        language: 'zh-CN',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>

</body>
</html>
