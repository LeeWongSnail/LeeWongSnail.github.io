<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>SVProgressHUD的简单封装</title>
    <url>/2016/09/01/ALiProgressHud/</url>
    <content><![CDATA[<p> 项目中，大多数时候都是在view或者控制器中进行弹窗的操作，有时候仅仅是为了一个弹窗还要把状态从view或者model中传到控制器进行弹窗，这相当的麻烦，为什么不让所有的NSObject都可以弹窗呢！</p>
<a id="more"></a>

<h4 id="1、目的"><a href="#1、目的" class="headerlink" title="1、目的"></a>1、目的</h4><p> 项目中，大多数时候都是在view或者控制器中进行弹窗的操作，有时候仅仅是为了一个弹窗还要把状态从view或者model中传到控制器进行弹窗，这相当的麻烦，为什么不让所有的NSObject都可以弹窗呢！</p>
<h4 id="2、具体的方法"><a href="#2、具体的方法" class="headerlink" title="2、具体的方法"></a>2、具体的方法</h4><p>废话不多说直接上方法，相信不用我解释大家都可以看得懂</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> *  显示纯文本 加一个转圈</span><br><span class="line"> *</span><br><span class="line"> *  @param aText 要显示的文本</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (void)showText:(NSString *)aText;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> *  显示错误信息</span><br><span class="line"> *</span><br><span class="line"> *  @param aText 错误信息文本</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (void)showErrorText:(NSString *)aText;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> *  显示成功信息</span><br><span class="line"> *</span><br><span class="line"> *  @param aText 成功信息文本</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (void)showSuccessText:(NSString *)aText;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> *  只显示一个加载框</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (void)showLoading;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> *  隐藏加载框（所有类型的加载框 都可以通过这个方法 隐藏）</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (void)dismissLoading;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> *  显示百分比</span><br><span class="line"> *</span><br><span class="line"> *  @param progress 百分比（整型 100 &#x3D; 100%）</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (void)showProgress:(NSInteger)progress;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> *  显示图文提示</span><br><span class="line"> *</span><br><span class="line"> *  @param image 自定义的图片</span><br><span class="line"> *  @param aText 要显示的文本</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (void)showImage:(UIImage*)image text:(NSString*)aText;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>如果你想自定义显示的图片 可以在ALiProgressHUD中替换那几张图片即可</code></p>
<p>demo演示：</p>
<p><img src="https://i.niupic.com/images/2016/09/08/RnE9pQ.gif" alt="demo"></p>
<h4 id="3、总结"><a href="#3、总结" class="headerlink" title="3、总结"></a>3、总结</h4><p> 项目中有很多让我们头疼的问题，就不要让这一个小小的弹窗困扰我们了。如果你还需要其他的样式 欢迎给我提issues，我会及时回复的！</p>
]]></content>
      <categories>
        <category>开源代码</category>
      </categories>
      <tags>
        <tag>弹窗,SVProgressHUD</tag>
      </tags>
  </entry>
  <entry>
    <title>抽象工厂模式</title>
    <url>/2016/09/27/AbstractFactoryPattern/</url>
    <content><![CDATA[<p>在上一篇工厂模式中，我开了一家pizza店，生意非常好哇，然后我就想着在国内多开几家分店。但是，问题来了，我如何确保每个地方pizza原材料的质量呢？接下来 我们可以使用抽象工厂方法来解决这个问题。</p>
<a id="more"></a>

<h4 id="1、定义"><a href="#1、定义" class="headerlink" title="1、定义"></a>1、定义</h4><p>抽象工厂模式：提供一个借口，用于创建相关或依赖对象的家族，而不需要明确指定具体类。</p>
<p>抽象工厂允许客户使用抽象的接口来创建一组相关的产品，而不需要知道实际产品的具体产品是什么。这样一来，客户就从具体的产品中解耦。</p>
<h4 id="2、使用场景"><a href="#2、使用场景" class="headerlink" title="2、使用场景"></a>2、使用场景</h4><p>前言中我也说道了，我的店目前要在全国到处都开分店，如何保证使用高质量的原材料，保证我的pizza的口味。</p>
<p>因此，我决定在全国各地建造原料加工厂，这时又有另外一个问题需要我考虑？如何保证每一个加工厂的材料标准。因此，我决定要制作一套各种口味pizza的制作标准，同时根据地理位置的不同做一些改变。</p>
<p>这样的话，如果需要新建加工厂只需要让这个加工厂按照我制作的这个标准对食材进行加工即可（具体的加工厂要遵照我指定的协议，实现协议中的各原材料的制作方法）。</p>
<p>结合前面的工厂模式，我只需要在创建各类Pizza的时候将就近的Pizza的加工厂传递过去就可以达到就近取材就近加工的目的了。</p>
<h4 id="3、思考"><a href="#3、思考" class="headerlink" title="3、思考"></a>3、思考</h4><p>1、如果我有一个协议，让每一个加工厂都遵守这个协议，那么是不是意味着，如果某一个加工厂需要修改东西我就需要在这个协议中做相应的修改，或者说我要加一个新的pizza，我需要修改协议和相应的类这可能会导致我修改很多类！</p>
<p>的确是这样的，因为我们使用抽象工厂就是要把很多相关的内容做一个集合，这就要求我们的这个接口必须 <code>全</code>。这也是抽象工厂模式的一个弊端！</p>
<p>2、感觉跟工厂模式的区别只在于一个使用了类的继承，另一个使用了对象的组合？</p>
<p>首先，两者的功能都是把应用程序从特定的实现中解耦出来。工厂模式是通过子类创建对象，客户只需要知道抽象类型，子类去负责具体类型。抽象工厂提供一个用来创建一个产品家族的抽象类型，这个类型的实例定义产品被生产的方法。</p>
<h4 id="4、具体实现"><a href="#4、具体实现" class="headerlink" title="4、具体实现"></a>4、具体实现</h4><p><img src="https://i.niupic.com/images/2016/09/27/0PVAm3.png" alt="协议抽象"></p>
<p>下面我们重新整理一下整个点餐的过程<br>1、创建一个store的实例<br>PizzaStore *store = [[BJPizzaStore alloc] init];</p>
<p>2、用户点单<br>[store orderPizza:1];</p>
<p>3、制作Pizza<br>Pizza *pizza = [self createPizza:1];</p>
<p>4、createPizza的具体实现<br>Pizza *pizza = [[BJCheesePizza alloc] initWith:BJFactory];</p>
<p>这里BJFactory是提前创建好的一个加工厂的实例对象。</p>
<p>5、调用BJFactory的准备原材料的方法</p>
<ul>
<li>(void)prepare{<br>  dough = [factory createDough];<br>  sauce = [factory createSauce];<br>}</li>
</ul>
<p>6、继续接着调用工厂方法中封装的那一套。</p>
<p><img src="https://i.niupic.com/images/2016/09/27/gbrJZW.png" alt="运行结果"></p>
<p><a href="https://github.com/LeeWongSnail/Head-First-DesignPattern/tree/master/FactoryPattern">代码放在这里了</a></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>工厂设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>App组件化文章收集</title>
    <url>/2016/06/12/App%E7%BB%84%E4%BB%B6%E5%8C%96%E6%96%87%E7%AB%A0%E6%94%B6%E9%9B%86/</url>
    <content><![CDATA[<p>公司打算新启一个APP，希望实现组件化，或者说我们几个对组件化毫无所知的人，打算用起来这个牛逼的东西，下面是我搜集的一些文章，以及我对这些文章的理解。</p>
<a id="more"></a>


<h4 id="1、组件的管理"><a href="#1、组件的管理" class="headerlink" title="1、组件的管理"></a>1、组件的管理</h4><p>目前网上找到的主要有三个：</p>
<p>1、<a href="https://github.com/mogujie/MGJRouter.git">蘑菇街</a></p>
<p>2、<a href="https://github.com/casatwy/CTMediator.git">casatwy大神</a></p>
<p>3、<a href="https://github.com/Lede-Inc/LDBusMediator.git">LDBusMediator</a> </p>
<p>4、<a href="https://github.com/joeldev/JLRoutes">JLRoutes</a></p>
<p>5、<a href="https://github.com/Huohua/HHRouter">HHRouter</a></p>
<p>下面我会仔细的看一下这几个架构方面的解析，判断到底该选择哪一个！</p>
]]></content>
      <categories>
        <category>组件化</category>
      </categories>
      <tags>
        <tag>文章收集</tag>
        <tag>组件化</tag>
      </tags>
  </entry>
  <entry>
    <title>装饰者模式</title>
    <url>/2016/09/18/DecoratorMode/</url>
    <content><![CDATA[<p>最近买了本设计模式的书Header First 非常喜欢其中的讲解方式。虽然买了有一段时间了但是没有认真的看过。这段时间工作相对没有那么难了，所以抽出点时间看一下这本书，同时，在这里做一下分享，希望可以帮到你！</p>
<a id="more"></a>

<h4 id="1、定义"><a href="#1、定义" class="headerlink" title="1、定义"></a>1、定义</h4><p><code>装饰者模式</code>：动态地将责任附加到对象上，若要扩展功能，装饰者提供了比继承更有弹性的替代方案。</p>
<p><code>给爱用继承的人一个全新的设计眼界</code></p>
<h4 id="2、使用场景"><a href="#2、使用场景" class="headerlink" title="2、使用场景"></a>2、使用场景</h4><p> 比如，我们现在有一个需求，建设一个<code>家</code>。首先我们需要<code>房子</code>，其次我们需要去装修这所房子。很明显在装修的过程中我们可能要用很多的<code>材料</code>，而且还要买很多的<code>家具</code>。那么在我做预算的时候我就要知道这个家的<code>总造价</code>,那么我如何更快更好的获取到这个房子的总造价呢？</p>
<p> 由于每个家具的造价是不相同的，而具体的价格只有家具本身最清楚。因此简单的讲，我们可以设置一个<code>父类</code>(家)，各种家具作为<code>子类</code>。父类针对每一个子类拥有两个属性（是否使用这个家具，这个家具的价格是多少）。这样父类在计算总价格的时候就可以通过判断是<code>否使用某一类家具</code>，如果使用那么在计算的时候就<code>加上</code>这个家具的<code>价格</code>。</p>
<p> 但是，每次我要添置一个新的家具，我就要修改父类中的方法，这完全违背了我们面向对象的设计原则。这时候就该装饰者模式大显身手了。</p>
<p> 装饰者模式，其实说白了就是组合的方式，存在一个主体，同时也存在很多与主体同类型的装饰品，一个复杂的主题可以通过一个单纯的主题和许多装饰品通过复杂的组合方式组合成一个复杂的主题。</p>
<p> 例如，我们有一个<code>房子</code>，这个房子作为<code>主体</code>，同时我们还有很多<code>家具</code>(家具和房子都是我们的<code>家</code>的<code>子类</code>)，我们从这些子类中选择一个作为主体(房子),选择其他的作为装饰者(家具等)，这样我们通过组合就能组合出一个漂亮的<code>家</code>。这其中要注意哪一个是主题哪一个是主题，哪一个是装饰者。</p>
<h4 id="3、思考"><a href="#3、思考" class="headerlink" title="3、思考"></a>3、思考</h4><p>  咦？？？？？，我们在使用装饰者模式，<code>家具和房子都是我们的家的子类</code>,这么明显的继承，显然违背了我们少用继承多用组合的设计原则啊！什么鬼！！！</p>
<p>  这里我们的确是使用了继承，但是要注意，我们这里使用继承的目的和使用继承与之前的区别。</p>
<p>  这里我们使用继承的目的是使装饰者和被装饰者是相同类型，也就是说有共同的父类。</p>
<p>  这里的继承与以往不同，以往的继承我们主要是想做到一些方法或者属性的继承，属于功能性的继承，但是这里我们的继承属于类型继承。</p>
<p>  这样，我们的装饰者和被装饰者属于同一种类型，那么我们在使用的时候就可以使用装饰者取代被装饰者，或者使用被装饰者取代装饰者。</p>
<h4 id="4、修改思路"><a href="#4、修改思路" class="headerlink" title="4、修改思路"></a>4、修改思路</h4><p>那么我们如何使用装饰者模式去实现我们的这个需求呢。</p>
<p>首先我们的家具和房子必须同属一个父类（确保二者的类型是相同的，保证互相可代替性）。</p>
<p>其次：作为主体，我们从父类继承了一个方法（比如cost()价格），对于其他的装饰者，我们也实现一个cost()方法。</p>
<p>我们如果要计算总的造价，比如要计算一个带有冰箱，电视机，空调，洗衣机的房子的总造价。那么最简单的方法是计算一个带冰箱的家的造价+带电视机的家的造价+带空调、洗衣机的家的造价+房子的造价 = 总造价。</p>
<p>对于装饰者和被装饰者的关系，可以通过下图来表述</p>
<p><img src="https://i.niupic.com/images/2016/09/19/4fl4aI.png" alt="关系图"></p>
<h4 id="5、具体实现"><a href="#5、具体实现" class="headerlink" title="5、具体实现"></a>5、具体实现</h4><ul>
<li>1、确定一个父类（Family）</li>
<li>2、这个父类有两个子类（装饰者和被装饰者）家具和房子</li>
<li>3、对于装饰者，每一个装饰者都有一个属性（family）一个方法cost()<br> 一个构造函数（传入family的初始值）,同时cost方法是将属性family<br>  的cost()+自己的价格</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    cost() &#123;</span><br><span class="line">    </span><br><span class="line">	return 0.4 + family.cost();</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ul>
<li>4、对于被装饰者，我们要实现一个cost()方法</li>
</ul>
<p>我们计算总造价的时候，是通过：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Family *f1 &#x3D; house();</span><br><span class="line"></span><br><span class="line">f1 &#x3D; bridge(f1);</span><br><span class="line"></span><br><span class="line">f1 &#x3D; washmachine(f1);</span><br><span class="line"></span><br><span class="line">f1 &#x3D; tv(f1);</span><br><span class="line"></span><br><span class="line">f1 &#x3D; aircondition(f1);</span><br><span class="line"></span><br><span class="line">nslog(f1.cost());</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>通过这种方式我们可以计算出房子的具体造价，具体实现的如下图所示：</p>
<p><img src="https://i.niupic.com/images/2016/09/19/sPN5r6.png" alt="具体实现"></p>
<p>具体的代码实现放到<a href="https://github.com/LeeWongSnail/Head-First-DesignPattern/tree/master/DecoratePattern">这里</a></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>装饰者模式</tag>
      </tags>
  </entry>
  <entry>
    <title>工厂模式</title>
    <url>/2016/09/26/Factory-Pattern/</url>
    <content><![CDATA[<p>最近买了本设计模式的书Header First 非常喜欢其中的讲解方式。虽然买了有一段时间了但是没有认真的看过。这段时间工作相对没有那么难了，所以抽出点时间看一下这本书，同时，在这里做一下分享，希望可以帮到你！</p>
<a id="more"></a>

<h4 id="1、定义"><a href="#1、定义" class="headerlink" title="1、定义"></a>1、定义</h4><p>工厂方法模式：定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法让类的实例化推迟到子类。</p>
<p>所有工厂模式都用来封装对象的创建，工厂方法模式通过让子类决定该创建的对象是什么，来达到将对象创建的过程封装的目的。</p>
<h4 id="2、使用场景"><a href="#2、使用场景" class="headerlink" title="2、使用场景"></a>2、使用场景</h4><p>假如我有一个披萨店，刚开始没有分店也只是提供了北京口味的pizza。所以我的创建很简单。</p>
<p><img src="https://i.niupic.com/images/2016/09/26/MZGIaS.png" alt="我的pizza"></p>
<p>但是后来用户给我反馈，因为他们来自不同的地区所以希望我提供，北京口味、东北口味的披萨。</p>
<p>OK 那么我在点单的时候让用户自主的去选择order(type);<br>那么我的点单的方法改成了这样</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)order:(NSInteger)aType</span><br><span class="line">&#123;</span><br><span class="line">    Pizza *pizza &#x3D; nil;</span><br><span class="line">    if (type &#x3D;&#x3D; @&quot;东北&quot;) &#123;</span><br><span class="line">        pizza &#x3D; DBPizza();</span><br><span class="line">    &#125; else if (type &#x3D;&#x3D; @&quot;北京&quot;)&#123;</span><br><span class="line">        pizza &#x3D; BJPizza();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>后来生意更好了，全国开了很多分店，就会不断的加入更多的其他口味的pizza，同时也有可能有很多pizza的口味因为不符合要求被下架。所以这可能导致我的点餐方法越来越复杂。</p>
<p>同时，因为全国都有分店，分店中可能很多同一口味的做法都不同，所以这时候要考虑把这个全国都使用的方法下方到地方，不再做统一的管理。</p>
<p>首先想到的肯定是把这个方法抽出来，单独放到一个类中。这个类实际上就是一个工厂类。我们将要点餐的type传入之后由这个工厂类决定到底实例化哪一种pizza。</p>
<h4 id="3、思考"><a href="#3、思考" class="headerlink" title="3、思考"></a>3、思考</h4><p> 1、这么做的好处是什么？还是只是做了简单的代码的分离。</p>
<p> 我们这里，在这个工厂类中只是提供了这一个方法，之后我们可能还会有其他的工厂方法，都可以放到这个类中，所以这个工厂方法为代码以后的扩展提供了方便，同时如果以后需要修改或者添加可以直接修改这个类就可以了。</p>
<p>2、对于pizza的工厂方法，我们可能有很多的类型比如BJPizzaFactory,DBPizzaFactory 如果有很多的这种工厂方法，我们如何做统一的管理呢？</p>
<p>我们可以设置一个基类，这个基类用来控制Pizza的整个制作流程，同时提供一个抽象方法createPizza，我们让BJPizzaFactory,DBPizzaFactory继承自这个类，同时实现createPizza这个抽象方法。</p>
<h4 id="4、修改思路"><a href="#4、修改思路" class="headerlink" title="4、修改思路"></a>4、修改思路</h4><p>1、客户点单<br>PizzaStore bjPizzaStore = new BJPizzaStore();<br>bjPizzaStore.orderPizza(“cheese”);</p>
<p>2、制作pizza<br>Pizza pizza = createPizza(“cheese”);</p>
<p>3、其他流程<br>pizza.bake();<br>pizza.cut();<br>pizza.box();</p>
<h4 id="5、具体实现"><a href="#5、具体实现" class="headerlink" title="5、具体实现"></a>5、具体实现</h4><p><img src="https://i.niupic.com/images/2016/09/26/6NdcNG.png" alt="流程"></p>
<p><img src="https://i.niupic.com/images/2016/09/27/5O6pj1.png" alt="结果"></p>
<p><a href="https://github.com/LeeWongSnail/Head-First-DesignPattern/tree/master/FactoryPattern">代码实现在这里</a></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>工厂模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Git使用笔记之冲突解决</title>
    <url>/2019/07/14/Git%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3/</url>
    <content><![CDATA[<p>我们公司产品有两条线 一个是针对日本地区的一个独立APP(B),另一个是针对除日本地区之外的其他的地区的APP(A) 。B是基于A的某个分支建立的,并且删除了部分功能,在过去的一段时间内两条产品线各自为战,但是前段时间公司希望将A中的某个功能直接迁移到B上,为此我们开始了下面的工作。</p>
<a id="more"></a>

<h3 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h3><p>对于这个任务我们分为下面三步：</p>
<blockquote>
<p>1、因为B是基于A创建的所以有些基础的部分二者是相同的(双方都有修改),所以第一步是抽取公共部分。<br>2、在A中将希望移植的功能与A的其他功能解耦(可以来来1中公共的部分)<br>3、将2中抽取的功能移植到B中</p>
</blockquote>
<p>额,有点跑偏了,我们这片文章主要是想介绍git的使用,但是上面为什么从重构开始说呢？那是因为在重构的过程中我们大量修改了现有工程的目录结构,之前工程大都是虚拟文件夹,重构后我们统一使用实体文件夹管理。但是我们在重构项目的过程中,还是有新的需求在不断的添加在以旧的工程目录结构为标准的项目中。在我们完成模块迁移后就发现了一个重要的问题：合代码！！！</p>
<p>下面我来简单的描述下这个悲伤的故事：<br>因为项目的目录结构被大量的修改,所以配置文件<code>project.pbxproj</code>有大量的冲突,配置文件的冲突大概分为两类：文件位置冲突、文件夹位置冲突。对于文件又可以分为:<code>both modified</code>、<code>deleted by us</code>、<code>new file</code>、<code>added by us</code>、<code>added by them</code> 这几大类。</p>
<p>先来看下<code>project.pbxproj</code>这个文件的结构：</p>
<p><img src="https://s2.ax1x.com/2019/07/21/e9zHkn.png" alt="e9zHkn.png"></p>
<h3 id="冲突类型"><a href="#冲突类型" class="headerlink" title="冲突类型"></a>冲突类型</h3><p>下面来简单的看下这几种冲突：</p>
<h4 id="配置文件冲突"><a href="#配置文件冲突" class="headerlink" title="配置文件冲突"></a>配置文件冲突</h4><h5 id="文件位置冲突"><a href="#文件位置冲突" class="headerlink" title="文件位置冲突"></a>文件位置冲突</h5><p><img src="https://s2.ax1x.com/2019/07/21/eCSS0J.jpg" alt="eCSS0J.jpg"></p>
<p>对于这种冲突，我们一般的解决方法是领边都保留。</p>
<h5 id="文件夹位置冲突"><a href="#文件夹位置冲突" class="headerlink" title="文件夹位置冲突"></a>文件夹位置冲突</h5><p><img src="https://s2.ax1x.com/2019/07/21/eCSPt1.jpg" alt="eCSPt1.jpg"></p>
<p><img src="https://s2.ax1x.com/2019/07/21/eCSkp6.jpg" alt="eCSkp6.jpg"></p>
<p><img src="https://s2.ax1x.com/2019/07/21/eCSene.jpg" alt="eCSene.jpg"></p>
<h4 id="类文件冲突"><a href="#类文件冲突" class="headerlink" title="类文件冲突"></a>类文件冲突</h4><h5 id="both-modified"><a href="#both-modified" class="headerlink" title="both modified"></a>both modified</h5><p>双方都有修改</p>
<p><img src="https://s2.ax1x.com/2019/07/21/eCSgHJ.jpg" alt="eCSgHJ.jpg"></p>
<h5 id="deleted-by-us"><a href="#deleted-by-us" class="headerlink" title="deleted by us"></a>deleted by us</h5><p>本地分支删除(也有可能是位置被修改),但是需要注意,本地分支如果移动位置且远端分支有修改那么本地分支会标记为deleted by us 远端的标记为new file。这时候我们需要对比两个文件,保留修改。</p>
<h5 id="new-file"><a href="#new-file" class="headerlink" title="new file"></a>new file</h5><p>新增文件,但是不要被这个名称迷惑,这里面很有可能是本地分支修改了位置,但是远端分支做了修改,但是因为本地的配置文件之前的位置已经没有这个文件了,所以在合并代码的时候会被标识为new file</p>
<h5 id="added-by-us"><a href="#added-by-us" class="headerlink" title="added by us"></a>added by us</h5><p>本地分支添加的文件,注意这里也有可能是从之前文件夹移动到新文件夹的文件</p>
<h5 id="added-by-them"><a href="#added-by-them" class="headerlink" title="added by them"></a>added by them</h5><p>远端分支添加</p>
<h4 id="问题和难点"><a href="#问题和难点" class="headerlink" title="问题和难点"></a>问题和难点</h4><h5 id="1、配置文件的合并"><a href="#1、配置文件的合并" class="headerlink" title="1、配置文件的合并"></a>1、配置文件的合并</h5><p>从上面分类中我们也可以看到,文件位置的冲突其实都好解决,但是文件夹位置的冲突,我们真的很难解决这个地方非常耗时。而且<code>project.pbxproj</code>这个文件是非常脆弱的,只要我们有一个地方没有修改正确 我们的工程都无法正常打开。所以我们一般在修改这个文件冲突的时候都选择两者都保留 或者根据文件夹的ID去查找。但是有些位置我们甚至无法做到两者都保留</p>
<p><img src="https://s2.ax1x.com/2019/07/21/eCSHDe.jpg" alt="eCSHDe.jpg"></p>
<p>这种情况下我们为了尽快可以打开项目,然后通过编译的方式查看刚才删除文件夹。我们可能会直接删除其中一个。</p>
<h5 id="2、范围的确定"><a href="#2、范围的确定" class="headerlink" title="2、范围的确定"></a>2、范围的确定</h5><p>因为第一步的操作过程中,给我们埋下了坑,第二步的时候需要我们找到,可能某些文件的实体文件是存在的但是项目中没有引用(第一步直接删除),当然 还有另外的可能就是:本地分支已经删除,远端还保留,那么这些文件实际上是需要删除。另外也有可能是本地分支移动了这个文件的位置导致某个文件在本地存有两份。</p>
<p>所以针对这种情况,我们需要仔细分析,然后在去解决冲突。</p>
<p>总结：根据上面的描述,我们在每次主分支发布新版本,重构代码版本需要合并新分支代码的时候,我们都要预留大概3-5天的时间去合并代码。耗时又费力。</p>
<h3 id="mergepbx"><a href="#mergepbx" class="headerlink" title="mergepbx"></a>mergepbx</h3><p>先来介绍一下使用方法：</p>
<h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>可以直接使用 brew 直接安装 mergepbx</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew install mergepbx</span><br></pre></td></tr></table></figure>

<h4 id="将mergepbx设置添加到〜-gitconfig"><a href="#将mergepbx设置添加到〜-gitconfig" class="headerlink" title="将mergepbx设置添加到〜/ .gitconfig"></a>将mergepbx设置添加到〜/ .gitconfig</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">git config --global merge.mergepbx.name“Xcode项目文件合并”</span><br><span class="line">git config --global merge.mergepbx.driver“mergepbx％O％A％B”</span><br></pre></td></tr></table></figure>

<h4 id="配置-gitconfig"><a href="#配置-gitconfig" class="headerlink" title="配置 .gitconfig"></a>配置 .gitconfig</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[合并“mergepbx”]</span><br><span class="line">    name &#x3D; Xcode项目文件合并</span><br><span class="line">    driver &#x3D; mergepbx％O％A％B</span><br></pre></td></tr></table></figure>

<h4 id="gitattributes"><a href="#gitattributes" class="headerlink" title=".gitattributes"></a>.gitattributes</h4><p>在项目的目录下(与.git同级)新建一个.gitattributes文件 同时在里面写入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* .pbxproj merge &#x3D; mergepbx</span><br></pre></td></tr></table></figure>

<h4 id="git-merge"><a href="#git-merge" class="headerlink" title="git merge"></a>git merge</h4><p>这时候 在使用本地分支merge远程 我们惊奇的发现 <code>project.pbxproj</code>这个该死的玩意没有冲突。感觉都已经要成功一半的样子。</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><h4 id="首先看下-gitattributes"><a href="#首先看下-gitattributes" class="headerlink" title="首先看下 .gitattributes"></a>首先看下 <code>.gitattributes</code></h4><p>gitattributes文件中的每一行都是以下格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pattern        attr1 attr2 ...</span><br></pre></td></tr></table></figure>

<p>.gitattributes实际上是定义在发生冲突时，应该采取的行动，比如merge=ours就表示文件冲突时使用原文件内容，merge=theirs表示使用其他分支的文件内容。</p>
<p>我们上面的定义表示 在发生冲突的时候使用mergepbx来确定冲突解决方法</p>
<h4 id="然后我们在来看下-gitconfig"><a href="#然后我们在来看下-gitconfig" class="headerlink" title="然后我们在来看下 .gitconfig"></a>然后我们在来看下 <code>.gitconfig</code></h4><p>这个文件表示 git的配置信息</p>
<p>我们通过</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">git config --global merge.mergepbx.name“Xcode项目文件合并”</span><br><span class="line">git config --global merge.mergepbx.driver“mergepbx％O％A％B”</span><br></pre></td></tr></table></figure>
<p>这两句 实际上就是在.gitconfig中添加了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[合并“mergepbx”]</span><br><span class="line">    name &#x3D; Xcode项目文件合并</span><br><span class="line">    driver &#x3D; mergepbx％O％A％B</span><br></pre></td></tr></table></figure>
<p>这两行</p>
<h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><p><a href="https://qiita.com/kaneshin/items/1deebde685c973fda6b8">pbxprojファイルのマージが便利になるmergepbxをインストールするスクリプト書いた</a></p>
<p><a href="https://www.jianshu.com/p/50cc564b58ce">iOSXcodeProject的内部结构分析</a></p>
<p><a href="https://nicreals.github.io/Gear/Xcode.html">XCodeConfig</a></p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>冲突</tag>
      </tags>
  </entry>
  <entry>
    <title>OSSMaker 使用详解</title>
    <url>/2018/09/02/OSSURLMontage/</url>
    <content><![CDATA[<p>项目中,当我们要在列表页展示图片时,为了提升图片的加载速度,同时兼顾显示效果。一般我们会采用展示缩略图的形式去加载图片。这时我们就会用到阿里云OSS的图片地址拼接策略。</p>
<a id="more"></a>

<h1 id="OSSMaker-使用详解"><a href="#OSSMaker-使用详解" class="headerlink" title="OSSMaker 使用详解"></a>OSSMaker 使用详解</h1><p>项目中,当我们要在列表页展示图片时,为了提升图片的加载速度,同时兼顾显示效果。一般我们会采用展示缩略图的形式去加载图片。这时我们就会用到阿里云OSS的图片地址拼接策略。</p>
<h2 id="Aliyun图片裁剪拼接参数简介"><a href="#Aliyun图片裁剪拼接参数简介" class="headerlink" title="Aliyun图片裁剪拼接参数简介"></a>Aliyun图片裁剪拼接参数简介</h2><h3 id="图片缩放"><a href="#图片缩放" class="headerlink" title="图片缩放"></a>图片缩放</h3><p>操作名称：<code>resize</code></p>
<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
<th>取值范围</th>
<th>当前是否支持</th>
</tr>
</thead>
<tbody><tr>
<td>m</td>
<td>指定缩略的模式：lfit：等比缩放，限制在指定w与h的矩形内的最大图片。mfit：等比缩放，延伸出指定w与h的矩形框外的最小图片。fill：固定宽高，将延伸出指定w与h的矩形框外的最小图片进行居中裁剪。pad：固定宽高，缩略填充。fixed：固定宽高，强制缩略</td>
<td>lfit、mfit、fill、pad、fixed，默认为lfit。</td>
<td>已支持</td>
</tr>
<tr>
<td>w</td>
<td>指定目标缩略图的宽度。</td>
<td>1-4096</td>
<td>已支持</td>
</tr>
<tr>
<td>h</td>
<td>指定目标缩略图的高度。</td>
<td>1-4096</td>
<td>已支持</td>
</tr>
<tr>
<td>l</td>
<td>指定目标缩略图的最长边。</td>
<td>1-4096</td>
<td>已支持</td>
</tr>
<tr>
<td>s</td>
<td>指定目标缩略图的最短边。</td>
<td>1-4096</td>
<td>已支持</td>
</tr>
<tr>
<td>limit</td>
<td>指定当目标缩略图大于原图时是否处理。值是 1 表示不处理；值是 0 表示处理。</td>
<td>0/1, 默认是 1</td>
<td>未支持</td>
</tr>
<tr>
<td>color</td>
<td>当缩放模式选择为pad（缩略填充）时，可以选择填充的颜色(默认是白色)参数的填写方式：采用16进制颜色码表示，如00FF00（绿色）。</td>
<td>[000000-FFFFFF]</td>
<td>未支持</td>
</tr>
</tbody></table>
<p><code>注意:</code></p>
<ul>
<li><p>1 对于原图：</p>
<blockquote>
<p>图片格式只能是：jpg、png、bmp、gif、webp、tiff。<br>文件大小不能超过20 MB。<br>使用图片旋转时图片的宽或者高不能超过4096。</p>
</blockquote>
</li>
<li><p>2 对于缩略图：对缩略后的图片大小有限制，目标缩略图宽与高的乘积不能超过 4096 x 4096，且单边长度不能超过 4096 x 4。</p>
</li>
<li><p>3 当只指定宽度或者高度时，在等比缩放的情况下，都会默认进行单边的缩放。在固定宽高的模式下，会默认宽高一样的情况下进行缩略。</p>
</li>
<li><p>4 如果只指定宽度或者高度，原图按原图格式返回。如果想保存成其他格式，详细可以查看质量变换及格式转换。</p>
</li>
<li><p>5 调用resize，默认是不允许放大。即如果请求的图片对原图大，那么返回的仍然是原图。如果想取到放大的图片，即增加参数调用limit,0 （如：<a href="https://image-demo.oss-cn-hangzhou.aliyuncs.com/example.jpg?x-oss-process=image/resize,w_500,limit_0%EF%BC%89">https://image-demo.oss-cn-hangzhou.aliyuncs.com/example.jpg?x-oss-process=image/resize,w_500,limit_0）</a></p>
</li>
</ul>
<h3 id="图片裁剪"><a href="#图片裁剪" class="headerlink" title="图片裁剪"></a>图片裁剪</h3><h4 id="内切圆"><a href="#内切圆" class="headerlink" title="内切圆"></a>内切圆</h4><p>操作名称：<code>circle</code></p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
<th>取值</th>
<th>是否支持</th>
</tr>
</thead>
<tbody><tr>
<td>r</td>
<td>从图片取出的圆形区域的半径</td>
<td>半径 r 不能超过原图的最小边的一半。如果超过，则圆的大小仍然是原圆的最大内切圆</td>
<td>已支持</td>
</tr>
</tbody></table>
<p><code>注意：</code></p>
<ul>
<li><p>如果图片的最终格式是 png、webp、 bmp 等支持透明通道的图片，那么图片非圆形区域的地方将会以透明填充。如果图片的最终格式是 jpg，那么非圆形区域是以白色进行填充。推荐保存成 png 格式。</p>
</li>
<li><p>如果指定半径大于原图最大内切圆的半径，则圆的大小仍然是图片的最大内切圆。</p>
</li>
</ul>
<h3 id="圆角矩形"><a href="#圆角矩形" class="headerlink" title="圆角矩形"></a>圆角矩形</h3><p>操作名称：<code>rounded-corners</code></p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
<th>取值</th>
<th>是否支持</th>
</tr>
</thead>
<tbody><tr>
<td>r</td>
<td>将图片切出圆角，指定圆角的半径。</td>
<td>[1, 4096] 生成的最大圆角的半径不能超过原图的最小边的一半。</td>
<td>已支持</td>
</tr>
</tbody></table>
<h2 id="之前的做法"><a href="#之前的做法" class="headerlink" title="之前的做法"></a>之前的做法</h2><p>对于图片的展示一般我们提前知晓图片要展示的宽高,或者知道图片的高度宽度自适应或者知道宽度高度自适应。</p>
<h3 id="定义一个该位置图片需要拼接的字符串常量"><a href="#定义一个该位置图片需要拼接的字符串常量" class="headerlink" title="定义一个该位置图片需要拼接的字符串常量"></a>定义一个该位置图片需要拼接的字符串常量</h3><p><code>static NSString *URL_SCALE_DUBLIST_AVATAR = @&quot;x-oss-process=image/resize,m_mfit,h_210,w_210/rounded-corners,r_9/format,png&quot;; </code></p>
<p>当我们需要展示的时候 将这个常量直接添加到我们要展示的图片的后面,就可以拿到我们要展示的缩略图了。</p>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>上面的这种做法最直观同时也最简单。但是如果每个列表展示的图片宽高均不相同 那么我们就要定义无数个字符串常量来满足我们的需求。</p>
<h2 id="改进方法"><a href="#改进方法" class="headerlink" title="改进方法"></a>改进方法</h2><p>由于大多数情况下我们展示的图片宽高都不尽相同,这些字符串常量基本上复用的可能性不是太大(当然为了提高图片缓存的利用率我们需要跟UI协调尽量统一)。</p>
<p>如果我们不去定义每处展示的字符串常量,那么我们可以通过在每个地方单独通过参数的方式传给我们的管理对象 我需要设置的属性(宽度/高度/圆角/内切圆/图片展示模式)。由于这里要传递的参数比较多,因此通过普通的工厂方法去实现的话会导致代码的可读性方面降低。同时使用者也需要书写大量的代码。因此,这里 推出链式调用的方式去拼接字符串。</p>
<h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *res = <span class="keyword">self</span>.coverURL.absoluteString.maker.resize.contentMode(@(OSSImageResizeContentModelTypeMfit)).height(@<span class="number">60</span>).width(@<span class="number">106</span>).resultString;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里是我们想要将图片切为宽度是106 高度为60 contentMode为Fit样式的展示。</p>
<p><code>注意:</code> 最终实际拼接出的图片的<code>宽高</code>为根据外部传入的参数 <code>乘以</code> 当前屏幕的 <code>Scale</code>,因此会根据当前设备去取2x还是3x图。</p>
<p>通过上面这样的拼接我们就可以将我们需要设置的各项参数拼接到图片URL的尾部。</p>
<h2 id="内部实现简介"><a href="#内部实现简介" class="headerlink" title="内部实现简介"></a>内部实现简介</h2><p>为了方便使用,这里将图片拼接的<code>maker</code>方法放到了字符串的分类中。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (ULOSSImageMaker *)maker</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!objc_getAssociatedObject(<span class="keyword">self</span>, &amp;makerName)) &#123;</span><br><span class="line">        ULOSSImageMaker  *maker = [[ULOSSImageMaker alloc] initWithBaseURLString:<span class="keyword">self</span>];</span><br><span class="line">        objc_setAssociatedObject(<span class="keyword">self</span>, &amp;makerName, maker, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> objc_getAssociatedObject(<span class="keyword">self</span>, &amp;makerName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里我们创建了一个 <code>ULOSSImageMaker</code> 对象,在这个类中包含两个方法: </p>
<ul>
<li>初始化方法 </li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)initWithBaseURLString:(<span class="built_in">NSString</span> *)aURLString</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</span><br><span class="line">        <span class="keyword">self</span>.baseURLString = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;%@?x-oss-process=image&quot;</span>,aURLString];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>resize的实现方法</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (ULOSSImageResize *)resize</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSString</span> *actionString = [<span class="keyword">self</span>.baseURLString stringByAppendingString:<span class="string">@&quot;/resize&quot;</span>];</span><br><span class="line">    ULOSSImageResize *action = [[ULOSSImageResize alloc] initWithBaseURLString:actionString];</span><br><span class="line">    <span class="keyword">return</span> action;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里在<code>resize</code>方法中我们我们创建了一个<code>ULOSSImageResize</code>对象,几乎所有的针对图片的缩放操作我们都放在了这个对象中进行。</p>
<h2 id="具体代码实现"><a href="#具体代码实现" class="headerlink" title="具体代码实现"></a>具体代码实现</h2><p>设置宽度</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- (ResizeHandler)width</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> ^(<span class="built_in">NSNumber</span> *attr) &#123;</span><br><span class="line">        <span class="keyword">self</span>.oss_w = [<span class="built_in">NSNumber</span> numberWithFloat:attr.floatValue*<span class="keyword">self</span>.curScale];</span><br><span class="line">        [<span class="keyword">self</span> addOSSImageAttributeValue:<span class="keyword">self</span>.oss_w.stringValue type:oss_w];</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>链接拼接：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)addOSSImageAttributeValue:(<span class="built_in">NSString</span> *)atrri type:(<span class="built_in">NSString</span> *)type</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSString</span> *tem = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;,%@%@&quot;</span>, type, atrri];</span><br><span class="line">    <span class="keyword">self</span>.baseURLString = [<span class="keyword">self</span>.baseURLString stringByAppendingString:tem];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="还存在的问题"><a href="#还存在的问题" class="headerlink" title="还存在的问题"></a>还存在的问题</h2><ul>
<li>对于属性的支持目前还没有全部支持 只是支持了项目中使用到的</li>
<li>对于枚举类型的支持提示效果不佳 且需要转换成NSNumber类型</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>OSS拼接本身是一个跟业务耦合度很低的逻辑,因此在实现的时候我们尽量将方法设置的尽可能的简单。通过链式调用的方式不仅可以很好的提示使用者使用方法,同时也降低了与业务代码的耦合。</p>
]]></content>
      <categories>
        <category>iOS进阶</category>
      </categories>
      <tags>
        <tag>oss</tag>
      </tags>
  </entry>
  <entry>
    <title>二维码生成扫描和识别(基于系统提供方法)</title>
    <url>/2016/09/07/QRCode/</url>
    <content><![CDATA[<p> 现在越来越多的App添加了一个扫码的功能，方便而且很实用，但是目前对弈iOS来说有些比较知名的库（比如<a href="https://github.com/TheLevelUp/ZXingObjC">ZXingObjC</a>）库都比较大，而实际上，在iOS 7.0之后系统在AVFoundation框架中就已经实现了对于二维码扫描和生成的的支持，我的方法主要是对系统的一些东西稍作封装（<a href="https://github.com/LeeWongSnail/QRCode">QRCode</a>）</p>
<a id="more"></a>

<h4 id="1、目的"><a href="#1、目的" class="headerlink" title="1、目的"></a>1、目的</h4><p> 现在越来越多的App添加了一个扫码的功能，方便而且很实用，但是目前对弈iOS来说有些比较知名的库（比如<a href="https://github.com/TheLevelUp/ZXingObjC">ZXingObjC</a>）库都比较大，而实际上，在iOS 7.0之后系统在AVFoundation框架中就已经实现了对于二维码扫描和生成的的支持，我的方法主要是对系统的一些东西稍作封装（<a href="https://github.com/LeeWongSnail/QRCode">QRCode</a>）</p>
<h4 id="2、生成二维码"><a href="#2、生成二维码" class="headerlink" title="2、生成二维码"></a>2、生成二维码</h4><p>目前见到的二维码一般是两种，中间有图片和没有图片的(通常是APP图标或者个人头像)或者是为二维码添加了背景颜色。这里我提供了三个方法，可以满足这几种需求。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> *  生成二维码图片的方法</span><br><span class="line"> *</span><br><span class="line"> *  @param string 二维码包含的内容</span><br><span class="line"> *  @param size   图片的尺寸</span><br><span class="line"> *  @param topimg 如果中间需要添加 头像可以传入此参数</span><br><span class="line"> *</span><br><span class="line"> *  @return 包含要生成内容的二维码图片</span><br><span class="line"> *&#x2F;</span><br><span class="line"> </span><br><span class="line">+ (UIImage *)qrImageForString:(NSString *)string </span><br><span class="line">	imageSize:(CGFloat)size Topimg:(UIImage *)topimg;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> *  生成二维码图片的方法</span><br><span class="line"> *</span><br><span class="line"> *  @param string       二维码包含的内容</span><br><span class="line"> *  @param size         图片的尺寸</span><br><span class="line"> *  @param pointType    点的类型（QRPointRect，</span><br><span class="line"> 										QRPointRound）</span><br><span class="line"> *  @param positionType 位置的类型 （QRPositionNormal，</span><br><span class="line"> 										QRPositionRound）</span><br><span class="line"> *  @param color        背景颜色</span><br><span class="line"> *</span><br><span class="line"> *  @return 包含要生成内容的二维码图片</span><br><span class="line"> *&#x2F;</span><br><span class="line">+(UIImage *)qrImageForString:(NSString *)string </span><br><span class="line">				    imageSize:(CGFloat)size </span><br><span class="line">				withPointType:(QRPointType)pointType</span><br><span class="line">			withPositionType:	</span><br><span class="line">				 			(QRPositionType)positionType</span><br><span class="line">				    withColor:(UIColor *)color;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> *  生成二维码图片的方法</span><br><span class="line"> *</span><br><span class="line"> *  @param string 二维码包含的内容</span><br><span class="line"> *  @param size    图片的尺寸</span><br><span class="line"> *  @param topimg 如果中间需要添加 头像可以传入此参数</span><br><span class="line"> *  @param color  背景颜色</span><br><span class="line"> *</span><br><span class="line"> *  @return 包含要生成内容的二维码图片</span><br><span class="line"> *&#x2F;</span><br><span class="line"> </span><br><span class="line">+(UIImage*)qrImageForString:(NSString *)string </span><br><span class="line">				  imageSize:(CGFloat)size </span><br><span class="line">				     Topimg:(UIImage *)topimg </span><br><span class="line">				  withColor:(UIColor*)color;</span><br><span class="line">				  </span><br></pre></td></tr></table></figure>

<h4 id="3、二维码扫描"><a href="#3、二维码扫描" class="headerlink" title="3、二维码扫描"></a>3、二维码扫描</h4><p>这里 需要重要注意的是 rectOfInterest属性的设置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;&#x2F;它的作用就是设置扫描范围</span><br><span class="line">output.rectOfInterest &#x3D; scanCrop;</span><br><span class="line"></span><br><span class="line">这个CGRect参数和普通的Rect范围不太一样，它的四个值的范围都是0-1，表示比例。</span><br><span class="line"></span><br><span class="line">rectOfInterest都是按照横屏来计算的 所以当竖屏的情况下 x轴和y轴要交换一下。</span><br><span class="line"></span><br><span class="line">宽度和高度设置的情况也是类似。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>具体的扫描结果通过遵守<code>AVCaptureMetadataOutputObjectsDelegate</code>协议并实现</p>
<p><code>-(void)captureOutput:(AVCaptureOutput *)captureOutput didOutputMetadataObjects:(NSArray *)metadataObjects fromConnection:(AVCaptureConnection *)connection</code></p>
<p>代理方法就可以拿到</p>
<p><img src="https://i.niupic.com/images/2016/09/07/2ea1uC.gif" alt="扫描"></p>
<h4 id="4、其他的使用场景"><a href="#4、其他的使用场景" class="headerlink" title="4、其他的使用场景"></a>4、其他的使用场景</h4><p>除了最常见的扫描识别二维码的方式之外 还有点击弹出框 选择识别图中二维码，或者 长按直接识别二维码的方式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> *  识别图中的二维码</span><br><span class="line"> *</span><br><span class="line"> *  @param aImage      图片</span><br><span class="line"> *  @param aCompletion 识别完成的回调</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (void)recognitionQRCodeFromImage:(UIImageView *)aImage</span><br><span class="line">		 completion:(void (^)(NSString *result,</span><br><span class="line">		 					 NSError *error))aCompletion;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://i.niupic.com/images/2016/09/07/f1hIfp.gif" alt="长按识别"></p>
<h4 id="5、总结"><a href="#5、总结" class="headerlink" title="5、总结"></a>5、总结</h4><p>这样的话在我们日常使用中常见的几种对于二维码的操作，基本可以实现。希望这个demo对你有所帮助。</p>
]]></content>
      <categories>
        <category>iOS进阶</category>
      </categories>
      <tags>
        <tag>QRCode</tag>
      </tags>
  </entry>
  <entry>
    <title>SDWebImage解析</title>
    <url>/2016/01/26/SDWebImage-1/</url>
    <content><![CDATA[<p>最近，公司的活比较少，所以特地抽出来一点时间，看了一下SDWebImage的源码，并写了这篇文章，查看源码的过程中看了很多相关的文章，总体思路是划分为几个大模块，会分几个博客讲述，下面提供了目录。</p>
<a id="more"></a>

<h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><ul>
<li>0、一张图片的下载流程</li>
<li>1、<a href="http://leewongsnail.github.io/blog/2016/01/27/sdwebimageyuan-ma-jie-xi-xia-zai/">图片的下载</a></li>
<li>2、<a href="http://leewongsnail.github.io/blog/2016/01/27/sdwebimageyuan-ma-jie-xi-huan-cun/">图片的缓存</a></li>
<li>3、分类的解析</li>
<li>4、SD常识汇总</li>
</ul>
<h3 id="SDWebImage的层次结构："><a href="#SDWebImage的层次结构：" class="headerlink" title="SDWebImage的层次结构："></a>SDWebImage的层次结构：</h3><p><img src="http://draveness.me/content/images/2015/04/Untitled-2.png" alt="icon"></p>
<p>接下来，就按照图片下载的流程来分析一下SDWebImage</p>
<h3 id="图片下载和缓存流程"><a href="#图片下载和缓存流程" class="headerlink" title="图片下载和缓存流程"></a>图片下载和缓存流程</h3><p>这一步主要就是跟踪一个图片的下载流程，通过这个流程，我们可以大致的了解SD的图片下载过程中的重要的方法以及处理问题的步骤！</p>
<p><code>方法过程</code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">最外层图片下载 可以添加占位图</span><br><span class="line">- (void)sd_setImageWithURL:(NSURL *)url placeholderImage:(UIImage *)placeholder options:(SDWebImageOptions)options </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">添加一个对于下载进度的监听的回调，下载完成的回调</span><br><span class="line">- (void)sd_setImageWithURL:(NSURL *)url placeholderImage:(UIImage *)placeholder options:(SDWebImageOptions)options progress:(SDWebImageDownloaderProgressBlock)progressBlock completed:(SDWebImageCompletionBlock)completedBlock </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">开始下载（包括查找缓存的过程）</span><br><span class="line">- (id &lt;SDWebImageOperation&gt;)downloadImageWith</span><br><span class="line">					URL:(NSURL *)url</span><br><span class="line">                   options:(SDWebImageOptions)options</span><br><span class="line">                   progress:(SDWebImageDownloaderProgressBlock)progressBlock</span><br><span class="line">                   completed:(SDWebImageCompletionWithFinishedBlock)completedBlock </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">查找图片</span><br><span class="line">- (NSOperation *)queryDiskCacheForKey:(NSString *)key done:(SDWebImageQueryCompletedBlock)doneBlock </span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">从缓存SDImageCache中查找图片</span><br><span class="line">- (UIImage *)imageFromMemoryCacheForKey:(NSString *)key </span><br><span class="line">如果查找到图片</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">从磁盘中查找图片</span><br><span class="line">- (UIImage *)diskImageForKey:(NSString *)key</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">开始下载</span><br><span class="line">- (id &lt;SDWebImageOperation&gt;)downloadImageWith</span><br><span class="line">						URL:(NSURL *)url </span><br><span class="line">						options:										(SDWebImageDownloaderOptions)options</span><br><span class="line">						 progress:							(SDWebImageDownloaderProgressBlock)progressBlock</span><br><span class="line">						  completed:(SDWebImageDownloaderCompletedBlock)completedBlock </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">添加下载进度的回调</span><br><span class="line">- (void)addProgressCallback:								(SDWebImageDownloaderProgressBlock)progressBlock </span><br><span class="line">			  completedBlock:								(SDWebImageDownloaderCompletedBlock)completedBlock</span><br><span class="line">			   forURL:(NSURL *)url</span><br><span class="line">			 createCallback:				</span><br><span class="line">			 (SDWebImageNoParamsBlock)createCallback</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">下载的请求</span><br><span class="line">- (id)initWithRequest:(NSURLRequest *)request</span><br><span class="line">              options:(SDWebImageDownloaderOptions)options</span><br><span class="line">             progress:(SDWebImageDownloaderProgressBlock)progressBlock</span><br><span class="line">            completed:(SDWebImageDownloaderCompletedBlock)completedBlock</span><br><span class="line">            cancelled:(SDWebImageNoParamsBlock)cancelBlock </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上面是简单的通过对一个图片的下载跟踪过程，整理出来的几个比较重要的方法,图片下载的流程就是-先从缓存中查找看是否已经下载-如果有直接显示，如果没有从磁盘中查找-如果找到现将图片移动到缓存中，在显示图片，如果没有找到开始下载；</p>
<p>在下面对这一步简单描述的各个流程进行简单的细化，过程中可能会存在一些问题，我们能也暂时说不清楚，会用重点的标志标记一下，希望看到这篇文章的同学也可以跟我联系，共同学习；</p>
<h3 id="1、图片的下载"><a href="#1、图片的下载" class="headerlink" title="1、图片的下载"></a>1、<a href="http://leewongsnail.github.io/blog/2016/01/27/sdwebimageyuan-ma-jie-xi-xia-zai/">图片的下载</a></h3><h3 id="2、图片的缓存"><a href="#2、图片的缓存" class="headerlink" title="2、图片的缓存"></a>2、<a href="http://leewongsnail.github.io/blog/2016/01/27/sdwebimageyuan-ma-jie-xi-huan-cun/">图片的缓存</a></h3><h3 id="3、缓存管理"><a href="#3、缓存管理" class="headerlink" title="3、缓存管理"></a>3、<a href="http://leewongsnail.github.io/blog/2016/01/27/sdwebimageyuan-ma-jie-xi-huan-cun-guan-li/">缓存管理</a></h3><h3 id="4、图片处理"><a href="#4、图片处理" class="headerlink" title="4、图片处理"></a>4、<a href="http://leewongsnail.github.io/blog/2016/01/27/sdwebimageyuan-ma-jie-xi-tu-pian-chu-li/">图片处理</a></h3><h3 id="5、多线程方面的注意-待写"><a href="#5、多线程方面的注意-待写" class="headerlink" title="5、多线程方面的注意(待写)"></a>5、多线程方面的注意(待写)</h3>]]></content>
      <categories>
        <category>源码分析</category>
      </categories>
      <tags>
        <tag>SDWebImage</tag>
        <tag>流程</tag>
      </tags>
  </entry>
  <entry>
    <title>SDWebImage - 缓存</title>
    <url>/2016/01/27/SDWebImage-3/</url>
    <content><![CDATA[<p>SDWebImage的缓存可以说是这个框架的一个重大的有点，下面我们就来了解一下这个框架的缓存是如何实现的。</p>
<p>从整体来说，SDWebImage的缓存分为两部分SDImageCache使用NSCache实现，另一部分磁盘缓存，使用NSFileManager实现</p>
<a id="more"></a>

<h4 id="下载后的图片缓存"><a href="#下载后的图片缓存" class="headerlink" title="下载后的图片缓存"></a>下载后的图片缓存</h4><p>图片下载成功之后的缓存</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)storeImage:(UIImage *)image recalculateFromImage:(BOOL)recalculate imageData:(NSData *)imageData forKey:(NSString *)key toDisk:(BOOL)toDisk</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="1、图片下载成功之后缓存到Cache中"><a href="#1、图片下载成功之后缓存到Cache中" class="headerlink" title="1、图片下载成功之后缓存到Cache中"></a>1、图片下载成功之后缓存到Cache中</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@property (strong, nonatomic) NSCache *memCache;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; if memory cache is enabled</span><br><span class="line">    if (self.shouldCacheImagesInMemory) &#123;</span><br><span class="line">        NSUInteger cost &#x3D; SDCacheCostForImage(image);</span><br><span class="line">        [self.memCache setObject:image forKey:key cost:cost];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>self.memCache实际上就是一个NSCache,类似于字典的一种存储方式，需要传入图片的消耗</p>
<h4 id="2、图片下载成功之后缓存到磁盘"><a href="#2、图片下载成功之后缓存到磁盘" class="headerlink" title="2、图片下载成功之后缓存到磁盘"></a>2、图片下载成功之后缓存到磁盘</h4><p><code>注意：</code>这里在图片保存之前有一个图片格式转换的过程（*-&gt;PNG）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 如果image存在，但是需要重新计算(recalculate)或者data为空</span><br><span class="line">&#x2F;&#x2F; 那就要根据image重新生成新的data</span><br><span class="line">&#x2F;&#x2F; 不过要是连image也为空的话，那就别存了</span><br><span class="line">if (image &amp;&amp; (recalculate || !data)) &#123;</span><br><span class="line">&#x2F;&#x2F;#if TARGET_OS_IPHONE</span><br><span class="line">    &#x2F;&#x2F; 我们需要判断image是PNG还是JPEG</span><br><span class="line">    &#x2F;&#x2F; PNG的图片很容易检测出来，因为它们有一个特定的标示 (http:&#x2F;&#x2F;</span><br><span class="line">    		www.w3.org&#x2F;TR&#x2F;PNG-Structure.html)</span><br><span class="line">    &#x2F;&#x2F; PNG图片的前8个字节不许符合下面这些值(十进制表示)</span><br><span class="line">    &#x2F;&#x2F; 137 80 78 71 13 10 26 10</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 如果imageData为空l (举个例子，比如image在下载后需要transform，</span><br><span class="line">    		那么就imageData就会为空)</span><br><span class="line">    &#x2F;&#x2F; 并且image有一个alpha通道, 我们将该image看做PNG以避免透明度</span><br><span class="line">    		(alpha)的丢失（因为JPEG没有透明色）</span><br><span class="line">	&#x2F;&#x2F;通过AlphaInfo获取图片的先关信息</span><br><span class="line">	int alphaInfo &#x3D; CGImageGetAlphaInfo(image.CGImage);</span><br><span class="line">	&#x2F;&#x2F; 该image中确实有透明信息，就认为image为PNG</span><br><span class="line">    BOOL hasAlpha &#x3D; !(alphaInfo &#x3D;&#x3D; kCGImageAlphaNone ||</span><br><span class="line">			  alphaInfo &#x3D;&#x3D; kCGImageAlphaNoneSkipFirst ||</span><br><span class="line">              alphaInfo &#x3D;&#x3D; kCGImageAlphaNoneSkipLast);</span><br><span class="line">    &#x2F;&#x2F;疑问：是否为PNG格式的图片和透明度有什么关系</span><br><span class="line">    BOOL imageIsPng &#x3D; hasAlpha;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; 但是如果我们已经有了imageData，我们就可以直接根据data中前几个字节</span><br><span class="line">		判断是不是PNG</span><br><span class="line">   if ([imageData length] &gt;&#x3D; [kPNGSignatureData length]) &#123;</span><br><span class="line">   		&#x2F;&#x2F; ImageDataHasPNGPreffix就是为了判断imageData前8个字节</span><br><span class="line">   			是不是符合PNG标志</span><br><span class="line">      imageIsPng &#x3D; ImageDataHasPNGPreffix(imageData);</span><br><span class="line">   &#125;</span><br><span class="line">   &#x2F;&#x2F;格式转换</span><br><span class="line">   if (imageIsPng) &#123;</span><br><span class="line">       data &#x3D; UIImagePNGRepresentation(image);</span><br><span class="line">   &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        data &#x3D; UIImageJPEGRepresentation(image, (CGFloat)1.0);</span><br><span class="line">   &#125;</span><br><span class="line">&#x2F;&#x2F;#else</span><br><span class="line">    data &#x3D; [NSBitmapImageRep representationOfImageRepsInArray:</span><br><span class="line">    				image.representations </span><br><span class="line">    				usingType: NSJPEGFileType properties:nil];</span><br><span class="line">&#x2F;&#x2F;#endif</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>图片个格式处理转换完成之后，将这个图片保存到本地</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;&#x2F; 首先判断disk cache的文件路径是否存在，不存在的话就创建一个</span><br><span class="line">&#x2F;&#x2F; disk cache的文件路径是存储在_diskCachePath中的</span><br><span class="line">if (![_fileManager fileExistsAtPath:_diskCachePath]) &#123;</span><br><span class="line">    [_fileManager createDirectoryAtPath:_diskCachePath </span><br><span class="line">    		withIntermediateDirectories:YES </span><br><span class="line">    				attributes:nil error:NULL];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> &#x2F;&#x2F; get cache Path for image key</span><br><span class="line"> 获取图片保存的路径：</span><br><span class="line"> NSString *fullNamespace &#x3D; [@&quot;com.hackemist.SDWebImageCache.&quot; stringByAppendingString:ns];</span><br><span class="line"> 图片放在cache目录下</span><br><span class="line"> [directory stringByAppendingPathComponent:fullNamespace]</span><br><span class="line"> 最终地址：</span><br><span class="line"> 目录+图片名（cachekey的MD5）</span><br><span class="line">&#x2F;&#x2F; 根据image的key(一般情况下理解为image的url)组合成最终的文件路径</span><br><span class="line">&#x2F;&#x2F; 上面那个生成的文件路径只是一个文件目录，就跟&#x2F;cache&#x2F;images&#x2F;img1.png和</span><br><span class="line">	cache&#x2F;images&#x2F;的区别一样</span><br><span class="line">&#x2F;&#x2F; defaultCachePathForKey后面会详解</span><br><span class="line"> NSString *cachePathForKey &#x3D; [self defaultCachePathForKey:key];</span><br><span class="line"> &#x2F;&#x2F; transform to NSUrl</span><br><span class="line"> NSURL *fileURL &#x3D; [NSURL fileURLWithPath:cachePathForKey];</span><br><span class="line"></span><br><span class="line"> [_fileManager createFileAtPath:cachePathForKey </span><br><span class="line"> 						contents:data attributes:nil];</span><br><span class="line"></span><br><span class="line"> &#x2F;&#x2F; disable iCloud backup</span><br><span class="line"> &#x2F;&#x2F;iCloud 不备份</span><br><span class="line"> if (self.shouldDisableiCloud) &#123;</span><br><span class="line">     [fileURL setResourceValue:[NSNumber numberWithBool:YES]</span><br><span class="line">     	 				forKey:NSURLIsExcludedFromBackupKey</span><br><span class="line">     	  				 error:nil];</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="缓存图片的查找："><a href="#缓存图片的查找：" class="headerlink" title="缓存图片的查找："></a>缓存图片的查找：</h3><h4 id="根据cachekey-判断这个图片是否缓存过"><a href="#根据cachekey-判断这个图片是否缓存过" class="headerlink" title="根据cachekey 判断这个图片是否缓存过"></a>根据cachekey 判断这个图片是否缓存过</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (NSOperation *)queryDiskCacheForKey:(</span><br><span class="line">NSString *)key done:(SDWebImageQueryCompletedBlock)doneBlock</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="从缓存中查找"><a href="#从缓存中查找" class="headerlink" title="从缓存中查找"></a>从缓存中查找</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (UIImage *)imageFromMemoryCacheForKey:(NSString *)key</span><br><span class="line"></span><br><span class="line">UIImage *image &#x3D; [self imageFromMemoryCacheForKey:key];</span><br><span class="line">if (image) &#123;</span><br><span class="line">    doneBlock(image, SDImageCacheTypeMemory);</span><br><span class="line">    return nil;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">如果查找到了，直接返回图片，如果没找到请看下一步</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="从磁盘中查找"><a href="#从磁盘中查找" class="headerlink" title="从磁盘中查找"></a>从磁盘中查找</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSOperation *operation &#x3D; [NSOperation new];</span><br><span class="line"> dispatch_async(self.ioQueue, ^&#123;</span><br><span class="line">     if (operation.isCancelled) &#123;</span><br><span class="line">         return;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     @autoreleasepool &#123;</span><br><span class="line">         UIImage *diskImage &#x3D; [self diskImageForKey:key];</span><br><span class="line">         if (diskImage &amp;&amp; self.shouldCacheImagesInMemory) &#123;</span><br><span class="line">             NSUInteger cost &#x3D; </span><br><span class="line">             			SDCacheCostForImage(diskImage);</span><br><span class="line">             [self.memCache setObject:diskImage forKey:key cost:cost];</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">             doneBlock(diskImage, SDImageCacheTypeDisk);</span><br><span class="line">         &#125;);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在磁盘中查找此图片</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (UIImage *)diskImageForKey:(NSString *)key &#123;</span><br><span class="line">    NSData *data &#x3D; [self diskImageDataBySearchingAllPathsForKey:key];</span><br><span class="line">    if (data) &#123;</span><br><span class="line">        UIImage *image &#x3D; [UIImage sd_imageWithData:data];</span><br><span class="line">        image &#x3D; [self scaledImageForKey:key image:image];</span><br><span class="line">        if (self.shouldDecompressImages) &#123;</span><br><span class="line">            image &#x3D; [UIImage decodedImageWithImage:image];</span><br><span class="line">        &#125;</span><br><span class="line">        return image;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>根据key获取到本地磁盘中关于这个图片的数据，注意这里stringByDeletingPathExtension方法以后可以多借鉴</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (NSData *)diskImageDataBySearchingAllPathsForKey:(NSString *)key &#123;</span><br><span class="line">    NSString *defaultPath &#x3D; [self defaultCachePathForKey:key];</span><br><span class="line">    NSData *data &#x3D; [NSData dataWithContentsOfFile:defaultPath];</span><br><span class="line">    if (data) &#123;</span><br><span class="line">        return data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; checking the key with and without the extension</span><br><span class="line">    data &#x3D; [NSData dataWithContentsOfFile:</span><br><span class="line">    			[defaultPath stringByDeletingPathExtension]];</span><br><span class="line">    if (data) &#123;</span><br><span class="line">        return data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    NSArray *customPaths &#x3D; [self.customPaths copy];</span><br><span class="line">    for (NSString *path in customPaths) &#123;</span><br><span class="line">        NSString *filePath &#x3D; </span><br><span class="line">        				[self cachePathForKey:key inPath:path];</span><br><span class="line">        NSData *imageData &#x3D; </span><br><span class="line">        				[NSData dataWithContentsOfFile:filePath];</span><br><span class="line">        				</span><br><span class="line">        if (imageData) &#123;</span><br><span class="line">            return imageData;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; checking the key with and without the extension</span><br><span class="line">        imageData &#x3D; </span><br><span class="line">        			[NSData dataWithContentsOfFile:</span><br><span class="line">        			[filePath stringByDeletingPathExtension]];</span><br><span class="line">        if (imageData) &#123;</span><br><span class="line">            return imageData;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return nil;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>根据key，获取这个图片在本地如果存在的话，返回图片的路径，这里的方法和图片下载完成之后图片的存储地址的生成是相同的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (NSString *)defaultCachePathForKey:(NSString *)key &#123;</span><br><span class="line">    return [self cachePathForKey:key inPath:self.diskCachePath];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSString *)cachePathForKey:(NSString *)key inPath:(NSString *)path &#123;</span><br><span class="line">    NSString *filename &#x3D; [self cachedFileNameForKey:key];</span><br><span class="line">    return [path stringByAppendingPathComponent:filename];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>对图片名称进行MD5的方法（可以保留做一个工具方法）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (NSString *)cachedFileNameForKey:(NSString *)key &#123;</span><br><span class="line">    const char *str &#x3D; [key UTF8String];</span><br><span class="line">    if (str &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">        str &#x3D; &quot;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 使用了MD5进行加密处理</span><br><span class="line">    &#x2F;&#x2F; 开辟一个16字节（128位：md5加密出来就是128bit）的空间</span><br><span class="line">    unsigned char r[CC_MD5_DIGEST_LENGTH];</span><br><span class="line">    &#x2F;&#x2F; 官方封装好的加密方法</span><br><span class="line">    &#x2F;&#x2F; 把str字符串转换成了32位的16进制数列（这个过程不可逆转） </span><br><span class="line">    	存储到了r这个空间中</span><br><span class="line">    CC_MD5(str, (CC_LONG)strlen(str), r);</span><br><span class="line">    &#x2F;&#x2F; 最终生成的文件名就是 &quot;md5码&quot;+&quot;.文件类型&quot;</span><br><span class="line">    NSString *filename &#x3D; </span><br><span class="line">    				     [NSString stringWithFormat:</span><br><span class="line">    						@&quot;%02x%02x%02x%02x%02x%02x%02x%02x</span><br><span class="line">    						%02x%02x%02x%02x%02x%02x%02x%02x%@&quot;,</span><br><span class="line">              r[0], r[1], r[2], r[3], r[4], r[5], r[6], </span><br><span class="line">              r[7], r[8], r[9], r[10], r[11], r[12], r[13], </span><br><span class="line">              r[14], r[15], </span><br><span class="line">              [[key pathExtension] isEqualToString:@&quot;&quot;] </span><br><span class="line">              ? @&quot;&quot; </span><br><span class="line">              : [NSString stringWithFormat:@&quot;.%@&quot;, [key 											pathExtension]]];</span><br><span class="line"></span><br><span class="line">    return filename;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>计算图片的消耗</p>
<pre><code>cost 被用来计算缓存中所有对象的代价。当内存受限或者所有缓存对象的总代价超过了最大允许的值时，缓存会移除其中的一些对象。
通常，精确的 cost 应该是对象占用的字节数</code></pre>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FOUNDATION_STATIC_INLINE NSUInteger SDCacheCostForImage(UIImage *image) &#123;</span><br><span class="line">	&#x2F;&#x2F;这里我觉得这样写不是很好，如果这样写就更直观了</span><br><span class="line">	&#x2F;&#x2F; return (height * scale) * (width * scale)</span><br><span class="line">	</span><br><span class="line">    return image.size.height * image.size.width * image.scale * image.scale;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>图片找到之后</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dispatch_main_sync_safe(^&#123;</span><br><span class="line">  __strong __typeof(weakOperation) strongOperation &#x3D;</span><br><span class="line">  												 weakOperation;</span><br><span class="line">  if (strongOperation &amp;&amp; !strongOperation.isCancelled) &#123;</span><br><span class="line">     completedBlock(image, nil, cacheType, YES, url);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"> @synchronized (self.runningOperations) &#123;</span><br><span class="line">    [self.runningOperations removeObject:operation];</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>源码分析</category>
      </categories>
      <tags>
        <tag>SDWebImage</tag>
        <tag>NSCache</tag>
        <tag>SDImageCache</tag>
      </tags>
  </entry>
  <entry>
    <title>SDWebImage - 图片处理</title>
    <url>/2016/01/27/SDWebImage-5/</url>
    <content><![CDATA[<p>本篇文章主要是介绍了，在SDWebImage源码查看过程中的一些对于图片处理的方法，这些方法可能在平时的工作中也会用到，所以单独拿出来一篇文章来介绍这些方法。</p>
<p>关于图片处理的方法个人本身了解的并不深，初期阶段可能只是简单的介绍一下，添加一些自己的理解，如果有问题，还请大家不吝赐教。</p>
<a id="more"></a>


<h4 id="图片的解码"><a href="#图片的解码" class="headerlink" title="图片的解码"></a>图片的解码</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+ (UIImage *)decodedImageWithImage:(UIImage *)image &#123;</span><br><span class="line">    &#x2F;&#x2F; while downloading huge amount of images</span><br><span class="line">    &#x2F;&#x2F; autorelease the bitmap context</span><br><span class="line">    &#x2F;&#x2F; and all vars to help system to free memory</span><br><span class="line">    &#x2F;&#x2F; when there are memory warning.</span><br><span class="line">    &#x2F;&#x2F; on iOS7, do not forget to call</span><br><span class="line">    &#x2F;&#x2F; [[SDImageCache sharedImageCache] clearMemory];</span><br><span class="line">    </span><br><span class="line">    @autoreleasepool&#123;</span><br><span class="line">        &#x2F;&#x2F; do not decode animated images</span><br><span class="line">        if (image.images) &#123; return image; &#125;</span><br><span class="line">    </span><br><span class="line">        CGImageRef imageRef &#x3D; image.CGImage;</span><br><span class="line">    </span><br><span class="line">        CGImageAlphaInfo alpha &#x3D; CGImageGetAlphaInfo(imageRef);</span><br><span class="line">        BOOL anyAlpha &#x3D; (alpha &#x3D;&#x3D; kCGImageAlphaFirst</span><br><span class="line">        	 			||alpha &#x3D;&#x3D; kCGImageAlphaLast</span><br><span class="line">        	 			||alpha &#x3D;&#x3D;kCGImageAlphaPremultipliedFirst</span><br><span class="line">        	 			||alpha&#x3D;&#x3D;kCGImageAlphaPremultipliedLast);</span><br><span class="line">    </span><br><span class="line">        if (anyAlpha) &#123; return image; &#125;</span><br><span class="line">    </span><br><span class="line">        size_t width &#x3D; CGImageGetWidth(imageRef);</span><br><span class="line">        size_t height &#x3D; CGImageGetHeight(imageRef);</span><br><span class="line">    </span><br><span class="line">        &#x2F;&#x2F; current</span><br><span class="line">        CGColorSpaceModel imageColorSpaceModel &#x3D; </span><br><span class="line">        CGColorSpaceGetModel(CGImageGetColorSpace(imageRef));</span><br><span class="line">        </span><br><span class="line">        CGColorSpaceRef colorspaceRef &#x3D; </span><br><span class="line">        						CGImageGetColorSpace(imageRef);</span><br><span class="line">        </span><br><span class="line">        bool unsupportedColorSpace &#x3D; (imageColorSpaceModel &#x3D;&#x3D; 0</span><br><span class="line">         	|| imageColorSpaceModel &#x3D;&#x3D; -1</span><br><span class="line">			|| imageColorSpaceModel &#x3D;&#x3D; kCGColorSpaceModelCMYK </span><br><span class="line">			|| imageColorSpaceModel&#x3D;&#x3D;kCGColorSpaceModelIndexed);</span><br><span class="line">		</span><br><span class="line">        if (unsupportedColorSpace)</span><br><span class="line">            colorspaceRef &#x3D; CGColorSpaceCreateDeviceRGB();</span><br><span class="line">    </span><br><span class="line">        CGContextRef context &#x3D; CGBitmapContextCreate(NULL, </span><br><span class="line">        						width,height,</span><br><span class="line">						CGImageGetBitsPerComponent(imageRef),</span><br><span class="line">                               0,colorspaceRef,</span><br><span class="line">                               kCGBitmapByteOrderDefault | 								kCGImageAlphaPremultipliedFirst);</span><br><span class="line">    </span><br><span class="line">        &#x2F;&#x2F; Draw the image into the context and retrieve the new </span><br><span class="line">        	image, which will now have an alpha layer</span><br><span class="line">        	</span><br><span class="line">        CGContextDrawImage(context, CGRectMake(0, 0, width,</span><br><span class="line">        					 height), imageRef);</span><br><span class="line">        					 </span><br><span class="line">        CGImageRef imageRefWithAlpha &#x3D; </span><br><span class="line">        					CGBitmapContextCreateImage(context);</span><br><span class="line">        					</span><br><span class="line">        UIImage *imageWithAlpha &#x3D; [UIImage </span><br><span class="line">        					imageWithCGImage:imageRefWithAlpha </span><br><span class="line">        					           scale:image.scale </span><br><span class="line">        					orientation:image.imageOrientation];</span><br><span class="line">    </span><br><span class="line">        if (unsupportedColorSpace)</span><br><span class="line">            CGColorSpaceRelease(colorspaceRef);</span><br><span class="line">        </span><br><span class="line">        CGContextRelease(context);</span><br><span class="line">        CGImageRelease(imageRefWithAlpha);</span><br><span class="line">        </span><br><span class="line">        return imageWithAlpha;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h4 id="由NSData转换为UIImage"><a href="#由NSData转换为UIImage" class="headerlink" title="由NSData转换为UIImage"></a>由NSData转换为UIImage</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">+ (UIImage *)sd_imageWithData:(NSData *)data &#123;</span><br><span class="line">    if (!data) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    UIImage *image;</span><br><span class="line">    NSString *imageContentType &#x3D; [NSData </span><br><span class="line">    						sd_contentTypeForImageData:data];</span><br><span class="line">    						</span><br><span class="line">    if ([imageContentType isEqualToString:@&quot;image&#x2F;gif&quot;]) &#123;</span><br><span class="line">        image &#x3D; [UIImage sd_animatedGIFWithData:data];</span><br><span class="line">    &#125;</span><br><span class="line">#ifdef SD_WEBP</span><br><span class="line">    else if ([imageContentType isEqualToString:@&quot;image&#x2F;webp&quot;])</span><br><span class="line">    &#123;</span><br><span class="line">        image &#x3D; [UIImage sd_imageWithWebPData:data];</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line">    else &#123;</span><br><span class="line">        image &#x3D; [[UIImage alloc] initWithData:data];</span><br><span class="line">        UIImageOrientation orientation &#x3D; [self </span><br><span class="line">        				sd_imageOrientationFromImageData:data];</span><br><span class="line">        				</span><br><span class="line">        if (orientation !&#x3D; UIImageOrientationUp) &#123;</span><br><span class="line">            image &#x3D; [UIImage imageWithCGImage:image.CGImage</span><br><span class="line">                                        scale:image.scale</span><br><span class="line">                                  orientation:orientation];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    return image;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="根据图片的NSData判断这个图片的类型"><a href="#根据图片的NSData判断这个图片的类型" class="headerlink" title="根据图片的NSData判断这个图片的类型"></a>根据图片的NSData判断这个图片的类型</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+ (NSString *)sd_contentTypeForImageData:(NSData *)data &#123;</span><br><span class="line">    uint8_t c;</span><br><span class="line">    [data getBytes:&amp;c length:1];</span><br><span class="line">    switch (c) &#123;</span><br><span class="line">        case 0xFF:</span><br><span class="line">            return @&quot;image&#x2F;jpeg&quot;;</span><br><span class="line">        case 0x89:</span><br><span class="line">            return @&quot;image&#x2F;png&quot;;</span><br><span class="line">        case 0x47:</span><br><span class="line">            return @&quot;image&#x2F;gif&quot;;</span><br><span class="line">        case 0x49:</span><br><span class="line">        case 0x4D:</span><br><span class="line">            return @&quot;image&#x2F;tiff&quot;;</span><br><span class="line">        case 0x52:</span><br><span class="line">            &#x2F;&#x2F; R as RIFF for WEBP</span><br><span class="line">            if ([data length] &lt; 12) &#123;</span><br><span class="line">                return nil;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            NSString *testString &#x3D; [[NSString alloc] </span><br><span class="line">            initWithData:</span><br><span class="line">            	[data subdataWithRange:NSMakeRange(0, 12)] </span><br><span class="line">            				  encoding:NSASCIIStringEncoding];</span><br><span class="line">            				</span><br><span class="line">            if ([testString hasPrefix:@&quot;RIFF&quot;]</span><br><span class="line">             &amp;&amp; [testString hasSuffix:@&quot;WEBP&quot;]</span><br><span class="line">             )</span><br><span class="line">             &#123;</span><br><span class="line">                return @&quot;image&#x2F;webp&quot;;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    return nil;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="NSData转Gif"><a href="#NSData转Gif" class="headerlink" title="NSData转Gif"></a>NSData转Gif</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+ (UIImage *)sd_animatedGIFWithData:(NSData *)data &#123;</span><br><span class="line">    if (!data) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    CGImageSourceRef source &#x3D;</span><br><span class="line">    					 CGImageSourceCreateWithData((__bridge 										CFDataRef)data, NULL);</span><br><span class="line"></span><br><span class="line">    size_t count &#x3D; CGImageSourceGetCount(source);</span><br><span class="line"></span><br><span class="line">    UIImage *animatedImage;</span><br><span class="line"></span><br><span class="line">    if (count &lt;&#x3D; 1) &#123;</span><br><span class="line">        animatedImage &#x3D; [[UIImage alloc] initWithData:data];</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        NSMutableArray *images &#x3D; [NSMutableArray array];</span><br><span class="line"></span><br><span class="line">        NSTimeInterval duration &#x3D; 0.0f;</span><br><span class="line"></span><br><span class="line">        for (size_t i &#x3D; 0; i &lt; count; i++) &#123;</span><br><span class="line">            CGImageRef image &#x3D; </span><br><span class="line">            			CGImageSourceCreateImageAtIndex(source, </span><br><span class="line">            									      i, NULL);</span><br><span class="line"></span><br><span class="line">            duration +&#x3D; [self sd_frameDurationAtIndex:i </span><br><span class="line">            									source:source];</span><br><span class="line"></span><br><span class="line">            [images addObject:[UIImage imageWithCGImage:image </span><br><span class="line">            					scale:[UIScreen mainScreen].scale </span><br><span class="line">            			  orientation:UIImageOrientationUp]];</span><br><span class="line"></span><br><span class="line">            CGImageRelease(image);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (!duration) &#123;</span><br><span class="line">            duration &#x3D; (1.0f &#x2F; 10.0f) * count;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        animatedImage &#x3D; [UIImage animatedImageWithImages:images</span><br><span class="line">        									  duration:duration];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    CFRelease(source);</span><br><span class="line"></span><br><span class="line">    return animatedImage;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="讲一个webP转换为UIImage"><a href="#讲一个webP转换为UIImage" class="headerlink" title="讲一个webP转换为UIImage"></a>讲一个webP转换为UIImage</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+ (UIImage *)sd_imageWithWebPData:(NSData *)data &#123;</span><br><span class="line">    WebPDecoderConfig config;</span><br><span class="line">    if (!WebPInitDecoderConfig(&amp;config)) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (WebPGetFeatures(data.bytes, data.length,</span><br><span class="line">    					 &amp;config.input) !&#x3D; VP8_STATUS_OK) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    config.output.colorspace &#x3D; config.input.has_alpha ?</span><br><span class="line">    								 MODE_rgbA : MODE_RGB;</span><br><span class="line">    config.options.use_threads &#x3D; 1;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Decode the WebP image data into a RGBA value array.</span><br><span class="line">    if (WebPDecode(data.bytes, data.length, &amp;config) !&#x3D; </span><br><span class="line">    									VP8_STATUS_OK)</span><br><span class="line">    &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int width &#x3D; config.input.width;</span><br><span class="line">    int height &#x3D; config.input.height;</span><br><span class="line">    if (config.options.use_scaling) &#123;</span><br><span class="line">        width &#x3D; config.options.scaled_width;</span><br><span class="line">        height &#x3D; config.options.scaled_height;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Construct a UIImage from the decoded RGBA value array.</span><br><span class="line">    CGDataProviderRef provider &#x3D;</span><br><span class="line">    CGDataProviderCreateWithData(NULL,</span><br><span class="line">     		config.output.u.RGBA.rgba,</span><br><span class="line">     		 config.output.u.RGBA.size,</span><br><span class="line">     		  FreeImageData);</span><br><span class="line">     		  </span><br><span class="line">    CGColorSpaceRef colorSpaceRef &#x3D; </span><br><span class="line">    							CGColorSpaceCreateDeviceRGB();</span><br><span class="line">    							</span><br><span class="line">    CGBitmapInfo bitmapInfo &#x3D; config.input.has_alpha ? </span><br><span class="line">    kCGBitmapByteOrder32Big | kCGImageAlphaPremultipliedLast</span><br><span class="line">     : 0;</span><br><span class="line">    </span><br><span class="line">    size_t components &#x3D; config.input.has_alpha ? 4 : 3;</span><br><span class="line">    </span><br><span class="line">    CGColorRenderingIntent renderingIntent &#x3D;</span><br><span class="line">    								 kCGRenderingIntentDefault;</span><br><span class="line">    								 </span><br><span class="line">    CGImageRef imageRef &#x3D; CGImageCreate(width, height, 8, components * 8, components * width, colorSpaceRef, bitmapInfo, provider, NULL, NO, renderingIntent);</span><br><span class="line"></span><br><span class="line">    CGColorSpaceRelease(colorSpaceRef);</span><br><span class="line">    CGDataProviderRelease(provider);</span><br><span class="line"></span><br><span class="line">    UIImage *image &#x3D; [[UIImage alloc] initWithCGImage:imageRef];</span><br><span class="line">    CGImageRelease(imageRef);</span><br><span class="line"></span><br><span class="line">    return image;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="其他格式"><a href="#其他格式" class="headerlink" title="其他格式"></a>其他格式</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">其他格式的图片的转换比较简单，直接使用</span><br><span class="line">[[UIImage alloc] initWithData:data];</span><br><span class="line">就可以</span><br><span class="line"></span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>源码分析</category>
      </categories>
      <tags>
        <tag>SDWebImage</tag>
        <tag>图片解码</tag>
        <tag>图片格式</tag>
      </tags>
  </entry>
  <entry>
    <title>Swift for stanford</title>
    <url>/2016/03/04/Swift-for-stanford/</url>
    <content><![CDATA[<p>最近Swift的发展速度很是迅速，所以决定开始搞一下Swift练练手，第一步打算看一下视频，首选当然是敬爱的白胡子老头的（网易公开课上都可以找到）</p>
<a id="more"></a>

<p>下面是看视频过程中，写的一些Demo,供大家参考</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">SwiftTest:一个简单的swift的计算器的实现，其中包含了部分方法演变的过程</span><br><span class="line"></span><br><span class="line">SwiftTest-MVC:使用MVC设计模式，同时对于运算做了封装</span><br><span class="line"></span><br><span class="line">Happiness : 使用贝塞尔曲线画出了一个笑脸</span><br><span class="line"></span><br><span class="line">Psychologist : Multi MVC 简单的使用 SplitViewController UINavigationController Popover</span><br><span class="line"></span><br><span class="line">ViewControllerLifeCycle: 控制器的生命周期</span><br><span class="line"></span><br><span class="line">AutoLayout : 简单的AutoLayout布局介绍</span><br><span class="line"></span><br><span class="line">Cassini: UIScrollView的简单介绍</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p><code>这是课程中所敲的所有代码 关于UITableView中的代码暂无！！</code></p>
<p><a href="https://github.com/LeeWongSnail/SwiftTestDemo">我的代码放到这里了</a></p>
]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>Stanford</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Swift little tips</title>
    <url>/2016/02/15/Swift-little-tips/</url>
    <content><![CDATA[<p>本文主要讲述了，我在学习swift过程中遇到的一些问题以及总结出的一些技巧，在这里分享给大家。</p>
<a id="more"></a>

<h4 id="1、方法的重载"><a href="#1、方法的重载" class="headerlink" title="1、方法的重载"></a>1、方法的重载</h4><p>大家都知道OC是不支持方法的重载（存在两个名称相同的方法）的，而swift支持方法的重载，所以在项目中，我们可能会遇到下面这个问题</p>
<p>我的代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import UIKit</span><br><span class="line"></span><br><span class="line">class BugViewController: UIViewController</span><br><span class="line">&#123;</span><br><span class="line">    func perform(operation: (Double) -&gt; Double) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func perform(operation: (Double, Double) -&gt; Double) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>错误</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Method &#39;perform&#39; with Objective-C selector &#39;perform: &#39; conflicts with previous declaration with the same Objective-C selector</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>疑问：</p>
<p>我是在用纯swift写代码，为什么会提示OC的东西？<br>原因：你的代码中包含了OC或者间接继承了OC的相关对象(我这里是因为控制器继承自UIViewController)<br>解决方法：</p>
<p>1、去掉和OC相关的部分（删除继承）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import UIKit</span><br><span class="line"></span><br><span class="line">class BugViewController</span><br><span class="line">&#123;</span><br><span class="line">    func perform(operation: (Double) -&gt; Double) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func perform(operation: (Double, Double) -&gt; Double) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>2、添加@objc</p>
<p>在重载的方法前，加上@nonobjc</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import UIKit</span><br><span class="line"></span><br><span class="line">class BugViewController: UIViewController</span><br><span class="line">&#123;</span><br><span class="line">    func perform(operation: (Double) -&gt; Double) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	@nonobjc</span><br><span class="line">    func perform(operation: (Double, Double) -&gt; Double) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>3、添加private标志</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import UIKit</span><br><span class="line"></span><br><span class="line">class BugViewController: UIViewController</span><br><span class="line">&#123;</span><br><span class="line">    func perform(operation: (Double) -&gt; Double) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">   private func perform(operation: (Double, Double) -&gt; Double) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>详细请参考<a href="http://stackoverflow.com/questions/29457720/compiler-error-method-with-objective-c-selector-conflicts-with-previous-declara/31500740#31500740">链接</a></p>
<h4 id="2、类方法"><a href="#2、类方法" class="headerlink" title="2、类方法"></a>2、类方法</h4><p>实例方法是被类型的某个实例调用的方法。你也可以定义类型本身调用的方法，这种方法就叫做类型方法。声明类的类型方法，在方法的func关键字之前加上关键字class；声明结构体和枚举的类型方法，在方法的func关键字之前加上关键字static</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">注意：</span><br><span class="line">在 Objective-C 里面，你只能为 Objective-C 的类定义类型方法(type-level methods)。在 Swift 中，你可以为所有的类、结构体和枚举定义类型方法：每一个类型方法都被它所支持的类型显式包含。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class SomeClass &#123;</span><br><span class="line">  class func someTypeMethod() &#123;</span><br><span class="line">    &#x2F;&#x2F; type method implementation goes here</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">SomeClass.someTypeMethod()</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>参考文章：</p>
<p><a href="http://www.topthink.com/topic/8972.html">1、static和class的使用</a></p>
<h4 id="3、Class-has-no-initializers错误"><a href="#3、Class-has-no-initializers错误" class="headerlink" title="3、Class has no initializers错误"></a>3、Class has no initializers错误</h4><p><img src="http://img.hoop8.com/attachments/1602/9323165027545.png" alt="errorTips"></p>
<p>这是我在swift学习中常见的一个错误，<br>这个错误通常是由于你的这个类中声明的某一个变量，<br>在声明的时候没有指定这个变量是否是optional，<br>这时你只需要检查一下，自己声明的变量是否需要添加！或者？</p>
<h4 id="4、获取类名或者实例的类型"><a href="#4、获取类名或者实例的类型" class="headerlink" title="4、获取类名或者实例的类型"></a>4、获取类名或者实例的类型</h4><p>使用类名获取</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UITableViewCell.self   UITableViewCell.classForCoder()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>实例对象获取类型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let date &#x3D; NSDate()</span><br><span class="line">let name &#x3D; date.dynamicType</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><a href="http://swifter.tips/instance-type/">获取对象类型</a></p>
<h4 id="5、使用Storyboard和纯代码创建Cell"><a href="#5、使用Storyboard和纯代码创建Cell" class="headerlink" title="5、使用Storyboard和纯代码创建Cell"></a>5、使用Storyboard和纯代码创建Cell</h4><p>在Swift开发中我们有两种方式 创建一个tableviewcell </p>
<p>1、纯代码</p>
<pre><code>一般需要重写init方法

override init(style: UITableViewCellStyle, 
                        reuseIdentifier: String?)

在使用cell之前要先注册

self.tableView.registerClass(NewsCell.self, 
            forCellReuseIdentifier: &quot;newscell&quot;)</code></pre>
<p>2、Storyboard</p>
<pre><code>需要在xib中定义好cell的结构，设置重用标示符，这样才可以重用</code></pre>
<p>注意：如果重写了init方法，则默认使用纯代码的方式去构造这个cell，不会走awakefromnib方法，</p>
<h4 id="6、Swift中错误的处理"><a href="#6、Swift中错误的处理" class="headerlink" title="6、Swift中错误的处理"></a>6、Swift中错误的处理</h4><p>异常处理的写法：</p>
<p><code>OC</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSError *error;</span><br><span class="line">BOOL success &#x3D; [data writeToFile: path options: options error: &amp;error];</span><br><span class="line">if(error) &#123;</span><br><span class="line">    &#x2F;&#x2F; 发生了错误</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>Swift</code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">do &#123;</span><br><span class="line">    try d.writeToFile(&quot;Hello&quot;, options: [])</span><br><span class="line">&#125; catch let error as NSError &#123;</span><br><span class="line">    print (&quot;Error: \(error.domain)&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>如果已知错误的类型可以采用这种枚举的方式</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">enum LoginError: ErrorType &#123;</span><br><span class="line">    case UserNotFound, UserPasswordNotMatch</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">do &#123;</span><br><span class="line">    try login(&quot;onevcat&quot;, password: &quot;123&quot;)</span><br><span class="line">&#125; catch LoginError.UserNotFound &#123;</span><br><span class="line">    print(&quot;UserNotFound&quot;)</span><br><span class="line">&#125; catch LoginError.UserPasswordNotMatch &#123;</span><br><span class="line">    print(&quot;UserPasswordNotMatch&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="7、Swift中互斥锁的使用"><a href="#7、Swift中互斥锁的使用" class="headerlink" title="7、Swift中互斥锁的使用"></a>7、Swift中互斥锁的使用</h4><p>OC中的锁的使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)myMethod:(id)anObj &#123;</span><br><span class="line">    @synchronized(anObj) &#123;</span><br><span class="line">        &#x2F;&#x2F; 在括号内 anObj 不会被其他线程改变</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>这个方法在Swift中已经无法使用了</code></p>
<p>解析@synchronized方法实现原理：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@synchronized 在幕后做的事情是调用了 objc_sync 中的 objc_sync_enter 和 objc_sync_exit 方法，并且加入了一些异常判断 </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>因此Swift中锁的实现可以这么写</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func synchronized(lock: AnyObject, closure: () -&gt; ()) &#123;</span><br><span class="line">    objc_sync_enter(lock)</span><br><span class="line">    closure()</span><br><span class="line">    objc_sync_exit(lock)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>根据Swift尾随闭包的特性，可以简化为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func myMethod(anObj: AnyObject!) &#123;</span><br><span class="line">    synchronized(anObj) &#123;</span><br><span class="line">        &#x2F;&#x2F; 在括号内 anObj 不会被其他线程改变</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="7、Swift中单例的创建"><a href="#7、Swift中单例的创建" class="headerlink" title="7、Swift中单例的创建"></a>7、Swift中单例的创建</h4><p>OC中单例的创建：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+ (id)sharedManager &#123;</span><br><span class="line"></span><br><span class="line">    static MyManager *staticInstance &#x3D; nil;</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line"></span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        staticInstance &#x3D; [[self alloc] init];</span><br><span class="line">    &#125;);</span><br><span class="line">    return staticInstance;”</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Swift中创建单例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private let sharedInstance &#x3D; MyManager()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>开发技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>Swift on the way</title>
    <url>/2016/02/19/Swift-on-the-way/</url>
    <content><![CDATA[<p>2015年已经过去了，iOS也做了有一段时间了。这两年Swift的势头越来越猛，所以，我觉得是时候开始系统的去学习和练习使用Swift了。</p>
<p>之前看了斯坦福大学白胡子的视频，对于Swift也算稍微了解了一点，近期打算看一些关于Swift相关的东西，看到了<a href="http://weibo.com/ttarticle/p/show?id=2309403942494873235448">Allen朝辉</a>的《自学 iOS - 三十天三十个 Swift 项目》感触很大，所以 我们打算在未来的一段时间里，学习Swift的同时坚持写一些小的Demo练手，希望自己坚持下去。</p>
<p>关于基础的语法，我觉得看一下中文版的<a href="http://wiki.jikexueyuan.com/project/swift/?hmsr=www_index_wiki">Swift开发指南</a>就好,下面将会附上，以后这段时间 每天的输出！</p>
<p><a href="https://github.com/LeeWongSnail/Swift-On-The-Way">Demo的代码放在这里</a></p>
<a id="more"></a>


<h4 id="Project01-SimpleStopWatch"><a href="#Project01-SimpleStopWatch" class="headerlink" title="Project01 - SimpleStopWatch"></a>Project01 - SimpleStopWatch</h4><p>一个可以暂停和开始和重置的计时器</p>
<p><img src="http://img.hoop8.com/attachments/1602/9201790664455.gif" alt="example"></p>
<p>重点练习了Autolayout布局，以及一个小的tips，在一个文件内使用performSelector调用一个私有方法的时候回报野指针的错误，可以通过在前面加<code>@objc</code>的方式解决这个问题</p>
<h4 id="Project02-CustomFont"><a href="#Project02-CustomFont" class="headerlink" title="Project02 - CustomFont"></a>Project02 - CustomFont</h4><p>自定义字体</p>
<p><img src="http://img.hoop8.com/attachments/1602/2701790664455.gif" alt="gitexample"></p>
<p>iOS 中有些字体是需要版权的因此可能需要购买，我这里使用的字体是Allen朝辉Demo中提供的ttf文件，并在plist文件中添加：</p>
<p>Fonts provided by application 属性 表明具体的字体</p>
<p>tips：获取当前显示字体的名称</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for family in UIFont.familyNames() &#123;</span><br><span class="line">        for font in UIFont.fontNamesForFamilyName(family)&#123;</span><br><span class="line">            orginFont &#x3D; font</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="Project03-Play-Local-Video"><a href="#Project03-Play-Local-Video" class="headerlink" title="Project03 - Play Local Video"></a>Project03 - Play Local Video</h4><p>播放本地文件</p>
<p><img src="http://img.hoop8.com/attachments/1602/0581790515984.gif" alt="play local video"></p>
<p>需要导入</p>
<p>import AVKit</p>
<p>import AVFoundation</p>
<p><code>练习一下协议的使用方式</code></p>
<h4 id="Project04-SnapChatMenu"><a href="#Project04-SnapChatMenu" class="headerlink" title="Project04 - SnapChatMenu"></a>Project04 - SnapChatMenu</h4><p>联系scrollView的布局<br>可以参考<a href="http://adad184.com/2015/12/01/scrollview-under-autolayout/">里脊的笔记</a></p>
<p><img src="http://img.hoop8.com/attachments/1602/2283165027545.gif" alt="snapChatMenu"></p>
<p>将一个控制器的view添加到另一个控制器中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let midVC &#x3D; MidViewController(nibName: </span><br><span class="line">      					&quot;MidViewController&quot;, bundle: nil)</span><br><span class="line">self.addChildViewController(midVC)</span><br><span class="line">self.scrollView.addSubview(midVC.view)</span><br><span class="line">midVC.didMoveToParentViewController(self)</span><br><span class="line">var midFrame &#x3D; midVC.view.frame</span><br><span class="line">midFrame.origin.x &#x3D; screenSize.width</span><br><span class="line">midVC.view.frame &#x3D; midFrame</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>涉及到拍摄界面的先关内容，这里还看得不太懂，以后再讲……</p>
<p>关于隐藏状态栏，我在使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UIApplication.sharedApplication().statusBarHidden &#x3D; true</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>方法设置的时候没有起作用，所以改用下面的方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">override func prefersStatusBarHidden() -&gt; Bool &#123;</span><br><span class="line">    return true</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="Project05-Carousel-Effect"><a href="#Project05-Carousel-Effect" class="headerlink" title="Project05 - Carousel Effect"></a>Project05 - Carousel Effect</h4><p>CollectionView简单使用</p>
<p><img src="http://img.hoop8.com/attachments/1602/3643165027545.gif" alt="icon"></p>
<p>了解UICollectionView的使用方法，学会使用extension在代理和数据源中的使用，学习使用Visual Effect View。</p>
<p><a href="http://www.cocoachina.com/ios/20150604/11987.html">UIVisualEffectView 学习</a></p>
<p>还有一个问题是在swift中如何区分类方法和对象方法以及使用static修饰的方法有什么特性，具体可以在我的<a href="http://leewongsnail.github.io/blog/2016/02/15/swift-little-tips/">这篇博客</a>看到</p>
<h4 id="Project06-Get-My-Location"><a href="#Project06-Get-My-Location" class="headerlink" title="Project06 - Get My Location"></a>Project06 - Get My Location</h4><p>定位功能的简单使用</p>
<p><img src="http://img.hoop8.com/attachments/1602/4513165027545.gif" alt="get my Location"></p>
<p>可以仔细的查看一下addressDict中的内容。<br>设置定位使用时间</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">　iOS 8对定位进行了一些修改，其中包括定位授权的方法，CLLocationManager增加了下面的两个方法：</span><br><span class="line">　　（1）始终允许访问位置信息</span><br><span class="line">　　- (void)requestAlwaysAuthorization;</span><br><span class="line">　　（2）使用应用程序期间允许访问位置数据</span><br><span class="line">　　- (void)requestWhenInUseAuthorization;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="Project07-Pull-To-Refresh"><a href="#Project07-Pull-To-Refresh" class="headerlink" title="Project07 - Pull To Refresh"></a>Project07 - Pull To Refresh</h4><p>简单的下拉刷新功能</p>
<p><img src="http://img.hoop8.com/attachments/1602/4783165027545.gif" alt="Pull To Refresh"></p>
<p>tableview这里使用的是纯代码 NavigationBar使用SB设置</p>
<p>熟悉使用extentsion</p>
<p>了解如何设置NavigationBar的一些属性，背景颜色、文字颜色、透明度</p>
<p>注意swift在闭包中使用变量的时候，需要添加self.</p>
<p><code>闭包中如何避免循环引用，在后面需要多注意</code></p>
<h4 id="Project08-Random-Color-Gradient"><a href="#Project08-Random-Color-Gradient" class="headerlink" title="Project08 - Random Color Gradient"></a>Project08 - Random Color Gradient</h4><p>就是练习了一下渐变色的使用（CAGradientLayer）</p>
<p><img src="http://img.hoop8.com/attachments/1602/0533165027545.gif" alt="RandomColorGradient"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;init layer</span><br><span class="line">gradientLayer.frame &#x3D; self.view.bounds</span><br><span class="line">self.view.layer.addSublayer(gradientLayer)</span><br><span class="line">        </span><br><span class="line">&#x2F;&#x2F;setting direction</span><br><span class="line">gradientLayer.startPoint &#x3D; CGPointZero</span><br><span class="line">gradientLayer.endPoint &#x3D; CGPointMake(1, 1)</span><br><span class="line">        </span><br><span class="line">&#x2F;&#x2F;设置颜色组</span><br><span class="line">for _ in 1...6 &#123;</span><br><span class="line">    let r &#x3D; CGFloat(drand48())</span><br><span class="line">    let g &#x3D; CGFloat(drand48())</span><br><span class="line">    let b &#x3D; CGFloat(drand48())</span><br><span class="line">     colors.append(UIColor(red:r, green: g, blue: b, alpha: </span><br><span class="line">     	1.0).CGColor)</span><br><span class="line">            </span><br><span class="line">    locs.append(Double(random()%10) &#x2F; 10.0)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">gradientLayer.colors &#x3D; colors</span><br><span class="line">        </span><br><span class="line">gradientLayer.locations &#x3D; locs</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h4 id="Project09-ImageScroller"><a href="#Project09-ImageScroller" class="headerlink" title="Project09 - ImageScroller"></a>Project09 - ImageScroller</h4><p>简单的查看大图，可以放大图片，左右滑动</p>
<p><img src="http://img.hoop8.com/attachments/1602/7213165027545.gif" alt="Image Scroller"></p>
<p><code>注意</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">imageView在初始化的时候 如果想让imageview根据image的大小自己去调整imageview的frame 必须使用</span><br><span class="line"></span><br><span class="line">var imageView &#x3D; UIImageView(image: UIImage(named: &quot;steve&quot;))</span><br><span class="line"></span><br><span class="line">进行初始化</span><br><span class="line">如果使用的是：</span><br><span class="line">let image &#x3D; UIImage(named: &quot;steve&quot;)</span><br><span class="line">imageView.image &#x3D; image</span><br><span class="line">则没有效果</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="Project10-SplashVideo"><a href="#Project10-SplashVideo" class="headerlink" title="Project10 - SplashVideo"></a>Project10 - SplashVideo</h4><p>使用一段视频作为背景</p>
<p><img src="http://img.hoop8.com/attachments/1602/6331790443611.gif" alt="Splash Video Background"></p>
<p>这个demo 涉及到类的集成，以及类中变量的访问控制</p>
<p>修饰类中的变量或者方法 可以使用public private internal 三种</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Public：可以访问自己模块或应用中源文件里的任何实体，别人也可以访问引入该模块中源文件里的所有实体。通常情况下，某个接口或Framework是可以被任何人使用时，你可以将其设置为public级别。</span><br><span class="line"></span><br><span class="line">Internal：可以访问自己模块或应用中源文件里的任何实体，但是别人不能访问该模块中源文件里的实体。通常情况下，某个接口或Framework作为内部结构使用时，你可以将其设置为internal级别。</span><br><span class="line"></span><br><span class="line">Private：只能在当前源文件中使用的实体，称为私有实体。使用private级别，可以用作隐藏某些功能的实现细节。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>多注意各个属性的设置</code></p>
<p><a href="http://www.devtalking.com/articles/swift-access-control/">访问控制参考文档</a></p>
<h4 id="Porject-10-Clear-Table-View"><a href="#Porject-10-Clear-Table-View" class="headerlink" title="Porject - 10 - Clear Table View"></a>Porject - 10 - Clear Table View</h4><p><img src="http://img.hoop8.com/attachments/1602/0973412352730.gif" alt="clear"></p>
<p>主要就是仿照clear APP 实现一个颜色的渐变</p>
<h4 id="Project-11-Login-Animation"><a href="#Project-11-Login-Animation" class="headerlink" title="Project - 11 - Login Animation"></a>Project - 11 - Login Animation</h4><p>一个简单的登录界面的动画</p>
<p><img src="http://img.hoop8.com/attachments/1602/4181790443611.gif" alt="Login Animation"></p>
<p>这里两个Textfield的动画是直接改变约束做的，如果想要有这样的动画效果，切记不可设置这两个控件距离左边的边距</p>
<p>这里学习使用了Spring动画，可以设置一个速率和一个阻尼系数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dampingRatio：阻尼系数，范围为 0.0 ~ 1.0，数值越小，弹簧振动的越厉害，Spring 的效果越明显</span><br><span class="line"></span><br><span class="line">velocity：表示速度，数值越大移动的越快。值为 1.0 时，这个速度为 1 秒钟之内走完整个动画距离的速度。更大或更小的值会让 view 刚到达终点时的速度更大或更小</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><a href="http://www.jianshu.com/p/9ed68b2b44d4">Spring动画参考</a></p>
<h4 id="Project-12-AnimatedTableViewCell"><a href="#Project-12-AnimatedTableViewCell" class="headerlink" title="Project - 12 - AnimatedTableViewCell"></a>Project - 12 - AnimatedTableViewCell</h4><p>实现了tableview内容加载的一个动画</p>
<p><img src="http://img.hoop8.com/attachments/1602/0971790516245.gif" alt="AnimatedTableViewCell"></p>
<p>复习了 Spring动画的使用</p>
<p>实现的基本思路就是：先将所有第一次要显示的cell下移一段距离，然后在使用动画上移实现动画效果</p>
<p>用SB实现界面间的跳转 给Segue设置一个标示符，然后调用</p>
<pre><code>performSegueWithIdentifier(&quot;pushtoSecond&quot;, sender: nil)</code></pre>
<h4 id="Project-13-Twetter-Splash"><a href="#Project-13-Twetter-Splash" class="headerlink" title="Project - 13 - Twetter Splash"></a>Project - 13 - Twetter Splash</h4><p>一个模仿推特界面的一个动画</p>
<p><img src="http://img.hoop8.com/attachments/1602/6731790516245.gif" alt="Twetter Splash"></p>
<p>使用的是关键帧动画</p>
<p><a href="http://www.devtalking.com/articles/uiview-keyframe-animation/">关于关键帧的学习参考</a></p>
<h4 id="Project-14-SlideMenu"><a href="#Project-14-SlideMenu" class="headerlink" title="Project - 14 - SlideMenu"></a>Project - 14 - SlideMenu</h4><p>转场动画</p>
<p><img src="http://img.hoop8.com/attachments/1602/1253412352730.gif" alt="slideMenu"></p>
<p>实现转场动画需要遵守UIViewControllerAnimatedTransitioning协议</p>
<p>实现下面几个方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public func transitionDuration(transitionContext:</span><br><span class="line"> UIViewControllerContextTransitioning?) -&gt; </span><br><span class="line"> 									NSTimeInterval</span><br><span class="line"></span><br><span class="line">public func animateTransition(transitionContext: </span><br><span class="line">			UIViewControllerContextTransitioning)</span><br><span class="line"></span><br><span class="line">optional public func </span><br><span class="line">		animationEnded(transitionCompleted: Bool)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="Project-15-TumblrMenu"><a href="#Project-15-TumblrMenu" class="headerlink" title="Project - 15 - TumblrMenu"></a>Project - 15 - TumblrMenu</h4><p>转场动画</p>
<p><img src="http://img.hoop8.com/attachments/1602/8463733055394.gif" alt="TumblrMenu"></p>
<p>转场动画的练习</p>
<h4 id="Project-16-CharacterLimit"><a href="#Project-16-CharacterLimit" class="headerlink" title="Project - 16 - CharacterLimit"></a>Project - 16 - CharacterLimit</h4><p><img src="http://img.hoop8.com/attachments/1603/6731790445216.gif" alt="characterLimit"></p>
<p>键盘的弹出和收起的两个动画，以及UITextView使用过程中如何进行字数的限制</p>
<p><code>注意 如何判断用户进行的是删除操作</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;删除键</span><br><span class="line">if text.characters.count &#x3D;&#x3D; 0 &amp;&amp; range.length &#x3D;&#x3D; 1 &#123;</span><br><span class="line">     return true</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="Project-17-PullToRefresh"><a href="#Project-17-PullToRefresh" class="headerlink" title="Project - 17 - PullToRefresh"></a>Project - 17 - PullToRefresh</h4><p>自定义下拉刷新的动画</p>
<p><img src="http://img.hoop8.com/attachments/1603/6061790445216.gif" alt="pullToRefresh"></p>
<p>这里使用的是最基本的动画 然后进行了拼接</p>
<p>animateRefreshStep1：旋转并改变颜色完成后恢复</p>
<p>animateRefreshStep2：文字放大完成后恢复</p>
<h4 id="Project-18-CollectionAnimation"><a href="#Project-18-CollectionAnimation" class="headerlink" title="Project - 18 - CollectionAnimation"></a>Project - 18 - CollectionAnimation</h4><p>这种动画通常可以用于一些不是很复杂界面，比如查看大图</p>
<p><img src="http://img.hoop8.com/attachments/1603/4753412352730.gif" alt="Collection Animation"></p>
<p>这个项目中比较注意，设计模型的使用，使用结构体代替模型</p>
<p>同时需要注意guard 语法的使用</p>
<p><a href="http://www.jianshu.com/p/3a8e45af7fdd">guard学习参看</a></p>
<h4 id="Project-19-SwipeCell"><a href="#Project-19-SwipeCell" class="headerlink" title="Project - 19 - SwipeCell"></a>Project - 19 - SwipeCell</h4><p>tableViewCell 左滑可以显示多个按钮</p>
<p><img src="http://img.hoop8.com/attachments/1603/5083412352730.gif" alt="SwipeCell"><br>实现方法：</p>
<p>代理方法：editActionsForRowAtIndexPath中返回要返回的按钮,每一个按钮的长度是根据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">按钮的定义：</span><br><span class="line"></span><br><span class="line">let delete &#x3D; UITableViewRowAction(style: .Normal, title: </span><br><span class="line">			&quot;Delete&quot;) &#123; (action, indexPath) -&gt; Void in</span><br><span class="line">			</span><br><span class="line">            print(&quot;press \(action.title) at</span><br><span class="line">             				\(indexPath.row)&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">delete.backgroundColor &#x3D; UIColor.grayColor()</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="Project-20-3DTouchTest"><a href="#Project-20-3DTouchTest" class="headerlink" title="Project - 20- 3DTouchTest"></a>Project - 20- 3DTouchTest</h4><p>测试3DTouch</p>
<p><img src="http://img.hoop8.com/attachments/1603/7713412352730.gif" alt="3DTouch"></p>
<p>注意plist文件的配置，使用类似于openurl</p>
<p>菜单显示后的点击事件会调用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func application(application: UIApplication,</span><br><span class="line">		 performActionForShortcutItem shortcutItem: </span><br><span class="line">		 UIApplicationShortcutItem, completionHandler: </span><br><span class="line">		 							(Bool) -&gt; Void) &#123;</span><br><span class="line">        </span><br><span class="line">        let handledShortCutItem &#x3D; </span><br><span class="line">        				handleShortCutItem(shortcutItem)</span><br><span class="line">        				</span><br><span class="line">        completionHandler(handledShortCutItem)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>应用被激活之后</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">根据shortcutItem的type，判断点击的是一个个功能选项，随机跳转到目标控制器</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="Project-21-TabBarAnimation"><a href="#Project-21-TabBarAnimation" class="headerlink" title="Project - 21 - TabBarAnimation"></a>Project - 21 - TabBarAnimation</h4><p>tabBar动画 在viewDidAppear中做的操作</p>
<p><img src="http://img.hoop8.com/attachments/1603/2763412352730.gif" alt="tabbarAnimation"></p>
<p>重新练习一下几个比较简单的动画</p>
]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>Demo</tag>
      </tags>
  </entry>
  <entry>
    <title>常用的SQL语句</title>
    <url>/2018/04/12/Userful-SQL/</url>
    <content><![CDATA[<p>SQL 是一门 ANSI 的标准计算机语言，用来访问和操作数据库系统。SQL 语句用于取回和更新数据库中的数据。SQL 可与数据库程序协同工作，比如 MS Access、DB2、Informix、MS SQL Server、Oracle、Sybase 以及其他数据库系统。</p>
<a id="more"></a>

<h2 id="SQL-SELECT-语句"><a href="#SQL-SELECT-语句" class="headerlink" title="SQL SELECT 语句"></a>SQL SELECT 语句</h2><p>语法：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 列名称 <span class="keyword">FROM</span> 表名称</span><br><span class="line">或者</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> 表名称</span><br></pre></td></tr></table></figure>
<p><code>注释</code>：SQL 语句对大小写不敏感。SELECT 等效于 select。</p>
<h2 id="SQL-SELECT-DISTINCT-语句"><a href="#SQL-SELECT-DISTINCT-语句" class="headerlink" title="SQL SELECT DISTINCT 语句"></a>SQL SELECT DISTINCT 语句</h2><p>在表中，可能会包含重复值。这并不成问题，不过，有时您也许希望仅仅列出不同（distinct）的值。</p>
<p>语法：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> 列名称 <span class="keyword">FROM</span> 表名称</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="SQL-WHERE-子句"><a href="#SQL-WHERE-子句" class="headerlink" title="SQL WHERE 子句"></a>SQL WHERE 子句</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 列名称 <span class="keyword">FROM</span> 表名称 <span class="keyword">WHERE</span> 列 运算符 值</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>操作符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>=</td>
<td>等于</td>
</tr>
<tr>
<td>&lt;&gt;</td>
<td>不等于</td>
</tr>
</tbody></table>
<blockquote>
<p>   | 大于<br>&lt;    | 小于<br>=    | 大于等于<br>&lt;=    | 小于等于<br>BETWEEN    | 在某个范围内<br>LIKE    | 搜索某种模式</p>
</blockquote>
<h2 id="SQL-AND-amp-OR-运算符"><a href="#SQL-AND-amp-OR-运算符" class="headerlink" title="SQL AND &amp; OR 运算符"></a>SQL AND &amp; OR 运算符</h2><p>AND 和 OR 可在 WHERE 子语句中把两个或多个条件结合起来。<br>如果第一个条件和第二个条件都成立，则 AND 运算符显示一条记录。<br>如果第一个条件和第二个条件中只要有一个成立，则 OR 运算符显示一条记录。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> Persons <span class="keyword">WHERE</span> firstname=<span class="string">&#x27;Thomas&#x27;</span> <span class="keyword">OR</span> lastname=<span class="string">&#x27;Carter&#x27;</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> Persons <span class="keyword">WHERE</span> FirstName=<span class="string">&#x27;Thomas&#x27;</span> <span class="keyword">AND</span> LastName=<span class="string">&#x27;Carter&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="SQL-ORDER-BY-子句"><a href="#SQL-ORDER-BY-子句" class="headerlink" title="SQL ORDER BY 子句"></a>SQL ORDER BY 子句</h2><p>ORDER BY 语句用于对结果集进行排序。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Company, OrderNumber <span class="keyword">FROM</span> Orders <span class="keyword">ORDER</span> <span class="keyword">BY</span> Company</span><br><span class="line"><span class="keyword">SELECT</span> Company, OrderNumber <span class="keyword">FROM</span> Orders <span class="keyword">ORDER</span> <span class="keyword">BY</span> Company <span class="keyword">DESC</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="SQL-INSERT-INTO-语句"><a href="#SQL-INSERT-INTO-语句" class="headerlink" title="SQL INSERT INTO 语句"></a>SQL INSERT INTO 语句</h2><p>INSERT INTO 语句用于向表格中插入新的行。</p>
<p>语法：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> 表名称 <span class="keyword">VALUES</span> (值<span class="number">1</span>, 值<span class="number">2</span>,....)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们也可以指定所要插入数据的列：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> table_name (列<span class="number">1</span>, 列<span class="number">2</span>,...) <span class="keyword">VALUES</span> (值<span class="number">1</span>, 值<span class="number">2</span>,....)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Persons <span class="keyword">VALUES</span> (<span class="string">&#x27;Gates&#x27;</span>, <span class="string">&#x27;Bill&#x27;</span>, <span class="string">&#x27;Xuanwumen 10&#x27;</span>, <span class="string">&#x27;Beijing&#x27;</span>)</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Persons (LastName, Address) <span class="keyword">VALUES</span> (<span class="string">&#x27;Wilson&#x27;</span>, <span class="string">&#x27;Champs-Elysees&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="SQL-UPDATE-语句"><a href="#SQL-UPDATE-语句" class="headerlink" title="SQL UPDATE 语句"></a>SQL UPDATE 语句</h2><p>Update 语句用于修改表中的数据。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> 表名称 <span class="keyword">SET</span> 列名称 = 新值 <span class="keyword">WHERE</span> 列名称 = 某值</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> Person <span class="keyword">SET</span> Address = <span class="string">&#x27;Zhongshan 23&#x27;</span>, City = <span class="string">&#x27;Nanjing&#x27;</span></span><br><span class="line"><span class="keyword">WHERE</span> LastName = <span class="string">&#x27;Wilson&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="SQL-DELETE-语句"><a href="#SQL-DELETE-语句" class="headerlink" title="SQL DELETE 语句"></a>SQL DELETE 语句</h2><p>DELETE 语句用于删除表中的行。</p>
<p>语法：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> 表名称 <span class="keyword">WHERE</span> 列名称 = 值</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>删除所有的行</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> table_name</span><br><span class="line">或者</span><br><span class="line"><span class="keyword">DELETE</span> * <span class="keyword">FROM</span> table_name</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> Person <span class="keyword">WHERE</span> LastName = <span class="string">&#x27;Wilson&#x27;</span> </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="SQL-PRIMARY-KEY-约束"><a href="#SQL-PRIMARY-KEY-约束" class="headerlink" title="SQL PRIMARY KEY 约束"></a>SQL PRIMARY KEY 约束</h2><p>PRIMARY KEY 约束唯一标识数据库表中的每条记录。<br>主键必须包含唯一的值。<br>主键列不能包含 NULL 值。<br>每个表都应该有一个主键，并且每个表只能有一个主键。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Persons</span><br><span class="line">(</span><br><span class="line">Id_P <span class="built_in">int</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">LastName <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">FirstName <span class="built_in">varchar</span>(<span class="number">255</span>),</span><br><span class="line">Address <span class="built_in">varchar</span>(<span class="number">255</span>),</span><br><span class="line">City <span class="built_in">varchar</span>(<span class="number">255</span>),</span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (Id_P)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>如果在表已存在的情况下为 “Id_P” 列创建 PRIMARY KEY 约束，请使用下面的 SQL：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> Persons</span><br><span class="line"><span class="keyword">ADD</span> PRIMARY <span class="keyword">KEY</span> (Id_P)</span><br></pre></td></tr></table></figure>

<p>撤销 PRIMARY KEY 约束</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> Persons</span><br><span class="line"><span class="keyword">DROP</span> PRIMARY <span class="keyword">KEY</span></span><br></pre></td></tr></table></figure>


<h2 id="SQL-FOREIGN-KEY-约束"><a href="#SQL-FOREIGN-KEY-约束" class="headerlink" title="SQL FOREIGN KEY 约束"></a>SQL FOREIGN KEY 约束</h2><p>一个表中的 FOREIGN KEY 指向另一个表中的 PRIMARY KEY。</p>
<p>FOREIGN KEY 约束用于预防破坏表之间连接的动作。<br>FOREIGN KEY 约束也能防止非法数据插入外键列，因为它必须是它指向的那个表中的值之一。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Orders</span><br><span class="line">(</span><br><span class="line">Id_O <span class="built_in">int</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">OrderNo <span class="built_in">int</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">Id_P <span class="built_in">int</span>,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (Id_O),</span><br><span class="line"><span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (Id_P) <span class="keyword">REFERENCES</span> Persons(Id_P)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>如果在 “Orders” 表已存在的情况下为 “Id_P” 列创建 FOREIGN KEY 约束，请使用下面的 SQL：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> Orders</span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (Id_P)</span><br><span class="line"><span class="keyword">REFERENCES</span> Persons(Id_P)</span><br></pre></td></tr></table></figure>

<p>撤销 FOREIGN KEY 约束</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> Orders</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> fk_PerOrders</span><br></pre></td></tr></table></figure>

<h2 id="SQL-JOIN"><a href="#SQL-JOIN" class="headerlink" title="SQL JOIN"></a>SQL JOIN</h2><p>SQL join 用于根据两个或多个表中的列之间的关系，从这些表中查询数据。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Persons.LastName, Persons.FirstName, Orders.OrderNo</span><br><span class="line"><span class="keyword">FROM</span> Persons, Orders</span><br><span class="line"><span class="keyword">WHERE</span> Persons.Id_P = Orders.Id_P</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Persons.LastName, Persons.FirstName, Orders.OrderNo</span><br><span class="line"><span class="keyword">FROM</span> Persons</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> Orders</span><br><span class="line"><span class="keyword">ON</span> Persons.Id_P = Orders.Id_P</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> Persons.LastName</span><br></pre></td></tr></table></figure>

<p>不同的 SQL JOIN</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">JOIN: 如果表中有至少一个匹配，则返回行</span><br><span class="line">LEFT JOIN: 即使右表中没有匹配，也从左表返回所有的行</span><br><span class="line">RIGHT JOIN: 即使左表中没有匹配，也从右表返回所有的行</span><br><span class="line">FULL JOIN: 只要其中一个表中存在匹配，就返回行</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>SQL 数据库</category>
      </categories>
      <tags>
        <tag>数据库 查询 插入 更新</tag>
      </tags>
  </entry>
  <entry>
    <title>基于CTMediator的组件间跳转</title>
    <url>/2016/09/26/alimediator/</url>
    <content><![CDATA[<p>  大概在去年，APP组件化讨论的非常热，各类组件化的文章也非常的多，看了其中的几篇，也是写的挺不错，我的这个思路就是继承其中一位采用(Target-Action)思路实现跳转解耦的。</p>
<a id="more"></a>

<h4 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h4><p>  大概在去年，APP组件化讨论的非常热，各类组件化的文章也非常的多，看了其中的几篇，也是写的挺不错，我的这个思路就是继承其中一位采用(Target-Action)思路实现跳转解耦的。</p>
<p>  我看过的几个<a href="http://leewongsnail.github.io/2016/06/12/App%E7%BB%84%E4%BB%B6%E5%8C%96%E6%96%87%E7%AB%A0%E6%94%B6%E9%9B%86/">文章</a>,这里跟大家分享一下。这篇文章的demo我放到了<a href="https://github.com/LeeWongSnail/ALiMediator">这里</a></p>
<h4 id="2、跳转方法实现（借用casatwy图片）"><a href="#2、跳转方法实现（借用casatwy图片）" class="headerlink" title="2、跳转方法实现（借用casatwy图片）"></a>2、跳转方法实现（借用casatwy图片）</h4><h5 id="2-1-方案的架构图"><a href="#2-1-方案的架构图" class="headerlink" title="2.1 方案的架构图"></a>2.1 方案的架构图</h5><p><img src="https://i.niupic.com/images/2016/09/08/xk7Jto.png" alt="mediator"></p>
<h5 id="2-2-调用方式"><a href="#2-2-调用方式" class="headerlink" title="2.2 调用方式"></a>2.2 调用方式</h5><p><img src="https://i.niupic.com/images/2016/09/08/nZc6mm.png" alt="Method"></p>
<h4 id="3、项目相关"><a href="#3、项目相关" class="headerlink" title="3、项目相关"></a>3、项目相关</h4><p>  我的项目中，将每一个模块，放在一个文件夹内，将每一个模块看做一个APP，在APP内部高度封装，必要时可将整个模块复用。千万不要因为某一个模块比较小就将其放到一个大的模块中，我认为只要感觉这个模块有一定的复用性，都要把他抽出来，即使这个项目不能服用，其他项目可能也可以复用。比如 分享 搜索。</p>
<h4 id="4、最后"><a href="#4、最后" class="headerlink" title="4、最后"></a>4、最后</h4><p>  我所写的只是 我对组件化的一个入门的小理解，感觉组件化大势所趋。如果觉得这篇文章没有什么，不妨去拜读一下 前面我提供的那几篇文章。希望对你有帮助。</p>
]]></content>
      <categories>
        <category>组件化</category>
      </categories>
      <tags>
        <tag>组件跳转 中间者模式 CTMediator</tag>
      </tags>
  </entry>
  <entry>
    <title>UITableView的嵌套</title>
    <url>/2016/08/27/artscrolltableView/</url>
    <content><![CDATA[<p>前端时间公司的某一个模块中，需要用到这么一个效果，一个看似很简单的东<br>西，当时直接用的第三方，现在把简单的东西抽出来，供大家参考。这不是一<br>个第三方的，可以直接使用的库，我只是简单的讲述了我的思想，所以其中有<br>一些东西的依赖比较重。大家只是参考一下就可以了</p>
<a id="more"></a>

<h4 id="1、效果图"><a href="#1、效果图" class="headerlink" title="1、效果图"></a>1、效果图</h4><p><img src="http://7xqmjb.com1.z0.glb.clouddn.com/2016082778727scrollTable.gif" alt="2016082778727scrollTable.gif"></p>
<h4 id="2、主要思路"><a href="#2、主要思路" class="headerlink" title="2、主要思路"></a>2、主要思路</h4><p>1、这个功能的实现主要是多控制器的管理，tableview的cell中嵌套了一个控制器，这个控制器也管理者多个控制器</p>
<p><code>这里的多控制器也可以改为多个view，大家可尝试做一些优化</code></p>
<p>2、这里为了解耦主要采用的是通知，通知的使用有利有弊，具体使用的时候一定要记得移除监听</p>
<p>具体思路：</p>
<ul>
<li><p>1 、外部控制器可滑动，当监听到第三个section的位置的关系判断</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> CGFloat tabOffsetY &#x3D; [_tableView rectForSection:</span><br><span class="line"> 						2].origin.y-64;</span><br><span class="line"> 						</span><br><span class="line">CGFloat offsetY &#x3D; scrollView.contentOffset.y;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>通过判断这两者的关系，判断应该是哪一个tableview可以被拖动</p>
</li>
</ul>
<p>待续</p>
]]></content>
      <categories>
        <category>UI</category>
      </categories>
      <tags>
        <tag>UI框架</tag>
      </tags>
  </entry>
  <entry>
    <title>Fastlane iOS</title>
    <url>/2017/10/12/fastlane-learning/</url>
    <content><![CDATA[<p>因为公司目前的项目需要一个项目打多个包,打包实际上是一个纯体力活,所以为了提升效率,之前同事写了一个利用Fastlane自动打包的脚本,最近项目不忙,所以看看文档总结一下！</p>
<a id="more"></a>

<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="确保安装了最新的-Xcode-command-line-tools"><a href="#确保安装了最新的-Xcode-command-line-tools" class="headerlink" title="确保安装了最新的 Xcode command line tools"></a>确保安装了最新的 Xcode command line tools</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xcode-select --install</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="安装Fastlane"><a href="#安装Fastlane" class="headerlink" title="安装Fastlane"></a>安装Fastlane</h3><p><img src="http://og0h689k8.bkt.clouddn.com/17-10-12/29284112.jpg" alt="安装Fastlane"></p>
<p>只需要这两步,安装过程就大功告成,下面开始把玩fastlane</p>
<h2 id="初始化Fastlane"><a href="#初始化Fastlane" class="headerlink" title="初始化Fastlane"></a>初始化Fastlane</h2><p>进入到你的项目的根目录(与xcodeproj文件同级目录下)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fastlane init</span><br></pre></td></tr></table></figure>

<p>期间会让你输入 Apple ID 和密码<br><img src="http://og0h689k8.bkt.clouddn.com/17-10-12/59536373.jpg" alt="输入密码"></p>
<p>确认信息<br><img src="http://og0h689k8.bkt.clouddn.com/17-10-12/67960903.jpg" alt="确认信息"></p>
<p>会自动下载现存的截图<br><img src="http://og0h689k8.bkt.clouddn.com/17-10-12/73492697.jpg" alt="下载现存的截图"></p>
<p>初始化完成后的目录结构<br><img src="http://og0h689k8.bkt.clouddn.com/17-10-12/31492902.jpg" alt="目录结构"></p>
<p>至此 fastlane就初始化完成了,再接再厉！！！</p>
<h2 id="截图"><a href="#截图" class="headerlink" title="截图"></a>截图</h2><p>每次发布新版本的时候截图是一件比较恶心的事情(虽然16年更新之后我们只需要上传最大尺寸的机型就可以适配),fastlane也可以为我们解决这件事！</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fastlane snapshot init</span><br></pre></td></tr></table></figure>
<p>初始化成功之后 我们可以得到<br><img src="http://og0h689k8.bkt.clouddn.com/17-10-12/84919492.jpg"></p>
<h3 id="导入文件"><a href="#导入文件" class="headerlink" title="导入文件"></a>导入文件</h3><p>导入上一步生成的SnapshotHelper.swift文件到你的UITest目录下<br><code>注意:</code>如果你是OC的项目这里要设置一下桥接</p>
<p><img src="http://upload-images.jianshu.io/upload_images/594219-109d427d7a9e4cb8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="桥接"></p>
<p>注意 对于 SnapshotHelper.swift<br><img src="http://og0h689k8.bkt.clouddn.com/17-10-12/54904384.jpg"></p>
<h3 id="导入头文件"><a href="#导入头文件" class="headerlink" title="导入头文件"></a>导入头文件</h3><p>这个头文件是系统默认生成的，不用我们手动创建，我们在拖入Siwft文件之后，直接引用就可以。 没有智能提示，所以不必惊慌，保证#import’target名称-Swift.h’正确就可以了。</p>
<h3 id="录制"><a href="#录制" class="headerlink" title="录制"></a>录制</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(void)setUp: 方法在XCTestCase的测试方法调用之前调用，可以在测试之前创建在test case方法中需要用到的一些对象等</span><br><span class="line">(void)tearDown: 当测试全部结束之后调用tearDown方法，法则在全部的test case执行结束之后清理测试现场，释放资源删除不用的对象等</span><br><span class="line">(void)testExample: 测试代码执行性能</span><br></pre></td></tr></table></figure>


<h3 id="添加截图代码"><a href="#添加截图代码" class="headerlink" title="添加截图代码"></a>添加截图代码</h3><p>在setUp方法中添加</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">XCUIApplication *app &#x3D; [[XCUIApplication alloc] init];</span><br><span class="line">[Snapshot setupSnapshot:app];</span><br><span class="line">[app launch];</span><br></pre></td></tr></table></figure>

<p>在在录制步骤产生的步骤代码中加入（testExample中）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[Snapshot snapshot:@&quot;01LoginScreen&quot; waitForLoadingIndicator:YES];</span><br></pre></td></tr></table></figure>

<p><img src="http://og0h689k8.bkt.clouddn.com/17-10-12/90575579.jpg"></p>
<h3 id="修改Snapfile文件"><a href="#修改Snapfile文件" class="headerlink" title="修改Snapfile文件"></a>修改Snapfile文件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">要截图的设备 默认所有的设备</span><br><span class="line"># A list of devices you want to take the screenshots from</span><br><span class="line"> devices([</span><br><span class="line">   &quot;iPhone 7&quot;,</span><br><span class="line">   &quot;iPhone 7 Plus&quot;,</span><br><span class="line">   &quot;iPhone 6&quot;</span><br><span class="line"> ])</span><br><span class="line"></span><br><span class="line">支持的语言,对于支持多语言的应用比较有利</span><br><span class="line">languages([</span><br><span class="line">  &quot;en-US&quot;,</span><br><span class="line">  #&quot;de-DE&quot;,</span><br><span class="line">  #&quot;it-IT&quot;,</span><br><span class="line">  #[&quot;pt&quot;, &quot;pt_BR&quot;] # Portuguese with Brazilian locale</span><br><span class="line">])</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="生成截图"><a href="#生成截图" class="headerlink" title="生成截图"></a>生成截图</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fastlane snapshot</span><br></pre></td></tr></table></figure>
<p><img src="http://og0h689k8.bkt.clouddn.com/17-10-12/99858121.jpg"><br><img src="http://og0h689k8.bkt.clouddn.com/17-10-12/85295801.jpg"></p>
<h2 id="添加边框"><a href="#添加边框" class="headerlink" title="添加边框"></a>添加边框</h2><h3 id="安装ImageMagick"><a href="#安装ImageMagick" class="headerlink" title="安装ImageMagick"></a>安装ImageMagick</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew install libpng jpeg imagemagick</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>下载最新的边框</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fastlane frameit setup</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="生成带边框的截图"><a href="#生成带边框的截图" class="headerlink" title="生成带边框的截图"></a>生成带边框的截图</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fastlane frameit</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="http://og0h689k8.bkt.clouddn.com/17-10-13/46969300.jpg" alt="结果"></p>
<h2 id="pem-生成推送证书"><a href="#pem-生成推送证书" class="headerlink" title="pem 生成推送证书"></a>pem 生成推送证书</h2><p>命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fastlane pem</span><br></pre></td></tr></table></figure>

<ul>
<li>1、创建新的签名请求(signing request)</li>
<li>2、创建新的推送证书( push certification)</li>
<li>3、下载这个证书(certificate)</li>
<li>4、在当前工作目录创建新的 .pem 文件,你可以上传到你的服务器</li>
</ul>
<p><code>pem不会revoke已经存在的证书,也不会下载已经存在的证书,因为私钥仅在创建的机器上可用</code></p>
<p>实用命令</p>
<p>如果你已经有一个可用的推送证书(certificate),而且有效期至少还有30天以上，pem就不会创建新的证书。如果你想要创建新的，使用force：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fastlane pem --force</span><br></pre></td></tr></table></figure>

<p>还可传参数,如:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fastlane pem -a com.krausefx.app -u username</span><br></pre></td></tr></table></figure>

<p>生成开发证书:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fastlane pem --development</span><br></pre></td></tr></table></figure>

<p>给p12文件设置密码:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fastlane pem -p &quot;MyPass&quot;</span><br></pre></td></tr></table></figure>

<p>可以指定输出名字:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fastlane pem -o my.pem</span><br></pre></td></tr></table></figure>

<p>列出可用命令选项:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fastlane pem --help</span><br></pre></td></tr></table></figure>


<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>–development</td>
<td>[VALUE] Renew the development push certificate instead of the production one (PEM_DEVELOPMENT)</td>
</tr>
<tr>
<td>–generate_p12</td>
<td>[VALUE] Generate a p12 file additionally to a PEM file (PEM_GENERATE_P12_FILE)</td>
</tr>
<tr>
<td>–active_days_limit</td>
<td>STRING If the current certificate is active for less than this number of days, generate a new one. Default value is 30 days (PEM_ACTIVE_DAYS_LIMIT)</td>
</tr>
<tr>
<td>–force</td>
<td>[VALUE]      Create a new push certificate, even if the current one is active for 30 (or PEM_ACTIVE_DAYS_LIMIT) more days (PEM_FORCE)</td>
</tr>
<tr>
<td>-s, –save_private_key</td>
<td>[VALUE] Set to save the private RSA key (PEM_SAVE_PRIVATEKEY)</td>
</tr>
<tr>
<td>-a, –app_identifier</td>
<td>STRING The bundle identifier of your app (PEM_APP_IDENTIFIER)</td>
</tr>
<tr>
<td>-u, –username</td>
<td>STRING Your Apple ID Username (PEM_USERNAME)</td>
</tr>
<tr>
<td>-b, –team_id</td>
<td>STRING The ID of your Developer Portal team if you’re in multiple teams (PEM_TEAM_ID)</td>
</tr>
<tr>
<td>-l, –team_name</td>
<td>STRING The name of your Developer Portal team if you’re in multiple teams (PEM_TEAM_NAME)</td>
</tr>
<tr>
<td>-p, –p12_password</td>
<td>STRING The password that is used for your p12 file (PEM_P12_PASSWORD)</td>
</tr>
</tbody></table>
<h2 id="签名"><a href="#签名" class="headerlink" title="签名"></a>签名</h2><p>sign可以创建，更新，下载和修复 provisioning profiles（使用一个命令）。<br>它支持App Store，Ad Hoc，开发和企业配置文件，并支持好的特性，如自动添加所有测试设备。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">下载最新的应用配置文件</span><br><span class="line">更新配置配置文件，当它已过期</span><br><span class="line">修复配置配置文件，当它坏了</span><br><span class="line">创建新的配置配置文件（如果尚不存在）</span><br><span class="line">支持App Store，Ad Hoc和Development Profile</span><br><span class="line">支持多个Apple帐户，将您的凭据安全地存储在钥匙串中</span><br><span class="line">支持多个团队(multiple Teams)</span><br><span class="line">支持企业应用配置(Enterprise Profiles)</span><br></pre></td></tr></table></figure>

<p>进入工程目录后</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fastlane sigh #默认会在当前文件夹下生成针对appstore的&#96;.mobileprovision&#96;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>fastlane sigh</td>
<td>App Store profile 或 InHouse profile</td>
</tr>
<tr>
<td>fastlane sigh -a com.krausefx.app -u username</td>
<td>指定bundle identifier 和 username(apple id)</td>
</tr>
<tr>
<td>fastlane sigh –adhoc</td>
<td>生成Ad Hoc profile</td>
</tr>
<tr>
<td>fastlane sigh –development</td>
<td>生成 development profile</td>
</tr>
<tr>
<td>fastlane sigh -o “./Certificates/“</td>
<td>指定输出文件夹</td>
</tr>
<tr>
<td>fastlane sigh download_all</td>
<td>下载所有的 provisioning profiles</td>
</tr>
<tr>
<td>fastlane sigh –help</td>
<td>列出帮助</td>
</tr>
</tbody></table>
<p>高级使用</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>fastlane sigh –skip_install</td>
<td>默认情况下，sigh将下载的配置文件安装在您的机器上。 如果只想生成配置文件并跳过安装,使用该命令</td>
</tr>
<tr>
<td>fastlane sigh -a com.krausefx.app -u username -q “myProfile.mobileprovision”</td>
<td>用特定的名字保存,使用 -q</td>
</tr>
<tr>
<td>fastlane sigh –skip_certificate_verification</td>
<td>跳过验证安装在本机上的 code signing identity</td>
</tr>
<tr>
<td>fastlane sigh –force</td>
<td>如果您需要更新配置配置文件，而不管其状态如何，请使用–force选项。这给您一个具有最大生命周期的配置文件。 –force还会将所有可用的设备添加到此配置文件中。</td>
</tr>
<tr>
<td>fastlane sigh –help</td>
<td>查看帮助:列出可用参数和命令</td>
</tr>
</tbody></table>
<p>结合fastlane 使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lane :beta do</span><br><span class="line">  cert</span><br><span class="line">  sigh(force: true)</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p><code>force：true将确保在每次运行时重新生成配置配置文件。 这将使得sign总是使用正确的签名证书(signing certificate),证书将会被安装到本机上。</code></p>
<p>所有参数</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>–adhoc</td>
<td>[VALUE]      Setting this flag will generate AdHoc profiles instead of App Store Profiles (SIGH_AD_HOC)</td>
</tr>
<tr>
<td>–development</td>
<td>[VALUE] Renew the development certificate instead of the production one (SIGH_DEVELOPMENT)</td>
</tr>
<tr>
<td>–skip_install</td>
<td>[VALUE] By default, the certificate will be added to your local machine. Setting this flag will skip this action (SIGH_SKIP_INSTALL)</td>
</tr>
<tr>
<td>-f, –force</td>
<td>[VALUE]  Renew provisioning profiles regardless of its state - to automatically add all devices for ad hoc profiles (SIGH_FORCE)</td>
</tr>
<tr>
<td>-a, –app_identifier</td>
<td>STRING The bundle identifier of your app (SIGH_APP_IDENTIFIER)</td>
</tr>
<tr>
<td>-u, –username</td>
<td>STRING Your Apple ID Username (SIGH_USERNAME)</td>
</tr>
<tr>
<td>-b, –team_id</td>
<td>STRING The ID of your Developer Portal team if you’re in multiple teams (SIGH_TEAM_ID)</td>
</tr>
<tr>
<td>-l, –team_name</td>
<td>STRING The name of your Developer Portal team if you’re in multiple teams (SIGH_TEAM_NAME)</td>
</tr>
<tr>
<td>-n, –provisioning_name</td>
<td>STRING The name of the profile that is used on the Apple Developer Portal (SIGH_PROVISIONING_PROFILE_NAME)</td>
</tr>
<tr>
<td>–ignore_profiles_with_different_name</td>
<td>[VALUE] Use in combination with :provisioning_name - when true only profiles matching this exact name will be downloaded(SIGH_IGNORE_PROFILES_WITH_DIFFERENT_NAME)</td>
</tr>
<tr>
<td>-o, –output_path</td>
<td>STRING Directory in which the profile should be stored(SIGH_OUTPUT_PATH)</td>
</tr>
<tr>
<td>-i, –cert_id</td>
<td>STRING The ID of the code signing certificate to use (e.g. 78ADL6LVAA)  (SIGH_CERTIFICATE_ID)</td>
</tr>
<tr>
<td>-c, –cert_owner_name</td>
<td>STRING The certificate name to use for new profiles, or to renew with. (e.g. “Felix Krause”) (SIGH_CERTIFICATE)</td>
</tr>
<tr>
<td>-q, –filename</td>
<td>STRING Filename to use for the generated provisioning profile (must include .mobileprovision) (SIGH_PROFILE_FILE_NAME)</td>
</tr>
<tr>
<td>-w, –skip_fetch_profiles</td>
<td>[VALUE] Skips the verification of existing profiles which is useful if you have thousands of profiles (SIGH_SKIP_FETCH_PROFILES)</td>
</tr>
<tr>
<td>-z, –skip_certificate_verification</td>
<td>[VALUE] Skips the verification of the certificates for every existing profiles. This will make sure the provisioning profile can be used on the local machine(SIGH_SKIP_CERTIFICATE_VERIFICATION)</td>
</tr>
<tr>
<td>-p, –platform</td>
<td>[VALUE] Set the provisioning profile’s platform (i.e. ios, tvos) (SIGH_PLATFORM)</td>
</tr>
<tr>
<td>–template_name</td>
<td>STRING The name of provisioning profile template. If the developer account has provisioning profile templates, template name can be found by inspecting the Entitlements drop-down while creating/editing a provisioning profile(SIGH_PROVISIONING_PROFILE_TEMPLATE_NAME)</td>
</tr>
</tbody></table>
<h2 id="自动打包"><a href="#自动打包" class="headerlink" title="自动打包"></a>自动打包</h2><p>用法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fastlane gym</span><br><span class="line">#fastlane gym --export_method ad-hoc</span><br><span class="line">#fastlane gym --export_method enterprise</span><br><span class="line">#fastlane gym --export_method app-store</span><br></pre></td></tr></table></figure>

<p>当然可以增加一些配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fastlane gym --workspace &quot;Example.xcworkspace&quot; --scheme &quot;AppName&quot; --clean</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>选择Xcode:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DEVELOPER_DIR&#x3D;&quot;&#x2F;Applications&#x2F;Xcode6.2.app&quot; gym</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>列出可用参数列表:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fastlane gym --help</span><br></pre></td></tr></table></figure>

<p>运行遇到错误,使用verbose模式获取更多信息:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fastlane gym --verbose</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果您没有上传到App Store或TestFlight，请设置正确的导出方法:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fastlane gym --export_method ad-hoc</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>要使用bool参数,确保这么使用gym:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fastlane gym --include_bitcode true --include_symbols false</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>获取xcodebuild输出,请到~/Library/Logs/gym查看。</p>
<p>gym 的常用参数</p>
<p> Options for build:</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>-w, –workspace</td>
<td>STRING Path to the workspace file (GYM_WORKSPACE)</td>
</tr>
<tr>
<td>-p, –project</td>
<td>STRING Path to the project file (GYM_PROJECT)</td>
</tr>
<tr>
<td>-s, –scheme</td>
<td>STRING  The project’s scheme. Make sure it’s marked as <code>Shared</code> (GYM_SCHEME)</td>
</tr>
<tr>
<td>-c, –clean</td>
<td>[VALUE]  Should the project be cleaned before building it? (GYM_CLEAN)</td>
</tr>
<tr>
<td>-o, –output_directory</td>
<td>STRING The directory in which the ipa file should be stored in (GYM_OUTPUT_DIRECTORY)</td>
</tr>
<tr>
<td>-n, –output_name</td>
<td>STRING The name of the resulting ipa file (GYM_OUTPUT_NAME)</td>
</tr>
<tr>
<td>-q, –configuration</td>
<td>STRING The configuration to use when building the app. Defaults to ‘Release’ (GYM_CONFIGURATION)</td>
</tr>
<tr>
<td>-a, –silent</td>
<td>[VALUE] Hide all information that’s not necessary while building (GYM_SILENT)</td>
</tr>
<tr>
<td>-i, –codesigning_identity</td>
<td>STRING The name of the code signing identity to use. It has to match the name exactly. e.g. ‘iPhone Distribution: SunApps GmbH’ (GYM_CODE_SIGNING_IDENTITY)</td>
</tr>
<tr>
<td>–skip_package_ipa</td>
<td>[VALUE] Should we skip packaging the ipa? (GYM_SKIP_PACKAGE_IPA)</td>
</tr>
<tr>
<td>-m, –include_symbols</td>
<td>[VALUE] Should the ipa file include symbols? (GYM_INCLUDE_SYMBOLS)</td>
</tr>
<tr>
<td>-z, –include_bitcode</td>
<td>[VALUE] Should the ipa file include bitcode? (GYM_INCLUDE_BITCODE)</td>
</tr>
<tr>
<td>-j, –export_method</td>
<td>STRING Method used to export the archive. Valid values are: app-store, ad-hoc, package, enterprise, development, developer-id (GYM_EXPORT_METHOD)</td>
</tr>
<tr>
<td>–export_options</td>
<td>[VALUE] Specifies path to export options plist. Use ‘xcodebuild -help’ to print the full set of available options (GYM_EXPORT_OPTIONS)</td>
</tr>
<tr>
<td>–export_xcargs</td>
<td>STRING Pass additional arguments to xcodebuild for the package phase. Be sure to quote the setting names and values e.g. OTHER_LDFLAGS=”-ObjC -lstdc++” (GYM_EXPORT_XCARGS)</td>
</tr>
<tr>
<td>–skip_build_archive</td>
<td>[VALUE] Export ipa from previously built xarchive. Uses archive_path as source (GYM_SKIP_BUILD_ARCHIVE)</td>
</tr>
<tr>
<td>–build_path</td>
<td>STRING  The directory in which the archive should be stored in (GYM_BUILD_PATH)</td>
</tr>
<tr>
<td>-b, –archive_path</td>
<td>STRING The path to the created archive (GYM_ARCHIVE_PATH)</td>
</tr>
<tr>
<td>-f, –derived_data_path</td>
<td>STRING The directory where built products and other derived data will go (GYM_DERIVED_DATA_PATH)</td>
</tr>
<tr>
<td>-u, –result_bundle</td>
<td>[VALUE] Location of the Xcode result bundle (GYM_RESULT_BUNDLE)</td>
</tr>
<tr>
<td>-l, –buildlog_path</td>
<td>STRING The directory where to store the build log (GYM_BUILDLOG_PATH)</td>
</tr>
<tr>
<td>-k, –sdk STRING</td>
<td>The SDK that should be used for building the application (GYM_SDK)</td>
</tr>
<tr>
<td>–toolchain</td>
<td>[VALUE]  The toolchain that should be used for building the application (e.g. com.apple.dt.toolchain.Swift_2_3, org.swift.30p620160816a) (GYM_TOOLCHAIN)</td>
</tr>
<tr>
<td>-d, –destination</td>
<td>STRING Use a custom destination for building the app (GYM_DESTINATION)</td>
</tr>
<tr>
<td>-g, –export_team_id</td>
<td>STRING Optional: Sometimes you need to specify a team id when exporting the ipa file (GYM_EXPORT_TEAM_ID)</td>
</tr>
<tr>
<td>-x, –xcargs</td>
<td>STRING  Pass additional arguments to xcodebuild for the build phase. Be sure to quote the setting names and values e.g. OTHER_LDFLAGS=”-ObjC -lstdc++” (GYM_XCARGS)</td>
</tr>
<tr>
<td>-y, –xcconfig</td>
<td>STRING Use an extra XCCONFIG file to build your app (GYM_XCCONFIG)</td>
</tr>
<tr>
<td>-r, –suppress_xcode_output</td>
<td>[VALUE] Suppress the output of xcodebuild to stdout. Output is still saved in buildlog_path (SUPPRESS_OUTPUT)</td>
</tr>
<tr>
<td>–disable_xcpretty</td>
<td>[VALUE] Disable xcpretty formatting of build output (DISABLE_XCPRETTY)</td>
</tr>
<tr>
<td>–xcpretty_test_format</td>
<td>[VALUE] Use the test (RSpec style) format for build output (XCPRETTY_TEST_FORMAT)</td>
</tr>
<tr>
<td>–xcpretty_formatter</td>
<td>STRING A custom xcpretty formatter to use (XCPRETTY_FORMATTER)</td>
</tr>
<tr>
<td>–xcpretty_report_junit</td>
<td>STRING Have xcpretty create a JUnit-style XML report at the provided path (XCPRETTY_REPORT_JUNIT)</td>
</tr>
<tr>
<td>–xcpretty_report_html</td>
<td>STRING Have xcpretty create a simple HTML report at the provided path (XCPRETTY_REPORT_HTML)</td>
</tr>
<tr>
<td>–xcpretty_report_json</td>
<td>STRING Have xcpretty create a JSON compilation database at the provided path (XCPRETTY_REPORT_JSON)</td>
</tr>
<tr>
<td>–analyze_build_time</td>
<td>[VALUE] Analyze the project build time and store the output in ‘culprits.txt’ file (GYM_ANALYZE_BUILD_TIME)</td>
</tr>
<tr>
<td>–xcpretty_utf</td>
<td>[VALUE] Have xcpretty us</td>
</tr>
</tbody></table>
<p>至此打包基本完成！！！</p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="http://www.bijishequ.com/detail/434702?p=">自动化工具Fastlane笔记三: snapshot自动截图基础+示例</a><br><a href="https://stackoverflow.com/questions/32044603/xcode-7-ui-debugging-recording-no-buildable-for-testable/33384426#33384426">无法录制</a><br><a href="https://tyrad.cc/archives/93.html">fastlane - snapshot 自动截图</a><br><a href="https://whlsxl.github.io/fastlane1/">小团队的自动化发布－Fastlane带来的全自动化发布</a><br><a href="http://www.devzhang.cn/2017/07/17/fastLane%E5%85%A5%E9%97%A8%E4%B9%8Bsnapshot/">fastlane入门之snapshot</a><br><a href="https://zhuanlan.zhihu.com/p/20739972">fastlane 之截图自动化</a><br><a href="https://tyrad.cc/archive.html">fastlane</a></p>
]]></content>
      <categories>
        <category>自动打包</category>
      </categories>
      <tags>
        <tag>Fastlane,截图,签名,自动打包</tag>
      </tags>
  </entry>
  <entry>
    <title>Xcode之断点调试</title>
    <url>/2020/07/25/howtousexcodebreakpoint/</url>
    <content><![CDATA[<p>Xcode这个开发工具的使用相信每一个iOS开发者都已经可以熟练使用，但是要说到所有功能都详细了解，想必人数不多，这篇文章主要介绍xcode的断点调试功能。</p>
<a id="more"></a>

<p>##简介</p>
<h3 id="Xcode断点调试"><a href="#Xcode断点调试" class="headerlink" title="Xcode断点调试"></a>Xcode断点调试</h3><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh3oilaohxj30ve0jmtbt.jpg"></p>
<p>上图是我们使用Xcode进行断点调试时，上图底部图标从左到右功能分别如下：</p>
<ul>
<li>启用/禁用断点（点击后变灰色，所有断点失效；再点击变蓝色，所有断点生效）</li>
<li>继续执行程序（点击后跳过本次断点，继续执行程序）</li>
<li>执行下一步（点击后执行第23行代码）</li>
<li>进入方法（点击后进入-testLog方法）</li>
<li>跳出方法（在-testLog方法内部点击后回到第22行代码）</li>
</ul>
<p>除了这些功能，我们还可以编辑断点，在断点出右键选择<code>Edit BreakPoint</code></p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh3oq80owkj30qg09itkn.jpg"></p>
<p>下面我们来分别介绍下这几个选项以及如何设置这些选项:</p>
<h4 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h4><p><code>Condition</code>表示断点条件。开发者可以在<code>Condition</code>输入框中设置触发断点的条件。比如上面for循环的例子我们可以在<code>Condition</code>条件中添加条件</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh3ovyntb5j31600e0h1s.jpg"></p>
<p>这样我们的断点只有在<code>index==5</code>时才会被触发,这样就有利于我们在某些for循环时只有在满足某个条件时才触发断点。</p>
<h4 id="Ignore"><a href="#Ignore" class="headerlink" title="Ignore"></a>Ignore</h4><p><code>Ignore</code>为忽略次数,同样我们在上面for循环的例子中可以将<code>Ignore</code>设置为5，那么断点第一次触发时index=6时。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh3p5pghn0j30va0dk40p.jpg"></p>
<h4 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h4><p>Action为触发动作。Action可以添加多条，在触发断点后，会紧接着执行设定的Actions。Action有6种执行类型，其中较常用的有Debugger Command和Log message。</p>
<h5 id="Debugger-Command"><a href="#Debugger-Command" class="headerlink" title="Debugger Command"></a>Debugger Command</h5><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gh3pxix809j315m0jgqp9.jpg"></p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gh3q07f1x0j31740ou1kx.jpg"></p>
<h5 id="Log-Message"><a href="#Log-Message" class="headerlink" title="Log Message"></a>Log Message</h5><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gh3q601k8qj319s0latzt.jpg"></p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gh3qbe3athj316s0le7uf.jpg"></p>
<p>当然log的信息还可以读出来</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gh3qdqls9pj30qg0g0wym.jpg"></p>
<p>试一下吧，有惊喜！！！</p>
<h4 id="Options"><a href="#Options" class="headerlink" title="Options"></a>Options</h4><p><code>Options</code>控制在执行断点对应的<code>Actions</code>后是否自动继续执行程序。勾选后<code>Options</code>后，断点被触发后不进入<code>Debug</code>界面。</p>
<p>接下来看下断点的正题</p>
<h2 id="断点"><a href="#断点" class="headerlink" title="断点"></a>断点</h2><h3 id="断点类型"><a href="#断点类型" class="headerlink" title="断点类型"></a>断点类型</h3><p>我们在Xocde中添加断点时有几种类型的断点：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gh3ql0796sj30gk0ree17.jpg"></p>
<p>下面我们来介绍下我们常用的集中类型的断点：</p>
<h4 id="Exception-Breakpoint（异常断点）"><a href="#Exception-Breakpoint（异常断点）" class="headerlink" title="Exception Breakpoint（异常断点）"></a>Exception Breakpoint（异常断点）</h4><p>当我们添加了一个<code>Exception BreakPoint </code>时，实际上是添加了一个全局断点</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh45yjnc3vj30na0a012t.jpg"></p>
<p>正常情况下我们的代码崩溃后，如果没有全局断点 代码会崩溃在main函数中，但是我们如果添加了全局断点，代码发生崩溃时，就会自动崩溃到出现问题的哪一行代码，比较方便我们去定位问题。</p>
<h4 id="Symbolic-Breakpoint-符号断点"><a href="#Symbolic-Breakpoint-符号断点" class="headerlink" title="Symbolic Breakpoint (符号断点)"></a>Symbolic Breakpoint (符号断点)</h4><p>当我们添加一个符号断点时，会自动为我们弹出自定义面板，</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh46crks7lj310a0fohaa.jpg"></p>
<p>与普通断点相比，符号断点的编辑界面多出来Symbol和Module两个输入框。下面我们来看下这两个输入框的作用。</p>
<h5 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h5><p>可以在Symbol输入框中设置断点出发方法/函数。在Symbol中设置一个方法/函数后，运行程序并执行到此方法时会触发断点。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gh4nyg02l0j31k00oob0j.jpg"></p>
<p>如果是C语言方法那么直接使用方法名就可以</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gh4o13mn2vj31ka0pq4qh.jpg"></p>
<h5 id="Module"><a href="#Module" class="headerlink" title="Module"></a>Module</h5><p>可以在Module输入框中设置Symbol中的函数所在的库，以避免不同库中存在名字相同的方法/函数，默认不用填写。</p>
<h5 id="Condition-1"><a href="#Condition-1" class="headerlink" title="Condition"></a>Condition</h5><p>与普通断点的用法基本一致<br>在Condition输入框中设置<code>$arg3==nil</code>，就会限制断点在满足第一个参数和第二个参数都为nil时才会被触发。但是实际上使用下面这种写法才可以<br><code>[(NSString *)$arg3 length] == 0</code></p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh4orcbwjxj31790u01kx.jpg"></p>
<p>这里我们可以用来判断某个方法再被调用时，哪里的参数传递是有问题的。</p>
<h4 id="Watch-Breakpoint-监控断点"><a href="#Watch-Breakpoint-监控断点" class="headerlink" title="Watch Breakpoint(监控断点)"></a>Watch Breakpoint(监控断点)</h4><p>有时候我们需要监听某个变量的值的变化</p>
<p>添加断点<br><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh4rzvcuwcj31c30u0tff.jpg"><br>断点结果<br><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh4s00sz7jj30tm0t4k1g.jpg"></p>
<p>很可惜没有发现监听数组个数变化的断点</p>
<h3 id="断点的应用"><a href="#断点的应用" class="headerlink" title="断点的应用"></a>断点的应用</h3><h4 id="查看UI控件约束冲突"><a href="#查看UI控件约束冲突" class="headerlink" title="查看UI控件约束冲突"></a>查看UI控件约束冲突</h4><p>我们先看下下面这段代码:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)addVCSubView &#123;</span><br><span class="line">    <span class="built_in">UIView</span> *contentView = [[<span class="built_in">UIView</span> alloc] init];</span><br><span class="line">    contentView.backgroundColor = [<span class="built_in">UIColor</span> blueColor];</span><br><span class="line">    [<span class="keyword">self</span>.view addSubview:contentView];</span><br><span class="line">    [contentView mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">        make.center.equalTo(<span class="keyword">self</span>.view);</span><br><span class="line">        make.width.height.equalTo(@<span class="number">200</span>);</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">UIView</span> *view = [[<span class="built_in">UIView</span> alloc] init];</span><br><span class="line">    view.backgroundColor = [<span class="built_in">UIColor</span> greenColor];</span><br><span class="line">    [contentView addSubview:view];</span><br><span class="line">    [view mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">        make.centerX.equalTo(contentView);</span><br><span class="line">        make.centerY.equalTo(contentView);</span><br><span class="line">        make.top.equalTo(contentView.mas_top).offset(<span class="number">20</span>);</span><br><span class="line">        make.width.height.equalTo(@<span class="number">100</span>);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体的展示如图:</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghc98hkth0j30jg0fe74c.jpg"></p>
<p>从图中我们可以很明显的看到绿色的子视图的宽高并不相同，同样在控制台上我们也看到了这样的输出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2020-08-02 10:16:30.755508+0800 APPLaunchTime[1629:28678] [LayoutConstraints] Unable to simultaneously satisfy constraints.</span><br><span class="line">	Probably at least one of the constraints in the following list is one you don&#39;t want. </span><br><span class="line">	Try this: </span><br><span class="line">		(1) look at each constraint and try to figure out which you don&#39;t expect; </span><br><span class="line">		(2) find the code that added the unwanted constraint or constraints and fix it. </span><br><span class="line">(</span><br><span class="line">    &quot;&lt;MASLayoutConstraint:0x600000e183c0 UIView:0x7fa513e11cc0.height &#x3D;&#x3D; 200&gt;&quot;,</span><br><span class="line">    &quot;&lt;MASLayoutConstraint:0x600000e181e0 UIView:0x7fa516604e70.centerY &#x3D;&#x3D; UIView:0x7fa513e11cc0.centerY&gt;&quot;,</span><br><span class="line">    &quot;&lt;MASLayoutConstraint:0x600000e18600 UIView:0x7fa516604e70.top &#x3D;&#x3D; UIView:0x7fa513e11cc0.top + 20&gt;&quot;,</span><br><span class="line">    &quot;&lt;MASLayoutConstraint:0x600000e186c0 UIView:0x7fa516604e70.height &#x3D;&#x3D; 100&gt;&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">Will attempt to recover by breaking constraint </span><br><span class="line">&lt;MASLayoutConstraint:0x600000e186c0 UIView:0x7fa516604e70.height &#x3D;&#x3D; 100&gt;</span><br><span class="line"></span><br><span class="line">Make a symbolic breakpoint at UIViewAlertForUnsatisfiableConstraints to catch this in the debugger.</span><br><span class="line">The methods in the UIConstraintBasedLayoutDebugging category on UIView listed in &lt;UIKitCore&#x2F;UIView.h&gt; may also be helpful.</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>控制台提示我们 下面列表中的约束其中有一个是不需要的，同时当前展示的样子是系统通过移除了哪个约束后展示出来的</p>
<h5 id="约束问题是什么"><a href="#约束问题是什么" class="headerlink" title="约束问题是什么"></a>约束问题是什么</h5><p>我们先看下控制台输出的提示</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;&lt;MASLayoutConstraint:0x600000e183c0 UIView:0x7fa513e11cc0.height &#x3D;&#x3D; 200&gt;&quot;,</span><br><span class="line">&quot;&lt;MASLayoutConstraint:0x600000e181e0 UIView:0x7fa516604e70.centerY &#x3D;&#x3D; UIView:0x7fa513e11cc0.centerY&gt;&quot;,</span><br><span class="line">&quot;&lt;MASLayoutConstraint:0x600000e18600 UIView:0x7fa516604e70.top &#x3D;&#x3D; UIView:0x7fa513e11cc0.top + 20&gt;&quot;,</span><br><span class="line">&quot;&lt;MASLayoutConstraint:0x600000e186c0 UIView:0x7fa516604e70.height &#x3D;&#x3D; 100&gt;&quot;</span><br></pre></td></tr></table></figure>

<p>上面的提示中设计到两个UIView对象，<code>0x600000e183c0</code>和<code>0x7fa513e11cc0</code>,通过查看上面的约束提示，我们发现<code>height</code>,<code>centerY</code>,<code>top</code>,<code>height</code> 这几个约束都是垂直方向的约束。</p>
<p>上面的提示还有下面这句</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">Will attempt to recover by breaking constraint </span><br><span class="line">&lt;MASLayoutConstraint:<span class="number">0x600000e186c0</span> <span class="built_in">UIView</span>:<span class="number">0x7fa516604e70</span>.height == <span class="number">100</span>&gt;</span><br></pre></td></tr></table></figure>
<p>尝试通过break高度为100的约束来正确展示这个视图，而结合我们上面展示的图片 没有生效的约束是<code>height=100</code>与上面的描述一致。</p>
<p>那通过上面的分析我们得出这次约束的问题是：</p>
<p>控件<code>0x600000e183c0</code>和<code>0x7fa516604e70</code>在垂直方向存在约束冲突，目前系统通过移除<code>UIView:0x7fa516604e70.height == 100</code>约束来展示UI，如果系统的修改与你的预期不符，可以通过修改上面提到的四个约束中的一个来展示出正确的UI。</p>
<h5 id="哪个视图约束有问题"><a href="#哪个视图约束有问题" class="headerlink" title="哪个视图约束有问题"></a>哪个视图约束有问题</h5><p>分析出约束的问题后，我们需要定位到底是哪两个视图出现了约束问题。</p>
<h6 id="通过内存地址定位"><a href="#通过内存地址定位" class="headerlink" title="通过内存地址定位"></a>通过内存地址定位</h6><p>我们可以通过查看层次结果，然后通过出现约束问题的视图的内存地址进行筛选，这样我们就能容易的定位到出现问题的视图。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghcaasl8hij31730u0hdt.jpg"></p>
<h6 id="通过lldb命令"><a href="#通过lldb命令" class="headerlink" title="通过lldb命令"></a>通过lldb命令</h6><p>我们还可以通过设置出现问题的视图的背景颜色来定位到底是哪个视图出现问题，当然是用lldb命令的前提是我们需要在合适的地方添加断点。</p>
<p>首先我们需要在项目中添加约束冲突(符号断点)断点，添加方法如下</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghcc7adgyej30qg0f8wvz.jpg"></p>
<p>添加了这个断点后，在应用启动遇到约束冲突的位置系统会，直接有约束冲突的位置设置断点，下面截取一部分发生断点时的提示</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*UIButton:0x10b091670&#39;注册&#x2F;登录&#39;- AMBIGUOUS LAYOUT for UIButton:0x10b091670&#39;注册&#x2F;登录&#39;.minY&#123;id: 159&#125;   UIButtonLabel:0x10b15fb60&#39;注册&#x2F;登录&#39;</span><br><span class="line"></span><br><span class="line"> *UILabel:0x10b08f790&#39;群组&#39;- AMBIGUOUS LAYOUT for UILabel:0x10b08f790&#39;群组&#39;.minX&#123;id: 136&#125;, UILabel:0x10b08f790&#39;群组&#39;.minY&#123;id: 138&#125;, UILabel:0x10b08f790&#39;群组&#39;.Width&#123;id: 135&#125;, UILabel:0x10b08f790&#39;群组&#39;.Height&#123;id: 140&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里我们可以通过关键词 <code>AMBIGUOUS LAYOUT</code> 来获取所有存在约束冲突的位置，因为log中有了按钮或者label的文案我们可以很快的定位到具体位置。</p>
<p>当然 如果层次非常深，或者我们无法通过文案进行区分，我们还可以通过下面的命令修改视图的背景颜色来定位出现约束冲突的视图。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">expr ((UILabel *)0x10b091670).backgroundColor &#x3D; [UIColor yellowColor];</span><br></pre></td></tr></table></figure>

<p>结果如下图：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghccdb25i4j30ku1120yj.jpg"></p>
<p>通过上面的方法我们可以定位到出现问题的视图控件，那么我们 下一步就要看如何去解决这个约束冲突。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过上面的方法我们可以准确的定位出出现约束冲突的控件是什么，约束冲突的原因是什么，那么接下来我们就需要根据自己的场景以及控制台给出的提示去判断目标的布局是什么样的，怎么去改。</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://stackoverflow.com/questions/26389273/how-to-trap-on-uiviewalertforunsatisfiableconstraints">How to trap on UIViewAlertForUnsatisfiableConstraints?</a></p>
<p><a href="https://www.jianshu.com/p/b2ab97a3b3b8">有歧义(AMBIGUOUS LAYOUT)的约束布局调试方法</a></p>
]]></content>
      <categories>
        <category>iOS进阶</category>
      </categories>
      <tags>
        <tag>Xcode,breakPoint</tag>
      </tags>
  </entry>
  <entry>
    <title>block的那些事</title>
    <url>/2018/02/27/block-something/</url>
    <content><![CDATA[<p>Blocks是C语言的扩充功能，而Apple 在OS X Snow Leopard 和 iOS 4中引入了这个新功能“Blocks”。从那开始，Block就出现在iOS和Mac系统各个API中，并被大家广泛使用。一句话来形容Blocks，带有自动变量（局部变量）的匿名函数。</p>
<a id="more"></a>

<h1 id="Block的那些事"><a href="#Block的那些事" class="headerlink" title="Block的那些事"></a>Block的那些事</h1><h2 id="Block-基础"><a href="#Block-基础" class="headerlink" title="Block 基础"></a>Block 基础</h2><h4 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Block_layout</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> *isa;  <span class="comment">//指向block的类型</span></span><br><span class="line">    <span class="keyword">int</span> flags;  <span class="comment">//附加信息</span></span><br><span class="line">    <span class="keyword">int</span> reserved;   <span class="comment">//block内部的变量数</span></span><br><span class="line">    <span class="keyword">void</span> (*invoke)(<span class="keyword">void</span> *, ...);    <span class="comment">//函数指针，指向block具体的函数调用地址</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Block_descriptor</span> *<span class="title">descriptor</span>;</span>    <span class="comment">//附加描述信息，比如变量数、大小、copy和dispose辅助操作函数指针</span></span><br><span class="line">    <span class="comment">/* Imported variables. */</span></span><br><span class="line">    <span class="comment">//复制到结构体中的外部局部变量或变量地址</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Block_descriptor</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> reserved;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">void</span> (*copy)(<span class="keyword">void</span> *dst, <span class="keyword">void</span> *src);</span><br><span class="line">    <span class="keyword">void</span> (*dispose)(<span class="keyword">void</span> *);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/1194012-1739b7e85e46b4db.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/510" alt="结构"></p>
<p>block中也存在一个isa指针,因此在OC中block也是被当做一个对象来看待的。</p>
<h4 id="Block的类型"><a href="#Block的类型" class="headerlink" title="Block的类型"></a>Block的类型</h4><h5 id="NSConcreteStackBlock"><a href="#NSConcreteStackBlock" class="headerlink" title="NSConcreteStackBlock"></a>NSConcreteStackBlock</h5><ul>
<li><p>只用到外部局部变量、成员属性变量，且没有强指针引用的block都是StackBlock。<br>StackBlock的生命周期由系统控制的，一旦返回之后，就被系统销毁了。</p>
</li>
<li><p>_NSConcreteStackBlock是不持有对象的。</p>
</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以下是在MRC下执行的</span></span><br><span class="line">    <span class="built_in">NSObject</span> * obj = [[<span class="built_in">NSObject</span> alloc]init];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;1.Block外 obj = %lu&quot;</span>,(<span class="keyword">unsigned</span> <span class="keyword">long</span>)obj.retainCount);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> (^myBlock)(<span class="keyword">void</span>) = ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;Block中 obj = %lu&quot;</span>,(<span class="keyword">unsigned</span> <span class="keyword">long</span>)obj.retainCount);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;2.Block外 obj = %lu&quot;</span>,(<span class="keyword">unsigned</span> <span class="keyword">long</span>)obj.retainCount);</span><br><span class="line">    </span><br><span class="line">    myBlock();</span><br></pre></td></tr></table></figure>

<p>打印结果:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.Block外 obj &#x3D; 1</span><br><span class="line">2.Block外 obj &#x3D; 1</span><br><span class="line">Block中 obj &#x3D; 1</span><br></pre></td></tr></table></figure>

<p>由于_NSConcreteStackBlock所属的变量域一旦结束，那么该Block就会被销毁。<br>因此,在ARC环境下，编译器会自动的判断，把Block自动的从栈copy到堆。</p>
<p>下面四种情况下会将block从栈自动copy到堆上:</p>
<ul>
<li>1.手动调用copy</li>
<li>2.Block是函数的返回值</li>
<li>3.Block被强引用，Block被赋值给__strong或者id类型</li>
<li>4.调用系统API入参中含有usingBlcok的方法</li>
</ul>
<p><code>注意</code>:copy方法可以将block从栈上copy到堆上,dispose方法可以将堆上的block销毁。</p>
<h5 id="NSConcreteMallocBlock"><a href="#NSConcreteMallocBlock" class="headerlink" title="NSConcreteMallocBlock"></a>NSConcreteMallocBlock</h5><ul>
<li><p>有强指针引用或copy修饰的成员属性引用的block会被复制一份到堆中成为MallocBlock，没有强指针引用即销毁，生命周期由程序员控制</p>
</li>
<li><p>_NSConcreteMallocBlock是持有对象的。</p>
</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以下是在MRC下执行的</span></span><br><span class="line"><span class="built_in">NSObject</span> * obj = [[<span class="built_in">NSObject</span> alloc]init];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;1.Block外 obj = %lu&quot;</span>,(<span class="keyword">unsigned</span> <span class="keyword">long</span>)obj.retainCount);</span><br><span class="line">    </span><br><span class="line"><span class="keyword">void</span> (^myBlock)(<span class="keyword">void</span>) = [^&#123;</span><br><span class="line">   <span class="built_in">NSLog</span>(<span class="string">@&quot;Block中 obj = %lu&quot;</span>,(<span class="keyword">unsigned</span> <span class="keyword">long</span>)obj.retainCount);</span><br><span class="line">&#125;<span class="keyword">copy</span>];</span><br><span class="line">    </span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;2.Block外 obj = %lu&quot;</span>,(<span class="keyword">unsigned</span> <span class="keyword">long</span>)obj.retainCount);</span><br><span class="line">    </span><br><span class="line">myBlock();</span><br><span class="line">    </span><br><span class="line">[myBlock release];</span><br><span class="line">    </span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;3.Block外 obj = %lu&quot;</span>,(<span class="keyword">unsigned</span> <span class="keyword">long</span>)obj.retainCount);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>打印结果:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>Block外 obj = <span class="number">1</span></span><br><span class="line"><span class="number">2.</span>Block外 obj = <span class="number">2</span></span><br><span class="line">Block中 obj = <span class="number">2</span></span><br><span class="line"><span class="number">3.</span>Block外 obj = <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h5 id="NSConcreteGlobalBlock"><a href="#NSConcreteGlobalBlock" class="headerlink" title="NSConcreteGlobalBlock"></a>NSConcreteGlobalBlock</h5><ul>
<li><p>没有用到外界变量或只用到全局变量、静态变量的block为_NSConcreteGlobalBlock，生命周期从创建到应用程序结束。</p>
</li>
<li><p>_NSConcreteGlobalBlock也不持有对象</p>
</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以下是在MRC下执行的</span></span><br><span class="line"><span class="keyword">void</span> (^myBlock)(<span class="keyword">void</span>) = ^&#123;</span><br><span class="line">   </span><br><span class="line">   <span class="built_in">NSObject</span> * obj = [[<span class="built_in">NSObject</span> alloc]init];</span><br><span class="line">   <span class="built_in">NSLog</span>(<span class="string">@&quot;Block中 obj = %lu&quot;</span>,(<span class="keyword">unsigned</span> <span class="keyword">long</span>)obj.retainCount);</span><br><span class="line">&#125;;</span><br><span class="line">    </span><br><span class="line">myBlock();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>打印结果:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Block 中 obj = <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h5 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">-(<span class="keyword">void</span>)method &#123; </span><br><span class="line"><span class="comment">//在ARC环境下，Block也是存在__NSStackBlock的时候的，平时见到最多的是_NSConcreteMallocBlock，是因为我们会对Block有赋值操作，所以ARC下，block 类型通过=进行传递时，会导致调用objc_retainBlock-&gt;_Block_copy-&gt;_Block_copy_internal方法链。并导致 __NSStackBlock__ 类型的 block 转换为 __NSMallocBlock__ 类型。</span></span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">void</span>(^block)() = ^&#123;</span><br><span class="line">      NSLog(@<span class="string">&quot;调用block%d&quot;</span>,a);<span class="comment">//这里的变量a，和self.string是一样效果</span></span><br><span class="line">  &#125;;</span><br><span class="line">  NSLog(@<span class="string">&quot;%@&quot;</span>,block);</span><br><span class="line"><span class="comment">//打印结果:&lt;__NSMallocBlock__: 0x7fc498746000&gt;</span></span><br><span class="line"><span class="comment">//此时后面的匿名函数赋值给block指针（创建带名字的block），且引用了外部局部变量,block会copy到堆</span></span><br><span class="line"></span><br><span class="line">NSLog(@<span class="string">&quot;%@&quot;</span>,^&#123;NSLog(@<span class="string">&quot;调用block%d&quot;</span>,a);&#125;);</span><br><span class="line"><span class="comment">//打印结果:&lt;__NSStackBlock__: 0x7fff54f0c700&gt;</span></span><br><span class="line"><span class="comment">//匿名函数无赋值操作，只存于栈上，会不定释放</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span>(^block)() = ^&#123;</span><br><span class="line">      NSLog(@<span class="string">&quot;调用block%d&quot;</span>,b);<span class="comment">//若不引用任何变量，也是__NSGloBalBlock__</span></span><br><span class="line">&#125;;</span><br><span class="line">  NSLog(@<span class="string">&quot;%@&quot;</span>,block);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//打印结果:&lt;__NSGloBalBlock__: 0x7fc498746000&gt;</span></span><br><span class="line"><span class="comment">//此时引用了全局变量,block放在全局区</span></span><br></pre></td></tr></table></figure>

<h2 id="Block与循环引用"><a href="#Block与循环引用" class="headerlink" title="Block与循环引用"></a>Block与循环引用</h2><p>什么情况下会出现循环引用呢？</p>
<h3 id="单向引用"><a href="#单向引用" class="headerlink" title="单向引用"></a>单向引用</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> (^block1)() = ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>,<span class="keyword">self</span>.view);</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>
<p>很明显这里是不会出现循环引用的。block虽然强引用了self但是self并没有强引用block</p>
<h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">[<span class="built_in">UIView</span> animateWithDuration:<span class="number">1</span> animations:^&#123;</span><br><span class="line">   <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>,<span class="keyword">self</span>.view);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<p>这样也不会产生循环引用,因为这是一个类方法,self没办法强引用一个类。</p>
<h3 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">self</span>.testBlock = ^(<span class="built_in">NSString</span> *text) &#123;</span><br><span class="line">   <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>,<span class="keyword">self</span>.view);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里是 self强引用了testblock 同时在block中也强引用了self。因此这回导致循环引用。</p>
<p>类似的还有:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">self</span>.testBlock = ^(<span class="built_in">NSString</span> *text) &#123;</span><br><span class="line">   <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>,_arr);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>即使没有出现self的字眼,这种情况下依然会发生循环引用。</p>
<p>正常情况下,如果出现明显的循环引用,编译器是会给我们提示的</p>
<p><img src="http://og0h689k8.bkt.clouddn.com/18-5-12/59352221.jpg"></p>
<h3 id="block参数"><a href="#block参数" class="headerlink" title="block参数"></a>block参数</h3><h4 id="纯粹的参数"><a href="#纯粹的参数" class="headerlink" title="纯粹的参数"></a>纯粹的参数</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">[<span class="keyword">self</span> doSomthing1:^&#123;</span><br><span class="line">   <span class="built_in">NSLog</span>(<span class="string">@&quot;str111:%@&quot;</span>,<span class="keyword">self</span>.str);</span><br><span class="line">&#125;];</span><br><span class="line">    </span><br><span class="line">[<span class="keyword">self</span> doSomthing2:^(<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123;</span><br><span class="line">   <span class="built_in">NSLog</span>(<span class="string">@&quot;str111:%@&quot;</span>,<span class="keyword">self</span>.str);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)doSomthing1:(<span class="keyword">void</span>(^)())block&#123;</span><br><span class="line"><span class="keyword">if</span>(block)&#123;</span><br><span class="line">   block();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)doSomthing2:(<span class="keyword">void</span> (^)(<span class="keyword">int</span> a, <span class="keyword">int</span> b))block&#123;</span><br><span class="line">    <span class="keyword">if</span>(block)&#123;</span><br><span class="line">        block(<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于上面的这两种情况,block其实都是作为参数,虽然block中持有了self但是self并没有持有block。因此这里不会产生循环引用的问题。</p>
<h4 id="参数被引用"><a href="#参数被引用" class="headerlink" title="参数被引用"></a>参数被引用</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">[<span class="keyword">self</span> doSomthing3:^(<span class="built_in">NSString</span> *text) &#123;</span><br><span class="line">   <span class="built_in">NSLog</span>(<span class="string">@&quot;str111:%@&quot;</span>,<span class="keyword">self</span>.str);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)doSomthing3:(Block)block&#123;</span><br><span class="line">    <span class="keyword">if</span>(block)&#123;</span><br><span class="line">        <span class="keyword">self</span>.testBlock = block;</span><br><span class="line">        block(<span class="string">@&quot;111&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>doSomthing3</code>方法中,self对block进行了强引用,这里就会造成循环引用。这种循环引用也称为间接的循环引用,而且这种循环引用编译器是无法提示的。所以,在日常工作中不太容易被发现。</p>
<h4 id="系统自带的block"><a href="#系统自带的block" class="headerlink" title="系统自带的block"></a>系统自带的block</h4><p>有时候我们会有一种错觉,系统自带的一些block中使用self不会产生循环引用。</p>
<p>很可惜,这的确是错觉！</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">[[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserverForName:<span class="string">@&quot;testblock&quot;</span> object:<span class="literal">nil</span> queue:<span class="literal">nil</span> usingBlock:^(<span class="built_in">NSNotification</span> * _Nonnull note) &#123;</span><br><span class="line">   <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>,<span class="keyword">self</span>.view);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<p>编译器不会提示有循环引用,但是的的确确这里会产生循环引用。所以还是老老实实的使用weakself,千万不要有这种错觉！</p>
<h3 id="AFN中的循环引用"><a href="#AFN中的循环引用" class="headerlink" title="AFN中的循环引用"></a>AFN中的循环引用</h3><p>我们在使用AFN进行网络请求的时候,实际上不需要关注网络回调中可能出现的循环引用,这是因为在AFN的内部做了处理。切断了循环引用链。</p>
<p>那么 我们是否就可以彻底的相信了AFN的处理而不需要自己做处理了呢？</p>
<p>看看下面的例子:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)afnBlock</span><br><span class="line">&#123;</span><br><span class="line">    AFHTTPSessionManager *mgr = [AFHTTPSessionManager manager];</span><br><span class="line">    mgr.responseSerializer = [AFHTTPResponseSerializer serializer];</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2.1 创建请求对象</span></span><br><span class="line">    <span class="built_in">NSURLRequest</span> *request = [<span class="built_in">NSURLRequest</span> requestWithURL:[<span class="built_in">NSURL</span> URLWithString:<span class="string">@&quot;https://meishubao-static.oss-cn-hangzhou.aliyuncs.com/logs/2018-05/09/121214/bba24fa9ed53970478cdbf640d69620a.zip&quot;</span>]];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSURLSessionDownloadTask</span> *downloadTask = [mgr downloadTaskWithRequest:request progress:^(<span class="built_in">NSProgress</span> * _Nonnull downloadProgress) &#123;<span class="comment">//进度</span></span><br><span class="line">        </span><br><span class="line">    &#125; destination:^<span class="built_in">NSURL</span> * _Nonnull(<span class="built_in">NSURL</span> * _Nonnull targetPath, <span class="built_in">NSURLResponse</span> * _Nonnull response) &#123;</span><br><span class="line">        <span class="built_in">NSString</span> *caches = [<span class="built_in">NSSearchPathForDirectoriesInDomains</span>(<span class="built_in">NSCachesDirectory</span>, <span class="built_in">NSUserDomainMask</span>, <span class="literal">YES</span>) lastObject];</span><br><span class="line">        <span class="comment">//拼接文件全路径</span></span><br><span class="line">        <span class="built_in">NSString</span> *fullpath = [caches stringByAppendingPathComponent:response.suggestedFilename];</span><br><span class="line">        <span class="built_in">NSURL</span> *filePathUrl = [<span class="built_in">NSURL</span> fileURLWithPath:fullpath];</span><br><span class="line">        sleep(<span class="number">20</span>);</span><br><span class="line">        <span class="keyword">return</span> filePathUrl;</span><br><span class="line">        </span><br><span class="line">    &#125; completionHandler:^(<span class="built_in">NSURLResponse</span> * _Nonnull response, <span class="built_in">NSURL</span> * _Nonnull filePath, <span class="built_in">NSError</span> * _Nonnull error) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>,<span class="keyword">self</span>.str);</span><br><span class="line">  </span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3.启动任务</span></span><br><span class="line">    [downloadTask resume];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正常情况下,在网络请求的回调中强引用了self,但是self并没有强引用这个网络请求。因此这里不会形成循环引用。</p>
<p>如果self强引用了网络请求(request)且request的回调中也强引用了self是否会造成循环引用呢？</p>
<p>正常情况,这是很明显的循环引用。但是实际上这并不会造成循环引用。因此 AFN肯定在内部做了一些事情。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableDictionary</span> *mutableTaskDelegatesKeyedByTaskIdentifier;</span><br></pre></td></tr></table></figure>

<p>我们关注一下AFN的这个属性,其作用是用来保存当前正在进行的所有请求。</p>
<p>开始请求的时候:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">self</span>.mutableTaskDelegatesKeyedByTaskIdentifier[@(task.taskIdentifier)] = delegate;</span><br></pre></td></tr></table></figure>
<p>将delegate与task进行绑定。</p>
<p>网络请求结束的时候:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)removeDelegateForTask:(<span class="built_in">NSURLSessionTask</span> *)task &#123;</span><br><span class="line">    <span class="built_in">NSParameterAssert</span>(task);</span><br><span class="line"></span><br><span class="line">    [<span class="keyword">self</span>.lock lock];</span><br><span class="line">    [<span class="keyword">self</span> removeNotificationObserverForTask:task];</span><br><span class="line">    [<span class="keyword">self</span>.mutableTaskDelegatesKeyedByTaskIdentifier removeObjectForKey:@(task.taskIdentifier)];</span><br><span class="line">    [<span class="keyword">self</span>.lock unlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解除task和delegate的绑定。</p>
<p>尝试一下把下面这句话注释掉:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[self.mutableTaskDelegatesKeyedByTaskIdentifier removeObjectForKey:@(task.taskIdentifier)];</span><br></pre></td></tr></table></figure>

<p>你会惊奇的发现,<code>这个网络请求导致了当前进行网络请求的控制器无法被释放!!! </code></p>
<p>所以,AFN中可以大胆使用self而不用考虑循环引用都是因为这一句。在网络请求成功之后 手动的将self与block与self的引用关系切断。</p>
<p>当然正常情况下,控制器不会持有这个请求。那么是否就表示正常情况下,我们使用AFN的时候完全不用考虑循环应用的情况了呢？</p>
<p>答案是否定的！</p>
<p>来看看这段代码:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">self</span>.task = [mgr downloadTaskWithRequest:<span class="keyword">self</span>.request progress:^(<span class="built_in">NSProgress</span> * _Nonnull downloadProgress) &#123;<span class="comment">//进度</span></span><br><span class="line">        </span><br><span class="line">    &#125; destination:^<span class="built_in">NSURL</span> * _Nonnull(<span class="built_in">NSURL</span> * _Nonnull targetPath, <span class="built_in">NSURLResponse</span> * _Nonnull response) &#123;</span><br><span class="line">        <span class="built_in">NSString</span> *caches = [<span class="built_in">NSSearchPathForDirectoriesInDomains</span>(<span class="built_in">NSCachesDirectory</span>, <span class="built_in">NSUserDomainMask</span>, <span class="literal">YES</span>) lastObject];</span><br><span class="line">        <span class="comment">//拼接文件全路径</span></span><br><span class="line">        <span class="built_in">NSString</span> *fullpath = [caches stringByAppendingPathComponent:response.suggestedFilename];</span><br><span class="line">        <span class="built_in">NSURL</span> *filePathUrl = [<span class="built_in">NSURL</span> fileURLWithPath:fullpath];</span><br><span class="line">        sleep(<span class="number">20</span>);</span><br><span class="line">        <span class="keyword">return</span> filePathUrl;</span><br><span class="line">        </span><br><span class="line">    &#125; completionHandler:^(<span class="built_in">NSURLResponse</span> * _Nonnull response, <span class="built_in">NSURL</span> * _Nonnull filePath, <span class="built_in">NSError</span> * _Nonnull error) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>,<span class="keyword">self</span>.str);</span><br><span class="line">  </span><br><span class="line">    &#125;];</span><br></pre></td></tr></table></figure>

<p>其实与上面的网络请求唯一的区别是多了一个:</p>
<p><code>sleep(20);</code> </p>
<p>我们用sleep方法模拟一个特别慢的网络请求。当网络请求开始之后，用户在等待一段时间之后发现网络请求还没有成功,于是退出了当前的页面。</p>
<p>这个时候网络请求没有成功,因此上面我们提到的那个关键的那句话还没有走。这也就导致了这个控制器无法被释放！ 因此AFN的这个处理也不是绝对安全的。</p>
<p>为了可以让这个控制器完全释放,我们还是老老实实的使用<code>weakself</code>。</p>
<h3 id="Masonry中的block"><a href="#Masonry中的block" class="headerlink" title="Masonry中的block"></a>Masonry中的block</h3><p>我们先看一下代码</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)masonryBlock</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span>.lab = [[<span class="built_in">UILabel</span> alloc] init];</span><br><span class="line">    <span class="keyword">self</span>.lab.textColor = [<span class="built_in">UIColor</span> redColor];</span><br><span class="line">    <span class="keyword">self</span>.lab.text = <span class="string">@&quot;测试&quot;</span>;</span><br><span class="line">    [<span class="keyword">self</span>.view addSubview:<span class="keyword">self</span>.lab];</span><br><span class="line">    [<span class="keyword">self</span>.lab mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">        make.centerX.equalTo(<span class="keyword">self</span>.view.mas_centerX);</span><br><span class="line">        make.centerY.equalTo(<span class="keyword">self</span>.view.mas_centerY);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们都知道循环引用的条件是互相持有,很明显block持有了self那么我们看一下self是否持有block就可以了,我们看一下下面的代码</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">NSArray</span> *)mas_makeConstraints:(<span class="keyword">void</span>(^)(MASConstraintMaker *))block &#123;</span><br><span class="line">    <span class="keyword">self</span>.translatesAutoresizingMaskIntoConstraints = <span class="literal">NO</span>;</span><br><span class="line">    MASConstraintMaker *constraintMaker = [[MASConstraintMaker alloc] initWithView:<span class="keyword">self</span>];</span><br><span class="line">    block(constraintMaker);</span><br><span class="line">    <span class="keyword">return</span> [constraintMaker install];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是view的分类,相当于方法调用中的<code>self.lab</code>。上面的代码我们可以看出self并没有持有block。所以这里绝对不会产生循环引用的问题。</p>
<h3 id="block循环引用-可用之处"><a href="#block循环引用-可用之处" class="headerlink" title="block循环引用 可用之处"></a>block循环引用 可用之处</h3><p>在我们使用block的场景中有这样一种场景,为了避免循环引用,我们需要在block中使用weakself,但是我们又希望我们的block被保证可以执行(如果self被释放block中的内容可能无法执行或者部分被执行)。</p>
<p>比如你有一个后台的任务，希望任务执行完后，通知另外一个实例。</p>
<p>我们该怎么做？</p>
<p>这时候 我们可以构造一个循环引用,然后在手动切断这个循环引用</p>
<p>这里我们有两种做法：</p>
<p>第一种: 参考AFN</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">__<span class="keyword">weak</span> __<span class="keyword">typeof</span>(<span class="keyword">self</span>)weakSelf = <span class="keyword">self</span>;</span><br><span class="line">AFNetworkReachabilityStatusBlock callback = ^(AFNetworkReachabilityStatus status) &#123;</span><br><span class="line">    __<span class="keyword">strong</span> __<span class="keyword">typeof</span>(weakSelf)strongSelf = weakSelf;</span><br><span class="line"></span><br><span class="line">    strongSelf.networkReachabilityStatus = status;</span><br><span class="line">    <span class="keyword">if</span> (strongSelf.networkReachabilityStatusBlock) &#123;</span><br><span class="line">        strongSelf.networkReachabilityStatusBlock(status);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在block内部添加一个对self的强引用,这样就会产生循环应用,这样就可以保证block的内容一定会完整的被执行(如果self被销毁了有可能block被释放了压根不会被执行)。在block执行完成之后 因为strongSelf是一个局部变量在执行完之后会就置为nil,因此循环引用链也会被断开。</p>
<p>第二种: 参考猿题库</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  YTKBaseRequest.m</span></span><br><span class="line">- (<span class="keyword">void</span>)clearCompletionBlock &#123;</span><br><span class="line">    <span class="comment">// nil out to break the retain cycle.</span></span><br><span class="line">    <span class="keyword">self</span>.successCompletionBlock = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">self</span>.failureCompletionBlock = <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为block强引用了self,那么如果我们在网络请求结束之后将block置为nil,来破坏到循环引用链那么也可以达到这个效果。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本篇文章总结了在平时工作中常用block相关的基础,后面会在写一篇进阶,主要介绍__block这个关键字。可以在<a href="http://www.leewong.cn/2018/04/25/what-did-block-do/#more">这里</a>看哦！</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul>
<li>1、<a href="https://bestswifter.com/strong-weak-dance/">对 Strong-Weak Dance 的思考</a></li>
<li>2、<a href="https://mp.weixin.qq.com/s?__biz=MjM5NTIyNTUyMQ==&mid=562061603&idx=1&sn=bd19562add018ab521a4581b1c2fba2d&scene=19#wechat_redirect">唐巧公众号文章</a></li>
<li>3、<a href="http://yolynn.com/2016/11/01/block/">block基础到进阶</a></li>
<li>4、<a href="https://www.jianshu.com/p/fc2f4d207d25">实际开发中-Block导致循环引用的问题</a></li>
<li>5、<a href="https://blog.csdn.net/DonnyDN/article/details/77750751">iOS中Block使用注意点及常见问题浅析</a></li>
</ul>
]]></content>
      <categories>
        <category>iOS基础</category>
      </categories>
      <tags>
        <tag>Block 循环引用 内存管理 引用计数</tag>
      </tags>
  </entry>
  <entry>
    <title>大数组的排序</title>
    <url>/2018/05/04/huge-array-sort/</url>
    <content><![CDATA[<p>之前有一个同事问我,如何对一个非常大的数组进行排序,最开始的思路是:化整为零 合并排序。但实际上具体的一些细节还是有待商榷,因此 这里写一篇文章来具体来总结一下。</p>
<a id="more"></a>

<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>假如一个数组中有1亿个数字,那么要对这个数组从小到大进行排序,我们该如何操作！</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>其实对于这种数据量比较大的问题,思路基本上都是一致的:</p>
<ul>
<li>首先,化整为零,对于那么大的一个数据,我们肯定不能直接对其进行操作,而是采用<code>某种方式</code>将这个数组划分成多个比较小的数组;</li>
<li>然后,我们在对这些比较小的数组采用<code>某种方式</code>进行排序;</li>
<li>最后,我们将所有排好序的数组采用<code>某种方式</code>合并到一个数组中。</li>
</ul>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>从上面的思路可以看出 要完成对这个大数组的排序,我们需要三个步骤,这三个步骤中我们可以采用不同的方法。下面我们就详细的看一下 每一步我们可以采用什么方法。</p>
<h3 id="化整为零"><a href="#化整为零" class="headerlink" title="化整为零"></a>化整为零</h3><p>那么我们采用何种方法化整为零呢？其实要看我们后面的算法需求(数组合并),化整为零其实就是将这个很大的数组分成若干个小块。</p>
<p>那么这些小块之间有什么关系呢？ 有序还是无序？</p>
<h4 id="数组间是有序的"><a href="#数组间是有序的" class="headerlink" title="数组间是有序的"></a>数组间是有序的</h4><p>如果我们要求划分出的数组块之间是有序的 也就是说 第一个数组块中的数 均小于第二个数组块中的数,那么我们很容易想到 快速排序 根据一个中间值 一次排序就可以将整个数组分成两部分,左边的比中间值小右边的比中间值大。</p>
<p>快速排序,思路其实是递归。但是这一步其实我们只是想将这个数组分组。那么我们可以设置一个表示每个子数组块大小的值。在递归的过程中 如果发现子数组的长度已经小于等于这个值 那么我们第一步化整为零完成。退出这次的快速排序。</p>
<p><code>注意</code>: 对于子数组的大小,个人感觉不需要过小(&lt;1000),因为如果采用快速排序进行分组,如果要分成每组只有1000条数据,递归的层数约为15层 个人感觉这属于比较深的递归了。需要考虑是否会造成内存溢出。</p>
<h5 id="内存溢出"><a href="#内存溢出" class="headerlink" title="内存溢出:"></a>内存溢出:</h5><p>溢出的意思就是越界，操作系统会给每个进程分配一个最大上限的堆栈空间，如果超过了这个内存空间大小程序就会coredump，就像你使用int *pi = new int[100000000];会崩溃一样，因为这里堆溢出了。<br>操作系统分配给一个进程的栈空间是2M，堆空间在32位机器上是4G。如果你的进程的栈空间使用超过了2M就会栈溢出，堆使用超过4G就会堆溢出。</p>
<p>那么递归为什么会导致栈溢出呢？相信大家知道栈的出入规则，先入后出，递归的话那么先入的一直不能出栈，会一致存在栈空间中，这样就容易导致栈满而溢出。</p>
<p>若递归调用次数太多，就会只入栈不出栈，于是堆栈就被压爆了，此为栈溢出</p>
<h4 id="数组间是无序的"><a href="#数组间是无序的" class="headerlink" title="数组间是无序的"></a>数组间是无序的</h4><p>如果我们对划分出来的子数组间没有要求,那么我们可以很简单的 通过一个表示子数组长度的值,将这个大的数组划分成多个小的数组。</p>
<p>不过如果不要求子数组之间是否有序,那么我们可以让数组的大小尽可能小(空间换时间),方便后面对子数组进行排序。</p>
<h3 id="对较小的数组排序"><a href="#对较小的数组排序" class="headerlink" title="对较小的数组排序"></a>对较小的数组排序</h3><p>对一个相对较小的数组排序的方法有很多,快速排序 选择排序都可以考虑。</p>
<p>这里贴一张图,常用的算法的时间和空间复杂度:</p>
<p><img src="https://img-blog.csdn.net/20161009171515225" alt="常用算法"></p>
<h3 id="数组合并"><a href="#数组合并" class="headerlink" title="数组合并"></a>数组合并</h3><p>数组的合并,如果在第一步的时候选择的是划分子数组之间是有序的,这一步我们只需要将划分好的数组合并一下就可以了。这样就可以实现对这个大的数组的排序。</p>
<p>如果第一步我们选择的是子数组间无序,那么我们就要在合并的时候,我们可以采取类似归并排序的方法对这些长度较小的数组进行合并。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上面所说的方法其实都可以实现排序的功能。但是对于数据非常多的情况，通常我们将数据全部读入内存在进行排序是非常困难的,因此在第一步的时候，如果我们选择的是将整个数据划分成有序块.那么我们要把所有的数据读到内存,而且快速排序的使用递归的思路更是大大的加大了排序过程中的内存占用。因此,一般情况 我们都采用先划分成小块(无序),然后每一个小块排序完成之后在进行多路归并排序。</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://blog.csdn.net/hzhsan/article/details/50476401">在c++中尾递归，普通递归，循环的效率对比</a></p>
<p><a href="https://blog.csdn.net/guyulongcs/article/details/7520467">10^n个整数（亿级）的排序</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>Time Profiler 使用</title>
    <url>/2018/12/22/iOS-Time-Profiler-%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>自从到现在的公司半年一来,业务上一直在不停的迭代。为了维持版本的迭代速度,代码review变得不再像之前那么严苛。导致近期出现了几个比较严重的问题,趁着周末的时间,使用Time Profiler好好的检测一下应用及时发现问题,解决问题。</p>
<a id="more"></a>

<h2 id="现状"><a href="#现状" class="headerlink" title="现状"></a>现状</h2><p>近期慢慢开始越来越多的线上用户反馈应用卡的问题,出现问题的页面主要集中在：</p>
<blockquote>
<p>1、登录卡住,实际已经登录成功但是一直卡在登录的loading页面<br>2、进入直播间的页面卡住<br>3、进入个人主页卡住</p>
</blockquote>
<p>出现问题的机型 基本都集中在iPhone 6上,虽说iPhone 6是属于比较旧的机型了,但是在用户中所占的比重还是挺多的(苹果的不作为导致大家都没有理由去换新手机了)。</p>
<p>听到用户反馈这个问题,其实第一感觉 对于2.3两个页面我们大概都能知道原因,因为界面比较复杂,而且要预加载部分信息,所以在较旧的设备上卡是正常的。对于登录页面其实我百思不得解。</p>
<p>现状就说到这里,下面开始干……</p>
<h2 id="性能检测工具"><a href="#性能检测工具" class="headerlink" title="性能检测工具"></a>性能检测工具</h2><p>对于iOS项目,苹果爸爸其实在Xcode中已经为我们提供了一套性能检测工具：</p>
<p><img src="https://ws1.sinaimg.cn/large/006tNbRwgy1fyfoorfbu7j316s0o0ad5.jpg" alt="工具套装"> </p>
<p>对于这些工具 可以做一个简单的分类：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2189300-2ed3883fb57c9abb.jpg" alt="工具分类"></p>
<p>可以根据自己的实际情况 去选择不同的工具,废话不多说,开干！！！</p>
<h2 id="Time-Profiler"><a href="#Time-Profiler" class="headerlink" title="Time Profiler"></a>Time Profiler</h2><p>根据我们的实际情况,首先是卡顿,所以我要知道 应用中的耗时操作到底在哪里,是否有一些耗时操作放到了主线程,导致应用的卡顿。</p>
<p>下面我们主要玩玩这个小东西：</p>
<p><img src="http://www.samirchen.com/images/use-instruments/time_profiler.png" alt="Time Profiler"></p>
<h3 id="选择正确的应用和正确的设备"><a href="#选择正确的应用和正确的设备" class="headerlink" title="选择正确的应用和正确的设备"></a>选择正确的应用和正确的设备</h3><p><img src="http://www.samirchen.com/images/use-instruments/instruments_trace_document_toolbar_target_menus.png"></p>
<p>温馨提示:<code>应用必须是已安装的哦</code></p>
<h3 id="开始检测"><a href="#开始检测" class="headerlink" title="开始检测"></a>开始检测</h3><p>点击红色按钮我们就可以开始对我们选中设备和选中的应用进行检测了。</p>
<h4 id="界面简单介绍"><a href="#界面简单介绍" class="headerlink" title="界面简单介绍"></a>界面简单介绍</h4><p><img src="https://img-blog.csdnimg.cn/20181120232259625.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hlbGxvX0h3Yw==,size_16,color_FFFFFF,t_70" alt="界面"></p>
<ul>
<li>各个线程的采集数据汇总</li>
<li>点击1中的某一行，可以看到采集到的堆栈，注意2区域的右上角，可以选择隐藏系统的符号</li>
<li>可以选择关注的队列/CPU等。</li>
<li>可以用pinch手势来放大缩小时间范围，鼠标可以拖动选择一段区域</li>
</ul>
<h4 id="检测结果"><a href="#检测结果" class="headerlink" title="检测结果"></a>检测结果</h4><p><img src="https://ws1.sinaimg.cn/large/006tNbRwgy1fyfp35i5jjj31240u0n1w.jpg" alt="结果"></p>
<p>额,顿时有种 裤子都脱了你给我看这个！！(问号脸)</p>
<h5 id="正确展示检测信息"><a href="#正确展示检测信息" class="headerlink" title="正确展示检测信息"></a>正确展示检测信息</h5><p>遇到这种事,一定要告诉自己:你一定不是第一个遇到这个问题的人。所以呢 谷歌一下 你就知道</p>
<p><img src="https://img-blog.csdnimg.cn/20181120232618275.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hlbGxvX0h3Yw==,size_16,color_FFFFFF,t_70" alt="谷歌"></p>
<p>原因：<code>打包模式没有开启dSYM或者debug symbols</code> 所以 将debug切换到 <code>DWARF with dSYM File</code></p>
<p>下面 我们重新跑一次！</p>
<p><img src="https://ws4.sinaimg.cn/large/006tNbRwgy1fyfpef2oycj31l20q2guf.jpg" alt="结果"></p>
<p>好像虽然有一些我比较熟悉的类出现,但是面对这样的提示,我依然是一脸懵逼呀！</p>
<h5 id="筛选检测信息"><a href="#筛选检测信息" class="headerlink" title="筛选检测信息"></a>筛选检测信息</h5><p><code>Time Profiler</code> 默认将检测的所有信息都返回给我们,所以,如果想快速的定位问题 我们需要正确的筛选这些信息。</p>
<p><img src="https://ws4.sinaimg.cn/large/006tNbRwgy1fyfpk0wywhj30q00a2agv.jpg" alt="小秘密"></p>
<p>在上图的位置处,Time Profiler 给我们这几个选项,首先来看看这几个选项是什么意思：</p>
<ul>
<li>Separate by State：线程分离，状态分开显示 ，例如：Running状态</li>
<li>Separate by Thread：按线程分开进行分析。容易找出消耗资源的问题线程，特别是对于主线程，因为主线程要处理和渲染所有的接口数据及UI视图，当主线程受到阻塞性操作，一定会造成程序的卡顿，或停止响应。</li>
<li>Invert Call Tree：反向显示调用树。把调用层级最深的方法显示在最上面，容易找到最耗时的操作。</li>
<li>Hide System Libraries：隐藏缺失的符号。把干扰信息屏蔽掉，即把列表中因为系统架构，或DSYM文件缺失造成奇怪的十六进制的数值。</li>
<li>Flatten Recursion：拼合递归。把同一递归函数产生的多条堆栈合并为一条。</li>
<li>Top Functions：找到最耗时的函数或方法。</li>
</ul>
<p>依据我们的情况可以选择 <code>Separate by Thread</code> 和 <code>Hide System Libraries</code> </p>
<h5 id="结果分析"><a href="#结果分析" class="headerlink" title="结果分析"></a>结果分析</h5><p><img src="https://ws3.sinaimg.cn/large/006tNbRwgy1fyfps8sxaaj312w0f2jvm.jpg"></p>
<p>筛选之后 我们可以拿到上面的记过,对于卡顿的问题,一般是因为有一些操作应该放在子线程去做的,结果放到了主线程中,因此 我们把重点放在主线程上</p>
<p><img src="https://ws4.sinaimg.cn/large/006tNbRwgy1fyfpuy0druj31bs0m0n52.jpg" alt="主线程"></p>
<p>在上面这张图中,我们就可以比较清晰的看到 我们在项目中书写的一些方法。每一行的前面,就是这一行代码对应的耗时时间。</p>
<p>现在我们需要操作一下手机,然后看一下出问题的这段时间,都有哪些耗时操作。</p>
<p>在分析耗时的时候 我们可以看到前面两列<code>Weight</code>和 <code>Self Weight</code> 这两列表示总的耗时和当前行在总耗时中的比重,因此我们可以直接排除掉<code>Self Weight</code>为0的行。</p>
<p><img src="https://ws1.sinaimg.cn/large/006tNbRwgy1fyfq2ae1ucj30ca074mxw.jpg" alt="比重"></p>
<p>这样我们一层层的展开就可以找到耗时的具体方法了</p>
<p><img src="https://ws1.sinaimg.cn/large/006tNbRwgy1fyfq60dao5j317x0u047h.jpg" alt="定位具体方法"></p>
<p>如果层级太深,我们可以双击某一行进入一个新的页面,单独看这一行展开的内容</p>
<p><img src="https://ws3.sinaimg.cn/large/006tNbRwgy1fyfq84bijuj310g08g0ts.jpg"></p>
<p>在这个页面 如果我们想定位到具体的代码,我们可以直接双击该行,就可以直接打开 对应耗时的那一行代码</p>
<p><img src="https://ws3.sinaimg.cn/large/006tNbRwgy1fyfq98zz4ij31kw0pijyg.jpg"></p>
<p>这样我们就可以根据实际情况,针对出现问题的代码进行修改和优化！</p>
<p>另外 我们可以对页面中出现的多个耗时操作进行排序</p>
<p><img src="https://img-blog.csdnimg.cn/20181120232517981.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hlbGxvX0h3Yw==,size_16,color_FFFFFF,t_70"></p>
<h3 id="耗时操作检测完成"><a href="#耗时操作检测完成" class="headerlink" title="耗时操作检测完成"></a>耗时操作检测完成</h3><p>通常很明显的页面卡顿都是因为将某些耗时操作放到了主线程中,解决方法也很简单,将一些复杂计算或者网络请求放到子线程中去执行。</p>
<p>当然,还有其他的页面会导致页面卡顿,比如,当界面有大量的shadow，mask或者有非常多的View/Layer，GPU渲染纹理和顶点的时候可能会有压力。</p>
<p>总结一下,页面卡顿的原因主要分为两大类：CPU瓶颈和GPU瓶颈。</p>
<p>所以<code>Time Profiler</code>能做的只是对于CPU使用率的监控。对于GPU的监控 我们应该去是用<code>Core Animation</code></p>
]]></content>
      <categories>
        <category>iOS优化</category>
      </categories>
      <tags>
        <tag>耗时 主线程 xCode</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS10 适配</title>
    <url>/2016/09/19/iOS10-adapter/</url>
    <content><![CDATA[<p> iOS 10 已经出来有一段时间了，beta版没有勇气去尝试，在苹果推送正式版之后马上升级，首先还是看了一下自己的APP是否有崩溃的问题，不过都还好问题不大，哈哈！！！</p>
<a id="more"></a>


<h4 id="1、使用权限"><a href="#1、使用权限" class="headerlink" title="1、使用权限"></a>1、使用权限</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;!-- 相册 --&gt; </span><br><span class="line">&lt;key&gt;NSPhotoLibraryUsageDescription&lt;&#x2F;key&gt;</span><br><span class="line"> </span><br><span class="line">&lt;string&gt;App需要您的同意,才能访问相册&lt;&#x2F;string&gt; </span><br><span class="line"></span><br><span class="line">&lt;!-- 相机 --&gt; </span><br><span class="line">&lt;key&gt;NSCameraUsageDescription&lt;&#x2F;key&gt; </span><br><span class="line"></span><br><span class="line">&lt;string&gt;App需要您的同意,才能访问相机&lt;&#x2F;string&gt; </span><br><span class="line"></span><br><span class="line">&lt;!-- 麦克风 --&gt; </span><br><span class="line">&lt;key&gt;NSMicrophoneUsageDescription&lt;&#x2F;key&gt; </span><br><span class="line"></span><br><span class="line">&lt;string&gt;App需要您的同意,才能访问麦克风&lt;&#x2F;string&gt; </span><br><span class="line">&lt;!-- 位置 --&gt; </span><br><span class="line"></span><br><span class="line">&lt;key&gt;NSLocationUsageDescription&lt;&#x2F;key&gt; </span><br><span class="line"></span><br><span class="line">&lt;string&gt;App需要您的同意,才能访问位置&lt;&#x2F;string&gt; </span><br><span class="line"></span><br><span class="line">&lt;!-- 在使用期间访问位置 --&gt; </span><br><span class="line"></span><br><span class="line">&lt;key&gt;NSLocationWhenInUseUsageDescription&lt;&#x2F;key&gt; </span><br><span class="line"></span><br><span class="line">&lt;string&gt;App需要您的同意,才能在使用期间访问位置&lt;&#x2F;string&gt; </span><br><span class="line"></span><br><span class="line">&lt;!-- 始终访问位置 --&gt; </span><br><span class="line"></span><br><span class="line">&lt;key&gt;NSLocationAlwaysUsageDescription&lt;&#x2F;key&gt; </span><br><span class="line"></span><br><span class="line">&lt;string&gt;App需要您的同意,才能始终访问位置&lt;&#x2F;string&gt; </span><br><span class="line"></span><br><span class="line">&lt;!-- 日历 --&gt; </span><br><span class="line"></span><br><span class="line">&lt;key&gt;NSCalendarsUsageDescription&lt;&#x2F;key&gt; </span><br><span class="line"></span><br><span class="line">&lt;string&gt;App需要您的同意,才能访问日历&lt;&#x2F;string&gt; </span><br><span class="line"></span><br><span class="line">&lt;!-- 提醒事项 --&gt; </span><br><span class="line"></span><br><span class="line">&lt;key&gt;NSRemindersUsageDescription&lt;&#x2F;key&gt; </span><br><span class="line"></span><br><span class="line">&lt;string&gt;App需要您的同意,才能访问提醒事项&lt;&#x2F;string&gt; </span><br><span class="line"></span><br><span class="line">&lt;!-- 运动与健身 --&gt; </span><br><span class="line"></span><br><span class="line">&lt;key&gt;NSMotionUsageDescription&lt;&#x2F;key&gt; </span><br><span class="line"></span><br><span class="line">&lt;string&gt;App需要您的同意,才能访问运动与健身&lt;&#x2F;string&gt;</span><br><span class="line"> </span><br><span class="line">&lt;!-- 健康更新 --&gt; </span><br><span class="line"></span><br><span class="line">&lt;key&gt;NSHealthUpdateUsageDescription&lt;&#x2F;key&gt; </span><br><span class="line"></span><br><span class="line">&lt;string&gt;App需要您的同意,才能访问健康更新 &lt;&#x2F;string&gt; </span><br><span class="line"></span><br><span class="line">&lt;!-- 健康分享 --&gt; </span><br><span class="line"></span><br><span class="line">&lt;key&gt;NSHealthShareUsageDescription&lt;&#x2F;key&gt; </span><br><span class="line"></span><br><span class="line">&lt;string&gt;App需要您的同意,才能访问健康分享&lt;&#x2F;string&gt; </span><br><span class="line"></span><br><span class="line">&lt;!-- 蓝牙 --&gt; </span><br><span class="line"></span><br><span class="line">&lt;key&gt;NSBluetoothPeripheralUsageDescription&lt;&#x2F;key&gt;</span><br><span class="line"> </span><br><span class="line">&lt;string&gt;App需要您的同意,才能访问蓝牙&lt;&#x2F;string&gt; </span><br><span class="line"></span><br><span class="line">&lt;!-- 媒体资料库 --&gt; </span><br><span class="line"></span><br><span class="line">&lt;key&gt;NSAppleMusicUsageDescription&lt;&#x2F;key&gt; </span><br><span class="line"></span><br><span class="line">&lt;string&gt;App需要您的同意,才能访问媒体资料库&lt;&#x2F;string&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p><a href="https://pan.baidu.com/s/1mhTA03I">直接下载</a></p>
<h4 id="2、TabBarshadowImage设置"><a href="#2、TabBarshadowImage设置" class="headerlink" title="2、TabBarshadowImage设置"></a>2、TabBarshadowImage设置</h4><p>iOS10跟新之后之前tabbar设置shadowimage的方法不起作用了，但是这个<br>方法还是可以的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UITabBar *tabbar &#x3D; [UITabBar appearance];</span><br><span class="line">[tabbar setBackgroundImage:[UIImage new]];</span><br><span class="line">[tabbar setShadowImage:[UIImage new]];</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h4 id="3、Label文字显示不全的问题"><a href="#3、Label文字显示不全的问题" class="headerlink" title="3、Label文字显示不全的问题"></a>3、Label文字显示不全的问题</h4><p>iOS 10更新后发现英文字母显示没问题，在显示中文的时候UILabel的宽度计算有问题</p>
<p>解决方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UILabel *myLabel &#x3D; [UILabel new];</span><br><span class="line"></span><br><span class="line">&#x2F;*UIFont 的preferredFontForTextStyle: 意思是指定一个样式，并让</span><br><span class="line">字体大小符合用户设定的字体大小。 *&#x2F;</span><br><span class="line"></span><br><span class="line">myLabel.font &#x3D;[UIFont preferredFontForTextStyle: UIFontTextStyleHeadline];</span><br><span class="line"></span><br><span class="line"> &#x2F;*</span><br><span class="line"> Indicates whether the corresponding element should </span><br><span class="line"> automatically update its font when the device’s </span><br><span class="line"> UIContentSizeCategory is changed.</span><br><span class="line"> </span><br><span class="line"> For this property to take effect, the element’s font </span><br><span class="line"> must be a font vended using +preferredFontForTextStyle: </span><br><span class="line"> or </span><br><span class="line">  </span><br><span class="line">+preferredFontForTextStyle:compatibleWithTraitCollection:</span><br><span class="line">  with a valid UIFontTextStyle.</span><br><span class="line"> *&#x2F;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;是否更新字体的变化</span><br><span class="line"></span><br><span class="line">myLabel.adjustsFontForContentSizeCategory &#x3D; YES;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>目前没有找到可以整体修改的方法</code></p>
<h4 id="4、真彩色的显示"><a href="#4、真彩色的显示" class="headerlink" title="4、真彩色的显示"></a>4、真彩色的显示</h4><p>真彩色的显示会根据光感应器来自动的调节达到特定环境下显示与性能的平衡效果,如果需要这个功能的话,可以在info.plist-Source Code里配置:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;key&gt;UIWhitePointAdaptivityStyle&lt;&#x2F;key&gt;</span><br><span class="line"></span><br><span class="line">它有五种取值,分别是:</span><br><span class="line">&#x2F;&#x2F; 标准模式</span><br><span class="line">&lt;string&gt;UIWhitePointAdaptivityStyleStandard&lt;&#x2F;string&gt;</span><br><span class="line">&#x2F;&#x2F; 阅读模式</span><br><span class="line">&lt;string&gt;UIWhitePointAdaptivityStyleReading&lt;&#x2F;string&gt;</span><br><span class="line">&#x2F;&#x2F; 图片模式 </span><br><span class="line">&lt;string&gt;UIWhitePointAdaptivityStylePhoto&lt;&#x2F;string&gt; </span><br><span class="line">&#x2F;&#x2F; 视频模式</span><br><span class="line">&lt;string&gt;UIWhitePointAdaptivityStyleVideo&lt;&#x2F;string&gt; </span><br><span class="line">&#x2F;&#x2F; 游戏模式</span><br><span class="line">&lt;string&gt;UIWhitePointAdaptivityStyleStandard&lt;&#x2F;string&gt; </span><br><span class="line"></span><br><span class="line">五种模式的显示效果是从上往下递减,也就是说如果你的项目是图片处理类的,你选择的是阅读模式,给选择太好的效果会影响性能</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="5、更智能的键盘选择"><a href="#5、更智能的键盘选择" class="headerlink" title="5、更智能的键盘选择"></a>5、更智能的键盘选择</h4><p>系统可以在某些情况下自动选择适当的键盘，并提高键盘修正和主动与其他文本输入机会的整合。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; The textContentType property is to provide the </span><br><span class="line">keyboard with extra information about the semantic intent </span><br><span class="line">of the text document.</span><br><span class="line"></span><br><span class="line">@property(nonatomic,copy) UITextContentType </span><br><span class="line">textContentType NS_AVAILABLE_IOS(10_0); &#x2F;&#x2F; default is nil</span><br><span class="line"></span><br><span class="line">UITextContentTypeName            </span><br><span class="line">UITextContentTypeNamePrefix      </span><br><span class="line">UITextContentTypeGivenName       </span><br><span class="line">UITextContentTypeMiddleName      UITextContentTypeFamilyName      </span><br><span class="line">UITextContentTypeNameSuffix      </span><br><span class="line">UITextContentTypeNickname        </span><br><span class="line">UITextContentTypeJobTitle        </span><br><span class="line">UITextContentTypeOrganizationName</span><br><span class="line">UITextContentTypeLocation        </span><br><span class="line">UITextContentTypeFullStreetAddres</span><br><span class="line">UITextContentTypeStreetAddressLin</span><br><span class="line">UITextContentTypeStreetAddressLin</span><br><span class="line">UITextContentTypeAddressCity     </span><br><span class="line">UITextContentTypeAddressState    </span><br><span class="line">UITextContentTypeAddressCityAndSt</span><br><span class="line">UITextContentTypeSublocality     </span><br><span class="line">UITextContentTypeCountryName     </span><br><span class="line">UITextContentTypePostalCode      </span><br><span class="line">UITextContentTypeTelephoneNumber </span><br><span class="line">UITextContentTypeEmailAddress    </span><br><span class="line">UITextContentTypeURL             </span><br><span class="line">UITextContentTypeCreditCardNumber</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>系统适配</category>
      </categories>
      <tags>
        <tag>iOS10,适配</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS11 Adatper</title>
    <url>/2017/10/09/iOS11-Adatper/</url>
    <content><![CDATA[<p>iOS来了一段时间了,每次系统更新,在体验New Feature的同时,我们要做的还有适配,因为我们的App包含iPhone和iPad,所以这里的总结包含了这两种设备的适配！</p>
<p>废话不多说,上干货！</p>
<a id="more"></a>

<h4 id="iOS11的判断"><a href="#iOS11的判断" class="headerlink" title="iOS11的判断"></a>iOS11的判断</h4><pre><code>#define IOS11OrLater    (@available(iOS 11.0, *))</code></pre>
<h4 id="导航栏高度"><a href="#导航栏高度" class="headerlink" title="导航栏高度"></a>导航栏高度</h4><p>导航栏高度一直是固定的64P, 到了iOS11这个规则被打破了！84!</p>
<p>iOS11之前</p>
<p><img src="https://user-gold-cdn.xitu.io/2017/10/3/a25e13e4a7c7dc403e3abe4f236632af?imageView2/0/w/1280/h/960" alt="iOS11之前"></p>
<p>iOS11之后</p>
<p><img src="https://user-gold-cdn.xitu.io/2017/10/3/db7501bdf726081e561998c37af3b77f?imageView2/0/w/1280/h/960" alt="iOS11之后"></p>
<p>其次,之前title和titleview是二选一的,在iOS11中可以通过开启</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;根据prefersLargeTitles设置, 默认为NO;</span><br><span class="line"> self.navigationController.navigationBar.prefersLargeTitles &#x3D; YES;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p>来选择设置大标题</p>
<p><img src="http://og0h689k8.bkt.clouddn.com/17-10-9/95933026.jpg" alt="设置效果"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">self.navigationController.navigationBar.prefersLargeTitles &#x3D; YES;</span><br><span class="line">self.title &#x3D; @&quot;这个是大标题&quot;;</span><br><span class="line"></span><br><span class="line">UIView *titleView &#x3D; [[UIView alloc] initWithFrame:CGRectMake(0, 0,SCREEN_W , 44)]; &#x2F;&#x2F;高度&lt;&#x3D;44</span><br><span class="line">titleView.backgroundColor &#x3D; [UIColor redColor];</span><br><span class="line"></span><br><span class="line">UILabel *label &#x3D; [UILabel new];</span><br><span class="line">label.text &#x3D; @&quot;这是TitleView(位置可以调整)&quot;;</span><br><span class="line">label.textColor &#x3D; [UIColor whiteColor];</span><br><span class="line">label.font &#x3D; [UIFont systemFontOfSize:18];</span><br><span class="line">label.frame &#x3D; CGRectMake(10, 10, SCREEN_W, 44); &#x2F;&#x2F;高度超过默认44 会向下偏移</span><br><span class="line">[titleView addSubview:label];</span><br><span class="line"></span><br><span class="line">self.navigationItem.titleView &#x3D; titleView;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>titleView支持autolayout，这要求titleView必须是能够自撑开的或实现了- intrinsicContentSize</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">- (CGSize)intrinsicContentSize &#123;</span><br><span class="line">    <span class="keyword">return</span> UILayoutFittingExpandedSize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="tabBar-高度"><a href="#tabBar-高度" class="headerlink" title="tabBar 高度"></a>tabBar 高度</h4><p>底部区域主要是iPhoneX与其他机型不一样, 一般机型高度为49, iPhoneX为83;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define kTabBarHeight ([[UIApplication sharedApplication] statusBarFrame].size.height&gt;20?83:49)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="导航栏返回按钮"><a href="#导航栏返回按钮" class="headerlink" title="导航栏返回按钮"></a>导航栏返回按钮</h4><p><img src="http://upload-images.jianshu.io/upload_images/2057602-aa6daf4862ed7bf2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="返回按钮"></p>
<p>之前如果通过某种方式自定义返回按钮,因为API的改变可能导致返回按钮下移</p>
<p>iOS 11之前</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UIImage *backButtonImage &#x3D; [[UIImage imageNamed:@&quot;icon_tabbar_back&quot;]</span><br><span class="line">    resizableImageWithCapInsets:UIEdgeInsetsMake(0, 18, 0, 0)];</span><br><span class="line">[[UIBarButtonItem appearance] setBackButtonBackgroundImage:backButtonImage</span><br><span class="line">                                                  forState:UIControlStateNormal</span><br><span class="line">                                               barMetrics:UIBarMetricsDefault];</span><br><span class="line">[[UIBarButtonItem appearance] setBackButtonTitlePositionAdjustment:UIOffsetMake(0, -60)</span><br><span class="line">                                                    forBarMetrics:UIBarMetricsDefault];</span><br><span class="line">                                                    </span><br></pre></td></tr></table></figure>
<p>iOS 11 中setBackButtonTitlePositionAdjustment:UIOffsetMake没法把按钮移出navigation bar。</p>
<p>解决方法是设置navigationController的backIndicatorImage和backIndicatorTransitionMaskImage</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UIImage *backButtonImage &#x3D; [[UIImage imageNamed:@&quot;icon_tabbar_back&quot;] imageWithRenderingMode:UIImageRenderingModeAlwaysOriginal];</span><br><span class="line">self.navigationBar.backIndicatorImage &#x3D; backButtonImage;</span><br><span class="line">self.navigationBar.backIndicatorTransitionMaskImage &#x3D; backButtonImage;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="automaticallyAdjustsScrollViewInsets废除"><a href="#automaticallyAdjustsScrollViewInsets废除" class="headerlink" title="automaticallyAdjustsScrollViewInsets废除"></a>automaticallyAdjustsScrollViewInsets废除</h4><p><img src="http://upload-images.jianshu.io/upload_images/2057602-5780671d66dccdb0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="inset"><br>iOS 11中ViewController的automaticallyAdjustsScrollViewInsets属性被废弃了，导致了 一些隐藏了系统导航栏或者自定义导航栏</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">self.automaticallyAdjustsScrollViewInsets &#x3D; NO;</span><br><span class="line">self.extendedLayoutIncludesOpaqueBars &#x3D; YES;</span><br><span class="line">self.edgesForExtendedLayout &#x3D; UIRectEdgeTop;</span><br></pre></td></tr></table></figure>

<p>automaticallyAdjustsScrollViewInsets属性被废弃了，顶部就多了一定的inset</p>
<p>解决方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (@available(iOS 11.0, *)) &#123;</span><br><span class="line">    self.tableView.contentInsetAdjustmentBehavior &#x3D; UIScrollViewContentInsetAdjustmentNever;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    self.automaticallyAdjustsScrollViewInsets &#x3D; NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="tableview-header的问题"><a href="#tableview-header的问题" class="headerlink" title="tableview header的问题"></a>tableview header的问题</h4><p><img src="http://upload-images.jianshu.io/upload_images/2057602-81c74d7c47ab2be6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="右边为正确样式"></p>
<p>iOS 11中如果不实现-tableView: viewForFooterInSection: 和 -tableView: viewForHeaderInSection:，那么-tableView: heightForHeaderInSection:和- tableView: heightForFooterInSection:不会被调用。</p>
<p>这是因为estimatedRowHeight estimatedSectionHeaderHeight estimatedSectionFooterHeight三个高度估算属性由默认的0变成了UITableViewAutomaticDimension，导致高度计算不对，解决方法是实现对应方法或吧这三个属性设为0</p>
<h4 id="tableview新特性"><a href="#tableview新特性" class="headerlink" title="tableview新特性"></a>tableview新特性</h4><blockquote>
<p>设置delaysContentTouches为NO, 不会立即触发cell的响应事件;<br>两根手指快速的轻击cell，可以同时选中两个cell进入编辑状态。如果两个手指存在不同步问题，则<br>  会默认识别其中的一个手指表示单选cell;<br>新增了一个属性separatorInsetReference可以自定义一个cell分割线的边距;<br>cell或者表头表尾默认采用自适应高度的方案(造成UI紊乱的原因);<br>增加了numberOfLines属性来实现类似于UILabel一样的高度自适应变化;</p>
</blockquote>
<h4 id="获取地理位置权限的问题"><a href="#获取地理位置权限的问题" class="headerlink" title="获取地理位置权限的问题"></a>获取地理位置权限的问题</h4><p>在IOS11，原有的NSLocationAlwaysUsageDeion被降级为NSLocationWhenInUseUsageDeion;</p>
<p>需要在plist文件中配置NSLocationAlwaysAndWhenInUseUsageDeion，系统框才会弹出;使用requestAlwaysAuthorization获取权限 IOS11系统弹框会把几种权限级别全部列出，供用户选择;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSLocationUsageDescription</span><br><span class="line">获取地理位置，精准推送服务</span><br><span class="line">NSLocationWhenInUseUsageDescription</span><br><span class="line">获取地理位置，精准推送服务</span><br><span class="line">NSLocationAlwaysUsageDescription</span><br><span class="line">App需要您的同意,才能始终访问位置</span><br><span class="line">NSLocationAlwaysAndWhenInUseUsageDeion</span><br><span class="line">App需要您的同意,才能始终访问位置</span><br></pre></td></tr></table></figure>

<h4 id="获取相册权限"><a href="#获取相册权限" class="headerlink" title="获取相册权限"></a>获取相册权限</h4><p>iOS11以前：<br>NSPhotoLibraryUsageDescription：访问相册和存储照片到相册（读写），会出现用户授权;</p>
<p>iOS11之后：<br>NSPhotoLibraryUsageDescription：无需添加。默认开启访问相册权限（读），无需用户授权;<br>NSPhotoLibraryAddUsageDescription： 添加内容到相册（写），会出现用户授权;</p>
<h4 id="xib编译问题"><a href="#xib编译问题" class="headerlink" title="xib编译问题"></a>xib编译问题</h4><p>一般是打开以前的工程, 编译的时候xib报错, 例如:</p>
<p><code>warning: Internationalization is not available when compiling for targets before iOS 6.0</code></p>
<p>解决办法：<br>选择编译错误的xib文件，找到Builds for 改为iOS 7.0 and Later</p>
<p><img src="https://user-gold-cdn.xitu.io/2017/10/3/4173ca5c988545dc956a7ff3a6883248?imageView2/0/w/1280/h/960" alt="iOS 7.0 and Later"></p>
<h4 id="iPhone-X-屏幕适配"><a href="#iPhone-X-屏幕适配" class="headerlink" title="iPhone X 屏幕适配"></a>iPhone X 屏幕适配</h4><p>添加iPhoneX的Launch图1125x2436<br>使用LaunchScreen来当做缓冲页或者修改Assets中的LaunchImage，添加iPhoneX的Launch图1125*2436（竖屏);</p>
<p><img src="http://og0h689k8.bkt.clouddn.com/17-10-9/25051633.jpg" alt="点击选中iOS8会自动"></p>
<p><img src="http://og0h689k8.bkt.clouddn.com/17-10-9/33437597.jpg"></p>
<h4 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h4><p><a href="http://www.cocoachina.com/ios/20170915/20580.html">简书App适配iOS 11</a><br><a href="http://www.jianshu.com/p/efbc8619d56b">iOS 11 安全区域适配总结</a><br><a href="https://juejin.im/entry/59d3712ef265da0651672a6d?utm_source=gold_browser_extension">iOS11问题汇总</a></p>
]]></content>
      <categories>
        <category>系统适配</category>
      </categories>
      <tags>
        <tag>iOS11,适配</tag>
      </tags>
  </entry>
  <entry>
    <title>组件化设计方案</title>
    <url>/2020/07/25/appmodule/</url>
    <content><![CDATA[<p>随着多个功能需要在多个业务线短时间内实现功能同步，我们需要将新增功能模块和已有的功能模块逐步组件化，以达到多个业务线间可快速同步的效果</p>
<a id="more"></a>

<h3 id="何为组件"><a href="#何为组件" class="headerlink" title="何为组件"></a>何为组件</h3><p>既然要实现组件化 那么什么样的叫做组件呢?<br>组件我们可以根据功能性和颗粒度的不同分为</p>
<ul>
<li>基础组件</li>
<li>独立功能组件</li>
<li>独立业务组件</li>
</ul>
<p>我们先看下对于整个APP架构，我们的层次划分</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggo04wwswaj30lf0dc3zp.jpg"></p>
<p>对于不同的业务组件我们的拆分方法和颗粒度是不同的下面我们来分别介绍一下这三种组件的设计方案</p>
<h2 id="基础组件"><a href="#基础组件" class="headerlink" title="基础组件"></a>基础组件</h2><p>基础组件是我们实现上层业务的基础，因此我们需要颗粒度较细的去拆分，根据上面的架构图我们可以看到这里所说基础组件就是APP架构中的最底层。</p>
<p>对于放到基础组件中的代码，我们务必需要遵守下面几个条件:</p>
<ul>
<li>基础组件中的代码必须无任何依赖(可依赖三方)</li>
<li>基础组件中的代码不涉及任何业务</li>
<li>基础组件中的代码为上层组件服务，尽可能精简，功能也尽可能通用</li>
<li>基础组件中不应包含任何资源文件</li>
</ul>
<h2 id="独立功能组件"><a href="#独立功能组件" class="headerlink" title="独立功能组件"></a>独立功能组件</h2><p>独立功能组件，实际上是对上层常用功能的封装，比如基类、数据库、网络、图片下载和展示等。拆分的颗粒度同样要求较细，相似的功能应尽可能的拆分。</p>
<p>独立功能组件在层次结构上位于基础组件的上层，可依赖基础组件的代码。</p>
<p>对于放到独立功能组件中的代码，我们务必遵守下面几个条件:</p>
<ul>
<li>功能独立，每个组件代码要求遵守单一功能原则，不可合并类似功能的组件为一个大组件</li>
<li>明确每个组件所属类别，例如：UI控件、网络模块</li>
<li>每个功能模块如果依赖上层的配置 需要提供明确的接口供上层设置</li>
<li>功能设计不涉及业务开关，如果需要那么提供配置来进行功能区分</li>
<li>如果独立的功能有资源文件，那么资源文件考虑由外部配置，或者提供支持多条业务线的资源文件包</li>
<li>多个独立功能组件间尽量减少依赖关系，尤其不可互相依赖</li>
<li>独立功能组件必须是多个模块共用的，不可将只有某个模块使用的组件放入</li>
<li>独立功能组件不可依赖上层组件</li>
</ul>
<h2 id="独立业务组件"><a href="#独立业务组件" class="headerlink" title="独立业务组件"></a>独立业务组件</h2><p>独立业务组件，顾名思义一个独立的业务功能模块，是某个业务的多个功能模块的集合。往往也是我们组件化过程中最复杂和最难的部分，当然也是我们这篇文章中重点介绍的部分。</p>
<p>下面我们来详细的介绍下，业务组件化的主要流程：</p>
<ul>
<li>组件代码模块化</li>
<li>组件内引用外部解耦</li>
<li>组件外引用组件内方法解耦</li>
<li>组件资源整理</li>
<li>组件间的跳转</li>
<li>组件多业务兼容</li>
</ul>
<p>下面我们来详细的描述这几个流程</p>
<h3 id="组件代码模块化"><a href="#组件代码模块化" class="headerlink" title="组件代码模块化"></a>组件代码模块化</h3><p>模块化，实际上是组件化过程中的一个中间形态，对于不是太复杂的工程中实际上做到模块化就可以了，但是对于较为复杂的工程组件化才是其终极形态。</p>
<h4 id="组件代码归纳集中"><a href="#组件代码归纳集中" class="headerlink" title="组件代码归纳集中"></a>组件代码归纳集中</h4><p>这一步我们主要的工作是:将同属于该业务的分散在各个位置的功能页面集中到一个文件夹中。如果之前的项目就是根据业务模块按照MVC或者MVVM的实体文件夹结构来划分的，那么恭喜你，这一步的工作量可以大大减少。</p>
<p>而对于将要移动到业务组件中的业务代码，我们需要确认该功能模块是否隶属于该业务模块。实际上这是对整个项目的业务模块划分，这样我们才能比较清楚的了解每个业务模块应该包含哪些内容。</p>
<p><code>注意</code>:代码集中时务必要使用实体文件夹进行管理</p>
<h4 id="按照组件结构模块化"><a href="#按照组件结构模块化" class="headerlink" title="按照组件结构模块化"></a>按照组件结构模块化</h4><p>再将业务模块代码集中到独立文件夹后，我们可以根据组件化的模块结构对业务组件代码重新进行文件结构划分。</p>
<p>下面我们先看下组件化结构中文件夹结构划分，以及每个文件夹下代码的功能</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggo47497wdj30xb08dacc.jpg"></p>
<p>当然在这个过程中，我们可以再次检查是否有遗漏的未移动的代码，同时要将外部涉及该业务模块的代码删除，统一移动到组件模块中进行统一的管理</p>
<h3 id="抽取组件中的各类常量"><a href="#抽取组件中的各类常量" class="headerlink" title="抽取组件中的各类常量"></a>抽取组件中的各类常量</h3><p>在将业务组件的代码都归纳整理之后，我们需要抽取该业务模块中的一些常量。</p>
<p>下面我们罗列了其中的集中类型的常量，如图所示：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggo51fpm4bj30jr06iaao.jpg"></p>
<p>我们需要将之前写死在代码中的常量提取到这几个文件中，实现统一管理。</p>
<h3 id="组件内引用外部解耦"><a href="#组件内引用外部解耦" class="headerlink" title="组件内引用外部解耦"></a>组件内引用外部解耦</h3><p>组件化过程中，其实最复杂的就是解耦。首先我们需要知道组件内引用了多少外部业务组件的类，然后分别进行解耦。</p>
<p>这一步的操作流程：</p>
<ul>
<li><p>通过查看组件中的每一个类，确认头文件和实现文件中对外部类的引用，然后通过文档进行记录。</p>
</li>
<li><p>将项目中的其他业务删除只保留当前组件化的业务模块，保证可以编译通过，进而找到之前隐藏未发现的依赖并记录。</p>
</li>
<li><p>确认记录的每一个类该如何解决，解决方法大抵分为下面几种方法</p>
<p>  1、将依赖外部的类复制一份放到组件中<br>  2、将依赖的方法抽取放到组件中<br>  3、将依赖的类解耦后放到独立功能组件中<br>  4、如果只是跳转依赖，那么记录后 在后续考虑如何解耦</p>
</li>
</ul>
<p>这一步操作完成后，我们实现了组件对外部依赖的耦合，且当前项目在只保留基础组件、独立项目组件和该业务组件时可以编译通过。</p>
<h3 id="组件外引用组件内方法解耦"><a href="#组件外引用组件内方法解耦" class="headerlink" title="组件外引用组件内方法解耦"></a>组件外引用组件内方法解耦</h3><p>完成组件内对外部的引用解耦之后，我们下一步要做的就是组件外部内内部的引用。</p>
<p>这一步的操作流程:</p>
<ul>
<li><p>将该模块从项目中移除通过编译报错的方式确认外部对改模块的依赖并记录成wiki</p>
</li>
<li><p>对于这部分发现的依赖主要有下面几种解决方法</p>
<p>  1、如果是外部跳转到该组件，那么需要改为调用该组件提供的跳转方法，进行跳转同时进行解耦</p>
<p>  2、如果外部依赖了组件内的某些类或者方法那么可以采取类似解决内因外耦合的方式通过复制类，复制方法或者通过非显示调用的方式进行解耦。</p>
</li>
</ul>
<p>这一步操作完成后，我们基本上已经实现了代码层面的解耦！</p>
<h3 id="组件资源整理"><a href="#组件资源整理" class="headerlink" title="组件资源整理"></a>组件资源整理</h3><p>组件的资源包括下面几个：</p>
<ul>
<li>国际化资源(不同语言文字转换)</li>
<li>图片资源(尤其是图片上有中文，或者图片与APP的icon有关)</li>
<li>文件资源(lottie资源、plist配置文件)</li>
</ul>
<p>我们首先需要将该组件用到的说有图片资源，放到一起，然后根据上面这三种类型对资源进行分类。其次我们需要将差异化的资源(例如图片上有中文的图片),根据不同业务线(业务线A、业务线B、业务线C)分别建立一个资源文件夹。</p>
<p>经过上述的整理最终的资源文件夹结构应该是</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggo9p64slcj30hn03kglt.jpg"></p>
<p>在不同的业务线即不同的APP中，我们使用图中的Public Resource和对应业务线的Resource。</p>
<p>在这一步操作完成后，我们基本上实现了不同业务线在该组件的资源整理和使用。</p>
<h2 id="组件间的跳转"><a href="#组件间的跳转" class="headerlink" title="组件间的跳转"></a>组件间的跳转</h2><p>组件间的跳转，实际上是组件化中最重要的一部，因为经过上面的这些操作，我们将组件的代码从主工程中剥离，且可以独立编译通过。但是这个模块目前并没有与主工程链接起来。</p>
<p>所以组件间跳转实际上就是在主工程中将所有的组件链接起来。</p>
<p>组件化时，组件间的跳转大体有两种思路：</p>
<ul>
<li>1、基于 URL Router、ModuleManager的跳转(目前博客已删除活设置为私有)</li>
<li>2、基于Target-Action的组件间跳转</li>
<li>3、iOS 组件化方案探索</li>
</ul>
<p>第三篇博客(Bang神)实际上比较了方案1和方案2两种做法，下面是从文章中摘抄出的总结：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">上面论述下方案1(Target-Action)确实比方案2+方案3(Router)简单明了，没有 注册表常驻内存&#x2F;参数传</span><br><span class="line">递限制&#x2F;调用分散 这些缺点，方案1多做的一步是需要对所有组件方法进行一层 wrapper，但若想要明确提供</span><br><span class="line">组件的方法和参数类型，解耦统一处理，方案2和方案3同样需要多加这层。</span><br></pre></td></tr></table></figure>
<p>但是，对于目前项目来说，盲目的迁移到Router或者Mediator实现组件间的跳转显然不太实际，而且维护的成本较高。</p>
<p>因此，我们采取的方法是在之前跳转的基础上稍加改动，并结合使用ProtocolKit进行解耦。</p>
<p>项目中之前就存在一个JumpUtil类这个类管理了项目中页面间的跳转，不过仍然可能会存在某些直接创建对应目标控制器并通过PUSH或Present方式跳转到对应页面。</p>
<p>因此 我们要做的第一件事为：将所有跳转到当前组件内页面的跳转方法统一改到JumpUtil中实现。每个模块我们通过创建JumpUtil对应分类的方式进行跳转的管理。通过这种方式，外部类在往组件中页面跳转时只需要引用JumpUtil对应的分类即可，不需要引用对应的控制器。</p>
<p>对于组件内部需要跳转到组件外的场景，我们使用ProtocolKit的方式进行解耦。</p>
<p><code>ProtocolKit 实际上是为对应的某个协议写一个默认实现。即我们声明了某个协议之后，不需要设置代理，直接调用协议中的方法。即可调用到我们写的默认实现中。</code></p>
<p>下面我们贴出ProtoclKit的核心源码:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// For a magic reserved keyword color, use @defs(your_protocol_name)</span></span><br><span class="line"><span class="comment">//defs 只是 _pk_extension 的别名，为了提供一个更加合适的名字作为接口 使用的时候用@defs()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> defs _pk_extension</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们使用的时候用@defs(Protocol)实际上是调用_pk_extension_imp方法</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _pk_extension($protocol) _pk_extension_imp($protocol, _pk_get_container_class($protocol))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个宏实际上是创建了一个隐藏类(container_class) 这个类遵守protocol这个协议</span></span><br><span class="line"><span class="comment">// 然后在load方法中调用内部实现的load(load方法也是在main函数执行之前执行的)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _pk_extension_imp($protocol, $container_class) \</span></span><br><span class="line">    protocol $protocol; \</span><br><span class="line">    <span class="class"><span class="keyword">@interface</span> $<span class="title">container_class</span> : <span class="title">NSObject</span> &lt;$<span class="title">protocol</span>&gt; @<span class="title">end</span> \</span></span><br><span class="line">    <span class="class"><span class="keyword">@implementation</span> $<span class="title">container_class</span> \</span></span><br><span class="line">    + (<span class="keyword">void</span>)load &#123; \</span><br><span class="line">        _pk_extension_load(<span class="class"><span class="keyword">@protocol</span>($<span class="title">protocol</span>), $<span class="title">container_class</span>.<span class="title">class</span>); \</span></span><br><span class="line">    &#125; \</span><br><span class="line"></span><br><span class="line"><span class="comment">// _pk_get_container_class 实际上就是生成一个类名</span></span><br><span class="line"><span class="comment">// 可以看到这个类名实际上是由类名+协议名+count(一个计数器每次调用会自动加一)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _pk_get_container_class($protocol) _pk_get_container_class_imp($protocol, __COUNTER__)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _pk_get_container_class_imp($protocol, $counter) _pk_get_container_class_imp_concat(__PKContainer_, $protocol, $counter)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _pk_get_container_class_imp_concat($a, $b, $c) $a ## $b ## _ ## $c</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> _pk_extension_load(Protocol *protocol, Class containerClass);</span><br></pre></td></tr></table></figure>

<p>因此当A组件中的某个事件响应要跳转到B组件中的某个页面时</p>
<p>之前的写法：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&quot;BViewController.h&quot;</span></span></span><br><span class="line">- (<span class="keyword">void</span>)moduleAJumpToModuleB &#123;</span><br><span class="line">    BViewController *bVc = [[BViewController alloc] init];</span><br><span class="line">    [<span class="keyword">self</span>.navigationController pushViewController:bVc animated:<span class="literal">YES</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修改之后的写法：</p>
<p>新建protocol</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">ULModuleBJumpDelegate</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)moduleAJumpToModuleB;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>首先当前类应遵守这个协议 <code>ULModuleBJumpDelegate</code></p>
<p>跳转方法改为直接调用协议中的方法</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)moduleAJumpToModuleBMediator &#123;</span><br><span class="line">    [<span class="keyword">self</span> ul_moduleAJumpToModuleB];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，在组件外新建一个解耦类ULModuleBMediator并实现对应方法</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&quot;BViewController.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@defs</span>(ULModuleBJumpDelegate)</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)ul_moduleAJumpToModuleB &#123;</span><br><span class="line">    BViewController *bVc = [[BViewController alloc] init];</span><br><span class="line">    [<span class="keyword">self</span>.navigationController pushViewController:bVc animated:<span class="literal">YES</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样我们就解除了，在A模块要跳转到B模块时必须导入B模块的相关类的问题，上面声明的协议放在A组件内，组件的实现放到外部主工程中。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对于一个成熟的项目，尤其是创建时间比较久的项目，组件化是一个任重而道远的过程，组件化过程中，我们要本着小步快走的方式，逐步进行组件化。同时也避免因为组件化而影响业务需求的进度。但组件化后，对于各个业务模块的维护有比较明显的提升同时组件在不同业务线之间进行复用也能更加的方便和快速。所以，组件化是项目的终极目标。</p>
]]></content>
      <categories>
        <category>组件化</category>
      </categories>
      <tags>
        <tag>组件化</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题——ChenYilong-总结</title>
    <url>/2015/08/13/interview-note-2/</url>
    <content><![CDATA[<p>本文是 看了github上 《招聘一个靠谱的iOS程序员》提供的面试题之后做的一些总结，内容大多为其中的一些摘抄。</p>
<a id="more"></a>

<h3 id="1、-objc-msgForward函数是做什么的，直接调用它将会发生什么？"><a href="#1、-objc-msgForward函数是做什么的，直接调用它将会发生什么？" class="headerlink" title="1、_objc_msgForward函数是做什么的，直接调用它将会发生什么？"></a>1、_objc_msgForward函数是做什么的，直接调用它将会发生什么？</h3><pre><code>_objc_msgForward是 IMP 类型，用于消息转发的：当向一个对象发送一条消息，但它并没有实现的时候，_objc_msgForward会尝试做消息转发。

在上篇中的《objc中向一个对象发送消息[obj foo]和objc_msgSend()函数之间有什么关系？》曾提到objc_msgSend在“消息传递”中的作用。在“消息传递”过程中，objc_msgSend的动作比较清晰：首先在 Class 中的缓存查找 IMP （没缓存则初始化缓存），如果没找到，则向父类的 Class 查找。如果一直查找到根类仍旧没有实现，则用_objc_msgForward函数指针代替 IMP 。最后，执行这个 IMP 。

为了展示消息转发的具体动作，这里尝试向一个对象发送一条错误的消息，并查看一下_objc_msgForward是如何进行转发的。</code></pre>
<p><img src="https://camo.githubusercontent.com/c06953c83cf1fd56eff670b88e4c3e0cc739c62d/687474703a2f2f692e696d6775722e636f6d2f556a626d5676422e706e67" alt="icon"></p>
<p>操作过程：<br><img src="https://camo.githubusercontent.com/c5d6a506acdf37eefcb090e3f7911d85186623f4/687474703a2f2f692e696d6775722e636f6d2f414145527a31542e706e67" alt="icon"><br>    结合《NSObject官方文档》，排除掉 NSObject 做的事，剩下的就是_objc_msgForward消息转发做的几件事：</p>
<pre><code>调用resolveInstanceMethod:方法 (或 resolveClassMethod:)。允许用户在此时为该 Class 动态添加实现。如果有实现了，则调用并返回YES，那么重新开始objc_msgSend流程。这一次对象会响应这个选择器，一般是因为它已经调用过class_addMethod。如果仍没实现，继续下面的动作。

调用forwardingTargetForSelector:方法，尝试找到一个能响应该消息的对象。如果获取到，则直接把消息转发给它，返回非 nil 对象。否则返回 nil ，继续下面的动作。注意，这里不要返回 self ，否则会形成死循环。

调用methodSignatureForSelector:方法，尝试获得一个方法签名。如果获取不到，则直接调用doesNotRecognizeSelector抛出异常。如果能获取，则返回非nil：创建一个 NSlnvocation 并传给forwardInvocation:。

调用forwardInvocation:方法，将第3步获取到的方法签名包装成 Invocation 传入，如何处理就在这里面了，并返回非ni。

调用doesNotRecognizeSelector: ，默认的实现是抛出异常。如果第3步没能获得一个方法签名，执行该步骤。</code></pre>
<p>下面回答下第二个问题“直接_objc_msgForward调用它将会发生什么？”</p>
<p>_objc_msgForward 方法解析</p>
<table>
<thead>
<tr>
<th align="left">–</th>
<th align="center">_objc_msgForward参数</th>
<th align="right">类型</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="center">所属对象</td>
<td align="right">id类型</td>
</tr>
<tr>
<td align="left">2</td>
<td align="center">方法名</td>
<td align="right">SEL类型</td>
</tr>
<tr>
<td align="left">3</td>
<td align="center">可变参数</td>
<td align="right">可变参数类型</td>
</tr>
</tbody></table>
<p>为了直观，我们可以通过如下方式定义一个 IMP类型 ：</p>
<pre><code>typedef void (*voidIMP)(id, SEL, ...)

一旦调用_objc_msgForward，将跳过查找 IMP 的过程，直接触发“消息转发”，
如果调用了_objc_msgForward，即使这个对象确实已经实现了这个方法，你也会告诉objc_msgSend：
“我没有在这个对象里找到这个方法的实现”
有哪些场景需要直接调用_objc_msgForward？最常见的场景是：你想获取某方法所对应的NSInvocation对象。举例说明：
JSPatch （Github 链接）就是直接调用_objc_msgForward来实现其核心功能的：

JSPatch（） 以小巧的体积做到了让JS调用/替换任意OC方法，让iOS APP具备热更新的能力、
作者的博文《JSPatch实现原理详解》详细记录了实现原理，有兴趣可以看下。</code></pre>
<h3 id="2、runtime如何实现weak变量的自动置nil？"><a href="#2、runtime如何实现weak变量的自动置nil？" class="headerlink" title="2、runtime如何实现weak变量的自动置nil？"></a>2、runtime如何实现weak变量的自动置nil？</h3><pre><code>runtime 对注册的类， 会进行布局，对于 weak 对象会放入一个 hash 表中。 用 weak 指向的对象内存地址作为 key，当此对象的引用计数为0的时候会 dealloc，假如 weak 指向的对象内存地址是a，那么就会以a为键， 在这个 weak 表中搜索，找到所有以a为键的 weak 对象，从而设置为 nil。
我们可以设计一个函数（伪代码）来表示上述机制：
objc_storeWeak(&amp;a, b)函数：
objc_storeWeak函数把第二个参数--赋值对象（b）的内存地址作为键值key，将第一个参数--weak修饰的属性变量（a）的内存地址（&amp;a）作为value，注册到 weak 表中。如果第二个参数（b）为0（nil），那么把变量（a）的内存地址（&amp;a）从weak表中删除，
你可以把objc_storeWeak(&amp;a, b)理解为：objc_storeWeak(value, key)，并且当key变nil，将value置nil。</code></pre>
<p>注意：</p>
<pre><code>在b非nil时，a和b指向同一个内存地址，在b变nil时，a变nil。此时向a发送消息不会崩溃：在Objective-C中向nil发送消息是安全的。

而如果a是由assign修饰的，则： 在b非nil时，a和b指向同一个内存地址，在b变nil时，a还是指向该内存地址，变野指针。此时向a发送消息极易崩溃。
原因：第一种情况a适用weak修饰 在b被置为nil的时候会遍历所有指向这块内存地址的指针 将这些指针置为ni 
    第二种情况a适用assign修饰，在b被置为nil的时候 不会将a指向的对象置为nil，所以默认a仍然指向原来的地址 但是这块地址被释放或者重新利用之后 现存的数据类型和原来的可能不一样了，所以可能出现野指针的问题</code></pre>
<h3 id="3、objc-initWeak和objc-destroyWeak解释"><a href="#3、objc-initWeak和objc-destroyWeak解释" class="headerlink" title="3、objc_initWeak和objc_destroyWeak解释"></a>3、objc_initWeak和objc_destroyWeak解释</h3><pre><code> 通过objc_initWeak函数初始化“附有weak修饰符的变量（obj1）”，在变量作用域结束时通过objc_destoryWeak函数释放该变量（obj1）。</code></pre>
<p>方法的内部实现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">objc_initWeak函数的实现是这样的：在将“附有weak修饰符的变量（obj1）”初始化为0（nil）后，会将“赋值对象”（obj）作为参数，调用objc_storeWeak函数。</span><br><span class="line"></span><br><span class="line">	obj1 &#x3D; 0；</span><br><span class="line">	obj_storeWeak(&amp;obj1, obj)</span><br></pre></td></tr></table></figure>

<p>weak 修饰的指针默认值是 nil （在Objective-C中向nil发送消息是安全的）<br>然后obj_destroyWeak函数将0（nil）作为参数，调用objc_storeWeak函数<br>objc_storeWeak(&amp;obj1, 0);</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">id obj1;</span><br><span class="line">obj1 &#x3D; 0;</span><br><span class="line">objc_storeWeak(&amp;obj1, obj);</span><br><span class="line">&#x2F;* ... obj的引用计数变为0，被置nil ... *&#x2F;</span><br><span class="line">objc_storeWeak(&amp;obj1, 0);</span><br></pre></td></tr></table></figure>
<p>objc_storeWeak函数把第二个参数–赋值对象（obj）的内存地址作为键值，将第一个参数–weak修饰的属性变量（obj1）的内存地址注册到 weak 表中。如果第二个参数（obj）为0（nil），那么把变量（obj1）的地址从weak表中删除</p>
<h3 id="4、能否向编译后得到的类中增加实例变量？能否向运行时创建的类中添加实例变量？为什么？"><a href="#4、能否向编译后得到的类中增加实例变量？能否向运行时创建的类中添加实例变量？为什么？" class="headerlink" title="4、能否向编译后得到的类中增加实例变量？能否向运行时创建的类中添加实例变量？为什么？"></a>4、能否向编译后得到的类中增加实例变量？能否向运行时创建的类中添加实例变量？为什么？</h3><pre><code>不能向编译后得到的类中增加实例变量；</code></pre>
<p>能向运行时创建的类中添加实例变量；<br>解释下：</p>
<pre><code>因为编译后的类已经注册在 runtime 中，类结构体中的 objc_ivar_list 实例变量的链表 和 instance_size 实例变量的内存大小已经确定，同时runtime 会调用 class_setIvarLayout 或 class_setWeakIvarLayout 来处理 strong weak 引用。所以不能向存在的类中添加实例变量；

运行时创建的类是可以添加实例变量，调用 class_addIvar 函数。但是得在调用 objc_allocateClassPair 之后，objc_registerClassPair 之前，原因同上。</code></pre>
<h3 id="5、runloop和线程有什么关系"><a href="#5、runloop和线程有什么关系" class="headerlink" title="5、runloop和线程有什么关系"></a>5、runloop和线程有什么关系</h3><p>1、主线程的run loop默认是启动的。<br>    iOS的应用程序里面，程序启动后会有一个如下的main()函数</p>
<pre><code>int main(int argc, char * argv[]) &#123;
@autoreleasepool &#123;
    return UIApplicationMain(argc, argv, nil,     NSStringFromClass([AppDelegate class]));
&#125;
&#125;
重点是UIApplicationMain()函数，这个方法会为main thread设置一个NSRunLoop对象，这就解释了：为什么我们的应用可以在无人操作的时候休息，需要让它干活的时候又能立马响应。
对其它线程来说，run loop默认是没有启动的，如果你需要更多的线程交互则可以手动配置和启动，如果线程只是去执行一个长时间的已确定的任务则不需要。
在任何一个 Cocoa 程序的线程中，都可以通过以下代码来获取到当前线程的 run loop 。
NSRunLoop *runloop = [NSRunLoop currentRunLoop];</code></pre>
<p><a href="http://blog.csdn.net/wzzvictory/article/details/9237973">《Objective-C之run loop详解》</a></p>
<h3 id="6、不手动指定autoreleasepool的前提下，一个autorealese对象在什么时刻释放？（比如在一个vc的viewDidLoad中创建）"><a href="#6、不手动指定autoreleasepool的前提下，一个autorealese对象在什么时刻释放？（比如在一个vc的viewDidLoad中创建）" class="headerlink" title="6、不手动指定autoreleasepool的前提下，一个autorealese对象在什么时刻释放？（比如在一个vc的viewDidLoad中创建）"></a>6、不手动指定autoreleasepool的前提下，一个autorealese对象在什么时刻释放？（比如在一个vc的viewDidLoad中创建）</h3><pre><code>分两种情况：手动干预释放时机、系统自动去释放。

手动干预释放时机--指定autoreleasepool 就是所谓的：当前作用域大括号结束时释放。
系统自动去释放--不手动指定autoreleasepool

Autorelease对象出了作用域之后，会被添加到最近一次创建的自动释放池中，并会在当前的 runloop 迭代结束时释放。</code></pre>
<p><img src="https://camo.githubusercontent.com/56f8ea718f47679e7771d247d8f6f820de2e0ab5/687474703a2f2f6936312e74696e797069632e636f6d2f32386b6f6477702e6a7067" alt="icon"></p>
<pre><code>我们都是知道： 所有 autorelease 的对象，在出了作用域之后，会被自动添加到最近创建的自动释放池中。

但是如果每次都放进应用程序的 main.m 中的 autoreleasepool 中，迟早有被撑满的一刻。这个过程中必定有一个释放的动作。何时？

在一次完整的运行循环结束之前，会被销毁。

那什么时间会创建自动释放池？运行循环检测到事件并启动后，就会创建自动释放池。

子线程的 runloop 默认是不工作，无法主动创建，必须手动创建。
@autoreleasepool 当自动释放池被销毁或者耗尽时，会向自动释放池中的所有对象发送 release 消息，释放自动释放池中的所有对象。
如果在一个vc的viewDidLoad中创建一个 Autorelease对象，那么该对象会在 viewDidAppear 方法执行前就被销毁了。
如果在一个vc的viewDidLoad中创建一个 Autorelease对象，那么该对象会在 viewDidAppear 方法执行前就被销毁了。</code></pre>
<p><a href="http://blog.sunnyxx.com/2014/10/15/behind-autorelease/">《黑幕背后的Autorelease》</a></p>
<h3 id="7、BAD-ACCESS在什么情况下出现？"><a href="#7、BAD-ACCESS在什么情况下出现？" class="headerlink" title="7、BAD_ACCESS在什么情况下出现？"></a>7、BAD_ACCESS在什么情况下出现？</h3><pre><code>访问了野指针，比如对一个已经释放的对象执行了release、访问已经释放对象的成员变量或者发消息。 死循环</code></pre>
<h3 id="8、苹果是如何实现autoreleasepool的？"><a href="#8、苹果是如何实现autoreleasepool的？" class="headerlink" title="8、苹果是如何实现autoreleasepool的？"></a>8、苹果是如何实现autoreleasepool的？</h3><pre><code>autoreleasepool 以一个队列数组的形式实现,主要通过下列三个函数完成.

objc_autoreleasepoolPush
objc_autoreleasepoolPop
objc_autorelease
看函数名就可以知道，对 autorelease 分别执行 push，和 pop 操作。销毁对象时执行release操作。</code></pre>
<p><img src="https://camo.githubusercontent.com/1e77679169328e5128722b3268bf9a488fc00ae2/687474703a2f2f6936302e74696e797069632e636f6d2f31356d666a31312e6a7067" alt="icon"></p>
<h3 id="9、-如何用GCD同步若干个异步调用？（如根据若干个url异步加载多张图片，然后在都下载完成后合成一张整图"><a href="#9、-如何用GCD同步若干个异步调用？（如根据若干个url异步加载多张图片，然后在都下载完成后合成一张整图" class="headerlink" title="9、 如何用GCD同步若干个异步调用？（如根据若干个url异步加载多张图片，然后在都下载完成后合成一张整图"></a>9、 如何用GCD同步若干个异步调用？（如根据若干个url异步加载多张图片，然后在都下载完成后合成一张整图</h3><pre><code>dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
dispatch_group_t group = dispatch_group_create();
dispatch_group_async(group, queue, ^&#123; /*加载图片1 */ &#125;);
dispatch_group_async(group, queue, ^&#123; /*加载图片2 */ &#125;);
dispatch_group_async(group, queue, ^&#123; /*加载图片3 */ &#125;); 
dispatch_group_notify(group, dispatch_get_main_queue(),     ^&#123;
        // 合并图片
&#125;);</code></pre>
<h3 id="10、apple用什么方式实现对一个对象的KVO？"><a href="#10、apple用什么方式实现对一个对象的KVO？" class="headerlink" title="10、apple用什么方式实现对一个对象的KVO？"></a>10、apple用什么方式实现对一个对象的KVO？</h3><pre><code>当你观察一个对象时，一个新的类会被动态创建。这个类继承自该对象的原本的类，并重写了被观察属性的 setter 方法。重写的 setter 方法会负责在调用原 setter 方法之前和之后，通知所有观察对象：值的更改。最后通过 isa 混写（isa-swizzling） 把这个对象的 isa 指针 ( isa 指针告诉 Runtime 系统这个对象的类是什么 ) 指向这个新创建的子类，对象就神奇的变成了新创建的子类的实例</code></pre>
<p><img src="https://camo.githubusercontent.com/9517b0d78961b5f32cf3392b99964f2e1f79fb35/687474703a2f2f6936322e74696e797069632e636f6d2f7379353775722e6a7067" alt="icon"></p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>靠谱的iOS程序员</tag>
      </tags>
  </entry>
  <entry>
    <title>数组和字典的小知识</title>
    <url>/2016/03/30/ios-arrayandDict/</url>
    <content><![CDATA[<p>最近出去面试的时候被问到了这个问题，回来之后觉得这个问题需要好好的思考一下，因此总结了几个和数组以及字典相关的知识点，目前暂未完成，有时间会陆续的完善！</p>
<a id="more"></a>

<h4 id="1、前言"><a href="#1、前言" class="headerlink" title="1、前言"></a>1、前言</h4><p>前几天出去面试一下，面试官问了一个问题</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">一个数组 使用下面两种方式获取数组中的第一个元素有什么区别</span><br><span class="line"></span><br><span class="line">数组 Arr</span><br><span class="line"></span><br><span class="line">1、arr.firstObject</span><br><span class="line">2、arr[0]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p> 当下，我只是回答了，当数组为空时，使用第一种方法获取数组的第一个元素不<br> 会崩溃，使用第二种方法获取数据的时候会发生崩溃。但是具体的原因，的确不<br> 怎么清楚，所以 回答的不怎么理想，回来之后总结一下关于这里的内容</p>
<h4 id="2、官网解释"><a href="#2、官网解释" class="headerlink" title="2、官网解释"></a>2、官网解释</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; Returns the first element of &#96;self&#96;, or &#96;nil&#96; if &#96;self&#96; is empty.</span><br><span class="line">&#x2F;&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F;&#x2F; - Complexity: O(1)</span><br><span class="line">public var first: Self.Generator.Element? &#123; get &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>相较于直接使用objectAtIndex，其实是多加了一个判断</p>
<h4 id="3、扩展"><a href="#3、扩展" class="headerlink" title="3、扩展"></a>3、扩展</h4><p>遇到这个问题，我又想到了数组的老搭档–&gt;字典</p>
<p><img src="http://i.niupic.com/images/2016/03/29/eMawJg.png" alt="icon"></p>
<p>结果很明显，都不会报错，且取出的值均为null</p>
<h4 id="4、其他"><a href="#4、其他" class="headerlink" title="4、其他"></a>4、其他</h4><p>对于具体 为什么使用arr.firstObject不会报错，目前只能<code>猜测</code>为添加了一个判空操作</p>
]]></content>
      <categories>
        <category>iOS基础</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
        <tag>NSArray</tag>
        <tag>NSDictionary</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS基础动画</title>
    <url>/2014/12/11/ios-base-animation/</url>
    <content><![CDATA[<p>简单的介绍了一下，iOS 开发过程中常用的一些基础动画，结合使用的场景能够更好的去了解和实践。</p>
<a id="more"></a>

<h3 id="1、CALayer-图层介绍"><a href="#1、CALayer-图层介绍" class="headerlink" title="1、CALayer 图层介绍"></a>1、CALayer 图层介绍</h3><p>Layer常用属性：<br>下面通过一个简单的Demo来看一下常用的属性:</p>
<p><img src="http://img.hoop8.com/attachments/1601/950757074960.png" alt="layer的常用属性"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;设置阴影</span><br><span class="line">image.layer.shadowColor &#x3D; [UIColor blackColor].CGColor;</span><br><span class="line">&#x2F;&#x2F;设置阴影的偏移</span><br><span class="line">image.layer.shadowOffset &#x3D; CGSizeMake(10, 10);</span><br><span class="line">&#x2F;&#x2F;设置不透明度</span><br><span class="line">image.layer.shadowOpacity &#x3D; 0.5;</span><br><span class="line">&#x2F;&#x2F;设置圆角</span><br><span class="line">image.layer.cornerRadius &#x3D; 10;</span><br><span class="line">&#x2F;&#x2F;必须设置 强制内部子控件支持圆角效果，少了这个设置，UIImageView将没有圆角效果</span><br><span class="line">&#x2F;&#x2F;设置之后将没有阴影效果</span><br><span class="line">image.layer.masksToBounds &#x3D; YES;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;设置边框</span><br><span class="line">image.layer.borderWidth &#x3D; 5.;</span><br><span class="line">image.layer.borderColor &#x3D; [UIColor grayColor].CGColor;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;旋转</span><br><span class="line">&#x2F;&#x2F;x轴方向缩小为原来的0.5倍</span><br><span class="line">image.layer.transform &#x3D; CATransform3DMakeScale(0.5, 1, 0);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2、图层的创建"><a href="#2、图层的创建" class="headerlink" title="2、图层的创建"></a>2、图层的创建</h3><p>1、图层的创建</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CALayer *layer &#x3D; [CALayer layer];</span><br><span class="line">layer.bounds &#x3D; CGRectMake(0, 0, 100, 100);</span><br><span class="line">layer.position &#x3D; CGPointMake(100, 100);</span><br><span class="line">&#x2F;&#x2F;锚点：指明哪一个点在position的位置</span><br><span class="line">&#x2F;&#x2F;x,y均在0-1的范围内 （0，0）为原点 （1，1）为右下角</span><br><span class="line">layer.anchorPoint &#x3D; CGPointMake(1, 1);</span><br><span class="line">layer.backgroundColor &#x3D; [UIColor redColor].CGColor;</span><br><span class="line">[self.view.layer addSublayer:layer];</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>注意区分position和anchorPoint</code></p>
<p>2、自定义图层的方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、间子类继承与CALayer,实现drawInContext:方法</span><br><span class="line">2、在控制器中设置代理，实现代理方法回执图层</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="3、CAAnimation"><a href="#3、CAAnimation" class="headerlink" title="3、CAAnimation"></a>3、CAAnimation</h3><h4 id="1、基础动画-CABasicAnimation"><a href="#1、基础动画-CABasicAnimation" class="headerlink" title="1、基础动画 CABasicAnimation"></a>1、基础动画 CABasicAnimation</h4><p>主要包括三种：形变 位置变化 旋转 都是通过设置keyPath实现的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    CABasicAnimation *anim &#x3D; [CABasicAnimation animation];</span><br><span class="line">    </span><br><span class="line">&#x2F;&#x2F;    anim.keyPath &#x3D; @&quot;bounds&quot;;  &#x2F;&#x2F;形变</span><br><span class="line">&#x2F;&#x2F;    anim.toValue &#x3D; [NSValue valueWithCGRect:CGRectMake(0, 0, 50, 50)];</span><br><span class="line">    </span><br><span class="line">&#x2F;&#x2F;    anim.keyPath &#x3D; @&quot;position&quot;; &#x2F;&#x2F;位置变化</span><br><span class="line">&#x2F;&#x2F;    anim.toValue &#x3D; [NSValue valueWithCGPoint:CGPointMake(300, 300)];  &#x2F;&#x2F;终止点的位置</span><br><span class="line">&#x2F;&#x2F;    anim.byValue &#x3D; [NSValue valueWithCGPoint:CGPointMake(100, 100)];    &#x2F;&#x2F;相对移动的位置</span><br><span class="line">    </span><br><span class="line">    anim.keyPath &#x3D; @&quot;transform&quot;; &#x2F;&#x2F;旋转</span><br><span class="line">    &#x2F;&#x2F;围绕x,y轴方向旋转</span><br><span class="line">    anim.toValue &#x3D; [NSValue valueWithCATransform3D:CATransform3DMakeRotation(M_PI_4, 1, 1, 0)];</span><br><span class="line">    </span><br><span class="line">    anim.duration &#x3D; 2.0f;</span><br><span class="line">    anim.removedOnCompletion &#x3D; NO;</span><br><span class="line">    anim.fillMode &#x3D; @&quot;forwards&quot;;</span><br><span class="line">    </span><br><span class="line">    [self.layer addAnimation:anim forKey:nil];</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="2、关键帧动画-CAKeyframeAnimation"><a href="#2、关键帧动画-CAKeyframeAnimation" class="headerlink" title="2、关键帧动画 CAKeyframeAnimation"></a>2、关键帧动画 CAKeyframeAnimation</h4><p>可以为动画设置一个路径，让某一个对象按这个路径去运动，可以设置动画的执行节奏</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    CAKeyframeAnimation *anim &#x3D; [CAKeyframeAnimation animationWithKeyPath:@&quot;position&quot;];</span><br><span class="line">    anim.removedOnCompletion &#x3D; NO;</span><br><span class="line">    &#x2F;&#x2F;保持最新的状态</span><br><span class="line">    anim.fillMode &#x3D; kCAFillModeForwards;</span><br><span class="line">    anim.duration &#x3D; 2.f;</span><br><span class="line">    CGMutablePathRef path &#x3D; CGPathCreateMutable();</span><br><span class="line">&#x2F;&#x2F;    CGPathAddRect(path, NULL, CGRectMake(0, 0, 100, 100));</span><br><span class="line">    CGPathAddEllipseInRect(path, NULL, CGRectMake(0, 0, 100, 100));</span><br><span class="line">    </span><br><span class="line">    anim.path &#x3D; path;</span><br><span class="line">    &#x2F;&#x2F;设置动画的执行节奏</span><br><span class="line">    anim.timingFunction &#x3D; [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseOut];</span><br><span class="line">    </span><br><span class="line">    [self.layer addAnimation:anim forKey:nil];</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="3、转场动画-CATransition"><a href="#3、转场动画-CATransition" class="headerlink" title="3、转场动画 CATransition"></a>3、转场动画 CATransition</h4><p>1、view的转场动画</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CATransition *transition &#x3D; [CATransition animation];</span><br><span class="line">transition.duration &#x3D; 2.f;</span><br><span class="line">transition.timingFunction &#x3D; [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseOut];</span><br><span class="line"></span><br><span class="line">transition.type &#x3D; @&quot;push&quot;;</span><br><span class="line">transition.subtype &#x3D; kCATransitionFromTop;</span><br><span class="line"></span><br><span class="line">[_animationView exchangeSubviewAtIndex:0 withSubviewAtIndex:1];</span><br><span class="line"></span><br><span class="line">[_animationView.layer addAnimation:transition forKey:@&quot;myAnimation&quot;];</span><br></pre></td></tr></table></figure>

<p>2、控制器的专场动画</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CATransition *transition &#x3D; [CATransition animation];</span><br><span class="line">transition.duration &#x3D; 2.f;</span><br><span class="line">transition.timingFunction &#x3D; [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseOut];</span><br><span class="line"></span><br><span class="line">transition.type &#x3D; @&quot;rippleEffect&quot;;</span><br><span class="line">transition.subtype &#x3D; kCATransitionFromTop;</span><br><span class="line"></span><br><span class="line">[self.navigationController.view.layer addAnimation:transition forKey:@&quot;navAnimation&quot;];</span><br><span class="line"></span><br><span class="line">DetailViewController *detailVc &#x3D; [[DetailViewController alloc] init];</span><br><span class="line">[self.navigationController showViewController:detailVc sender:nil];</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="http://img.hoop8.com/attachments/1601/5941760466397.gif" alt="icon"></p>
<p>支持的过渡效果和过渡方向</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* 过渡效果</span><br><span class="line"> fade     &#x2F;&#x2F;交叉淡化过渡(不支持过渡方向) kCATransitionFade</span><br><span class="line"> push     &#x2F;&#x2F;新视图把旧视图推出去  kCATransitionPush</span><br><span class="line"> moveIn   &#x2F;&#x2F;新视图移到旧视图上面   kCATransitionMoveIn</span><br><span class="line"> reveal   &#x2F;&#x2F;将旧视图移开,显示下面的新视图  kCATransitionReveal</span><br><span class="line"> cube     &#x2F;&#x2F;立方体翻滚效果</span><br><span class="line"> oglFlip  &#x2F;&#x2F;上下左右翻转效果</span><br><span class="line"> suckEffect   &#x2F;&#x2F;收缩效果，如一块布被抽走(不支持过渡方向)</span><br><span class="line"> rippleEffect &#x2F;&#x2F;滴水效果(不支持过渡方向)</span><br><span class="line"> pageCurl     &#x2F;&#x2F;向上翻页效果</span><br><span class="line"> pageUnCurl   &#x2F;&#x2F;向下翻页效果</span><br><span class="line"> cameraIrisHollowOpen  &#x2F;&#x2F;相机镜头打开效果(不支持过渡方向)</span><br><span class="line"> cameraIrisHollowClose &#x2F;&#x2F;相机镜头关上效果(不支持过渡方向)</span><br><span class="line">*&#x2F;</span><br><span class="line">   </span><br><span class="line">&#x2F;* 过渡方向</span><br><span class="line"> kCATransitionFromRight</span><br><span class="line"> kCATransitionFromLeft</span><br><span class="line"> kCATransitionFromBottom</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>使用的时候一定要注意，有些事苹果私有的API，小心被拒</code></p>
<h4 id="4、动画组-CAAnimationGroup"><a href="#4、动画组-CAAnimationGroup" class="headerlink" title="4、动画组 CAAnimationGroup"></a>4、动画组 CAAnimationGroup</h4><p>将几个动画放到一个动画组里，这些动画会依次执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CATransition *transition &#x3D; [CATransition animation];</span><br><span class="line">transition.duration &#x3D; 2.f;</span><br><span class="line">transition.timingFunction &#x3D; [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseOut];</span><br><span class="line"></span><br><span class="line">transition.type &#x3D; @&quot;push&quot;;</span><br><span class="line">transition.subtype &#x3D; kCATransitionFromTop;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CATransition *transition1 &#x3D; [CATransition animation];</span><br><span class="line">transition1.duration &#x3D; 2.f;</span><br><span class="line">transition1.timingFunction &#x3D; [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseOut];</span><br><span class="line"></span><br><span class="line">transition1.type &#x3D; @&quot;moveIn&quot;;</span><br><span class="line">transition1.subtype &#x3D; kCATransitionFromTop;</span><br><span class="line"></span><br><span class="line">CAAnimationGroup *group &#x3D; [CAAnimationGroup animation];</span><br><span class="line">group.animations &#x3D; @[transition,transition1];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[_animationView exchangeSubviewAtIndex:0 withSubviewAtIndex:1];</span><br><span class="line"></span><br><span class="line">[_animationView.layer addAnimation:group forKey:@&quot;myAnimation&quot;];</span><br><span class="line"></span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>UI</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
        <tag>CABaseAnimation</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS 内存管理</title>
    <url>/2016/03/04/ios-memory-management/</url>
    <content><![CDATA[<p>这篇文章简单的根据几个常见的面试题，引导出了iOS在ARC模式下仍需要注意的一些内存管理方面的小知识，本文中提到的一些知识点需要仔细的考虑。</p>
<a id="more"></a>

<h4 id="1、存储空间的类别和管理方式"><a href="#1、存储空间的类别和管理方式" class="headerlink" title="1、存储空间的类别和管理方式"></a>1、存储空间的类别和管理方式</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">1、栈区（stack）——由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。</span><br><span class="line"></span><br><span class="line">2、堆区（heap）——一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表。</span><br><span class="line"></span><br><span class="line">3、全局区（静态区）（static）——全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。程序结束后由系统释放。</span><br><span class="line"></span><br><span class="line">4、文字常量区——常量字符串就是放在这里的。程序结束后由系统释放。</span><br><span class="line"></span><br><span class="line">5、程序代码区——存放函数体的二进制代码。</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h5 id="1、NSString-str-”111”"><a href="#1、NSString-str-”111”" class="headerlink" title="1、NSString *str = @”111”"></a>1、NSString *str = @”111”</h5><p>首先str是一个指针，这种指针变量本身肯定是在栈空间，而@”111”是一个常量<br>字符串，注意iOS中NSString所指向的NSString是一个常量，分配在常量区，<br>你可能会问，常量存储区不是不能改变吗？我们可以验证下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSString *str1 &#x3D; @&quot;121&quot;;</span><br><span class="line">NSLog(@&quot;%p&quot;,str1);</span><br><span class="line">&#x2F;&#x2F; 两个打印结果相同，可以证明str1指向一个常量</span><br><span class="line">NSLog(@&quot;%p&quot;,@&quot;121&quot;);  </span><br><span class="line">&#x2F;&#x2F; 而通过subString 等方法返回的是一个新的常量,NSNumber同理</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>关于NSString的分析 可以参考<a href="https://blog.cnbluebox.com/blog/2014/04/16/nsstringte-xing-fen-xi-xue-xi/">这篇文章</a></p>
<h5 id="3、OC和C在数组表示中的区别"><a href="#3、OC和C在数组表示中的区别" class="headerlink" title="3、OC和C在数组表示中的区别"></a>3、OC和C在数组表示中的区别</h5><p><img src="http://i.niupic.com/images/2016/03/07/pg9E5w.jpg" alt="NSArray"></p>
<h5 id="2、使用copy和strong修饰数组的区别"><a href="#2、使用copy和strong修饰数组的区别" class="headerlink" title="2、使用copy和strong修饰数组的区别"></a>2、使用copy和strong修饰数组的区别</h5><p>代码：</p>
<p>@property (nonatomic, strong) NSString *str1;</p>
<p>@property (nonatomic, copy) NSString *str2;</p>
<p>结果：</p>
<p><img src="http://i.niupic.com/images/2016/03/07/3XJhmA.png" alt="string"></p>
<h5 id="3、自动释放池的使用"><a href="#3、自动释放池的使用" class="headerlink" title="3、自动释放池的使用"></a>3、自动释放池的使用</h5><p><img src="http://i.niupic.com/images/2016/03/07/wThjRM.png" alt="autorelaesepool"></p>
<p><code>附赠 </code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">测试代码耗时的方法：</span><br><span class="line">NSLog(@&quot;开始&quot;);</span><br><span class="line">CFAbsoluteTime start &#x3D; CFAbsoluteTimeGetCurrent();</span><br><span class="line">[self answer1];</span><br><span class="line">CFAbsoluteTime end &#x3D; CFAbsoluteTimeGetCurrent();</span><br><span class="line">NSLog(@&quot;外部 %f&quot;, end - start); </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="2、const关键字"><a href="#2、const关键字" class="headerlink" title="2、const关键字"></a>2、const关键字</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const char *p;</span><br><span class="line">char const *p;  </span><br><span class="line">char * const p;  </span><br><span class="line">const char * const p;</span><br><span class="line"> </span><br><span class="line">参考答案：</span><br><span class="line"></span><br><span class="line">const char *p定义了一个指向不可变的字符串的字符指针，可以这么看：const char *为类型，p是变量。</span><br><span class="line">char const *p与上一个是一样的。</span><br><span class="line">char * const p定义了一个指向字符串的指针，该指针值不可改变，即不可改变指向。这么看：char *是类型，const是修饰变量p，也就是说p是一个常量</span><br><span class="line">const char * const p定义了一个指向不可变的字符串的字符指针，且该指针也不可改变指向。这一个就很容易看出来了。两个const分别修饰，因此都是不可变的。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int age &#x3D; 10;</span><br><span class="line">int money &#x3D; 200;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; const修饰的是*p1</span><br><span class="line">int const * p1 &#x3D; &amp;age;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; const修饰的是p2</span><br><span class="line">int * const p2 &#x3D; &amp;age;</span><br><span class="line"></span><br><span class="line">*p1 &#x3D; 999; &#x2F;&#x2F; 错误</span><br><span class="line">p1 &#x3D; &amp;money;  &#x2F;&#x2F; 正确</span><br><span class="line">*p2 &#x3D; 999; &#x2F;&#x2F; 正确</span><br><span class="line">p2 &#x3D; &amp;money; &#x2F;&#x2F; 错误</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; OC字符串常量的定义</span><br><span class="line">NSString * const url &#x3D; @&quot;http:&#x2F;&#x2F;baidu.com&quot;;</span><br><span class="line">url &#x3D; @&quot;http:&#x2F;&#x2F;apple.com&quot;; &#x2F;&#x2F; 错误</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="4、static-关键字"><a href="#4、static-关键字" class="headerlink" title="4、static 关键字"></a>4、static 关键字</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static的作用</span><br><span class="line">-修饰&#96;局部变量&#96; ：修改的是&#96;生命周期&#96;</span><br><span class="line"></span><br><span class="line">1&gt; 被static修饰的局部变量，在整个程序运行过程中，都只有一份内存</span><br><span class="line">2&gt; 被static修饰的局部变量，并没有改变作用域</span><br><span class="line"></span><br><span class="line"> 修饰&#96;全局变量&#96; ： 修改的是&#96;作用域&#96;</span><br><span class="line"></span><br><span class="line">1&gt; 没有被static修饰的全局变量，能被项目中的任何文件访问</span><br><span class="line">2&gt; 被static修饰的全局变量，只能被本文件访问（定义这个变量的文件）</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="3、iOS内存管理-来自标哥"><a href="#3、iOS内存管理-来自标哥" class="headerlink" title="3、iOS内存管理(来自标哥)"></a>3、iOS内存管理(来自标哥)</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">描述一下iOS的内存管理，在开发中对于内存的使用和优化包含哪些方面。我们在开发中应该注意哪些问题。</span><br><span class="line"></span><br><span class="line">内存管理准则：谁强引用过，谁就在不再使用时使引用计数减一。</span><br><span class="line"></span><br><span class="line">对于内存的使用和优化常见的有以下方面：</span><br><span class="line"></span><br><span class="line">重用问题：如UITableViewCells、UICollectionViewCells、UITableViewHeaderFooterViews设置正确的reuseIdentifier，充分重用。</span><br><span class="line"></span><br><span class="line">尽量把views设置为不透明：当opque为NO的时候，图层的半透明取决于图片和其本身合成的图层为结果，可提高性能。</span><br><span class="line"></span><br><span class="line">不要使用太复杂的XIB&#x2F;Storyboard：载入时就会将XIB&#x2F;storyboard需要的所有资源，包括图片全部载入内存，即使未来很久才会使用。那些相比纯代码写的延迟加载，性能及内存就差了很多。</span><br><span class="line"></span><br><span class="line">选择正确的数据结构：学会选择对业务场景最合适的数组结构是写出高效代码的基础。比如，数组: 有序的一组值。使用索引来查询很快，使用值查询很慢，插入&#x2F;删除很慢。字典: 存储键值对，用键来查找比较快。集合: 无序的一组值，用值来查找很快，插入&#x2F;删除很快。</span><br><span class="line"></span><br><span class="line">gzip&#x2F;zip压缩：当从服务端下载相关附件时，可以通过gzip&#x2F;zip压缩后再下载，使得内存更小，下载速度也更快。</span><br><span class="line"></span><br><span class="line">延迟加载：对于不应该使用的数据，使用延迟加载方式。对于不需要马上显示的视图，使用延迟加载方式。比如，网络请求失败时显示的提示界面，可能一直都不会使用到，因此应该使用延迟加载。</span><br><span class="line"></span><br><span class="line">数据缓存：对于cell的行高要缓存起来，使得reload数据时，效率也极高。而对于那些网络数据，不需要每次都请求的，应该缓存起来，可以写入数据库，也可以通过plist文件存储。</span><br><span class="line"></span><br><span class="line">处理内存警告：一般在基类统一处理内存警告，将相关不用资源立即释放掉</span><br><span class="line">重用大开销对象：一些objects的初始化很慢，比如NSDateFormatter和NSCalendar，但又不可避免地需要使用它们。通常是作为属性存储起来，防止反复创建。</span><br><span class="line"></span><br><span class="line">避免反复处理数据：许多应用需要从服务器加载功能所需的常为JSON或者XML格式的数据。在服务器端和客户端使用相同的数据结构很重要。</span><br><span class="line"></span><br><span class="line">使用Autorelease Pool：在某些循环创建临时变量处理数据时，自动释放池以保证能及时释放内存。</span><br><span class="line"></span><br><span class="line">正确选择图片加载方式：详情阅读细读UIImage加载方式</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="4、数组名称与数组首元素地址"><a href="#4、数组名称与数组首元素地址" class="headerlink" title="4、数组名称与数组首元素地址"></a>4、数组名称与数组首元素地址</h4><hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int array[3] &#x3D; &#123;11, 22, 33&#125;;</span><br><span class="line">&#x2F;&#x2F; array可看做是一个指针：指向array[0]（某个数组元素），指向是int类型的数据（4个字节的数据）</span><br><span class="line">&#x2F;&#x2F; &amp;array[0]可看做是一个指针：指向array[0]（某个数组元素），指向是int类型的数据（4个字节的数据）</span><br><span class="line">&#x2F;&#x2F; &amp;array可看做是一个指针：指向array（整个数组），指向int[3]类型的数据（12个字节的数据）</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; &amp;array[0] &#x3D;&#x3D;&#x3D; array</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int array[2][3] &#x3D; &#123;</span><br><span class="line">            &#123;1, 11, 111&#125;,</span><br><span class="line">            &#123;2, 22, 222&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">&#x2F;&#x2F; array[0] : 指向array[0][0]元素（4个字节的空间）</span><br><span class="line">&#x2F;&#x2F; array[1] : 指向array[1][0]元素（4个字节的空间）</span><br><span class="line">&#x2F;&#x2F; &amp;array[0][0] : 指向array[0][0]元素（4个字节的空间）</span><br><span class="line">&#x2F;&#x2F; &amp;array[1][0] : 指向array[1][0]元素（4个字节的空间）</span><br><span class="line">&#x2F;&#x2F; array : 指向array[0]（数组&#123;1, 11, 111&#125;，12个字节的空间）</span><br><span class="line">&#x2F;&#x2F; &amp;array : 指向array（整个数组，24个字节的空间）</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; array[0] &#x3D;&#x3D;&#x3D; &amp;array[0][0]</span><br><span class="line">&#x2F;&#x2F; array[1] &#x3D;&#x3D;&#x3D; &amp;array[1][0]</span><br><span class="line">&#x2F;&#x2F; array &#x3D;&#x3D;&#x3D; &amp;array[0]</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>iOS进阶</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
        <tag>Memory Management</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS开发中的小技巧</title>
    <url>/2015/05/05/ios-develop-tips/</url>
    <content><![CDATA[<p>这篇文章主要总结了一部分iOS开发中的小技巧，有些方法对系统有依赖(iOS 8.0以上才可以使用)，一个复杂的问题，通过使用一些小技巧就可以很简单的实现。</p>
<a id="more"></a>


<p>1、<br>用 Property() 这个 macro 在编译时检查一个 class 是否包含一个 property，并取到那个 property 的名字（一个 NSString），配合 Core Data 使用非常方便。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define Property(Class, PropertyName) @(((void)(NO &amp;&amp; ((void)[Class nilObject].PropertyName, NO)), # PropertyName))</span><br></pre></td></tr></table></figure>

<p>2、设置透明的导航栏</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[self.navigationController.navigationBar setBackgroundImage:[UIImage new] forBarMetrics:UIBarMetricsDefault];</span><br><span class="line">&#x2F;&#x2F;导航栏底部线清楚</span><br><span class="line">self.navigationController.navigationBar.barStyle &#x3D; UIBarStyleBlack;</span><br><span class="line">self.navigationController.navigationBar.translucent &#x3D; YES;[self.navigationController.navigationBar setShadowImage:[UIImage new]];</span><br><span class="line">self.navigationBar.translucent &#x3D; YES;</span><br></pre></td></tr></table></figure>
<p><img src="https://pic4.zhimg.com/e844607cdaa057885b84142de2e3c297_b.jpg" alt="icon"></p>
<p>3、iOS8 以上 侧滑多按钮</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (nullable NSArray</span><br><span class="line">*)tableView:(UITableView *)tableView editActionsForRowAtIndexPath:(NSIndexPath *)indexPath</span><br><span class="line"></span><br><span class="line">返回一个UITableViewRowAction数组，每一个&quot;Action&quot;代表一个侧滑删除的Button。这样侧滑每一行Cell可以有更多按钮提供给用户交互。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>4、设置banner中的图片的时候 一般情况下对图片进行的设置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、aspect fill 让图片填充</span><br><span class="line">2、clip subviews 如果有图片宽度过宽裁剪超出部分（超出部分不会自动裁剪） </span><br></pre></td></tr></table></figure>

<p>5、使用tableviewcell的时候 最好采用注册-使用的方式不要</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if( cell &#x3D;&#x3D; nil )</span><br></pre></td></tr></table></figure>
<p>太low</p>
<p>6、最好不要再用#define定义常量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">原因：1、宏只是进行字符串替换   2  如果作为一个第三方的容易和现有的宏冲突 如果非要用 必须加上 if define</span><br><span class="line"></span><br><span class="line">如何定义常量</span><br><span class="line">static NSString const kImageWidth&#x3D; 80.f</span><br><span class="line">使用这种方式定义</span><br></pre></td></tr></table></figure>

<p>7、手动调用一个按钮的点击事件（适合于使用RAC或者block的情况）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[cell.callTeacherBtn sendActionsForControlEvents:UIControlEventTouchUpInside];</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>8、控制台输出 想要的数据</p>
<p><img src="http://ww1.sinaimg.cn/bmiddle/cb8a22eagw1eys7l6nzz5j20gb07ajsw.jpg" alt="icon"></p>
<p>这个略叼啊！！！！</p>
<p>9、tableview 动态计算行高</p>
<p>方法1：传入这个cell对应的模型，然后一次进行计算<br>方法2：传入模型，根据模型更新约束会改变的控件的约束，刷新界面，获取最下面的空间的最大高度</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;在表格cell中 计算出高度</span><br><span class="line">-(CGFloat)rowHeightWithCellModel:(HomeModel *)homeModel</span><br><span class="line">&#123;</span><br><span class="line">    _homeModel&#x3D;homeModel;</span><br><span class="line">    __weak __typeof(&amp;*self)weakSelf &#x3D; self;</span><br><span class="line">    &#x2F;&#x2F;设置标签的高度</span><br><span class="line">    [self.content mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">        &#x2F;&#x2F; weakSelf.contentLabelH  这个会调用下面的懒加载方法</span><br><span class="line">        make.height.mas_equalTo(weakSelf.contentLabelH);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 2. 更新约束</span><br><span class="line">    [self layoutIfNeeded];</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;3.  视图的最大 Y 值</span><br><span class="line">    CGFloat h&#x3D; CGRectGetMaxY(self.content.frame);</span><br><span class="line">   </span><br><span class="line">    return h+marginW; &#x2F;&#x2F;最大的高度+10</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>方法2的优化版：</p>
<pre><code>缓存行高，可以通过在这个cell对应的模型中增加一个属性，在第二次计算的事后，判断这个值是否为0如果不为0，就是用这个值</code></pre>
<p>方法3：预估行高</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">思路1：使用tableview代理方法estimatedHeightForRowAtIndexPath 给一个预估的行高，这样可以大量的减少行高的计算，但是在实际应用中，如果给出的这个预估的行高和真是的行高差别较大的时候 会出现cell窜动的现象</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="http://s6.51cto.com/wyfs02/M01/6E/F4/wKiom1WMuObjSUiVABLXImYoZ_o796.gif" alt="icon"></p>
<p>因此对于，tableview中cell有不同的样式的时候不要采用这个方法。</p>
<p>iOS8新特性方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">self.tableView.estimatedRowHeight &#x3D; 50.0f; </span><br><span class="line">self.tableView.rowHeight &#x3D; UITableViewAutomaticDimension; </span><br></pre></td></tr></table></figure>
<p>使用这种方法 苹果会帮你把行高都计算了</p>
<p>10、获取CollectionView当前cell的indexPath</p>
<p>注意：仅适用于 一个界面只显示一个cell，但是 [self.collectionView indexPathsForVisibleItems] 返回的有时候个数不只是一个 所以第三种方法是最安全的（前两种方法适用于一般的情况，不适用于二级联动的情况）</p>
<p>方法1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)collectionView:(UICollectionView *)collectionView</span><br><span class="line">  didEndDisplayingCell:(UICollectionViewCell *)cell</span><br><span class="line">    forItemAtIndexPath:(NSIndexPath *)indexPath &#123;</span><br><span class="line">    &#x2F;&#x2F; 获取当前显示的cell的下标</span><br><span class="line">    NSIndexPath *firstIndexPath &#x3D; [[self.collectionView indexPathsForVisibleItems] firstObject]; &#x2F;&#x2F;一定要第一个</span><br><span class="line">    &#x2F;&#x2F; 赋值给记录当前坐标的变量</span><br><span class="line">    self.currentIndexPath &#x3D; firstIndexPath;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)scrollViewDidEndDecelerating:(UIScrollView *)scrollView &#123;</span><br><span class="line">    &#x2F;&#x2F; 获取当前显示的cell的下标</span><br><span class="line">    NSIndexPath *firstIndexPath &#x3D; [[self.collectionView indexPathsForVisibleItems] firstObject];</span><br><span class="line">    &#x2F;&#x2F; 赋值给记录当前坐标的变量</span><br><span class="line">    self.currentIndexPath &#x3D; firstIndexPath;</span><br><span class="line">    &#x2F;&#x2F; 更新底部的数据 </span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>方法3：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)scrollViewDidEndDecelerating:(UIScrollView *)scrollView &#123;</span><br><span class="line">    &#x2F;&#x2F; 将collectionView在控制器view的中心点转化成collectionView上的坐标</span><br><span class="line">    CGPoint pInView &#x3D; [self.view convertPoint:self.collectionView.center toView:self.collectionView];</span><br><span class="line">    &#x2F;&#x2F; 获取这一点的indexPath</span><br><span class="line">    NSIndexPath *indexPathNow &#x3D; [self.collectionView indexPathForItemAtPoint:pInView];</span><br><span class="line">    &#x2F;&#x2F; 赋值给记录当前坐标的变量</span><br><span class="line">    self.currentIndexPath &#x3D; indexPathNow;</span><br><span class="line">    &#x2F;&#x2F; 更新底部的数据 </span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>11、rangeOfString:&amp;rangeOfString:option:<br>在平时的使用中大家都比较习惯使用，下面这种方式！</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSString *str &#x3D; @&quot;:&#x2F;lalalal&quot;;</span><br><span class="line"></span><br><span class="line">NSRange range &#x3D; [str rangeOfString:@&quot;:&quot;];</span><br></pre></td></tr></table></figure>
<p>但是，这里的range.lenght = 0;<br>跟重要的是 len = str.length; 结果len = 0; </p>
<p>原因：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Unicode对于组成有两种形式：合成形式与分解形式。</span><br><span class="line">而NSString的rangeOfString，这个api对此的支持是这样的。rangeOfString，默认不是按照码元来查找的，也就是不是按照literalSearch.虽然它里面包含&quot;:&quot;，但是，这两个字符可以合成另一个与其等价的字符，所以就找不到了。</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p>12、获取launchImage的方法</p>
<pre><code>launchimage程序启动过程中加载的那张图片，加载完毕就会消失，但有时候我们不希望他那么快的消失，比如需要添加广告页的时候，这时候 我们就需要获取到这张图片，把他作为背景图</code></pre>
<p>获取这张图片的方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 为不同分辨率的屏幕设置不同的图片名称，使用的时候通过拼接图片名称的方式获取，但是这种方式比较依赖于图片的命名，一旦屏幕分辨率改变了 就需要改动</span><br><span class="line"></span><br><span class="line">2、通过下面的代码 从bundle中读取，前提是 图片通过Asset.xcassets设置</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;&#96;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<pre><code>NSArray* imagesDict = [[[NSBundle mainBundle] infoDictionary] valueForKey:@&quot;UILaunchImages&quot;];
for (NSDictionary* dict in imagesDict)
&#123;
    CGSize imageSize = CGSizeFromString(dict[@&quot;UILaunchImageSize&quot;]);

    if (CGSizeEqualToSize(imageSize, viewSize) &amp;&amp; [viewOrientation isEqualToString:dict[@&quot;UILaunchImageOrientation&quot;]])
    &#123;
        launchImage = dict[@&quot;UILaunchImageName&quot;];
    &#125;
&#125;</code></pre>
<p>   launchImage 就是这张图片的名称</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">13、设置tableviewcell的分割线左对齐</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>if ([[[UIDevice currentDevice] systemVersion] floatValue] &gt;= 7) {</p>
<p>self.tableView.separatorInset = UIEdgeInsetsMake(0, 0, 0, 0);</p>
<p>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">查看更多的设置方法：</span><br><span class="line">[分割线左对齐](http:&#x2F;&#x2F;www.skyfox.org&#x2F;ios7-tableview-separatorinset-ajust.html)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">14、去掉tableview中section的headerview粘性</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>(void)scrollViewDidScroll:(UIScrollView *)scrollView<br>{<br>  CGFloat sectionHeaderHeight = 40;<br>  if (scrollView.contentOffset.y&lt;=sectionHeaderHeight&amp;&amp;scrollView.contentOffset.y&gt;=0) {  <pre><code>  scrollView.contentInset = UIEdgeInsetsMake(-scrollView.contentOffset.y, 0, 0, 0);  </code></pre>
  }<br>  else if (scrollView.contentOffset.y&gt;=sectionHeaderHeight) {  <pre><code>  scrollView.contentInset = UIEdgeInsetsMake(-sectionHeaderHeight, 0, 0, 0);  </code></pre>
  }<br>}</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">15、纯手码布局的好帮手</span><br><span class="line"></span><br><span class="line">	使用下面的这个宏，在你做界面布局的时候，有些控件通常要根据屏幕的尺寸设置，使用这个宏就可以以6P为基准，直接拿到你想要的转换之后的数值了</span><br><span class="line">	</span><br><span class="line">	#define SYRealValue(value) ((value)&#x2F;414.0f*[UIScreen mainScreen].bounds.size.width)</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">16、如何隐藏tableview中的某一行</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>(CGFloat) tableView:(UITableView *)tableView heightForRowAtIndexPath:<br>(NSIndexPath *)indexPath {<br>  return indexPath.row == 3 ? 0 : 40;<br>}</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">这样未必有效果吧，有时可能会出现：</span><br><span class="line">![图片超出喽](http:&#x2F;&#x2F;upload-images.jianshu.io&#x2F;upload_images&#x2F;139317-120fc766b0282440.png?imageMogr2&#x2F;auto-orient&#x2F;strip%7CimageView2&#x2F;2&#x2F;w&#x2F;1240)</span><br><span class="line"></span><br><span class="line">所以还需要另外一句</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>(void)tableView:(UITableView *)tableView willDisplayCell:(UITableViewCell *)cell forRowAtIndexPath:(NSIndexPath *)indexPath {<br>  cell.clipsToBounds = YES;<br>}</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">17、如何改变UITextfield的placeholder的颜色</span><br><span class="line">集成UITextfield重写这个方法</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>(void) drawPlaceholderInRect:(CGRect)rect {<br>  [[UIColor blueColor] setFill];<br>  [self.placeholder drawInRect:rect withFont:self.font lineBreakMode:UILineBreakModeTailTruncation alignment:self.textAlignment];<br>}</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">也可以使用KVC</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>[textField setValue:[UIColor blueColor] forKeyPath:@”_placeholderLabel.textColor”]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">18、本来我的statusbar是lightcontent的，结果用UIImagePickerController会导致我的statusbar的样式变成黑色，怎么办？</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>(void)navigationController:(UINavigationController *)navigationController willShowViewController:(UIViewController *)viewController animated:(BOOL)animated<br>{<br>  [[UIApplication sharedApplication] setStatusBarStyle:UIStatusBarStyleLightContent];<br>}</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">19、如何修改tableviewcell中选中符号的颜色</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>_mTableView.tintColor = [UIColor redColor];</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">20、ScrollView莫名其妙不能在viewController划到顶怎么办?</span><br><span class="line"></span><br><span class="line">这个可能是设置了导航栏的背景图片导致的</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>self.automaticallyAdjustsScrollViewInsets = NO;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">21、怎么点击self.view就让键盘收起,需要添加一个tapGestures么</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>(void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event<br>{<br> [self.view endEditing:YES];<br>}</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">22、怎么像safari一样滑动的时候隐藏navigationbar?</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>navigationController.hidesBarsOnSwipe = Yes</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">23、打印app中的所有windows</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>UIWindow 的私有类方法<br>+allWindowsIncludingInternalWindows: onlyVisibleWindows:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">![icon](http:&#x2F;&#x2F;ww1.sinaimg.cn&#x2F;mw690&#x2F;92172277jw1f2e25kp8ihj20mn06xjti.jpg)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">24、收起键盘的几种方式</span><br><span class="line"></span><br><span class="line">1、点击return 收起键盘</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>首先，设置键盘的return键，同事设置UITextFieldDelegate为self<br>然后，实现代理方法textFieldShouldReturn，在这个方法中让textField放弃第一响应者</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">2、点击背景后收起键盘</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>(void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches<br>withEvent:(UIEvent *)event{<br>   //实现该方法是需要注意view需要是继承UIControl而来的<br>  [self.view endEditing:YES];<br>}</li>
</ul>
<p>这里也可以添加一个手势UITapGestureRecognizer</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">3、不用view实现endEditing方法</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果比较难获得viewController的view时，可以采用这个方法</p>
<p>[[[UIApplication sharedApplication] keyWindow]<br>endEditing:YES];</p>
<p>或者</p>
<p>[[UIApplication sharedApplication] sendAction:@selector(resignFirstResponder) to:nil from:nil forEvent:nil];</p>
<pre><code>

25、导出沙盒文件

plist文件中加入
Application supports iTunes file sharing
YES
在iTunes中就可以看到沙盒文件了

、、、、、、未完待续、、、、、、
</code></pre>
]]></content>
      <categories>
        <category>iOS基础</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
        <tag>tips</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS 多控制器管理</title>
    <url>/2016/03/07/ios-multiVc-manager/</url>
    <content><![CDATA[<p>我们在日常开发中，经常会用到多控制器管理，实际上，在多控制器中，我们有<br>很多地方需要注意，否则可能会出现一些，不容易调试和定位的错误，大大的消<br>耗了我们的时间和精力，所以，本片文章中提到的内容一定要注意。</p>
<a id="more"></a>

<h3 id="多控制器管理铁则"><a href="#多控制器管理铁则" class="headerlink" title="多控制器管理铁则"></a>多控制器管理铁则</h3><hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">如果2个控制器的view是父子关系，那么这2个控制器也应该为父子关系</span><br><span class="line">[vc01.view addSubview: vc02.view];</span><br><span class="line">[vc01 addChildViewController: vc02];</span><br><span class="line">&#x2F;&#x2F; 会将vc02添加到vc01.childViewControllers数组中</span><br><span class="line">&#x2F;&#x2F;  vc01.childViewControllers --&gt; @[vc02]</span><br></pre></td></tr></table></figure>

<h4 id="在一个大控制器里面切换多个小控制器的步骤"><a href="#在一个大控制器里面切换多个小控制器的步骤" class="headerlink" title="在一个大控制器里面切换多个小控制器的步骤"></a>在一个大控制器里面切换多个小控制器的步骤</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1&gt; 通过addChildViewController方法，将有可能显示的小控制器变为大控制器的子控制器</span><br><span class="line">[self addChildViewController:[[HMOneViewController alloc] init]];</span><br><span class="line">[self addChildViewController:[[HMTwoViewController alloc] init]];</span><br><span class="line">[self addChildViewController:[[HMThreeViewController alloc] init]];</span><br><span class="line">    </span><br><span class="line">2&gt; 在大控制器中声明一个属性，用来记录当前正在显示的子控制器</span><br><span class="line">@property (nonatomic, weak) UIViewController *showingChildVc;</span><br><span class="line"></span><br><span class="line">3&gt; 需要提供一个方法，来切换子控制器</span><br><span class="line">&#x2F;&#x2F; index : 即将需要显示的子控制器的索引</span><br><span class="line">- (void)switchVc:(int)index</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; 1.移除当前正在显示的子控制器view</span><br><span class="line">    [self.showingChildVc.view removeFromSuperview];</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 2.添加index位置对应控制器的view</span><br><span class="line">    UIViewController *newVc &#x3D; self.childViewControllers[index];</span><br><span class="line">    newVc.view.frame &#x3D; CGRectMake(0, 44, self.view.frame.size.width, self.view.frame.size.height - 44);</span><br><span class="line">    [self.view addSubview:newVc.view];</span><br><span class="line">    self.showingChildVc &#x3D; newVc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="不建立控制器父子关系的后果"><a href="#不建立控制器父子关系的后果" class="headerlink" title="不建立控制器父子关系的后果"></a>不建立控制器父子关系的后果</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">内部的小控制器可能会发生以下情况：</span><br><span class="line">1&gt; 无法察觉到比较重大的系统事件发生了（比如屏幕旋转事件）</span><br><span class="line">2&gt; 可能会导致self.navigationController &#x3D;&#x3D; nil、self.tabBarController &#x3D;&#x3D; nil</span><br><span class="line">3&gt; 可能会导致[self dismissViewControllerAnimated:YES completion:nil]无效（无法关闭控制器）</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>iOS基础</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
        <tag>多控制器</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS 第三方支付</title>
    <url>/2016/03/07/ios-third-payment/</url>
    <content><![CDATA[<p>APP中我们常用的第三方支付主要是：微信支付和支付宝支付，去年公司的项目<br>中加入了两种支付方式，特地总结如下：</p>
<a id="more"></a>

<h4 id="支付流程"><a href="#支付流程" class="headerlink" title="支付流程"></a>支付流程</h4><h5 id="1、支付流程图"><a href="#1、支付流程图" class="headerlink" title="1、支付流程图"></a>1、支付流程图</h5><p><img src="https://pay.weixin.qq.com/wiki/doc/api/img/chapter8_3_1.png" alt="支付流程图"></p>
<h5 id="2、添加URL"><a href="#2、添加URL" class="headerlink" title="2、添加URL"></a>2、添加URL</h5><p><img src="http://i.niupic.com/images/2016/03/08/6m4jJv.png" alt="icon"></p>
<h5 id="3、导入SDK"><a href="#3、导入SDK" class="headerlink" title="3、导入SDK"></a>3、导入SDK</h5><p><img src="http://i.niupic.com/images/2016/03/08/bBUVlA.png" alt="SDK"></p>
<h5 id="4、注册自己的微信ID"><a href="#4、注册自己的微信ID" class="headerlink" title="4、注册自己的微信ID"></a>4、注册自己的微信ID</h5><p><img src="http://i.niupic.com/images/2016/03/08/4a26sD.png" alt="icon"></p>
<h5 id="5、具体流程"><a href="#5、具体流程" class="headerlink" title="5、具体流程"></a>5、具体流程</h5><h6 id="1、点击支付"><a href="#1、点击支付" class="headerlink" title="1、点击支付"></a>1、点击支付</h6><p>需要判断是保证金支付还是订单支付，下面的方法以微信支付为例</p>
<h6 id="2、获取订单信息（服务端交互）"><a href="#2、获取订单信息（服务端交互）" class="headerlink" title="2、获取订单信息（服务端交互）"></a>2、获取订单信息（服务端交互）</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;保证金支付</span><br><span class="line">- (RACSignal *)wechatPayDepositWithOrder:(ArtOrder *)order</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;订单支付</span><br><span class="line">- (RACSignal *)wechatPayWithOrder:(ArtOrder *)order</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里订单支付和保证金支付有点不同：</p>
<p>保证金支付是与这个订单无关的，所以在与服务端交互的时候不需要传递具体上项目或者商品的相关信息，只是传递一个保证金的金额即可，而在订单支付的过程中，我们需要将这次付款行为的商品相关信息传递给服务端。然后服务端与微信提供的接口进行交互获取订单信息</p>
<h6 id="3、获取订单信息"><a href="#3、获取订单信息" class="headerlink" title="3、获取订单信息"></a>3、获取订单信息</h6><p>与服务端交互完成后会返回一个PayReq的对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*! @brief 第三方向微信终端发起支付的消息结构体</span><br><span class="line"> *</span><br><span class="line"> *  第三方向微信终端发起支付的消息结构体，微信终端处理后会向第三方返回处理结果</span><br><span class="line"> * @see PayResp</span><br><span class="line"> *&#x2F;</span><br><span class="line">@interface PayReq : BaseReq</span><br><span class="line"></span><br><span class="line">&#x2F;** 商家向财付通申请的商家id *&#x2F;</span><br><span class="line">@property (nonatomic, retain) NSString *partnerId;</span><br><span class="line">&#x2F;** 预支付订单 *&#x2F;</span><br><span class="line">@property (nonatomic, retain) NSString *prepayId;</span><br><span class="line">&#x2F;** 随机串，防重发 *&#x2F;</span><br><span class="line">@property (nonatomic, retain) NSString *nonceStr;</span><br><span class="line">&#x2F;** 时间戳，防重发 *&#x2F;</span><br><span class="line">@property (nonatomic, assign) UInt32 timeStamp;</span><br><span class="line">&#x2F;** 商家根据财付通文档填写的数据和签名 *&#x2F;</span><br><span class="line">@property (nonatomic, retain) NSString *package;</span><br><span class="line">&#x2F;** 商家根据微信开放平台文档对数据做的签名 *&#x2F;</span><br><span class="line">@property (nonatomic, retain) NSString *sign;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><a href="http://www.jianshu.com/p/362fcbbf107c">参数详细介绍</a></p>
<h5 id="4、调用微信API等待返回"><a href="#4、调用微信API等待返回" class="headerlink" title="4、调用微信API等待返回"></a>4、调用微信API等待返回</h5><p>从服务端获取到了订单的信息之后，需要调用微信的API提供的这个接口，传递数据，跳转到微信客户端 用户进行支付，自己的应用等待用户操作之后的回调</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*! @brief 发送请求到微信，等待微信返回onResp</span><br><span class="line"> *</span><br><span class="line"> * 函数调用后，会切换到微信的界面。第三方应用程序等待微信返回onResp。微信在异步处理完成后一定会调用onResp。支持以下类型</span><br><span class="line"> * SendAuthReq、SendMessageToWXReq、PayReq等。</span><br><span class="line"> * @param req 具体的发送请求，在调用函数后，请自己释放。</span><br><span class="line"> * @return 成功返回YES，失败返回NO。</span><br><span class="line"> *&#x2F;</span><br><span class="line"> </span><br><span class="line">+(BOOL) sendReq:(BaseReq*)req;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h6 id="5、-用户进行支付操作"><a href="#5、-用户进行支付操作" class="headerlink" title="5、 用户进行支付操作"></a>5、 用户进行支付操作</h6><p><img src="http://i.niupic.com/images/2016/03/08/NKqM4k.png" alt="pay1"></p>
<h6 id="6、-支付结果回调"><a href="#6、-支付结果回调" class="headerlink" title="6、 支付结果回调"></a>6、 支付结果回调</h6><p><img src="http://i.niupic.com/images/2016/03/08/rPZfFA.png" alt="pay2"></p>
<p>支付动作结束之后，微信会调用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*! @brief 发送一个sendReq后，收到微信的回应</span><br><span class="line"> *</span><br><span class="line"> * 收到一个来自微信的处理结果。调用一次sendReq后会收到onResp。</span><br><span class="line"> * 可能收到的处理结果有SendMessageToWXResp、SendAuthResp等。</span><br><span class="line"> * @param resp具体的回应内容，是自动释放的</span><br><span class="line"> *&#x2F;</span><br><span class="line"> </span><br><span class="line">-(void) onResp:(BaseResp*)resp;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里根据返回的状态码做出对应的操作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">switch (resp.errCode) &#123;</span><br><span class="line">            case WXSuccess:&#123;</span><br><span class="line">                NSLog(@&quot;支付成功－PaySuccess，retcode &#x3D; %d&quot;, </span><br><span class="line">                							resp.errCode);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            case WXErrCodeCommon:&#123;</span><br><span class="line">                errorMessage &#x3D; @&quot;支付失败&quot;;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            case WXErrCodeUserCancel:&#123;</span><br><span class="line">                errorMessage &#x3D; @&quot;用户中途取消&quot;;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            default:&#123;</span><br><span class="line">                NSLog(@&quot;错误，retcode &#x3D; %d, retstr &#x3D; %@&quot;, </span><br><span class="line">                		resp.errCode,resp.errStr);</span><br><span class="line">                errorMessage &#x3D; @&quot;支付失败&quot;;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这样，本次支付就结束了。可以进行下面的操作啦………………</p>
<h5 id="6、微信、支付宝支付中常见的问题"><a href="#6、微信、支付宝支付中常见的问题" class="headerlink" title="6、微信、支付宝支付中常见的问题"></a>6、微信、支付宝支付中常见的问题</h5><ul>
<li><p>1、一定要添加下面的回调</p>
<p>  [[AlipaySDK defaultService] </p>
<pre><code>                  processOrderWithPaymentResult:url
                   standbyCallback:^(NSDictionary
                                        *resultDic) &#123;</code></pre>
<p>  }];<br>  否则可能收不到支付结果的回调</p>
</li>
</ul>
<p> <code>未完…………………………</code></p>
]]></content>
      <categories>
        <category>支付</category>
      </categories>
      <tags>
        <tag>支付</tag>
      </tags>
  </entry>
  <entry>
    <title>ios异常处理之try-catch-finally</title>
    <url>/2018/04/12/ios-try-catch/</url>
    <content><![CDATA[<p>OC中的异常一般是通过传递一个NSError的对象到方法中,如果方法执行错误会直接返回。并没有像JAVA一样大量使用Try catch进行异常的捕获。这是因为try catch无法捕获UncaughtException，而oc中大部分crash如：内存溢出、野指针等都是无法捕获的，而能捕获的只是像数组越界之类。所以try catch对于oc来说，比较鸡肋。虽说是鸡肋 但是我们在某些情况下还是有用的 这里简单介绍一下。</p>
<a id="more"></a>

<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p><img src="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Exceptions/Tasks/Art/flow_control_directive.gif" alt="语法"></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@try</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 业务逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@catch</span> (异常类型名<span class="number">1</span> ex)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//异常处理代码</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@catch</span> (异常类型名<span class="number">2</span> ex)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//异常处理代码</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 可以捕捉 N 个 异常 ...</span></span><br><span class="line"><span class="keyword">@finally</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//回收资源</span></span><br><span class="line">&#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure>

<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)catchException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSArray</span>* array = [[<span class="built_in">NSArray</span> alloc] init];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">@try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Attempt access to an empty array</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;Object: %@&quot;</span>, [array objectAtIndex:<span class="number">0</span>]);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//虽然支持捕捉特定类型的NSException 但是 异常的类型确只有NSException这一种 奇怪</span></span><br><span class="line">    <span class="keyword">@catch</span> (<span class="built_in">NSException</span> *exception)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Print exception information</span></span><br><span class="line">        <span class="built_in">NSLog</span>( <span class="string">@&quot;NSException caught&quot;</span> );</span><br><span class="line">        <span class="built_in">NSLog</span>( <span class="string">@&quot;Name: %@&quot;</span>, exception.name);</span><br><span class="line">        <span class="built_in">NSLog</span>( <span class="string">@&quot;Reason: %@&quot;</span>, exception.reason );</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">@finally</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Cleanup, in both success and fail cases</span></span><br><span class="line">        <span class="built_in">NSLog</span>( <span class="string">@&quot;In finally block&quot;</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2018-04-12 17:07:21.895703+0800 TryCatch_Demo[65406:18722039] NSException caught</span><br><span class="line">2018-04-12 17:07:21.895808+0800 TryCatch_Demo[65406:18722039] Name: NSRangeException</span><br><span class="line">2018-04-12 17:07:21.895889+0800 TryCatch_Demo[65406:18722039] Reason: *** -[__NSArray0 objectAtIndex:]: index 0 beyond bounds for empty NSArray</span><br><span class="line">2018-04-12 17:07:21.895970+0800 TryCatch_Demo[65406:18722039] In finally block</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Apple虽然同时提供了错误处理（NSError）和异常处理（exception）两种机制，但是Apple更加提倡开发者使用NSError来处理程序运行中可恢复的错误。而异常被推荐用来处理不可恢复的错误。</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Exceptions/Tasks/HandlingExceptions.html">官方文档</a></p>
<p><a href="https://www.jianshu.com/p/1cb65e05b3ed">Objective-C中try/catch/finally 使用</a></p>
<p><a href="https://www.jianshu.com/p/f28b9b3f8e44">iOS @try @catch异常机制</a></p>
]]></content>
      <categories>
        <category>iOS优化</category>
      </categories>
      <tags>
        <tag>try catch finally</tag>
      </tags>
  </entry>
  <entry>
    <title>iphone手机流量、内存监控插件</title>
    <url>/2016/09/05/iosuserful%E6%8F%92%E4%BB%B6/</url>
    <content><![CDATA[<p>大家都知道，iOS系统中没有实时流量监控的功能，尤其是最近我们在做直播功能的时候需要知道不同的分辨率我们的推拉流过程中的实时网速，还有一个是实时的查看APP的内存使用情况。</p>
<a id="more"></a>

<h4 id="1、实时流量监控"><a href="#1、实时流量监控" class="headerlink" title="1、实时流量监控"></a>1、实时流量监控</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (NSString *)getDataCounters</span><br><span class="line">&#123;</span><br><span class="line">    BOOL   success;</span><br><span class="line">    struct ifaddrs *addrs;</span><br><span class="line">    const struct ifaddrs *cursor;</span><br><span class="line">    const struct if_data *networkStatisc;</span><br><span class="line">    </span><br><span class="line">    static int SZNetSent &#x3D; 0;</span><br><span class="line">    static int SZNetReceived &#x3D; 0;</span><br><span class="line">    int NetSent &#x3D; 0;</span><br><span class="line">    int NetReceived &#x3D; 0;</span><br><span class="line">    </span><br><span class="line">    NSString *name&#x3D;[[NSString alloc]init];</span><br><span class="line">    </span><br><span class="line">    success &#x3D; getifaddrs(&amp;addrs) &#x3D;&#x3D; 0;</span><br><span class="line">    if (success)</span><br><span class="line">    &#123;</span><br><span class="line">        cursor &#x3D; addrs;</span><br><span class="line">        while (cursor !&#x3D; NULL)</span><br><span class="line">        &#123;</span><br><span class="line">            </span><br><span class="line">            name&#x3D;[NSString stringWithFormat:</span><br><span class="line">            					@&quot;%s&quot;,cursor-&gt;ifa_name];</span><br><span class="line">            </span><br><span class="line">            if (cursor-&gt;ifa_addr-&gt;sa_family &#x3D;&#x3D; AF_LINK)</span><br><span class="line">            &#123;</span><br><span class="line">                if ([name hasPrefix:@&quot;en&quot;])</span><br><span class="line">                &#123;</span><br><span class="line">                    networkStatisc &#x3D;</span><br><span class="line">               			(const struct if_data *) cursor</span><br><span class="line">                    		-&gt;ifa_data;</span><br><span class="line">                    </span><br><span class="line">                    NetSent+&#x3D;networkStatisc-&gt;ifi_obytes;</span><br><span class="line">                    </span><br><span class="line">                    NetReceived+&#x3D;networkStatisc-</span><br><span class="line">                    						&gt;ifi_ibytes;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                if ([name hasPrefix:@&quot;pdp_ip&quot;])</span><br><span class="line">                &#123;</span><br><span class="line">                    networkStatisc &#x3D; </span><br><span class="line">                    (const struct if_data *) cursor</span><br><span class="line">                    						-&gt;ifa_data;</span><br><span class="line">                    						</span><br><span class="line">                    NetSent+&#x3D;networkStatisc-&gt;ifi_obytes;</span><br><span class="line">                    NetReceived+&#x3D;</span><br><span class="line">                    		networkStatisc-&gt;ifi_ibytes;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            cursor &#x3D; cursor-&gt;ifa_next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        freeifaddrs(addrs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    CGFloat CZNetSent &#x3D; NetSent - SZNetSent;</span><br><span class="line">    CGFloat CZNetReceived &#x3D; NetReceived - SZNetReceived;</span><br><span class="line">    SZNetSent &#x3D; NetSent;</span><br><span class="line">    SZNetReceived &#x3D; NetReceived;</span><br><span class="line">    </span><br><span class="line">    NSString *str &#x3D; [NSString stringWithFormat:@&quot;%3.2f -</span><br><span class="line">    				 %3.2f KB&#x2F;s&quot;, CZNetSent &#x2F; 1024.,</span><br><span class="line">     				CZNetReceived &#x2F; 1024.];</span><br><span class="line">    return str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h4 id="2、APP内存使用情况"><a href="#2、APP内存使用情况" class="headerlink" title="2、APP内存使用情况"></a>2、APP内存使用情况</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、获取APP已使用的内存</span><br><span class="line"></span><br><span class="line">vm_size_t usedMemory(void) &#123;</span><br><span class="line">    struct task_basic_info info;</span><br><span class="line">    mach_msg_type_number_t size &#x3D; sizeof(info);</span><br><span class="line">    kern_return_t kerr &#x3D; task_info(mach_task_self(), TASK_BASIC_INFO, (task_info_t)&amp;info, &amp;size);</span><br><span class="line">    return (kerr &#x3D;&#x3D; KERN_SUCCESS) ? info.resident_size : 0; &#x2F;&#x2F; size in bytes</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">2、获取可以使用的内存</span><br><span class="line">vm_size_t freeMemory(void) &#123;</span><br><span class="line">    mach_port_t host_port &#x3D; mach_host_self();</span><br><span class="line">    mach_msg_type_number_t host_size &#x3D; sizeof(vm_statistics_data_t) &#x2F; sizeof(integer_t);</span><br><span class="line">    vm_size_t pagesize;</span><br><span class="line">    vm_statistics_data_t vm_stat;</span><br><span class="line">    </span><br><span class="line">    host_page_size(host_port, &amp;pagesize);</span><br><span class="line">    (void) host_statistics(host_port, HOST_VM_INFO, (host_info_t)&amp;vm_stat, &amp;host_size);</span><br><span class="line">    return vm_stat.free_count * pagesize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>经过测试这个方法与实际Xcode中显示的内存有一定的差距。不过在用于显示内存占用变化情况的时候还是可以使用的</code></p>
]]></content>
      <categories>
        <category>iOS开发插件</category>
      </categories>
      <tags>
        <tag>流量监控</tag>
        <tag>iOS</tag>
        <tag>内存监控</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS 跳转到设置界面</title>
    <url>/2015/12/05/jump-to-setting/</url>
    <content><![CDATA[<p>在APP开发中 我们会经常遇到，要跳转到设置的某个界面提示用户去设置（开启<br>定位或者其他功能），下面详细的介绍了，跳转到每一个界面的方法</p>
<a id="more"></a>

<h4 id="1、方法"><a href="#1、方法" class="headerlink" title="1、方法"></a>1、方法</h4><p>例子：跳转到定位服务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;定位服务设置界面</span><br><span class="line">NSURL *url &#x3D; [NSURL URLWithString:@&quot;prefs:root&#x3D;LOCATION_SERVICES&quot;];</span><br><span class="line">if ([[UIApplication sharedApplication] canOpenURL:url])</span><br><span class="line">&#123;</span><br><span class="line">    [[UIApplication sharedApplication] openURL:url];</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>其他界面也是一个类型，不过URL改变一下就可以</p>
<h4 id="2、跳转类型"><a href="#2、跳转类型" class="headerlink" title="2、跳转类型"></a>2、跳转类型</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">About — prefs:root&#x3D;General&amp;path&#x3D;About	&#x2F;&#x2F;关于本机</span><br><span class="line">Airplane Mode On — prefs:root&#x3D;AIRPLANE_MODE  &#x2F;&#x2F;飞行模式</span><br><span class="line">Auto-Lock — prefs:root&#x3D;General&amp;path&#x3D;AUTOLOCK &#x2F;&#x2F;屏幕锁定</span><br><span class="line">Bluetooth — prefs:root&#x3D;General&amp;path&#x3D;Bluetooth	&#x2F;&#x2F;蓝牙设置</span><br><span class="line">Date &amp; Time — prefs:root&#x3D;General&amp;path&#x3D;DATE_AND_TIME &#x2F;&#x2F;日期时间</span><br><span class="line">FaceTime — prefs:root&#x3D;FACETIME	&#x2F;&#x2F;FaceTime 设置</span><br><span class="line">General — prefs:root&#x3D;General	&#x2F;&#x2F;通用</span><br><span class="line">Keyboard — prefs:root&#x3D;General&amp;path&#x3D;Keyboard	&#x2F;&#x2F;键盘</span><br><span class="line">iCloud — prefs:root&#x3D;CASTLE	 &#x2F;&#x2F;iCloud 用户设置</span><br><span class="line">iCloud Storage &amp; Backup  </span><br><span class="line">prefs:root&#x3D;CASTLE&amp;path&#x3D;STORAGE_AND_BACKUP &#x2F;&#x2F;iCloud 存储空间</span><br><span class="line">International — prefs:root&#x3D;General&amp;path&#x3D;INTERNATIONAL	&#x2F;&#x2F;语言地区</span><br><span class="line">Location Services — prefs:root&#x3D;LOCATION_SERVICES &#x2F;&#x2F;定位服务</span><br><span class="line">Network — prefs:root&#x3D;General&amp;path&#x3D;Network	&#x2F;&#x2F;通用并非网络</span><br><span class="line">Notes — prefs:root&#x3D;NOTES	&#x2F;&#x2F;备忘录</span><br><span class="line">Notification — prefs:root&#x3D;NOTIFICATIONS_ID &#x2F;&#x2F;通知	</span><br><span class="line">Photos — prefs:root&#x3D;Photos &#x2F;&#x2F;照片与相机</span><br><span class="line">Profile — prefs:root&#x3D;General&amp;path&#x3D;ManagedConfigurationList</span><br><span class="line">&#x2F;&#x2F; 描述文件</span><br><span class="line">Reset — prefs:root&#x3D;General&amp;path&#x3D;Reset &#x2F;&#x2F;还原</span><br><span class="line">Sounds — prefs:root&#x3D;Sounds	&#x2F;&#x2F;声音</span><br><span class="line">Software Update — 	prefs:root&#x3D;General&amp;path&#x3D;SOFTWARE_UPDATE_LINK &#x2F;&#x2F;软件更新</span><br><span class="line">Wallpaper — prefs:root&#x3D;Wallpaper &#x2F;&#x2F;墙纸</span><br><span class="line">Wi-Fi — prefs:root&#x3D;WIFI	&#x2F;&#x2F;WiFi</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>总结：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">希望这篇文章可以帮到你！</span><br></pre></td></tr></table></figure>

<p>参考文章:<a href="http://www.superqq.com/blog/2015/12/01/jump-setting-per-page/">iOS开发之如何跳到系统设置里的各种设置界面</a></p>
]]></content>
      <categories>
        <category>iOS基础</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
        <tag>SystemJump</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程 相关概念</title>
    <url>/2016/03/17/multThread-concept/</url>
    <content><![CDATA[<p>这篇文章主要是记录了，我在学习多线程过程中觉得比较重要概念，在这里做一下总结。</p>
<p>文章还会陆续的增加内容，需要持续的更新……</p>
<a id="more"></a>

<h4 id="1、自动释放池"><a href="#1、自动释放池" class="headerlink" title="1、自动释放池"></a>1、自动释放池</h4><h5 id="1、基本定义"><a href="#1、基本定义" class="headerlink" title="1、基本定义"></a>1、基本定义</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">工作原理：自动释放池被销毁或耗尽时会向池中所有对象发送release消息，释放所有的autorelease对象</span><br><span class="line"></span><br><span class="line">创建和销毁：每一次运行循环启动会后会自动创建自动释放池</span><br><span class="line"></span><br><span class="line">程序执行过程中，所有autorelease对象在出了作用域之后，会被添加到最近创建的自动释放池中</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="2、图片示意"><a href="#2、图片示意" class="headerlink" title="2、图片示意"></a>2、图片示意</h5><p><img src="http://i.niupic.com/images/2016/03/21/kFsujE.png" alt="autoreleasepool"></p>
<h4 id="2、运行循环"><a href="#2、运行循环" class="headerlink" title="2、运行循环"></a>2、运行循环</h4><h5 id="1、作用和特性"><a href="#1、作用和特性" class="headerlink" title="1、作用和特性"></a>1、作用和特性</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">作用：保证程序不退出，监听所有时间（手势触摸、时钟触发）</span><br><span class="line"></span><br><span class="line">特性：没有事件时，会休眠，一旦监听到事件，就会立即响应</span><br><span class="line"></span><br><span class="line">每一个线程都有一个runloop 但是主线程的runloop会默认启动（其他线程的runloop默认是关闭的）</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="2、开启一个运行循环的两种种方法"><a href="#2、开启一个运行循环的两种种方法" class="headerlink" title="2、开启一个运行循环的两种种方法"></a>2、开启一个运行循环的两种种方法</h5><ul>
<li>1、 [[NSRunLoop currentRunLoop] run]</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">这种方法一旦开启了运行循环就再也关不了了，也就是说这之后的程序都无法执行了</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>2、间隔主动调用</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">每隔一段时间，主动调用一次运行循环并且持续一段时间（这就可以响应这段时间内发生的事件），主动调用可以通过设置标志的方法实现 </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="http://i.niupic.com/images/2016/03/21/0uKCZP.png" alt="runloop"></p>
<h4 id="3、简述retain、strong、assign、weak、copy有什么区别？"><a href="#3、简述retain、strong、assign、weak、copy有什么区别？" class="headerlink" title="3、简述retain、strong、assign、weak、copy有什么区别？"></a>3、简述retain、strong、assign、weak、copy有什么区别？</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-retain：是MRC，在设置数值的时候，会对引用计数器+1</span><br><span class="line">-strong：是ARC,与retain等效</span><br><span class="line">-assign:是ARC&#x2F;MRC都有，在设置数值时不会做任何的附加操作</span><br><span class="line">    	-MRC中如果不需要引用，就直接使用assign</span><br><span class="line">    	-ARC中通常是用来保存基本数据类型</span><br><span class="line">-weak是ARC的，用来保存不需要强引用的对象</span><br><span class="line">-weak和assign的区别</span><br><span class="line">    -assign 指向的对象如果被释放，地址不会有任何变化，效率高，但是风险大，容易造成野指针错误</span><br><span class="line">    -weak 指向的对象如果被释放，地址会立即变为nil ,但是在OC中向nil（空指针）发送消息的时候不会报错</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="4、响应者链条"><a href="#4、响应者链条" class="headerlink" title="4、响应者链条"></a>4、响应者链条</h4><p>说一下点击了按钮之后，按钮响应点击事件的原理</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">程序启动之后，会创建一个程序的代理（AppDelegate）,didFinishLaunchingWithOptions之后创建一个主运</span><br><span class="line">行循环（主运行循环的作用是可以保证程序不退出、负责监听所有事件）当按钮</span><br><span class="line">被点击的时候，事件会通过按钮传递给视图（view）进而传递给控制器，然后依</span><br><span class="line">次上传到UIWindow，最后到达运行循环，告诉运行循环，btn被点击了，这时</span><br><span class="line">候运行循环就会给控制器发消息，告诉控制器按钮被点击了，然后在从上向下的</span><br><span class="line">传递过程中，会一次寻找最合适的响应者，而寻找最合适相应者的过程中是通过</span><br><span class="line">hitTest方法递归的一层一层的去寻找（主要用到的方法是：hitTest,pointInside方法）</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="5、TCP和UDP的区别"><a href="#5、TCP和UDP的区别" class="headerlink" title="5、TCP和UDP的区别"></a>5、TCP和UDP的区别</h4> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> </span><br><span class="line">UDP:(用户数据报协议)---前身是电报</span><br><span class="line"></span><br><span class="line">		-只管发送，不确认对方是否接收到</span><br><span class="line">		-将数据及源和目的封装成数据包中，不需要建立连接</span><br><span class="line">		-每个数据报的大小限制在64K之内</span><br><span class="line">		-因为无需连接，因此是不可靠协议</span><br><span class="line">		-不需要建立连接，速度快</span><br><span class="line">		-应用：多媒体教室、流媒体视频、广播 实际开发中用的少</span><br><span class="line">		</span><br><span class="line">TCP:(传输控制协议)</span><br><span class="line"></span><br><span class="line">		-建立连接，行程传输数据的通道</span><br><span class="line">		-在连接中进行大数据传输（数据大小不受限制）</span><br><span class="line">		-通过三次握手完成连接，是可靠协议，安全送达</span><br><span class="line">		-必须建立连接，效率会稍低</span><br><span class="line">		-建立连接时的三次握（1老师在吗？ 2我在啊 3我可以问你一个问题吗？）</span><br><span class="line">		-断开连接四次握手（1老师我没有问题了，2恩好的，3没有问题我下线了，4好的老师）</span><br><span class="line">		</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<h4 id="6、通知"><a href="#6、通知" class="headerlink" title="6、通知"></a>6、通知</h4><ul>
<li>1、通知中心是同步的还是异步的？ </li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">同步的</span><br><span class="line"></span><br><span class="line">原因：发生事件，通知中心广播，有可能有多个监听者，设计上使用同步的方式，能保证所有的监听者都对通知做出响应，不会发生遗漏</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>2、通知执行的三个步骤</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、发送字符串给通知中心</span><br><span class="line">2、通知中心广播</span><br><span class="line">3、所有的通知监听方法执行完毕后，才继续执行代码</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>3、通知里到底有什么</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-name : 通知的名称的字符串，通知中心本质上就是监听这个字符串</span><br><span class="line">-object：发布通知的时候，希望传递给监听者的对象</span><br><span class="line">-userInfo：发布通知的时候，希望传递给监听者的附加信息字典</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>4、通知和代理有什么区别？</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- 代理是一对一的，设置delegate属性，在需要的时候，通过delegate调用</span><br><span class="line">	selector方法</span><br><span class="line">	</span><br><span class="line">- 通知是一对多的，只要发生事件，就会以广播的形式，通知所有的监听者</span><br><span class="line">		</span><br><span class="line">- 通知中心&#x2F;发布通知的对象不需要知道谁是监听者，发布对象和监听者之间的	耦合度很低</span><br><span class="line"></span><br><span class="line">- 监听者需要知道通知的名称字符串，如果发布者还需要传递userInfo字典，</span><br><span class="line">	监听者同时需要知道字典的键名</span><br><span class="line">	</span><br><span class="line">技巧：在OC框架中，如果定义通知，通常通知的名字包含Notification字样，同时key会和通知定义在一起</span><br><span class="line">		</span><br><span class="line">- 通知监听方法不能有返回值</span><br><span class="line"></span><br><span class="line">- 代理可以有返回值</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>iOS基础</category>
      </categories>
      <tags>
        <tag>自动释放池，运行循环，响应者链条，通知</tag>
      </tags>
  </entry>
  <entry>
    <title>多级滚动视图联动</title>
    <url>/2019/02/24/multiscrollview/</url>
    <content><![CDATA[<p>好像最近都没怎么写UI,最近公司有一个新的模块需要一个多级的列表联动,主要涉及到多个列表滚动时滚动对象的控制以及多个可滚动列表滑动手势处理。</p>
<a id="more"></a>


<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>废话不多说 先看下UI要求的效果</p>
<p><img src="https://ws2.sinaimg.cn/large/006tKfTcly1g0hwl9gmv1g305k09vnpd.gif" alt="效果图"></p>
<h3 id="层次拆分"><a href="#层次拆分" class="headerlink" title="层次拆分"></a>层次拆分</h3><p>通过下面的图 我们将这个效果整体的UI实现大概画一下(按照比较通用的方式 有些地方可以优化)</p>
<p><img src="https://ws3.sinaimg.cn/large/006tKfTcly1g0hsmuviv7j30vf0jy3zd.jpg"></p>
<p>大概的结构就是:</p>
<p><img src="https://ws2.sinaimg.cn/large/006tKfTcly1g0hsxic9t1j31nk0n0n0n.jpg"></p>
<h3 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h3><h4 id="如何让多个可滚动视图手势可以同时相应"><a href="#如何让多个可滚动视图手势可以同时相应" class="headerlink" title="如何让多个可滚动视图手势可以同时相应"></a>如何让多个可滚动视图手势可以同时相应</h4><p>在我们搭建好基本框架 去直接滚动视图的时候 我们发现 我们在滚动最内层tableview时 外面是不动的。也就是说 滚动的手势同时只可以有一个响应者。而最顶部的视图肯定是最优先的响应者。</p>
<p>那么如何让多个滚动视图同时相应一个手势呢？</p>
<p>来看下面的方法</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// note: returning YES is guaranteed to allow simultaneous recognition. returning NO is not guaranteed to prevent simultaneous recognition, as the other gesture&#x27;s delegate may return YES</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)gestureRecognizer:(<span class="built_in">UIGestureRecognizer</span> *)gestureRecognizer shouldRecognizeSimultaneouslyWithGestureRecognizer:(<span class="built_in">UIGestureRecognizer</span> *)otherGestureRecognizer;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>简单的翻译一下:是否允许多个手势识别器共同识别，一个控件的手势识别后是否阻断手势识别继续向下传播，默认返回NO；如果为YES，响应者链上层对象触发手势识别后，如果下层对象也添加了手势并成功识别也会继续执行，否则上层对象识别后则不再继续传播。</p>
<p>所以我们要做的第一步需要重写这个方法然后返回 YES</p>
<h4 id="多滚动视图协同"><a href="#多滚动视图协同" class="headerlink" title="多滚动视图协同"></a>多滚动视图协同</h4><p>我们可以先分析一下这种场景下滚动的顺序：</p>
<p>首先,假设我们三层的滚动视图 分别为 A B C </p>
<p>向上滚动:</p>
<table>
<thead>
<tr>
<th>状态</th>
<th>A</th>
<th>B</th>
<th>C</th>
<th>状态结束</th>
</tr>
</thead>
<tbody><tr>
<td>状态0</td>
<td>开始滚动</td>
<td>不可滚动</td>
<td>不可滚动</td>
<td>A 滚动到需要停止的区域(offset = contentsize.h-a.left)</td>
</tr>
<tr>
<td>状态1</td>
<td>停止滚动</td>
<td>开始滚动</td>
<td>不可滚动</td>
<td>B 滚动到需要停止的区域 (offset = contentsize.h-b.left)</td>
</tr>
<tr>
<td>状态2</td>
<td>不可滚动</td>
<td>停止滚动</td>
<td>开始滚动</td>
<td>滚动到页面底部</td>
</tr>
<tr>
<td>状态3</td>
<td>不可滚动</td>
<td>不可滚动</td>
<td>不可滚动</td>
<td>C 滚动到顶部(offset == 0)</td>
</tr>
<tr>
<td>状态4</td>
<td>不可滚动</td>
<td>开始滚动</td>
<td>停止滚动</td>
<td>B 滚动到顶部(offset == 0)</td>
</tr>
<tr>
<td>状态5</td>
<td>开始滚动</td>
<td>停止滚动</td>
<td>不可滚动</td>
<td>A 滚动到顶部(offset == 0) 页面整体回到顶部</td>
</tr>
</tbody></table>
<p>那么我们如何控制一个滚动视图是否滚动呢？</p>
<p>这里我们选择的是 设置滚动视图的contentOffset,即在不让某个视图滚动的时候 通过设置其contentOffset.y为某个固定值的方式 不让其滚动。</p>
<p>当然 应该是还有其他的方式,大家可以尝试其他的方式,以及其他的方式可能存在的问题。</p>
<h4 id="多视图之间消息传递"><a href="#多视图之间消息传递" class="headerlink" title="多视图之间消息传递"></a>多视图之间消息传递</h4><p>由最开始的部分我们可以看到,整个页面的视图结构层次非常深,这就给我们带来了一个问题: 如何通知各个视图？</p>
<p>这里我们采用的是: 通知 原因也很简单 耦合性最低。</p>
<h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><p>首先 页面的滚动 我们基本上是通过下面两个属性来控制</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>canScroll</td>
<td>scrollViewDidScroll方法中判断当前控制器是否可以滚动 默认A为YES B/C 为NO</td>
</tr>
<tr>
<td>fixOffset</td>
<td>当scrollView不可以滚动时 将其offset设置为该值 默认为0</td>
</tr>
</tbody></table>
<h4 id="首先对于最底层："><a href="#首先对于最底层：" class="headerlink" title="首先对于最底层："></a>首先对于最底层：</h4><p>默认 canScroll = YES fixOffset = 0</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)ul_scrollViewDidScroll:(<span class="built_in">UIScrollView</span> *)scrollView &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>.canScroll) &#123; <span class="comment">// 默认可以滚动</span></span><br><span class="line">        [scrollView setContentOffset:<span class="built_in">CGPointMake</span>(scrollView.contentOffset.x, kULGroupHomeViewControllerMargin)];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (scrollView.contentOffset.y &gt;= kULGroupHomeViewControllerMargin) &#123; <span class="comment">// 当滚动到临界值时</span></span><br><span class="line">        [scrollView setContentOffset:<span class="built_in">CGPointMake</span>(scrollView.contentOffset.x, kULGroupHomeViewControllerMargin)];</span><br><span class="line">        <span class="comment">// 发送 顶部视图到达顶部通知 让第中间的scrollView 滚动</span></span><br><span class="line">        [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:kULGroupTopViewGotoTopNotificationName object:<span class="literal">nil</span> userInfo:@&#123;kULGroupScrollViewCanScroll:<span class="string">@&quot;1&quot;</span>&#125;];</span><br><span class="line">        _canScroll = <span class="literal">NO</span>; <span class="comment">// 当自身是否可以滚动设置为NO</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="对于中间的那层"><a href="#对于中间的那层" class="headerlink" title="对于中间的那层:"></a>对于中间的那层:</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)ul_scrollViewDidScroll:(<span class="built_in">UIScrollView</span> *)scrollView &#123;</span><br><span class="line">    <span class="comment">// 默认不可以滚动</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>.canScroll) &#123;</span><br><span class="line">        [scrollView setContentOffset:<span class="keyword">self</span>.fixOffset];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 先确认 要停止滚动的位置 </span></span><br><span class="line">    <span class="built_in">CGFloat</span> tabOffsetY = [<span class="keyword">self</span>.tableView rectForSection:<span class="number">1</span>].origin.y;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CGFloat</span> offsetY = scrollView.contentOffset.y;</span><br><span class="line">    <span class="comment">// 因为这里调用的比较频繁 这里记录一下之前的状态 </span></span><br><span class="line">    _preCanMoveTableView = _canMoveTableView;</span><br><span class="line">    <span class="comment">// 判断 当前是否到达了临界值(不可滚动 到 可以滚动 )</span></span><br><span class="line">    <span class="keyword">if</span> (offsetY&gt;=tabOffsetY) &#123;</span><br><span class="line">        scrollView.contentOffset = <span class="built_in">CGPointMake</span>(<span class="number">0</span>, tabOffsetY);</span><br><span class="line">        _canMoveTableView = <span class="literal">YES</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        _canMoveTableView = <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果状态没有变化 那么不用改变</span></span><br><span class="line">    <span class="keyword">if</span> (_canMoveTableView != _preCanMoveTableView) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!_preCanMoveTableView &amp;&amp; _canMoveTableView) &#123;</span><br><span class="line">            <span class="comment">// 由不可以滚动变为可以滚动</span></span><br><span class="line">            [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:kULGroupMiddleViewGotoTopNotificationName object:<span class="literal">nil</span> userInfo:@&#123;kULGroupScrollViewCanScroll:<span class="string">@&quot;1&quot;</span>&#125;];</span><br><span class="line">            _canScroll = <span class="literal">NO</span>;</span><br><span class="line">            <span class="keyword">self</span>.fixOffset = scrollView.contentOffset;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(_preCanMoveTableView &amp;&amp; !_canMoveTableView)&#123;</span><br><span class="line">            <span class="comment">// 由可以滚动变为不可以滚动</span></span><br><span class="line">            <span class="keyword">if</span> (!_canScroll) &#123;</span><br><span class="line">                scrollView.contentOffset = <span class="built_in">CGPointMake</span>(<span class="number">0</span>, tabOffsetY);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里为了 大幅度滚动顺畅 当offset &lt; 3 默认就认为已经到达了顶部</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.canScroll &amp;&amp; offsetY &lt; <span class="number">3</span>) &#123;</span><br><span class="line">        [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:kULGroupMiddleViewLeaveTopNotificationName object:<span class="literal">nil</span> userInfo:@&#123;kULGroupScrollViewCanScroll:<span class="string">@&quot;1&quot;</span>&#125;];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="对于-最顶层"><a href="#对于-最顶层" class="headerlink" title="对于 最顶层"></a>对于 最顶层</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)ul_scrollViewDidScroll:(<span class="built_in">UIScrollView</span> *)scrollView &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>.canScroll) &#123;</span><br><span class="line">        [scrollView setContentOffset:<span class="built_in">CGPointZero</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">CGFloat</span> offsetY = scrollView.contentOffset.y;</span><br><span class="line">    <span class="comment">// 是否到达了顶部 如果到达通知第二层去滚动</span></span><br><span class="line">    <span class="keyword">if</span> (offsetY&lt;<span class="number">0</span>) &#123;</span><br><span class="line">        [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:kULGroupBottomViewLeaveTopNotificationName object:<span class="literal">nil</span> userInfo:@&#123;kULGroupScrollViewCanScroll:<span class="string">@&quot;1&quot;</span>&#125;];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面就是我们按照前面分析的规则 在视图滚动的时候 所要做的操作！ </p>
<h4 id="通知及处理"><a href="#通知及处理" class="headerlink" title="通知及处理"></a>通知及处理</h4><p>还有最后一步:通知的处理 </p>
<p>我们先看一下代码里涉及到的几个通知</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 顶部进入置顶通知</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">NSString</span> *<span class="keyword">const</span> kULGroupTopViewGotoTopNotificationName = <span class="string">@&quot;kULGroupTopViewGotoTopNotificationName&quot;</span>;</span><br><span class="line"><span class="comment">// 中间view到达顶部通知</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">NSString</span> *<span class="keyword">const</span> kULGroupMiddleViewGotoTopNotificationName = <span class="string">@&quot;kULGroupMiddleViewGotoTopNotificationName&quot;</span>;</span><br><span class="line"><span class="comment">// 中间view离开顶部通知</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">NSString</span> *<span class="keyword">const</span> kULGroupMiddleViewLeaveTopNotificationName = <span class="string">@&quot;kULGroupMiddleViewLeaveTopNotificationName&quot;</span>;</span><br><span class="line"><span class="comment">// 底部view离开顶部通知</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">NSString</span> *<span class="keyword">const</span> kULGroupBottomViewLeaveTopNotificationName = <span class="string">@&quot;kULGroupBottomViewLeaveTopNotificationName&quot;</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其实根据通知的名字 我们就基本可以了解到 收到这些通知的时候我们需要做什么</p>
<table>
<thead>
<tr>
<th>通知名</th>
<th>何时发送</th>
<th>监听者需要做的事</th>
</tr>
</thead>
<tbody><tr>
<td>kULGroupTopViewGotoTopNotificationName</td>
<td>最底层滚动到指定位置</td>
<td>中间层监听 监听到时需要使自己可以滚动</td>
</tr>
<tr>
<td>kULGroupMiddleViewGotoTopNotificationName</td>
<td>中间层滚动到指定位置</td>
<td>最顶部滚动视图 监听 监听到时 让自己可以滚动</td>
</tr>
<tr>
<td>kULGroupMiddleViewLeaveTopNotificationName</td>
<td>中间层从滚动到固定位置的地方离开</td>
<td>中间层监听 监听到时 中间层不可以滚动; 最底层监听 监听到时 最底层可以滚动</td>
</tr>
<tr>
<td>kULGroupBottomViewLeaveTopNotificationName</td>
<td>最顶层滚动到顶部时</td>
<td>最底层监听监听到后 让自己不可以滚动; 中间层监听 监听到后让自己可以滚动</td>
</tr>
</tbody></table>
<p>代码我就不具体的贴出来了,可以到项目里更详细的看一下。</p>
<h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p><img src="https://ws2.sinaimg.cn/large/006tKfTcly1g0huj318olg30ai0h6tkg.gif"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>其实这个结构还是挺复杂的不过在仔细分析实现后,我们发现这个效果其实并没有很难实现。只是在实现之前我们需要把 东西缕清楚。这样我们在去动手写代码的时候才可以有的放矢。</p>
<p>希望本文能够帮到你！！！</p>
]]></content>
      <categories>
        <category>UI</category>
      </categories>
      <tags>
        <tag>多级联动、scrollView</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程</title>
    <url>/2016/03/16/multithread/</url>
    <content><![CDATA[<p>最近工作，相对来说没那么忙了。自认为网络和多线程是我比较弱的模块，所以<br>趁这段时间有空，找了一些网络多线程相关的视频看了一下，这里做一下总结。</p>
<p>这是第一篇，主要介绍了线程的基本概念、队列 的相关知识</p>
<a id="more"></a>


<h4 id="线程的基本概念"><a href="#线程的基本概念" class="headerlink" title="线程的基本概念"></a>线程的基本概念</h4><h5 id="1、创建线程的三种方法"><a href="#1、创建线程的三种方法" class="headerlink" title="1、创建线程的三种方法"></a>1、创建线程的三种方法</h5><ul>
<li>1、alloc init</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSThread *thread &#x3D; [[NSThread alloc]</span><br><span class="line"> 			initWithTarget:self selector:@selector(demo:)</span><br><span class="line"> 			 		object:@&quot;Thread&quot;]</span><br><span class="line"> 			 		</span><br><span class="line">[thread start];</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>2、detachNewThreadSelector</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[NSThread detachNewThreadSelector:@selector(demo:) 		toTarget:self withObject:@&quot;Detach&quot;];</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>3、performSelectorInBackground</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[self performSelectorInBackground:@selector(demo:) withObject:@&quot;background&quot;];</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="2、线程的常用属性"><a href="#2、线程的常用属性" class="headerlink" title="2、线程的常用属性"></a>2、线程的常用属性</h5><ul>
<li>1、name </li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">线程的名字，在多个线程开发时，可以判断到底是谁在执行任务</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>2、threadPriority</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">线程优先级（0~1递增）默认优先级是0.5</span><br><span class="line"></span><br><span class="line">注意：优先级高并不意味着会先被调用，只是表示CUP调用的频	率相对较高</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>3、state</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">isExecuting(只读属性，是否正在执行)</span><br><span class="line">isFinished（只读属性，线程是否完成）</span><br><span class="line">isCancelled（只读属性，线程是否被取消）</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>4、stackSize</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">堆栈的大小，线程执行前，堆栈大小为512k，线程执行完毕之后，堆栈大小为0k 内存空间被释放，注意，线程执行完毕之后，由于内存空间已经被释放，不能再次启动</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="3、线程常用的方法"><a href="#3、线程常用的方法" class="headerlink" title="3、线程常用的方法"></a>3、线程常用的方法</h5><ul>
<li>1、currentThread</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">当前线程（1表示主线程，非1表示其他线程）</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>2、阻塞方法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sleepUntilDate:休眠到指定时间</span><br><span class="line"></span><br><span class="line">sleepForTimeInterval:休眠指定时长</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>3、exit</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">终止当前线程的执行（注意不要再主线程中执行这个方法）</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>4、其他方法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+isMainThread 是否为主线程</span><br><span class="line">+mainThread 返回主线程对象</span><br><span class="line">+isMultiThreaded 是否是多线程</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="4、线程状态详解"><a href="#4、线程状态详解" class="headerlink" title="4、线程状态详解"></a>4、线程状态详解</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">新建：实例化线程对象</span><br><span class="line"></span><br><span class="line">就绪：向对象发送start消息，将线程添加到“可调度线程池”等待CUP的调度，其他两种线程的创建方法，都是直接实例化一个线程对象，并将其加入“可调度线程池中”</span><br><span class="line"></span><br><span class="line">运行：CUP负责调度“可调度线程池”中的内容，在线程执行完成前可能会进行多次的运行和就绪的转换，这个转换由CPU负责，程序员不干预</span><br><span class="line"></span><br><span class="line">阻塞：满足某一个预定条件时，可以使用休眠或者锁阻塞线程，具体可以使用下面的几个方法：sleepForTimeInterval、sleepUntilDate、@synchronized(self)</span><br><span class="line"></span><br><span class="line">死亡：死亡方式：1、正常死亡  2、非正常死亡</span><br><span class="line">		1、正常死亡  :线程执行完毕 </span><br><span class="line">    	2、线程内死亡 :  [NSThread exit]</span><br><span class="line">    	   线程外死亡 :[threadObj cancel]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="5、线程相关注意点"><a href="#5、线程相关注意点" class="headerlink" title="5、线程相关注意点"></a>5、线程相关注意点</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、不要使用exit方法杀死主线程</span><br><span class="line"></span><br><span class="line">2、一旦强行终止线程后续的所有代码都不会被执行，因此，在线程终止之前，</span><br><span class="line">应该注意释放之前分配的对象，如果是ARC开发，需要注意，清理C语言框架创建的对象，否则会出现内存泄露</span><br><span class="line"></span><br><span class="line">3、多线程的目的：将耗时操作放在后台，不阻塞主线程和用户之间的交互，线</span><br><span class="line">程的优先级不要修改，多线程开发要尽量简单，多线程的优点是通过并发提高程</span><br><span class="line">序的执行效率</span><br><span class="line"></span><br><span class="line">4、在大型的商业项目中，通常会给线程起名字，因为他们希望如果程序崩溃可</span><br><span class="line">以准确的定位到，是哪一个线程出现了问题</span><br><span class="line"></span><br><span class="line">5、多线程的优缺点：</span><br><span class="line">优点：能适当提高程序的执行效率，能适当的提高资源利用率（CPU、内存利用</span><br><span class="line">率）；</span><br><span class="line">缺点：开启线程要占用一定的内存空间，默认情况下一条县城占用512KB，因此</span><br><span class="line">如果开启大量的线程，会占用大量的内存空间，降低程序性能</span><br><span class="line"></span><br><span class="line">7、线程安全：在多线程进行读写操作时，仍然能保证数据正确</span><br><span class="line"></span><br><span class="line">8、线程间通讯：performSelectorOnMainThread &quot;线程间通讯&quot;</span><br><span class="line"> 1. 在主线程执行的方法 </span><br><span class="line"> 2. 传递给方法的参数  </span><br><span class="line"> 3. 是否等待被调用方法执行完成，有可能也会等待调用方法的执行完成！几率</span><br><span class="line"> 	极少！</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="6、锁"><a href="#6、锁" class="headerlink" title="6、锁"></a>6、锁</h5><ul>
<li>1、互斥锁</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">同时时间内，只有一个线程能够执行锁定的代码</span><br><span class="line"></span><br><span class="line">在锁定的时候，其他线程会睡眠，等待条件满足后，再被唤醒</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>2、自旋锁</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">同时时间内，只有一个线程能够执行锁定的代码</span><br><span class="line"></span><br><span class="line">在锁定的时候，其他线程会做死循环，一直等待条件满足，性能会好（适合执行非常快，非常短的代码）</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="7、资源抢夺"><a href="#7、资源抢夺" class="headerlink" title="7、资源抢夺"></a>7、资源抢夺</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">现象：多个线程访问同一块资源 进行读写操作 </span><br><span class="line">解决方法： 加锁</span><br><span class="line"></span><br><span class="line">1、加互斥锁</span><br><span class="line"></span><br><span class="line">@synchronized(self):</span><br><span class="line"></span><br><span class="line">- 使用互斥锁，在同一个时间，只允许一条线程执行锁中的代码</span><br><span class="line">- 互斥锁的代价非常昂贵</span><br><span class="line">- 互斥锁的代码范围应该尽可能的小，只要锁住资源读写部分的代码即可</span><br><span class="line">- 使用互斥锁会影响并发性能</span><br><span class="line"></span><br><span class="line">2、使用原子属性</span><br><span class="line"></span><br><span class="line">能够实现“单写多读”的数据保护</span><br><span class="line"></span><br><span class="line">- 同一时间只允许一个线程修改属性值，但允许多个线程读取</span><br><span class="line">- 有可能出现脏数据--读取数据的值可能会不正确</span><br><span class="line">- 原子属性是默认属性，如果不需要考虑线程安全，指定nonatomic</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="2、队列"><a href="#2、队列" class="headerlink" title="2、队列"></a>2、队列</h4><h5 id="1、队列的类型"><a href="#1、队列的类型" class="headerlink" title="1、队列的类型"></a>1、队列的类型</h5><ul>
<li>1、串行队列</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dispatch_queue_create(&quot;leewong&quot;, NULL);</span><br><span class="line">一次只调度一个任务执行，一个任务执行完成后，在调度下一个任务</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>2、并发队列</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dispatch_queue_create(&quot;LeeWong&quot;,DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">可以同时调度多个任务</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>3、主队列</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">负责在主线程上调度任务，用于线程间通讯（所有的UI更新都应该在主线程上进行）</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>4、全局队列</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dispatch_get_global_queue(0, 0);与并发队列相比：调度任务的方式相同，全局队列没有队列名称，在MRC开发中，全局队列不需要释放</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="2、队列的执行方式"><a href="#2、队列的执行方式" class="headerlink" title="2、队列的执行方式"></a>2、队列的执行方式</h5><ul>
<li>1、同步 dispatch_sync</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">串行队列：会在当前线程上同步执行</span><br><span class="line">并发队列：会在当前线程上同步执行</span><br><span class="line">主 队列 ：在主线程上添加同步任务会造成死锁，利用同步任务，可以建立任务</span><br><span class="line">		之间的“依赖”关系</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>2、异步 dispatch_async</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">串行队列：会开启新的线程调度任务</span><br><span class="line">并发队列：会开启新的线程调度任务</span><br><span class="line">主队列：等待主线程空闲时调度任务</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="3、队列的选择"><a href="#3、队列的选择" class="headerlink" title="3、队列的选择"></a>3、队列的选择</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">串行队列：对执行效率要求不高，对执行顺序要求高，性能消耗小；</span><br><span class="line">并发队列：对执行效率要求高，对执行顺序要求不高，性能消耗大</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="4、GCD"><a href="#4、GCD" class="headerlink" title="4、GCD"></a>4、GCD</h5><h6 id="1、延时"><a href="#1、延时" class="headerlink" title="1、延时"></a>1、延时</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dispatch_after(when, queue, block);</span><br><span class="line"></span><br><span class="line">参数：从现在起经过多少纳秒；调度任务的队列；异步执行任务</span><br><span class="line"></span><br><span class="line">注意：dispatch_after中的参数是保留dispatch_after这句话执行的时候的参数，如果之后再代码块中语句执行之前，之中包含的参数发生变化，在之后代码块执行的时候，其值不改变</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h6 id="2、调度组"><a href="#2、调度组" class="headerlink" title="2、调度组"></a>2、调度组</h6><p>使用场景：需要在多个耗时操作执行完毕之后，在统一做后续处理</p>
<p>创建调度组：<br>dispatch_group_t group = dispatch_group_create();</p>
<ul>
<li>1、dispatch_group_leave、dispatch_group_enter<br><img src="http://i.niupic.com/images/2016/03/21/Kgi9Ow.png" alt="icon"></li>
</ul>
<ul>
<li>2、dispatch_group_notify</li>
</ul>
<p><img src="http://i.niupic.com/images/2016/03/21/gghbm4.png" alt="icon"></p>
<h6 id="3、一次性"><a href="#3、一次性" class="headerlink" title="3、一次性"></a>3、一次性</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">保证某段代码在程序运行过程中只被执行一次，在单例设计模式中被广泛使用</span><br><span class="line">dispatch_once是线程安全的</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h6 id="4、GCD的排列组合"><a href="#4、GCD的排列组合" class="headerlink" title="4、GCD的排列组合"></a>4、GCD的排列组合</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- 1、串行队列，同步执行：不会开线程，顺序执行</span><br><span class="line"> </span><br><span class="line">- 2、串行队列，异步执行：会开线程(1条)，顺序执行</span><br><span class="line"></span><br><span class="line">- 3、并发队列，异步执行：会开线程，不会顺序执行，具体开几条线程取决于</span><br><span class="line">	队列</span><br><span class="line">	</span><br><span class="line">- 4、并发队列，同步执行：和串行队列同步执行效果一样</span><br><span class="line"></span><br><span class="line">- 5、主队列，异步执行:不开线程，异步任务必须等待主线程上的任务完成之后</span><br><span class="line">	才会被调用</span><br><span class="line">	</span><br><span class="line">- 6、主队列、同步执行：会发生死锁，因为，同步任务要求必须顺序执行，但</span><br><span class="line">	是同步任务必须等待主队列中没有任务可以被调用的时候才会被执行，因此</span><br><span class="line">	这两方会造成死锁的情况</span><br><span class="line">	</span><br><span class="line">- 7、同步任务的特点：可以再多个异步任务调度前，指定一个同步任务，让所</span><br><span class="line">	有的异步任务，等待同步任务执行完成，这就是所谓的依赖关系</span><br><span class="line">	</span><br><span class="line">- 8、全局队列，系统提供给程序员，方便程序员使用的全局队列，有关服务质</span><br><span class="line">	量的问题，使用下面的代码能够做到IOS7&amp;IOS8的适配，全局队列本质上</span><br><span class="line">	就是一个异步队列</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h6 id="5、全局队列与串行队列的选择"><a href="#5、全局队列与串行队列的选择" class="headerlink" title="5、全局队列与串行队列的选择"></a>5、全局队列与串行队列的选择</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">全局队列：并发，能够调度多个线程，执行效率高    但是费电</span><br><span class="line"></span><br><span class="line">串行队列：一个接一个，只能够开启一条县城，执行效率地</span><br><span class="line">    	但是如果任务之间有依赖关系，可以使用串行队列</span><br><span class="line">    	省电，省钱，省流量</span><br><span class="line">判断的依据：用户的上网方式</span><br><span class="line">    	  -WIFI 可以开多条线程 6条</span><br><span class="line">    	  -3G&#x2F;4G 尽量少开线程2~3条</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h5 id="5、NSOperation"><a href="#5、NSOperation" class="headerlink" title="5、NSOperation"></a>5、NSOperation</h5><h6 id="1、NSInvocationOperation和NSBlockOperation"><a href="#1、NSInvocationOperation和NSBlockOperation" class="headerlink" title="1、NSInvocationOperation和NSBlockOperation"></a>1、NSInvocationOperation和NSBlockOperation</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSInvocationOperation:</span><br><span class="line"></span><br><span class="line">NSOperationQueue *q &#x3D; [[NSOperationQueue alloc] init];</span><br><span class="line"></span><br><span class="line">    for (int i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">        NSInvocationOperation *op &#x3D; [[NSInvocationOperation</span><br><span class="line">       alloc] initWithTarget:self </span><br><span class="line">        			selector:@selector(downloadImage:) </span><br><span class="line">        			  object:@(i)];</span><br><span class="line">        			  </span><br><span class="line">        [q addOperation:op];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">   </span><br><span class="line">NSBlockOperation:</span><br><span class="line">   </span><br><span class="line">NSOperationQueue *q &#x3D; [[NSOperationQueue alloc] init];</span><br><span class="line">    	for (int i &#x3D; 0; i&lt;10; i++) &#123;</span><br><span class="line">        NSBlockOperation *op &#x3D; [NSBlockOperation 		blockOperationWithBlock:^&#123;</span><br><span class="line">            NSLog(@&quot;%@ ---- %d &quot;, [NSThread currentThread], i);</span><br><span class="line">        &#125;];</span><br><span class="line">        [q addOperation:op];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>执行结果：开启多个线程，不会顺序执行-&gt;GCD并发队列，异步执行任务</p>
<h6 id="2、队列的取消操作"><a href="#2、队列的取消操作" class="headerlink" title="2、队列的取消操作"></a>2、队列的取消操作</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">判断队列是否挂起： isSuspended</span><br><span class="line"></span><br><span class="line">在暂停的时候，队列中的操作数，是包含正在执行的操作的</span><br><span class="line"></span><br><span class="line">再次继续的时候，如果之前执行的操作已经完成，队列中的操作数就只有没有调</span><br><span class="line">度的操作</span><br><span class="line"></span><br><span class="line">在设置度列的挂起属性的时候，并不会判断队列中是否有操作，如果不希望用户产生困惑，可以提前判断，判断队列中当前是否有操作</span><br><span class="line"></span><br><span class="line">取消所有操作cancelAllOperations，不会取消正在执行的操作</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h6 id="3、操作的依赖关系"><a href="#3、操作的依赖关系" class="headerlink" title="3、操作的依赖关系"></a>3、操作的依赖关系</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSOperation 提供了依赖关系,NSOperation的所有操作都是异步执行的，但</span><br><span class="line">是为了建立任务之间的依赖，提供了dependency的功能,GCD中，可以直接通过</span><br><span class="line">同步任务来实现，可以通过串行队列</span><br><span class="line"></span><br><span class="line">[op2 addDependency:op1]; op1执行完毕之后才可以执行op2</span><br><span class="line"></span><br><span class="line">添加依赖关系之后可以调用 waitUntilFinished 来决定是否等待所有操作完</span><br><span class="line">成，但是这种等待是阻塞式的，类似于</span><br><span class="line"></span><br><span class="line">   		dispatch_group_wait(g, DISPATCH_TIME_FOREVER);</span><br><span class="line">   		</span><br><span class="line">依赖关系可以跨队列指定</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>但是要注意不要指定循环依赖，一旦指定了循环依赖，队列就不工作了</code></p>
<h6 id="4、自定义Operation的实现"><a href="#4、自定义Operation的实现" class="headerlink" title="4、自定义Operation的实现"></a>4、自定义Operation的实现</h6><p>目的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、将操作部分的代码重构到一个单独的子类完成工作</span><br><span class="line"></span><br><span class="line">2、主要是在开发第三方框架时，会使用，日常开发直接使用operation会比较</span><br><span class="line">	方便</span><br><span class="line">	</span><br><span class="line">3、自定义操作，可以支持队列的取消操作</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>自定义NSOperation的子类的步骤：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">-重写main方法</span><br><span class="line">-添加自动释放池，因为子线程运行循环默认不工作</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>重要提示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSOperation默认提供了一个completionBlock的参数，一旦设置了，就会在操作执行完毕之后自动执行</span><br><span class="line"></span><br><span class="line">completionBlock 会在后台线程执行，不会再主线程执行，所以如果需要更新UI，需要注意线程</span><br><span class="line"></span><br><span class="line">completionBlock 不能接受参数，没有返回值，因此在使用的时候，会有很多限制</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注意：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">作为所有c语言程序的入口，自定义操作也需要有自己的main函数，同时子线程</span><br><span class="line">的运行循环默认是不开启的，因此也不会主动的区创建自动释放池，因此自定义</span><br><span class="line">NSOperation的子类的时候，需要自己添加自动释放池</span><br><span class="line"></span><br><span class="line">		- (void)main &#123;</span><br><span class="line">    		@autoreleasepool &#123;&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">   </span><br><span class="line">每一次运行循环的开启，都会创建一个自动释放池，当对象出了他们的作用域之</span><br><span class="line">后就会被添加到自动释放池中，在运行循环即将结束的时候，会被销毁（每一个</span><br><span class="line">线程都有自己的runloop但是之后主线程的默认被开启）</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h6 id="5、NSOperation和GCD的区别"><a href="#5、NSOperation和GCD的区别" class="headerlink" title="5、NSOperation和GCD的区别"></a>5、NSOperation和GCD的区别</h6><ul>
<li>1、GCD</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- GCD在iOS4.0推出，主要针对多核处理器做了优化的并发计数，是C语言的</span><br><span class="line"></span><br><span class="line">- 将任务[block]添加到度列[串行&#x2F;并发&#x2F;主队列&#x2F;全局队列],并且制定执行任</span><br><span class="line">	务的函数[同步&#x2F;异步]</span><br><span class="line">	</span><br><span class="line">- 线程间通讯dispatch_get_main_queue</span><br><span class="line"></span><br><span class="line">- 提供了一些NSOperation不具备的功能</span><br><span class="line">		- 一次性执行</span><br><span class="line"> 		- 延迟执行</span><br><span class="line"> 		- 调度组（在op中也可以做到，就是有点麻烦）</span><br><span class="line">	</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>2、NSOperation</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- NSOperation在iOS2.0之后推出，苹果推出GCD之后，对NSOperation底</span><br><span class="line">	层重写了一遍</span><br><span class="line">- 将操作[异步执行的任务]添加到队列[并发队列]，就会立即异步执行</span><br><span class="line">- mainQueue</span><br><span class="line">- 提供了一些GCD实现起来比较困难的功能</span><br><span class="line">		- 最大并发操作数</span><br><span class="line">		- 队列的暂停&#x2F;继续</span><br><span class="line">		- 取消所有的操作</span><br><span class="line">		- 制定操作之间的依赖关系（GCD用同步实现）</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>iOS基础</category>
      </categories>
      <tags>
        <tag>多线程</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title>NSURLSessionConfiguration配置</title>
    <url>/2016/03/21/networking-concept/</url>
    <content><![CDATA[<p>本文主要介绍了NSURLSessionConfiguration配置，只是简单的写了一个 最常用的设置，后续会陆续补充。</p>
<a id="more"></a>


<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">可以设置全局的网络访问属性-- 对某台服务器所有特殊的设置，统一在config中设置</span><br><span class="line"></span><br><span class="line">最重要的一个属性 应用于身份验证的</span><br><span class="line"></span><br><span class="line">	HTTPAdditionalHeaders“”</span><br><span class="line">		 &#x2F;&#x2F; 设置身份验证的数据 - 一旦设置，全局共享的好处！</span><br><span class="line">		 </span><br><span class="line">    NSString *authStr &#x3D; [self base64Encode:@&quot;admin:</span><br><span class="line">    										123456&quot;];</span><br><span class="line">    										</span><br><span class="line">        authStr &#x3D; [@&quot;BASIC &quot; </span><br><span class="line">        				stringByAppendingString:authStr];</span><br><span class="line">        				</span><br><span class="line">        &#x2F;&#x2F; 设置请求头 身份验证 的字段</span><br><span class="line">        </span><br><span class="line">&#x2F;&#x2F;        [request setValue:authStr forHTTPHeaderField:@&quot;Authorization&quot;];</span><br><span class="line"></span><br><span class="line">        config.HTTPAdditionalHeaders &#x3D; @&#123;@&quot;Authorization&quot;: </span><br><span class="line">        								authStr&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>iOS基础</category>
      </categories>
      <tags>
        <tag>NSURLSessionConfiguration</tag>
      </tags>
  </entry>
  <entry>
    <title>NSURLRequest 详解</title>
    <url>/2016/03/21/networking/</url>
    <content><![CDATA[<p>本片文章重点介绍了NSURLRequest的配置，作为网络请求的主要载体，NSURLRequest的配置十分重要。本文会对创建请求，发送请求以及这个过程中的参数设置进行详细的解析。</p>
<a id="more"></a>

<h4 id="1、NSURLRequest"><a href="#1、NSURLRequest" class="headerlink" title="1、NSURLRequest"></a>1、NSURLRequest</h4><ul>
<li>1、创建方法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSURLRequest *request &#x3D; [NSURLRequest requestWithURL:url </span><br><span class="line">					cachePolicy:0 timeoutInterval:2.0];</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p>2、参数介绍</p>
<ul>
<li><p>1、cachePolicy 缓存策略</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 默认缓存策略</span><br><span class="line"> NSURLRequestUseProtocolCachePolicy &#x3D; 0, </span><br><span class="line"> </span><br><span class="line"> NSURLRequestReload(刷新)Ignoring(忽略)Local(本</span><br><span class="line"> 						地)Cache(缓存)Data &#x3D; 1,  </span><br><span class="line"> 						 </span><br><span class="line"> 如果有缓存，返回缓存数据，否则加载		</span><br><span class="line"> NSURLRequestReturnCacheDataElseLoad &#x3D; 2,       </span><br><span class="line">   </span><br><span class="line">   如果有缓存，返回缓存数据，否则不加载</span><br><span class="line">NSURLRequestReturnCacheDataDontLoad &#x3D; 3,       </span><br><span class="line">      </span><br></pre></td></tr></table></figure>
</li>
<li><p>2、timeoutInterval 超长时间</p>
</li>
</ul>
</li>
</ul>
<pre><code>    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">超长事件，访问一个服务器，如果在制定时间内服务器没有做</span><br><span class="line">出响应，就放弃请求，默认时长是60s</span><br><span class="line">		</span><br><span class="line">一般在实际开发中，建议设置为15~30s，太短服务器可能来</span><br><span class="line">不及做出响应，太长用户等待的事件又太长，影响用户体验</span><br><span class="line">		</span><br><span class="line">  SDWebImage 默认时长就是 15s</span><br><span class="line"></span><br><span class="line">     AFNetworking 默认时长是 60s</span><br><span class="line"></span><br></pre></td></tr></table></figure></code></pre>
<ul>
<li>3、发送请求</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[NSURLConnection sendAsynchronousRequest:request</span><br><span class="line"> 		queue:[[NSOperationQueue alloc] init]</span><br><span class="line"> 		 completionHandler:^(NSURLResponse *response, </span><br><span class="line"> 		 	NSData *data, NSError *connectionError) &#123;</span><br><span class="line">      </span><br><span class="line">       if (connectionError || data &#x3D;&#x3D; nil) &#123;</span><br><span class="line">           NSLog(@&quot;你的网络不给力，请稍候再试！&quot;);</span><br><span class="line">           NSLog(@&quot;&#x3D;&#x3D;&#x3D;&gt; %@&quot;, connectionError);</span><br><span class="line">           return;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       NSString *json &#x3D; [[NSString alloc]</span><br><span class="line">       	 initWithData:data </span><br><span class="line">       	     encoding:NSUTF8StringEncoding];</span><br><span class="line">       	     </span><br><span class="line">       NSLog(@&quot;%@&quot;, json);</span><br><span class="line">   &#125;];</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>参数介绍</p>
<p> 1、request</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">索要资源的请求队列</span><br></pre></td></tr></table></figure>

<p>2、queue 调度任务的队列</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">指定调度回调块代码在哪个线程上执行</span><br><span class="line">-主队列：回调的块代码在主线程上执行</span><br><span class="line">-新建队列：就会在其他线程执行回调代码</span><br><span class="line"></span><br><span class="line">选择的原则：</span><br><span class="line"></span><br><span class="line">是否需要对返回的数据做耗时操作，如果直接更新UI可以使用主队列，否则建议新建队列</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>3、回调块代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在网络请求结束后执行，已经获得了服务器返回的二进制</span><br><span class="line"></span><br><span class="line">回调参数：</span><br><span class="line"></span><br><span class="line">1、response(NSHTTPURLResponse):</span><br><span class="line">	-服务器的响应（一般只有在做下载的网络操作，才会使用的 response）</span><br><span class="line"></span><br><span class="line">	URL：                     </span><br><span class="line">	服务器返回的 URL，绝大多数是和请求的 URL 是一致的，有的时候会不</span><br><span class="line">	一样，&quot;重定向&quot;</span><br><span class="line"></span><br><span class="line">	MIMEType:               </span><br><span class="line">	二进制数据的文件类型，服务器告诉客户端，可以使用什么软件，打开二进</span><br><span class="line">	制数据</span><br><span class="line">	</span><br><span class="line">	textEncodingName：</span><br><span class="line">	文本编码名称，大多数都是 UTF8</span><br><span class="line">	</span><br><span class="line">	expectedContentLength:</span><br><span class="line">	下载文件的长度！</span><br><span class="line">	</span><br><span class="line">	suggestedFilename:</span><br><span class="line">	服务器建议保存的文件名</span><br><span class="line">	</span><br><span class="line">	statusCode:</span><br><span class="line">	状态码，2XX OK，3XX 重定向，4XX 客户端错误，5XX 服务器错误！</span><br><span class="line">	</span><br><span class="line">	allHeaderFields:</span><br><span class="line">	所有响应头的内容</span><br><span class="line">	</span><br><span class="line">2、data :</span><br><span class="line">	- 数据实体，程序员开发最关注的</span><br><span class="line">	</span><br><span class="line">	数据的序列化：</span><br><span class="line">	NSArray *result &#x3D; [NSJSONSerialization </span><br><span class="line">						JSONObjectWithData:data </span><br><span class="line">								   options:0 </span><br><span class="line">								     error:NULL];</span><br><span class="line">	可序列化数据的要求：</span><br><span class="line">	  - 顶级节点是一个NSArray或者NSDictionary</span><br><span class="line">	  - 所有对象是</span><br><span class="line">	  	NSString,NSNumber,NSArray,NSDictionary,NSNull</span><br><span class="line">	  - 所有字典的key时NSString</span><br><span class="line">	  - NSNumber 不能为空或者无穷大</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">3、connectionError</span><br><span class="line">	-连接错误 只要是网络开发，就有可能出现错误！在实际开发中，一定要对</span><br><span class="line">	错误进行处理！</span><br><span class="line">	</span><br><span class="line">	错误处理：</span><br><span class="line">    if (connectionError || data &#x3D;&#x3D; nil) &#123;</span><br><span class="line">        NSLog(@&quot;你的网络不给力，请稍候再试！&quot;);</span><br><span class="line">        NSLog(@&quot;&#x3D;&#x3D;&#x3D;&gt; %@&quot;, connectionError);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h4 id="2、请求方式以及区别"><a href="#2、请求方式以及区别" class="headerlink" title="2、请求方式以及区别"></a>2、请求方式以及区别</h4><p>1、请求类型的简单介绍</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET http:&#x2F;&#x2F;www.x.com&#x2F;product&#x2F;123 </span><br><span class="line">语义：获取产品代号是123的商品信息</span><br><span class="line"></span><br><span class="line">POST http:&#x2F;&#x2F;www.x.com&#x2F;product&#x2F;123 </span><br><span class="line">语义：新增产品代号是123的商品信息</span><br><span class="line"></span><br><span class="line">PUT  http:&#x2F;&#x2F;www.x.com&#x2F;product&#x2F;123 </span><br><span class="line">语义：修改产品代号是123的商品信息</span><br><span class="line"></span><br><span class="line">DELETE http:&#x2F;&#x2F;www.x.com&#x2F;product&#x2F;123 </span><br><span class="line">语义：删除产品代号是123的商品信息</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>2、POST和GET在发送网络请求时的区别：</p>
<ul>
<li>1、URL</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">GET 所有的参数都包含在URL中，URL的格式如下</span><br><span class="line">	&lt;1&gt;login.php是负责登录的脚本（可以有很多种）</span><br><span class="line">	&lt;2&gt;?表示脚本后面要接参数</span><br><span class="line">	&lt;3&gt;参数格式：参数名 &#x3D; 值</span><br><span class="line">	&lt;4&gt;如果有多个参数，使用&amp;连接，后续的参数仍按照“值对”方式定义</span><br><span class="line">	&lt;5&gt;如果URL字符串中包含中文或者空格等特殊符号，需要对URL字符串添</span><br><span class="line">		加百分号转义</span><br><span class="line">POST:只是负责登录的脚本，其它参数无需确定</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>2、Request</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET 因为所有的参数URL中已经包含，request中无需指定任何内容</span><br><span class="line">	request的默认方法是GET GET效率最高，GET方法是使用最频繁的网络</span><br><span class="line">	方法</span><br><span class="line"></span><br><span class="line">POST：</span><br><span class="line">	1、指定HTTPMethod 要想服务器“贴”数据,</span><br><span class="line">		request.HTTPMethod &#x3D; &quot;POST&quot;</span><br><span class="line">	2、要设置请求体的二进制数据</span><br><span class="line">		提示：可以从firebug中直接粘贴，然后替换参数</span><br><span class="line">		格式：和GET方法中参数的格式一样，只是没有?</span><br><span class="line">	3、connection -将请求发送给服务器，等待服务器返回的响应和数</span><br><span class="line">		据实体在网络访问中，这个方法是最单纯的</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>GET和POST请求的区别</code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">1、GET的本质是“得” POST的本质是“给”</span><br><span class="line"></span><br><span class="line">2、GET是从服务器拿数据，效率更高，POST是想服务器发送数据，</span><br><span class="line">	也可以获取服务器处理之后的结果，效果不如GET</span><br><span class="line"></span><br><span class="line">3、GET请求能够被缓存（一个指定URL所代表的内容一般不会变）POST请求不</span><br><span class="line">	能被缓存</span><br><span class="line">4、GET在HTTP协议中没有对GET请求的数据大小限制，不过因为浏览器的不同</span><br><span class="line">	一般限制在2-8K之间POST提交数据比较大，大小靠服务器设定值限制，</span><br><span class="line">	PHP通常限定2M</span><br><span class="line">5、GET请求所有的参数包装在URL中，并且服务器的访问日志会记录，不要传递</span><br><span class="line">	敏感信息 POST：URL中只有资源路径，但不包含参数，服务器日志不会记	录参数相对更安全参数被包装成二进制的数据体，格式与GET基本一致，只</span><br><span class="line">	是不包含</span><br><span class="line">6、GET的参数在资源路径末尾添加?表示追加参数，</span><br><span class="line">	参数：变量名&#x3D;变量值不能包含空格或者中文，多个参数使用&amp;连接POST需</span><br><span class="line">		要设置请求体</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>发送请求的URL字符串中，如果包含了中文或者空格等特殊符号，需要对URL字 符串添加“百分号转义”</code></p>
]]></content>
      <categories>
        <category>iOS基础</category>
      </categories>
      <tags>
        <tag>NSURLRequest</tag>
        <tag>cachePolicy</tag>
        <tag>timeoutInterval</tag>
      </tags>
  </entry>
  <entry>
    <title>几种常用的排序算法</title>
    <url>/2016/12/08/paixusuanfa/</url>
    <content><![CDATA[<p>这里总结了一下我们平时常用的集中排序方法，供大家学习参考</p>
<a id="more"></a>
<h4 id="1、插入排序"><a href="#1、插入排序" class="headerlink" title="1、插入排序"></a>1、插入排序</h4><p>每次从无序表中取出第一个元素，把它插入到有序表的合适位置，使有序表仍然有序。</p>
<p><code>直接插入排序算法时间复杂度：O(n^2)；空间复杂度：O(1)。直接插入排序是稳定的排序方法。</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int a[]&#x3D;&#123;98,76,109,34,67,190,80,12,14,89,1&#125;;</span><br><span class="line">    int k&#x3D;sizeof(a)&#x2F;sizeof(a[0]);</span><br><span class="line">    int j;</span><br><span class="line">    for(int i&#x3D;1;i&lt;k;i++)&#x2F;&#x2F;循环从第2个元素开始</span><br><span class="line">    &#123;</span><br><span class="line">        if(a[i]&lt;a[i-1])</span><br><span class="line">        &#123;</span><br><span class="line">            int temp&#x3D;a[i];</span><br><span class="line">            for(j&#x3D;i-1;j&gt;&#x3D;0 &amp;&amp; a[j]&gt;temp;j--)</span><br><span class="line">            &#123;</span><br><span class="line">                a[j+1]&#x3D;a[j];</span><br><span class="line">            &#125;</span><br><span class="line">            a[j+1]&#x3D;temp;&#x2F;&#x2F;此处就是a[j+1]&#x3D;temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int f&#x3D;0;f&lt;k;f++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;a[f]&lt;&lt;&quot;  &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2、冒泡排序"><a href="#2、冒泡排序" class="headerlink" title="2、冒泡排序"></a>2、冒泡排序</h4><p><code>冒泡排序时间复杂度，最好情况：数组已有序O(n)；最坏情况:数组反序O(n^2)，平均时间复杂度：O(n^2)。空间复杂度，冒泡排序是原地排序，空间复杂度为O(1)。冒泡排序算法是稳定的排序算法。</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void bubble_sort(int a[], int n)</span><br><span class="line">&#123;</span><br><span class="line">    int i, j, temp;</span><br><span class="line">    for (j &#x3D; 0; j &lt; n - 1; j++)</span><br><span class="line">        for (i &#x3D; 0; i &lt; n - 1 - j; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(a[i] &gt; a[i + 1])</span><br><span class="line">            &#123;</span><br><span class="line">                temp &#x3D; a[i];</span><br><span class="line">                a[i] &#x3D; a[i + 1];</span><br><span class="line">                a[i + 1] &#x3D; temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="3、直接选择排序"><a href="#3、直接选择排序" class="headerlink" title="3、直接选择排序"></a>3、直接选择排序</h4><p>无序数组a[0…n-1]，第一次从a[0]<del>a[n-1]中选取最小值，与a[0]交换，第二次从a[1]</del>a[n-1]中选取最小值，与a[1]交换，….，第i次从a[i-1]<del>a[n-1]中选取最小值，与a[i-1]交换，…..，第n-1次从a[n-2]</del>a[n-1]中选取最小值，与a[n-2]交换，总共通过n-1次，得到一个按关键字从小到大排列的有序序列·</p>
<p><code>在直接选择排序中，共需要进行n-1次选择和交换，每次选择需要进行 n-i 次比较 (1&lt;=i&lt;=n-1),而每次交换最多需要3次移动，因此，总的比较次数C=(n*n - n)/2，时间复杂度O(n^2)。直接选择排序为原地排序，空间复杂度O(1)。直接选择排序不是稳定的排序算法。</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;直接选择排序  </span><br><span class="line">void sort(int array[],int size)&#123;  </span><br><span class="line">        int i,j,small,temp;  </span><br><span class="line">        for(i&#x3D;0;i&lt;size;i++)&#123;  </span><br><span class="line">        &#x2F;&#x2F;将i假设为最小的  </span><br><span class="line">                small &#x3D; i;  </span><br><span class="line">        &#x2F;&#x2F;从i+1开始遍历，找到最小的但是比i大的数的下标  </span><br><span class="line">                for(j&#x3D;i+1;j&lt;size;j++)&#123;  </span><br><span class="line">                        if(array[j]&lt;array[small])&#123;  </span><br><span class="line">                                small &#x3D; j;  </span><br><span class="line">                        &#125;  </span><br><span class="line">                &#125;  </span><br><span class="line">        &#x2F;&#x2F;将i和找到的最小的数交换  </span><br><span class="line">                temp &#x3D; array[i];  </span><br><span class="line">                array[i] &#x3D; array[small];  </span><br><span class="line">                array[small] &#x3D; temp;  </span><br><span class="line">  </span><br><span class="line">                display(array,size);  </span><br><span class="line">        &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<h4 id="4、归并排序"><a href="#4、归并排序" class="headerlink" title="4、归并排序"></a>4、归并排序</h4><p><code>时间复杂度为O(nlogn) 是归并排序算法中最好、最坏和平均的时间性能。空间复杂度O(n)。归并排序比较占用内存，但却是一种效率高且稳定的排序算法算法。</code></p>
<p><img src="http://www.hubwiz.com/course/5718b82208ce8b3d3a1432fa/img/merge.png" alt="icon"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void Merge(int sourceArr[],int tempArr[], int startIndex, int midIndex, int endIndex)</span><br><span class="line">&#123;</span><br><span class="line">    int i &#x3D; startIndex, j&#x3D;midIndex+1, k &#x3D; startIndex;</span><br><span class="line">    while(i!&#x3D;midIndex+1 &amp;&amp; j!&#x3D;endIndex+1)</span><br><span class="line">    &#123;</span><br><span class="line">        if(sourceArr[i] &gt; sourceArr[j])</span><br><span class="line">            tempArr[k++] &#x3D; sourceArr[j++];</span><br><span class="line">        else</span><br><span class="line">            tempArr[k++] &#x3D; sourceArr[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    while(i !&#x3D; midIndex+1)</span><br><span class="line">        tempArr[k++] &#x3D; sourceArr[i++];</span><br><span class="line">    while(j !&#x3D; endIndex+1)</span><br><span class="line">        tempArr[k++] &#x3D; sourceArr[j++];</span><br><span class="line">    for(i&#x3D;startIndex; i&lt;&#x3D;endIndex; i++)</span><br><span class="line">        sourceArr[i] &#x3D; tempArr[i];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;内部使用递归</span><br><span class="line">void MergeSort(int sourceArr[], int tempArr[], int startIndex, int endIndex)</span><br><span class="line">&#123;</span><br><span class="line">    int midIndex;</span><br><span class="line">    if(startIndex &lt; endIndex)</span><br><span class="line">    &#123;</span><br><span class="line">        midIndex &#x3D; (startIndex + endIndex) &#x2F; 2;</span><br><span class="line">        MergeSort(sourceArr, tempArr, startIndex, midIndex);</span><br><span class="line">        MergeSort(sourceArr, tempArr, midIndex+1, endIndex);</span><br><span class="line">        Merge(sourceArr, tempArr, startIndex, midIndex, endIndex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="5、快速排序"><a href="#5、快速排序" class="headerlink" title="5、快速排序"></a>5、快速排序</h4><p><code>快速排序算法平均时间复杂度O(nlgn)，最坏O(n^2)。快速排序需要栈空间来实现递归，如果数组按局等方式被分割时，则最大的递归深度为 log n，需要的栈空间为 O(log n)。最坏的情况下在递归的每一级上，数组分割成长度为0的左子数组和长度为 n - 1 的右数组。这种情况下，递归的深度就成为 n，需要的栈空间为 O(n)。快速排序不是稳定排序算法。</code></p>
<p>算法说明：<br><img src="http://www.hubwiz.com/course/5718b82208ce8b3d3a1432fa/img/quicksort.png" alt="icon"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void sort(int *a, int left, int right)</span><br><span class="line">&#123;</span><br><span class="line">    if(left &gt;&#x3D; right)&#x2F;*如果左边索引大于或者等于右边的索引就代表已经整理完成一个组了*&#x2F;</span><br><span class="line">    &#123;</span><br><span class="line">        return ;</span><br><span class="line">    &#125;</span><br><span class="line">    int i &#x3D; left;</span><br><span class="line">    int j &#x3D; right;</span><br><span class="line">    int key &#x3D; a[left];</span><br><span class="line">     </span><br><span class="line">    while(i &lt; j)                               &#x2F;*控制在当组内寻找一遍*&#x2F;</span><br><span class="line">    &#123;</span><br><span class="line">        while(i &lt; j &amp;&amp; key &lt;&#x3D; a[j])</span><br><span class="line">        &#x2F;*而寻找结束的条件就是，1，找到一个小于或者大于key的数（大于或小于取决于你想升</span><br><span class="line">        序还是降序）2，没有符合条件1的，并且i与j的大小没有反转*&#x2F; </span><br><span class="line">        &#123;</span><br><span class="line">            j--;&#x2F;*向前寻找*&#x2F;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        a[i] &#x3D; a[j];</span><br><span class="line">        &#x2F;*找到一个这样的数后就把它赋给前面的被拿走的i的值（如果第一次循环且key是</span><br><span class="line">        a[left]，那么就是给key）*&#x2F;</span><br><span class="line">         </span><br><span class="line">        while(i &lt; j &amp;&amp; key &gt;&#x3D; a[i])</span><br><span class="line">        &#x2F;*这是i在当组内向前寻找，同上，不过注意与key的大小关系停止循环和上面相反，</span><br><span class="line">        因为排序思想是把数往两边扔，所以左右两边的数大小与key的关系相反*&#x2F;</span><br><span class="line">        &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        a[j] &#x3D; a[i];</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    a[i] &#x3D; key;&#x2F;*当在当组内找完一遍以后就把中间数key回归*&#x2F;</span><br><span class="line">    sort(a, left, i - 1);&#x2F;*最后用同样的方式对分出来的左边的小组进行同上的做法*&#x2F;</span><br><span class="line">    sort(a, i + 1, right);&#x2F;*用同样的方式对分出来的右边的小组进行同上的做法*&#x2F;</span><br><span class="line">                       &#x2F;*当然最后可能会出现很多分左右，直到每一组的i &#x3D; j 为止*&#x2F;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序 冒泡 快排</tag>
      </tags>
  </entry>
  <entry>
    <title>Protobuf 的使用</title>
    <url>/2018/03/31/protobuf-research/</url>
    <content><![CDATA[<p>Google Protocol Buffer(简称Protobuf)是由Google推出的一种轻便高效的结构化数据存储格式，可以用于结构化数据串行化，或者说序列化。它很适合做数据存储或RPC数据交换格式。可用于通讯协议、数据存储等领域的语言无关、平台无关、可扩展的序列化结构数据格式</p>
<a id="more"></a>

<h2 id="Protobuf的安装"><a href="#Protobuf的安装" class="headerlink" title="Protobuf的安装"></a>Protobuf的安装</h2><p>这里推荐使用homebrew安装,如果没有安装,先<a href="https://brew.sh/index_zh-cn.html">安装</a>吧</p>
<h3 id="安装protobuf"><a href="#安装protobuf" class="headerlink" title="安装protobuf"></a>安装protobuf</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$brew install protobuf</span><br></pre></td></tr></table></figure>

<h3 id="安装Protobuf-Compiler"><a href="#安装Protobuf-Compiler" class="headerlink" title="安装Protobuf Compiler"></a>安装Protobuf Compiler</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew install automake </span><br><span class="line">brew install libtool </span><br><span class="line">brew install protobuf</span><br></pre></td></tr></table></figure>

<h2 id="Protobuf-使用"><a href="#Protobuf-使用" class="headerlink" title="Protobuf 使用"></a>Protobuf 使用</h2><p>安装完成后我们就可以直接使用了！</p>
<p><code>注意</code>:上面只是安装了编译环境,可以帮我们将.proto文件编译成我们需要的.h和.m环境</p>
<h3 id="Protobuf-导入"><a href="#Protobuf-导入" class="headerlink" title="Protobuf 导入"></a>Protobuf 导入</h3><p>下面我们就可以新建一个iOS的工程了,然后使用pod方式管理protobuf</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pod &#39;Protobuf&#39;, &#39;~&gt; 3.4.0&#39;</span><br></pre></td></tr></table></figure>

<h3 id="编写一个proto文件"><a href="#编写一个proto文件" class="headerlink" title="编写一个proto文件"></a>编写一个proto文件</h3><p>这个proto文件就相当于一个类,不过要使用protobuf的语法来定义</p>
<p>可以简单的这么写：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"></span><br><span class="line">message ChatMessage &#123;</span><br><span class="line">    <span class="built_in">string</span> title = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">string</span> body = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：<br><code>使用proto3的时候不需要在变量前面加上required和optional,默认就是optional</code><br>具体的语法规则我们后面介绍</p>
<h3 id="编译这个proto文件"><a href="#编译这个proto文件" class="headerlink" title="编译这个proto文件"></a>编译这个proto文件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protoc --plugin&#x3D;&#x2F;usr&#x2F;local&#x2F;bin&#x2F;protoc-gen-objc *.proto --objc_out&#x3D;&quot;.&#x2F;*&quot;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>第一个<em>号的地方是你.proto文件所在的位置,<br>第二个</em>所在的地方是你编译完成之后.h和.m要导出的地方</p>
</blockquote>
<h3 id="将生成的文件添加到项目中"><a href="#将生成的文件添加到项目中" class="headerlink" title="将生成的文件添加到项目中"></a>将生成的文件添加到项目中</h3><p>直接添加之后,编译一下,肯定是会报错的(除非你还活在远古的MRC)。这时候你需要将编译出来的对象文件标记为MRC<br>Target - BuildPhases - Compile Sources</p>
<p><img src="http://og0h689k8.bkt.clouddn.com/18-3-31/6967231.jpg"></p>
<p>然后我们仔细阅读,生成的.h文件会发现中的这一段:</p>
<p><img src="http://og0h689k8.bkt.clouddn.com/18-3-31/92058883.jpg"></p>
<p>因为我们是使用pod管理的因此我们这里使用&lt;&gt;导入,因此在</p>
<p>Target - Build Setting - Preprocessor Macros </p>
<p>在Debug和Release中都添加</p>
<p><img src="http://og0h689k8.bkt.clouddn.com/18-3-31/739274.jpg"></p>
<p>这样我们在编译一下,Done! 这就没什么问题了！ </p>
<p>到目前为止,我们基本上已经完成了Protobuf的所有配置,下面开始使用Protobuf了。</p>
<h2 id="简单的使用"><a href="#简单的使用" class="headerlink" title="简单的使用"></a>简单的使用</h2><p>先导入我们生成的.h文件</p>
<p><code>#import &quot;ProtobufChatmessage.pbobjc.h&quot;</code></p>
<p>简单的创建一个的对象–序列化成data然后在解析这个data。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">ChatMessage *message = [[ChatMessage alloc] init];</span><br><span class="line">    message.title = <span class="string">@&quot;Lee&quot;</span>;</span><br><span class="line">    message.body = <span class="string">@&quot;Hom&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSData</span> *data = [message data];</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSError</span> *error = <span class="literal">nil</span>;</span><br><span class="line">    ChatMessage *msg = [ChatMessage parseFromData:data error:&amp;error];</span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;parseData Error %@&quot;</span>,error.localizedDescription);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;parseData Success&quot;</span>);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;ChatMessage:title=%@ body=%@&quot;</span>,msg.title,msg.body);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>运行结果:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2018-03-31 10:31:00.854929+0800 ProtobufDemo[5901:690009] parseData Success</span><br><span class="line">2018-03-31 10:31:00.855157+0800 ProtobufDemo[5901:690009] ChatMessage:title&#x3D;Lee body&#x3D;Hom</span><br></pre></td></tr></table></figure>

<p>至此,我们已经成功的使用到了Protobuf,最直观的感觉就是直接从二进制的NSData转变成了我们想要的模型 Cool!!</p>
<p>Protocol还有很多高深的内容,网上也有很多关于他的文章,喜欢的可以多看看！</p>
<h2 id="Protobuf-基本语法"><a href="#Protobuf-基本语法" class="headerlink" title="Protobuf  基本语法"></a>Protobuf  基本语法</h2><h3 id="字段格式定义"><a href="#字段格式定义" class="headerlink" title="字段格式定义"></a>字段格式定义</h3><p>在Protobuf中，协议是由一系列的消息组成的。因此最重要的就是定义通信时使用到的消息格式。协议中个消息格式固定了t通信双方才能理解对象的码流。</p>
<p><code>限定修饰符① | 数据类型② | 字段名称③ | = | 字段编码值④ | [字段默认值⑤]</code></p>
<h3 id="限定修饰符"><a href="#限定修饰符" class="headerlink" title="限定修饰符"></a>限定修饰符</h3><p>限定修饰符 主要有required\optional\repeated(required在3.0的时候已经被废除,默认是optional)</p>
<ul>
<li><p>Optional：表示是一个可选字段，可选对于发送方，在发送消息时，可以有选择性的设置或者不设置该字段的值。对于接收方，如果能够识别可选字段就进行相应的处理，如果无法识别，则忽略该字段，消息中的其它字段正常处理。因为optional字段的特性，很多接口在升级版本中都把后来添加的字段都统一的设置为optional字段，这样老的版本无需升级程序也可以正常的与新的软件进行通信，只不过新的字段无法识别而已，因为并不是每个节点都需要新的功能，因此可以做到按需升级和平滑过渡。</p>
</li>
<li><p>Repeated：表示该字段可以包含0~N个元素。其特性和optional一样，但是每一次可以包含多个值。可以看作是在传递一个数组的值</p>
</li>
</ul>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>Protobuf到C++的类型映射</p>
<table>
<thead>
<tr>
<th>proto Type</th>
<th>C++ Type</th>
<th>Notes</th>
</tr>
</thead>
<tbody><tr>
<td>double</td>
<td>double</td>
<td></td>
</tr>
<tr>
<td>float</td>
<td>float</td>
<td></td>
</tr>
<tr>
<td>int32</td>
<td>int32</td>
<td>使用可变长编码方式。编码负数时不够高效——如果你的字段可能含有负数，那么请使用sint32。</td>
</tr>
<tr>
<td>int64</td>
<td>int64</td>
<td>使用可变长编码方式。编码负数时不够高效——如果你的字段可能含有负数，那么请使用sint64</td>
</tr>
<tr>
<td>uint32</td>
<td>uint32</td>
<td>Uses variable-length encoding</td>
</tr>
<tr>
<td>uint64</td>
<td>uint64</td>
<td>Uses variable-length encoding.</td>
</tr>
<tr>
<td>sint32</td>
<td>int32</td>
<td>使用可变长编码方式。有符号的整型值。编码时比通常的int32高效。</td>
</tr>
<tr>
<td>sint64</td>
<td>int64</td>
<td>使用可变长编码方式。有符号的整型值。编码时比通常的int64高效。</td>
</tr>
<tr>
<td>fixed32</td>
<td>uint32</td>
<td>总是4个字节。如果数值总是比总是比228大的话，这个类型会比uint32高效</td>
</tr>
<tr>
<td>fixed64</td>
<td>uint64</td>
<td>总是8个字节。如果数值总是比总是比256大的话，这个类型会比uint64高效。</td>
</tr>
<tr>
<td>sfixed32</td>
<td>int32</td>
<td>总是4个字节</td>
</tr>
<tr>
<td>sfixed64</td>
<td>int64</td>
<td>总是8个字节</td>
</tr>
<tr>
<td>bool</td>
<td>bool</td>
<td></td>
</tr>
<tr>
<td>string</td>
<td>string</td>
<td>一个字符串必须是UTF-8编码或者7-bit ASCII编码的文本。</td>
</tr>
<tr>
<td>bytes</td>
<td>string</td>
<td>可能包含任意顺序的字节数据。</td>
</tr>
</tbody></table>
<h3 id="字段名称"><a href="#字段名称" class="headerlink" title="字段名称"></a>字段名称</h3><p>protobuf建议字段的命名采用以下划线分割的驼峰式。例如 first_name 而不是firstName.</p>
<h3 id="字段编码值"><a href="#字段编码值" class="headerlink" title="字段编码值"></a>字段编码值</h3><p>有了该值，通信双方才能互相识别对方的字段。当然相同的编码值，其限定修饰符和数据类型必须相同。</p>
<p>编码值的取值范围为 1~2^32（4294967296）。</p>
<p>其中 1~15的编码时间和空间效率都是最高的，编码值越大，其编码的时间和空间效率就越低（相对于1-15），当然一般情况下相邻的2个值编码效率的是相同的，除非2个值恰好实在4字节，12字节，20字节等的临界区。比如15和16.</p>
<p>1900~2000编码值为Google protobuf 系统内部保留值，建议不要在自己的项目中使用。</p>
<p>protobuf 还建议把经常要传递的值把其字段编码设置为1-15之间的值。</p>
<p>消息中的字段的编码值无需连续，只要是合法的，并且不能在同一个消息中有字段包含相同的编码值</p>
<h5 id="关于import"><a href="#关于import" class="headerlink" title="关于import"></a>关于import</h5><p>Protobuf接口文件可以像C语言的h文件一个，分离为多个，在需要的时候通过import导入需要对文件。其行为和C语言的#include或者iOS中的的#import的行为大致相同。</p>
<h5 id="关于package"><a href="#关于package" class="headerlink" title="关于package"></a>关于package</h5><p>避免名称冲突，可以给每个文件指定一个package名称，对于java解析为java中的包。对于C++则解析为名称空间。</p>
<h5 id="关于message"><a href="#关于message" class="headerlink" title="关于message"></a>关于message</h5><p>支持嵌套消息，消息可以包含另一个消息作为其字段。也可以在消息内定义一个新的消息。</p>
<h5 id="关于enum"><a href="#关于enum" class="headerlink" title="关于enum"></a>关于enum</h5><p>枚举的定义和C++相同，但是有一些限制。枚举值必须大于等于0的整数。使用分号(;)分隔枚举变量而不是C++语言中的逗号(,)</p>
<h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1,数据压缩效果好,序列化反序列速度快</span><br><span class="line">2,跨平台,生成一次proto文件,多端使用</span><br></pre></td></tr></table></figure>

<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1,可读性行差(在代码中)</span><br><span class="line">2,最增加App包体积(生成的类本身就代码很多,而且需要使用第三方库)</span><br><span class="line">3,用的人少(在项目交接时,还需要学习这方面的知识)</span><br></pre></td></tr></table></figure>

<p>本文的Demo,放在<a href="https://github.com/LeeWongSnail/Blog_Demo/tree/master/ProtobufDemo">这里</a></p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="http://blog.devzeng.com/blog/ios-protobuf.html">iOS中使用Protocol Buffers</a></p>
<p><a href="https://www.jianshu.com/p/751aa2b621d5">ProtocolBuffer在iOS中的使用</a></p>
]]></content>
      <categories>
        <category>三方库使用</category>
      </categories>
      <tags>
        <tag>Protobuf Google</tag>
      </tags>
  </entry>
  <entry>
    <title>无线循环的滚动视图方案</title>
    <url>/2019/12/20/recyclescrollview/</url>
    <content><![CDATA[<p>我们近期的项目中有两种场景分别是视频流和直播间,由于项目初期直播间或者视频量较少。因此在用户滑动切换直播间或者视频时需要我们做到可以循环滑动。</p>
<a id="more"></a>

<h2 id="可循环滚动内容方案"><a href="#可循环滚动内容方案" class="headerlink" title="可循环滚动内容方案"></a>可循环滚动内容方案</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>我们近期的项目中有两种场景分别是视频流和直播间,由于项目初期直播间或者视频量较少。因此在用户滑动切换直播间或者视频时需要我们做到可以循环滑动。</p>
<h3 id="框架选择"><a href="#框架选择" class="headerlink" title="框架选择"></a>框架选择</h3><p>遇到这几种场景时我们一般都会想到下面三种方案,对于滑动切换这种场景实际上我们要关注的点是：<br>1、何时确定切换完成<br>2、如果在切换完成时获取当前要展示元素(view+model)时机以及方法<br>3、如何滚动到某个具体位置</p>
<p>下面我们带着上面的两个主要问题,讨论下面三个方案可行性和各自的优缺点。</p>
<h4 id="方案一-UICollectionView"><a href="#方案一-UICollectionView" class="headerlink" title="方案一:UICollectionView"></a>方案一:UICollectionView</h4><h5 id="1、何时确定切换完成？"><a href="#1、何时确定切换完成？" class="headerlink" title="1、何时确定切换完成？"></a>1、何时确定切换完成？</h5><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)collectionView:(<span class="built_in">UICollectionView</span> *)collectionView didEndDisplayingCell:(<span class="built_in">UICollectionViewCell</span> *)cell forItemAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath;</span><br></pre></td></tr></table></figure>
<p>这个方法会在滚动停止时被调用,当然滚动停止并不意味着切换完成因为存在滚动停止时页面并未切换的场景。<br>因此想要确认切换完成 需要将页面停止时当前的Index与滚动前的Index做对比,进而确认是否完成切换。</p>
<h5 id="2、如果在切换完成时获取当前要展示元素-view-model-时机以及方法？"><a href="#2、如果在切换完成时获取当前要展示元素-view-model-时机以及方法？" class="headerlink" title="2、如果在切换完成时获取当前要展示元素(view+model)时机以及方法？"></a>2、如果在切换完成时获取当前要展示元素(view+model)时机以及方法？</h5><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">UICollectionViewCell</span> *)cellForItemAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath</span><br></pre></td></tr></table></figure>
<p>在页面滚动停止时获取当前展示页面的IndexPath,但是页面滚动停止代理方法返回的是结束展示的view和indexPath所以这里需要做一下转换</p>
<h5 id="3、如何滚动到某个具体位置"><a href="#3、如何滚动到某个具体位置" class="headerlink" title="3、如何滚动到某个具体位置"></a>3、如何滚动到某个具体位置</h5><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)scrollToItemAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath atScrollPosition:(<span class="built_in">UICollectionViewScrollPosition</span>)scrollPosition animated:(<span class="built_in">BOOL</span>)animated;</span><br></pre></td></tr></table></figure>


<h4 id="方案二-UITableView"><a href="#方案二-UITableView" class="headerlink" title="方案二:UITableView"></a>方案二:UITableView</h4><h5 id="1、何时确定切换完成？-1"><a href="#1、何时确定切换完成？-1" class="headerlink" title="1、何时确定切换完成？"></a>1、何时确定切换完成？</h5><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)tableView:(<span class="built_in">UITableView</span> *)tableView didEndDisplayingCell:(<span class="built_in">UITableViewCell</span> *)cell forRowAtIndexPath:(<span class="built_in">NSIndexPath</span>*)indexPath API_AVAILABLE(ios(<span class="number">6.0</span>));</span><br></pre></td></tr></table></figure>

<p>与UICollectionView类似,页面滚动停止时可以拿到完成展示的页面以及IndexPath。</p>
<h5 id="2、如果在切换完成时获取当前要展示元素-view-model-时机以及方法？-1"><a href="#2、如果在切换完成时获取当前要展示元素-view-model-时机以及方法？-1" class="headerlink" title="2、如果在切换完成时获取当前要展示元素(view+model)时机以及方法？"></a>2、如果在切换完成时获取当前要展示元素(view+model)时机以及方法？</h5><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">nullable</span> __kindof <span class="built_in">UITableViewCell</span> *)cellForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath;   <span class="comment">// returns nil if cell is not visible or index path is out of range</span></span><br></pre></td></tr></table></figure>
<p>获取视图和模型的方法与UICollectionView的一致。</p>
<h5 id="3、如何滚动到某个具体位置-1"><a href="#3、如何滚动到某个具体位置-1" class="headerlink" title="3、如何滚动到某个具体位置"></a>3、如何滚动到某个具体位置</h5><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)scrollToRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath atScrollPosition:(<span class="built_in">UITableViewScrollPosition</span>)scrollPosition animated:(<span class="built_in">BOOL</span>)animated;</span><br></pre></td></tr></table></figure>
<p>该方法与UICollectionView一致。</p>
<h4 id="方案三-UIScrollView"><a href="#方案三-UIScrollView" class="headerlink" title="方案三:UIScrollView"></a>方案三:UIScrollView</h4><h5 id="1、何时确定切换完成？-2"><a href="#1、何时确定切换完成？-2" class="headerlink" title="1、何时确定切换完成？"></a>1、何时确定切换完成？</h5><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)scrollViewDidScroll:(<span class="built_in">UIScrollView</span> *)scrollView;                                               <span class="comment">// any offset changes</span></span><br></pre></td></tr></table></figure>
<p>该方法的调用时机为页面滚动,调用频率比较高！需要根据页面滚动的contentOffset来判断当前的页码。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// called on finger up if the user dragged. decelerate is true if it will continue moving afterwards</span></span><br><span class="line">- (<span class="keyword">void</span>)scrollViewDidEndDragging:(<span class="built_in">UIScrollView</span> *)scrollView willDecelerate:(<span class="built_in">BOOL</span>)decelerate;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)scrollViewDidEndDecelerating:(<span class="built_in">UIScrollView</span> *)scrollView;      <span class="comment">// called when scroll view grinds to a halt</span></span><br></pre></td></tr></table></figure>

<p>这两个方法表示滚动停止！其调用时机分别是：</p>
<p>1、scrollViewDidEndDragging：</p>
<p>scrollView 结束拖动(松开鼠标停止拖动的那一瞬间调用(水平滚动ScrollView也调用，垂直滚动TableView也调用))</p>
<p>2、scrollViewDidEndDecelerating：</p>
<p> scrollview 减速停止(必须得有快速拖动的动作，scrollView滚动完毕(速度减为0)并且手已经松开的时候调用)</p>
<h5 id="2、如果在切换完成时获取当前要展示元素-view-model-时机以及方法？-2"><a href="#2、如果在切换完成时获取当前要展示元素-view-model-时机以及方法？-2" class="headerlink" title="2、如果在切换完成时获取当前要展示元素(view+model)时机以及方法？"></a>2、如果在切换完成时获取当前要展示元素(view+model)时机以及方法？</h5><p>滚动完成时获取当前处于第几个位置,使用scrollView的contentOffset.y与单个视图的高度做除法来获取当前滚动到的视图的位置</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">CGFloat</span> screenHeigh = <span class="keyword">self</span>.view.frame.size.height;</span><br><span class="line"><span class="built_in">NSInteger</span> offsety = scrollView.contentOffset.y;</span><br><span class="line"><span class="built_in">NSInteger</span> height = screenHeigh;</span><br><span class="line"><span class="built_in">CGFloat</span> ratio = offsety % height;</span><br><span class="line"><span class="built_in">NSInteger</span> index = offsety/screenHeigh;</span><br><span class="line">ULLogInfo(<span class="string">@&quot;LIVEMANAGER： scrollViewDidScroll=index=%@&quot;</span>,@(index));</span><br><span class="line"><span class="keyword">if</span> (index == <span class="keyword">self</span>.currentIndex) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;enter_live_room_new %s, %@&quot;</span>, __PRETTY_FUNCTION__, <span class="string">@&quot;1&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (scrollView == <span class="keyword">self</span>.tableView &amp;&amp; ratio == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">self</span>.currentIndex = index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据上面的条件可以获取到当前展示的视图的位置</p>
<h5 id="3、如何滚动到某个具体位置-2"><a href="#3、如何滚动到某个具体位置-2" class="headerlink" title="3、如何滚动到某个具体位置"></a>3、如何滚动到某个具体位置</h5><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setContentOffset:(<span class="built_in">CGPoint</span>)contentOffset animated:(<span class="built_in">BOOL</span>)animated;  <span class="comment">// animate at constant velocity to new offset</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="无限循环方案"><a href="#无限循环方案" class="headerlink" title="无限循环方案"></a>无限循环方案</h3><p>假设目前有下面几个视图 </p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gbc3eho3e8j30y004g3yq.jpg" alt="viewtree"></p>
<p>如果我们要实现无限循环的滚动那么实际上我们有两种方案：</p>
<ul>
<li>1、修改数据源 实现无线循环滚动(缺点较明显)</li>
<li>2、修改滚动视图位置 静默滚动 (详细介绍)</li>
</ul>
<h4 id="修改数据源-实现无线循环滚动"><a href="#修改数据源-实现无线循环滚动" class="headerlink" title="修改数据源 实现无线循环滚动"></a>修改数据源 实现无线循环滚动</h4><p>咱们的滚动视图中,以UITableView为例,因为我们的cell是可复用的所以不用考虑创建大量的view的问题：</p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gbc3oliqj4j31kw06ygn0.jpg"></p>
<p>我们可以对数据源做大量的复制比如在tableView中做分组<br>在</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">NSInteger</span>)numberOfSectionsInTableView:(<span class="built_in">UITableView</span> *)tableView</span><br></pre></td></tr></table></figure>
<p>方法中返回一个固定值 例如1000<br>在</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">NSInteger</span>)tableView:(<span class="built_in">UITableView</span> *)tableView numberOfRowsInSection:(<span class="built_in">NSInteger</span>)section;</span><br></pre></td></tr></table></figure>
<p>中返回我们视图个数</p>
<p>如此我们页面上展示的就是一个有1000个分组 每个分组中有N个row的TableView</p>
<p>在初始化页面展示完成后静默的将页面滚动到中间的分组位置,这样就可以实现循环滚动的效果！</p>
<p>问题：<br>1、这种方式比较适合每个分组中个数固定的类型 比如banner 但是如果我们在滑动过程中需要动态请求接口来扩充每一个分组中数据的个数 那么这种方式需要频繁操作大量数据源。<br>2、在滚动过程中如果我们遇到了某些数据是不符合业务条件的(比如直播间中被拉黑),我们在进行过滤操作时需要操作所有的分组。<br>优点：<br>在数据量不是太大的情况下,我们不需要对页面做滚动操作。</p>
<h4 id="修改滚动视图位置-静默滚动"><a href="#修改滚动视图位置-静默滚动" class="headerlink" title="修改滚动视图位置 静默滚动"></a>修改滚动视图位置 静默滚动</h4><p>这种方法我们不去操作数据源 保证数据源的稳定,只是在临界条件时需要进行静默滚动操作</p>
<p>通过下面这张图我们来更加详细的描述下</p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gbc404oojrj319w05474q.jpg"></p>
<p>下面我们重点介绍下临界点时的处理逻辑</p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gbc42i2ct1j31b8064t9b.jpg"></p>
<h5 id="1、当页面滚动到A且为向上滚动时"><a href="#1、当页面滚动到A且为向上滚动时" class="headerlink" title="1、当页面滚动到A且为向上滚动时"></a>1、当页面滚动到A且为向上滚动时</h5><p>按照理想的情况 当前情况再次向上滚动我们应该滚动到最末尾的位置。</p>
<p>1、如何判断当前是向上滚动且滚动到了A的位置</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">self</span>.currentIndex == <span class="number">0</span> &amp;&amp; !<span class="keyword">self</span>.isFirstEntry) &#123;</span><br><span class="line">    <span class="comment">// 滚动到了第一个位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、如何滚动</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 需要滚动到列表的倒数第二个位置</span></span><br><span class="line"><span class="built_in">NSInteger</span> rowCount = <span class="keyword">self</span>.liveListArray.count;</span><br><span class="line"><span class="keyword">if</span> (rowCount &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">self</span>.currentIndex = rowCount<span class="number">-2</span>;</span><br><span class="line">    [<span class="keyword">self</span>.tableView scrollToRowAtIndexPath:[<span class="built_in">NSIndexPath</span> indexPathForRow:<span class="keyword">self</span>.currentIndex inSection:<span class="number">0</span>] atScrollPosition:<span class="built_in">UITableViewScrollPositionTop</span> animated:<span class="literal">NO</span>];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果数组的个数小于2 那么证明只有一个直播间不可以滚动</span></span><br><span class="line">    [<span class="keyword">self</span> canSlideChangeLiveRoom:<span class="literal">NO</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：判断数组的个数是因为如果只有一个数据 不需要滚动</p>
<h5 id="2、当前页面滚动到E且为向下滚动时"><a href="#2、当前页面滚动到E且为向下滚动时" class="headerlink" title="2、当前页面滚动到E且为向下滚动时"></a>2、当前页面滚动到E且为向下滚动时</h5><p>这种情况的判断比较简单：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">self</span>.currentIndex == <span class="keyword">self</span>.liveListArray.count <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="comment">// 滚动到了最后一个</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>滚动到指定位置</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 滚动到最后一个位置 此处的数据为补充数据 需要滚动列表</span></span><br><span class="line">    <span class="comment">// 需要滚到第一个位置</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.liveListArray.count == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果当前直播间列表只有一个直播间</span></span><br><span class="line">        [<span class="keyword">self</span> canSlideChangeLiveRoom:<span class="literal">NO</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.currentIndex = <span class="number">1</span>;</span><br><span class="line">        [<span class="keyword">self</span>.tableView scrollToRowAtIndexPath:[<span class="built_in">NSIndexPath</span> indexPathForRow:<span class="keyword">self</span>.currentIndex inSection:<span class="number">0</span>] atScrollPosition:<span class="built_in">UITableViewScrollPositionTop</span> animated:<span class="literal">NO</span>];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><code>注意</code>:上面两个方法的调用均是在页面滚动停止之后进行！</p>
<p>通过上面这些操作,我们基本实现了一个可以循环滑动的列表！！ </p>
<p>但是在应用到实际的场景时我们肯定会遇到数据源的增删问题,那么这种情况下我们如何去处理呢？</p>
<h3 id="异常情况处理"><a href="#异常情况处理" class="headerlink" title="异常情况处理"></a>异常情况处理</h3><h4 id="数据源增加"><a href="#数据源增加" class="headerlink" title="数据源增加"></a>数据源增加</h4><p>这种情况通常是我们列表中的数据并不是一成不变的比如分页拉取多条数据,那么在这个时候我们应该如何操作呢？</p>
<p>下面我们通过,分页加载数据时如何处理：</p>
<p>假设我们在滚动到倒数第三个数据(有效数据倒数第二条)时我们预加载下一页的内容。</p>
<p>因为需要通过接口返回数据 所以我们无法确认接口返回数据的时机,所以这里要<code>注意处理数据源的时机和方式</code></p>
<p>假如我们接口返回了2条数据 F G </p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gbc4zx31e9j31m40d0jt6.jpg"></p>
<p>我们在返回数据后因为之前在数组的首尾都添加了占位的数据,因此数据添加后我们依然要重置这两个占位数据<br>同时在每次数据重置时都要确认当前数据的个数。</p>
<p>数组重置方法：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">NSArray</span> *)reCombineWithArray:(<span class="built_in">NSArray</span> *)liveList &#123;</span><br><span class="line">    <span class="built_in">NSMutableArray</span> *listArray = [<span class="built_in">NSMutableArray</span> arrayWithArray:liveList];</span><br><span class="line">    <span class="comment">// 当前直播间列表中有多个直播间</span></span><br><span class="line">    ULDiscovery *firstObject = listArray.firstObject;</span><br><span class="line">    ULDiscovery *firstPlacehoder = [ULDiscovery parse:[firstObject toDictionary]];</span><br><span class="line">    ULDiscovery * lastObject = listArray.lastObject;</span><br><span class="line">    ULDiscovery *lastPlacehoder = [ULDiscovery parse:[lastObject toDictionary]];</span><br><span class="line">    [listArray addObject:firstPlacehoder];</span><br><span class="line">    [listArray insertObject:lastPlacehoder atIndex:<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">return</span> [listArray <span class="keyword">copy</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之所以使用数据copy的方法是因为防止数组中数据对象相同导致在获取index时发生错位！</p>
<p>上面说过 因为数据是接口返回 那么可能存在下面两种情况：</p>
<ul>
<li>接口速度较快 在用户从倒数第二条数据滑动到倒数第一条数据前已经获取到数据了</li>
</ul>
<p>这种情况下我们在滚动之前就已经操作了数据源 因此此时数据中已经包含了新请求的F G 因此在此向下滑动时可以正确的滚动到F和G这两条数据。</p>
<ul>
<li>接口速度较慢 在用户从倒数第二条主句滑动到倒数第一条数据时或者之后才获取到数据</li>
</ul>
<p>这种情况下,我们滚动已经开始或者已经结束了,我们要滚动的位置已经根据之前的数据源(EABCDEA)确定了,当接口数据返回后数据源变成了(GABCDEFGA)我们可以发现除了占位数据外其他数据的index是没有改变的,所以这里不会影响数据返回前滚动的index数据的展示(index和数据还是一一对应的),只是新返回的数据需要再次滑动一遍之前的直播间(ABCDE)之后才有机会展示。</p>
<p>这样 我们就完成了动态添加数据后无限循环滚动视图的实现！</p>
<h4 id="数据源删除"><a href="#数据源删除" class="headerlink" title="数据源删除"></a>数据源删除</h4><p>这种情况通常发生在滚动列表数据源中的某一条数据被用户动态删除,我们在查询列表数据详情时发现该数据状态为已删除时需要将这条数据从列表中删除。</p>
<p>这种情况下我们需要做</p>
<ul>
<li>1、删除这条无效数据</li>
<li>2、重置当前数据源</li>
<li>3、找到下一个要滚动到的视图并进行滚动</li>
<li>4、滚动到指定位置</li>
</ul>
<p>第一步和第二部我们在上面都说过这里不再赘述。我们在着重说一下第三步</p>
<p>下面先介绍找到下一个视图的方法和参数：</p>
<p>liveList：删除完无效数据之后重置的数组<br>index: 已删除的无效数据的index<br>destIndex: 根据滚动方向判断出的下一个要展示的视图的位置<br>scrollDown: 是否为向下滚动</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">///  滚动到下一个直播间的index</span></span><br><span class="line"><span class="comment">/// @param aDiscovery aDiscovery description</span></span><br><span class="line"><span class="comment">/// @param scrollDown scrollDown description</span></span><br><span class="line">- (<span class="built_in">NSInteger</span>)findNextLiveItems:(<span class="built_in">NSArray</span> &lt;ULDiscovery *&gt; *)liveList index:(<span class="built_in">NSInteger</span>)index destIndex:(<span class="built_in">NSInteger</span>)destIndex scrollDown:(<span class="built_in">BOOL</span>)scrollDown &#123;</span><br><span class="line">    <span class="keyword">if</span> (scrollDown &amp;&amp; (destIndex &gt;= <span class="keyword">self</span>.liveListArray.count - <span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="comment">// 如果是向下滚动且为最后一个直播间向第一个直播间滚动 第一个直播间被拉黑</span></span><br><span class="line">        <span class="comment">// 需要滚动到第一个直播间的下一个直播间</span></span><br><span class="line">        <span class="comment">// 数组正向遍历</span></span><br><span class="line">        ULDiscovery *destDis = [liveList ul_safeObjectAtIndex:index];</span><br><span class="line">        __block <span class="built_in">NSInteger</span> disIndex = destIndex;</span><br><span class="line">        [liveList enumerateObjectsUsingBlock:^(ULDiscovery * _Nonnull obj, <span class="built_in">NSUInteger</span> idx, <span class="built_in">BOOL</span> * _Nonnull stop) &#123;</span><br><span class="line">            <span class="keyword">if</span> (obj.room.roomID == destDis.room.roomID) &#123;</span><br><span class="line">                *stop = <span class="literal">YES</span>;</span><br><span class="line">                disIndex = idx;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;];</span><br><span class="line">        destIndex = disIndex+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">self</span>.currentIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">self</span>.lastRoomIndex = <span class="number">-1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!scrollDown &amp;&amp; destIndex &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果是向上滚动且为第一个直播间向最后一个直播间滚动 最后一个直播间被拉黑</span></span><br><span class="line">        ULDiscovery *destDis = [liveList ul_safeObjectAtIndex:index];</span><br><span class="line">        __block <span class="built_in">NSInteger</span> disIndex = destIndex;</span><br><span class="line">        [liveList enumerateObjectsWithOptions:<span class="built_in">NSEnumerationReverse</span> usingBlock:^(ULDiscovery * _Nonnull obj, <span class="built_in">NSUInteger</span> idx, <span class="built_in">BOOL</span> * _Nonnull stop) &#123;</span><br><span class="line">            <span class="keyword">if</span> (obj.room.roomID == destDis.room.roomID) &#123;</span><br><span class="line">                disIndex = idx;</span><br><span class="line">                *stop = <span class="literal">YES</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;];</span><br><span class="line">        destIndex = disIndex<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">self</span>.lastRoomIndex = <span class="keyword">self</span>.liveListArray.count <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> destIndex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>滚动到指定位置方法</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 滚动到指定位置</span></span><br><span class="line">    dispatch_main_async_ulsafe(^&#123;</span><br><span class="line">        <span class="keyword">if</span> (destIndex &gt; <span class="number">0</span> &amp;&amp; destIndex &lt; <span class="keyword">self</span>.liveListArray.count) &#123;</span><br><span class="line">            [<span class="keyword">self</span>.tableView scrollToRowAtIndexPath:[<span class="built_in">NSIndexPath</span> indexPathForRow:destIndex inSection:<span class="number">0</span>] atScrollPosition:<span class="built_in">UITableViewScrollPositionTop</span> animated:<span class="literal">NO</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            [<span class="keyword">self</span>.tableView scrollToRowAtIndexPath:[<span class="built_in">NSIndexPath</span> indexPathForRow:<span class="number">0</span> inSection:<span class="number">0</span>] atScrollPosition:<span class="built_in">UITableViewScrollPositionTop</span> animated:<span class="literal">NO</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>

<p>这样我们就完成了 删除某条数据后循环滚动方案！！</p>
]]></content>
      <categories>
        <category>UI</category>
      </categories>
      <tags>
        <tag>循环 滚动视图</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS LLDB 打印技巧</title>
    <url>/2015/12/19/something-about-lldb/</url>
    <content><![CDATA[<p>今天在微博上看到<a href="http://www.jianshu.com/users/1f93e3b1f3da/latest_articles">小笨狼</a>分享的一片文章，其中比较详细的介绍了LLDB的使用，顿时感觉原来LLDB控制体可以做那么多事情，下面是我挑选的几个，开发中比较常用的命令</p>
<a id="more"></a>

<h4 id="1、基本语法"><a href="#1、基本语法" class="headerlink" title="1、基本语法"></a>1、基本语法</h4><p>首先还是先看一下最近本的语法，这会让我们会更容易的去理解和记住下面的命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;command&gt; [&lt;subcommand&gt; [&lt;subcommand&gt;...]] </span><br><span class="line">&lt;action&gt; [-options [option-value]] </span><br><span class="line">[argument [argument...]]</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;	</span><br><span class="line">参数解析：</span><br><span class="line">1、&#96;&lt;command&gt;&#96;和&lt;subcommand&gt;:是LLDB调试命令的名称，命令和子命令是按照层级结构排列的</span><br><span class="line">一个命令对象为跟随他的子对象创建一个上下文，子命令又为子命令创建一个上下文</span><br><span class="line"></span><br><span class="line">2、&#96;&lt;action&gt;&#96;:执行命令的操作</span><br><span class="line"></span><br><span class="line">3、&#96;&lt;option&gt;&#96;：命令选项</span><br><span class="line"></span><br><span class="line">4、&#96;&lt;argument&gt;&#96;:命令参数</span><br><span class="line"></span><br><span class="line">5、&#96;[]&#96;:表示命令是可选的，可有可无</span><br><span class="line"></span><br><span class="line">exmp:</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>breakpoint set - n main</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、&#96;command&#96;:breakpoint 表示断点命令</span><br><span class="line"></span><br><span class="line">2、&#96;断点命令&#96;:set 表示设置断点</span><br><span class="line"></span><br><span class="line">3、&#96;-n&#96;:表示根据方法name设置断点</span><br><span class="line"></span><br><span class="line">4、&#96;argument&#96;: main 表示方法名为main</span><br><span class="line"></span><br><span class="line">#### 2、唯一匹配原则</span><br><span class="line"></span><br><span class="line">LLDB的命令遵循唯一匹配原则：假如根据前n个字母已经能唯一匹配到某个命令，则只写前n个字母等效于写下完整的命令。</span><br><span class="line">e.g:</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>breakpoint set -n main<br>br s -n main</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">下面一行的命令可以唯一匹配到上一行的命令，所以二者是等效的</span><br><span class="line"></span><br><span class="line">&#96;~&#x2F;.lldbinit&#96;</span><br><span class="line"></span><br><span class="line">LLDB有了一个启动时加载的文件~&#x2F;.lldbinit，每次启动都会加载。所以一些初始化的事儿，我们可以写入~&#x2F;.lldbinit中，比如给命令定义别名等。但是由于这时候程序还没有真正运行，也有部分操作无法在里面玩，比如设置断点。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 3、LLDB常用命令</span><br><span class="line"></span><br><span class="line">##### 1、expression</span><br><span class="line">语法格式</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>expression <cmd-options> – <expr></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">作用：执行一个表达式，并将表达式的返回值输出</span><br><span class="line"></span><br><span class="line">e.g 1：执行一个表达式</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p> expression – self.view.backgroundColor = [UIColor redColor]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">e.g 2:输出返回值</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p> (lldb) expression – self.view<br>    (UIView *) $1 = 0x00007fe322c18a10</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;expression 可以简写做e&#96;</span><br><span class="line"></span><br><span class="line">##### 2、p &amp; print &amp; call</span><br><span class="line">其实这三个方法都可以看做是expression的别名，只是不再向expression那样可以设置命令选项（一般情况下，我们是不需要去设置命令选项的）</span><br><span class="line"></span><br><span class="line">print:打印出某个东西，可以是变量或者是表达式</span><br><span class="line"></span><br><span class="line">p:可以看做是print的缩写</span><br><span class="line"></span><br><span class="line">call:调用某个方法</span><br><span class="line"></span><br><span class="line">e.g:</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>(lldb) expression – self.view<br>(UIView *) $5 = 0x00007fb2a40344a0<br>(lldb) p self.view<br>(UIView *) $6 = 0x00007fb2a40344a0<br>(lldb) print self.view<br>(UIView *) $7 = 0x00007fb2a40344a0<br>(lldb) call self.view<br>(UIView *) $8 = 0x00007fb2a40344a0<br>(lldb) e self.view<br>(UIView *) $9 = 0x00007fb2a40344a0</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">##### 3、PO</span><br><span class="line">通常我们在控制台打印的时候，一般都是变量值或者是对象</span><br><span class="line">如果我们直接</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>expression – self.view<br>(UIView *) $13 = 0x00007fb2a40344a0</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">显然结果并不是我们想要的，所以，我们需要添加命令选项：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>(lldb) expression -O – self.view</p>
<p>&lt;UIView: 0x7fb2a40344a0; frame = (0 0; 375 667); autoresize = W+H; layer = &lt;CALayer: 0x7fb2a4018c80&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">这里 为了方便使用，LLDB为expression定义了一个别名 po,因此：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>(lldb) po self.view</p>
<p>&lt;UIView: 0x7fb2a40344a0; frame = (0 0; 375 667); autoresize = W+H; layer = &lt;CALayer: 0x7fb2a4018c80&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">也能达到上面一样的效果</span><br><span class="line"></span><br><span class="line">##### 4、thread backtrace &amp; bt</span><br><span class="line">作用：打印线程的堆栈</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>thread backtrace [-c <count>] [-s <frame-index>] [-e <boolean>]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">thread backtrace 后面的都是命令选项</span><br><span class="line"></span><br><span class="line">&#96;-c&#96;: 设置打印堆栈帧的帧数（frame）</span><br><span class="line">&#96;-s&#96;: 设置从哪一帧开始打印</span><br><span class="line">&#96;-e&#96;: 是否显示额外的回溯</span><br><span class="line"></span><br><span class="line">&#96;实际上，我们在平时的使用中一般都不会添加这些命令选项&#96;</span><br><span class="line"></span><br><span class="line">e.g: crash happens</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>(lldb) thread backtrace</p>
<ul>
<li>thread #1: tid = 0xdd42, 0x000000010afb380b libobjc.A.dylib<code>objc_msgSend + 11, queue = &#39;com.apple.main-thread&#39;, stop reason = EXC_BAD_ACCESS (code=EXC_I386_GPFLT)   frame #0: 0x000000010afb380b libobjc.A.dylib</code>objc_msgSend + 11<ul>
<li>frame #1: 0x000000010aa9f75e TLLDB<code>-[ViewController viewDidLoad](self=0x00007fa270e1f440, _cmd=&quot;viewDidLoad&quot;) + 174 at ViewController.m:23 frame #2: 0x000000010ba67f98 UIKit</code>-[UIViewController loadViewIfRequired] + 1198<br>frame #3: 0x000000010ba682e7 UIKit<code>-[UIViewController view] + 27 frame #4: 0x000000010b93eab0 UIKit</code>-[UIWindow addRootViewControllerViewIfPossible] + 61<br>frame #5: 0x000000010b93f199 UIKit<code>-[UIWindow _setHidden:forced:] + 282 frame #6: 0x000000010b950c2e UIKit</code>-[UIWindow makeKeyAndVisible] + 42</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">这里，我们可以比较清晰的看到 crash 触发的位置，就可以有针对性的进行检查</span><br><span class="line"></span><br><span class="line">&#96;backtrace &#x3D; bt&#96; 可以使用简单的bt来代替backtrace</span><br><span class="line"></span><br><span class="line">##### 5、thread return</span><br><span class="line">作用： return 返回，表示不再执行断点下面的代码，直接返回，&#96;可以自己定义要返回的值&#96;</span><br><span class="line"></span><br><span class="line">e.g: </span><br><span class="line">![icon](http:&#x2F;&#x2F;upload-images.jianshu.io&#x2F;upload_images&#x2F;1122433-cf22e45902233a0c.png?imageMogr2&#x2F;auto-orient&#x2F;strip%7CimageView2&#x2F;2&#x2F;w&#x2F;1240)</span><br><span class="line"></span><br><span class="line">如果我们不想执行断点后面的代码，同时还想让这个方法的返回值为NO</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>(lldb) thread return NO</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">##### 6、c &amp; n &amp; s &amp; finish</span><br><span class="line"></span><br><span class="line">![icon](http:&#x2F;&#x2F;upload-images.jianshu.io&#x2F;upload_images&#x2F;1122433-17ba978ac411af3d.png?imageMogr2&#x2F;auto-orient&#x2F;strip%7CimageView2&#x2F;2&#x2F;w&#x2F;1240)</span><br><span class="line"></span><br><span class="line">其实这四个按钮都可以用下面的命令来代替：</span><br><span class="line"></span><br><span class="line">1、&#96;c&#96;&#x2F;&#96;continue&#96;&#x2F;&#96;thread continue&#96;: 这三个命令的效果等同于图片中的第一个按钮，表示继续运行</span><br><span class="line"></span><br><span class="line">2、&#96;n&#96;&#x2F;&#96;next&#96;&#x2F;&#96;thread step-over&#96;:等同于第二个按钮，表示单步执行</span><br><span class="line"></span><br><span class="line">3、&#96;s&#96;&#x2F;&#96;step&#96;&#x2F;&#96;thread step-in&#96;:等同于第三个按钮，表示进入方法内部</span><br><span class="line"></span><br><span class="line">4、&#96;finish&#96;&#x2F;&#96;step-out&#96;:等同于第四个按钮，表示直接走完当前方法，返回到上一层</span><br><span class="line"></span><br><span class="line">###### 7、breakpoint </span><br><span class="line">1、breakpoint set 设置断点</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个方法的功能比较强大，可以根据方法名设置断点，可以给指定文件中的指定方法设置断点(方法不存在，无法设置断点)，给指定文件的某一行设置断点、设置条件断点、设置单次执行断点。由于这些在实际的开发中用的比较少，所以在这里不再详细说明（需要看的可以在本文最后查看引用的文章）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2、breakpoint command add 给断点添加命令</span><br><span class="line"></span><br><span class="line">3、breakpoint command list 查看某个断点已有的命令</span><br><span class="line"></span><br><span class="line">4、breakpoint command delete 删除断点</span><br><span class="line"></span><br><span class="line">5、breakpoint list 查看一ing设置断点的位置</span><br><span class="line"></span><br><span class="line">6、breakpoint enable&#x2F;disable 断点暂时失效&#x2F;生效</span><br><span class="line"></span><br><span class="line">7、breakpoint delete 彻底删除所有断点（也可以删除指定行）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">###### 8、watchpoint </span><br><span class="line">&#96;breakpoint&#96;有一个孪生兄弟&#96;watchpoint&#96;。如果说&#96;breakpoint&#96;是对方法生效的断点，&#96;watchpoint&#96;就是对地址生效的断点</span><br><span class="line"></span><br><span class="line">基本用法和breakpoint 类似，这里不再详细说明</span><br><span class="line"></span><br><span class="line">###### 9、target</span><br><span class="line"></span><br><span class="line">对于target这个命令，我们用得最多的可能就是target modules lookup。由于LLDB给target modules取了个别名image，所以这个命令我们又可以写成image lookup</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1、image lookup --address 查找这个地址具体对应的文件位置（具体到行）</span><br><span class="line">当我们遇到崩溃（不是停留在main函数中的崩溃）我们可以通过这个方法获取到这个控制器的哪一行出现问题</span><br><span class="line">e.g : crash happens</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>2015-12-17 14:51:06.301 TLLDB[25086:246169] <strong>* Terminating app due to uncaught exception ‘NSRangeException’, reason: ‘*</strong> -[__NSArray0 objectAtIndex:]: index 1 beyond bounds for empty NSArray’<br>*** First throw call stack:<br>(<br>    0   CoreFoundation                      0x000000010accde65 __exceptionPreprocess + 165<br>    1   libobjc.A.dylib                     0x000000010a746deb objc_exception_throw + 48<br>    2   CoreFoundation                      0x000000010ac7c395 -[__NSArray0 objectAtIndex:] + 101<br>    3   TLLDB                               0x000000010a1c3e36 -[ViewController viewDidLoad] + 86<br>    4   UIKit                               0x000000010b210f98 -[UIViewController loadViewIfRequired] + 1198<br>    5   UIKit                               0x000000010b2112e7 -[UIViewController view] + 27</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<p>(lldb) image lookup -a 0x000000010a1c3e36<br>      Address: TLLDB[0x0000000100000e36] (TLLDB.__TEXT.__text + 246)<br>      Summary: TLLDB`-[ViewController viewDidLoad] + 86 at ViewController.m:32</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">准确定位，崩溃出现的方法名，及在文件中的行号</span><br><span class="line"></span><br><span class="line">2、image lookup --name </span><br><span class="line"></span><br><span class="line">e.g : </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>某个第三方SDK用了一个我们项目里原有的第三方库，库里面对NSDictionary添加了category。也就是有2个class对NSDictionary添加了名字相同的category，项目中调用自己的category的地方实际走到了第三方SDK里面去了。最大的问题是，这2个同名category方法行为并不一致，导致出现bug<br>现在问题来了，怎么寻找到底是哪个第三方SDK？方法完全包在.a里面</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>(lldb) image lookup -n dictionaryWithXMLString:<br>2 matches found in /Users/jiangliancheng/Library/Developer/Xcode/DerivedData/VideoIphone-aivsnqmlwjhxapdlvmdmrubbdxpq/Build/Products/Debug-iphoneos/BaiduIphoneVideo.app/BaiduIphoneVideo:<br>        Address: BaiduIphoneVideo[0x00533a7c] (BaiduIphoneVideo.__TEXT.__text + 5414908)<br>        Summary: BaiduIphoneVideo<code>+[NSDictionary(SAPIXmlDictionary) dictionaryWithXMLString:] at XmlDictionary.m          Module: file = &quot;/Users/jiangliancheng/Library/Developer/Xcode/DerivedData/VideoIphone-aivsnqmlwjhxapdlvmdmrubbdxpq/Build/Products/Debug-iphoneos/BaiduIphoneVideo.app/BaiduIphoneVideo&quot;, arch = &quot;armv7&quot;     CompileUnit: id = &#123;0x00000000&#125;, file = &quot;/Users/jiangliancheng/Development/Work/iOS_ShareLib/SharedLib/Srvcs/BDPassport4iOS/BDPassport4iOS/SAPI/Extensive/ThirdParty/XMLDictionary/XmlDictionary.m&quot;, language = &quot;Objective-C&quot;        Function: id = &#123;0x23500000756&#125;, name = &quot;+[NSDictionary(SAPIXmlDictionary) dictionaryWithXMLString:]&quot;, range = [0x005a6a7c-0x005a6b02)        FuncType: id = &#123;0x23500000756&#125;, decl = XmlDictionary.m:189, clang_type = &quot;NSDictionary *(NSString *)&quot;          Blocks: id = &#123;0x23500000756&#125;, range = [0x005a6a7c-0x005a6b02)       LineEntry: [0x005a6a7c-0x005a6a98): /Users/jiangliancheng/Development/Work/iOS_ShareLib/SharedLib/Srvcs/BDPassport4iOS/BDPassport4iOS/SAPI/Extensive/ThirdParty/XMLDictionary/XmlDictionary.m          Symbol: id = &#123;0x0000f2d5&#125;, range = [0x005a6a7c-0x005a6b04), name=&quot;+[NSDictionary(SAPIXmlDictionary) dictionaryWithXMLString:]&quot;        Variable: id = &#123;0x23500000771&#125;, name = &quot;self&quot;, type = &quot;Class&quot;, location =  [sp+32], decl =         Variable: id = &#123;0x2350000077e&#125;, name = &quot;_cmd&quot;, type = &quot;SEL&quot;, location =  [sp+28], decl =         Variable: id = &#123;0x2350000078b&#125;, name = &quot;string&quot;, type = &quot;NSString *&quot;, location =  [sp+24], decl = XmlDictionary.m:189        Variable: id = &#123;0x23500000799&#125;, name = &quot;data&quot;, type = &quot;NSData *&quot;, location =  [sp+20], decl = XmlDictionary.m:192         Address: BaiduIphoneVideo[0x012ee160] (BaiduIphoneVideo.__TEXT.__text + 19810016)         Summary: BaiduIphoneVideo</code>+[NSDictionary(XMLDictionary) dictionaryWithXMLString:] at XMLDictionary.m<br>         Module: file = “/Users/jiangliancheng/Library/Developer/Xcode/DerivedData/VideoIphone-aivsnqmlwjhxapdlvmdmrubbdxpq/Build/Products/Debug-iphoneos/BaiduIphoneVideo.app/BaiduIphoneVideo”, arch = “armv7”<br>    CompileUnit: id = {0x00000000}, file = “/Users/wingle/Workspace/qqlive4iphone/iphone_4.0_fabu_20150601/Common_Proj/mobileTAD/VIDEO/Library/Third Party/XMLDictionary/XMLDictionary.m”, language = “Objective-C”<br>       Function: id = {0x79900000b02}, name = “+[NSDictionary(XMLDictionary) dictionaryWithXMLString:]”, range = [0x01361160-0x0136119a)<br>       FuncType: id = {0x79900000b02}, decl = XMLDictionary.m:325, clang_type = “NSDictionary *(NSString *)”<br>         Blocks: id = {0x79900000b02}, range = [0x01361160-0x0136119a)<br>      LineEntry: [0x01361160-0x01361164): /Users/wingle/Workspace/qqlive4iphone/iphone_4.0_fabu_20150601/Common_Proj/mobileTAD/VIDEO/Library/Third Party/XMLDictionary/XMLDictionary.m<br>         Symbol: id = {0x0003a1e9}, range = [0x01361160-0x0136119c), name=”+[NSDictionary(XMLDictionary) dictionaryWithXMLString:]”<br>       Variable: id = {0x79900000b1e}, name = “self”, type = “Class”, location =  r0, decl =<br>       Variable: id = {0x79900000b2c}, name = “_cmd”, type = “SEL”, location =  r1, decl =<br>       Variable: id = {0x79900000b3a}, name = “string”, type = “NSString *”, location =  r2, decl = XMLDictionary.m:325<br>       Variable: id = {0x79900000b4a}, name = “data”, type = “NSData *”, location =  r2, decl = XMLDictionary.m:327</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">找到file:</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>CompileUnit: id = {0x00000000}, file = “/Users/jiangliancheng/Development/Work/iOS_ShareLib/SharedLib/Srvcs/BDPassport4iOS/BDPassport4iOS/SAPI/Extensive/ThirdParty/XMLDictionary/XmlDictionary.m”, language = “Objective-C”<br>CompileUnit: id = {0x00000000}, file = “/Users/wingle/Workspace/qqlive4iphone/iphone_4.0_fabu_20150601/Common_Proj/mobileTAD/VIDEO/Library/Third Party/XMLDictionary/XMLDictionary.m”, language = “Objective-C”</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">这样就可以找到了……</span><br><span class="line"></span><br><span class="line">3、imag lookup --type  查看类型可以打印类的属性和成员变量</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>(lldb) image lookup -t Model<br>Best match found in /Users/jiangliancheng/Library/Developer/Xcode/DerivedData/TLLDB-beqoowskwzbttrejseahdoaivpgq/Build/Products/Debug-iphonesimulator/TLLDB.app/TLLDB:<br>id = {0x30000002f}, name = “Model”, byte-size = 32, decl = Modek.h:11, clang_type = “@interface Model : NSObject{<br>    NSString * _bb;<br>    NSString * _cc;<br>    NSString * _name;<br>}<br>@property ( getter = name,setter = setName:,readwrite,nonatomic ) NSString * name;<br>@end<br>“</p>
<pre><code>
4、其他不常用的方法，这里不再多说

### tips:

help &amp; apropos
LLDB的命令其实还有很多，很多命令我也没玩过。就算玩过的命令，我们也非常容易忘记，下次可能就不记得是怎么用的了。还好LLDB给我们提供了2个查找命令的命令:help &amp; apropos

参考文章：
[小笨狼与LLDB的故事](http://www.jianshu.com/p/e89af3e9a8d7)

</code></pre>
]]></content>
      <categories>
        <category>iOS进阶</category>
      </categories>
      <tags>
        <tag>lldb</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之策略模式</title>
    <url>/2016/09/12/stragtery-model/</url>
    <content><![CDATA[<p> 最近买了本设计模式的书Header First 非常喜欢其中的讲解方式。虽然买了有一段时间了但是没有认真的看过。这段时间工作相对没有那么难了，所以抽出点时间看一下这本书，同时，在这里做一下分享，希望可以帮到你！</p>
<a id="more"></a>

<h4 id="1、定义"><a href="#1、定义" class="headerlink" title="1、定义"></a>1、定义</h4><pre><code>策略模式定义了算法族，分别封装起来，让他们之间可以互相替换，此模式让算法的变化独立于使用算法的客户</code></pre>
<h4 id="2、使用场景"><a href="#2、使用场景" class="headerlink" title="2、使用场景"></a>2、使用场景</h4><p>   我们的日常开发中经常碰到一类问题，例如有一个类（Animals),他有几个方法（fly,eat）,某一天我们需要创建一个对象1恰好是要有fly/eat这两个方法,后来我们又创建了另外的一个对象2有eat这个方法。这时候我们最容易想到的肯定是<code>继承</code>。但是如果有一天，我们要给对象1和对象2增加一个sleep方法，显然最简单的方法就是在Animals中加入一个方法sleep。</p>
<p>   后来，产品有要求创建另外的一个对象拥有sleep和eat的对象3，很显然，我们仍然可以通过继承的方式，派生出一个Animals的子类。尽管没有要求对象3有fly这个方法，但是实际上这个方法已经从父类中继承了。</p>
<p>   开始的时候，产品大大说这三个对象的eat方法是一样的，直接打印出一个吃就可以了，但是慢慢地，产品大大们发现，这三个对象不是一个品种呀，所以他们吃的东西肯定也是不一样的。因此他们的eat方法的实现是不一样的。</p>
<p>   我的天呐，这可怎么办，我们之前是直接写在父类中的。所以，我们最直接的方法就是在Animals的所有子类中重写eat这个方法。甚至有些没有eat这个行为的对象，我们为了避免出现问题也实现了这个方法（方法中不做任何操作）。另一方面 这也在考验我们的记忆力，那些对象是继承自Animals的，哪些对象的eat方法对需要做什么。</p>
<p>   这时候才发现：<code>继承害人不浅啊！！！！</code>；</p>
<h4 id="3、思考"><a href="#3、思考" class="headerlink" title="3、思考"></a>3、思考</h4><p>1、以后，产品大大们脑洞大开，可能还会有很多<code>新的对象要加入</code>，他们的行为可能会更加的复杂，我们该如何做？</p>
<p>2、父类中的有些方法，并不是非要让所有的子类都去实现？ 这可能造成大量的<code>代码冗余</code>。</p>
<p>3、如果从代码复用的角度去考虑，如果哪天我们有一个Person类也需要调用eat这个方法，我们该如何<code>复用</code>？</p>
<p>4、新人报道，他是如何知道父类中eat方法到底有<code>多少种类型</code>。挨个查找子类中的方法 Are you Kidding me?</p>
<p>5、如何去动态的改变子类中的这些方法，有一天 我想让他吃肉，第二天我又想让他吃素，怎么<code>动态判断和修改</code>。</p>
<h4 id="4、修改思路"><a href="#4、修改思路" class="headerlink" title="4、修改思路"></a>4、修改思路</h4><p>   考虑到代码的复用，我们最先想到的就是代码的隔离，上面我们采用的方法是面向方法的实现进行编程。子类实现了什么样的方法。我们在去做对应的操作，这就意味着，我们的操作具有了一个前提：我知道他要做什么了。这样就导致了我们的代码<code>毫无复用性可言</code>。</p>
<p>   从这一点考虑，我们首先想到了面向接口编程的方法：将具体的方法和对象隔离，简单点来说就是，如果你想要有eat的功能，那么你就<code>遵守我eat这个协议，实现协议方法</code>。这样就可以从一定程度上降低了对象和方法的耦合性，最起码这两者不再是绑定的关系了。</p>
<p>   但是，仔细考虑一下，我们的代码复用性还是不高，如果我们两个对象要实现的功能是一模一样的，那岂不是我这两个对象同时都要遵守协议实现接口中的方法？ 代码的复用性还是有待提高啊！</p>
<p>   所以，我们考虑<code>将方法的实现彻底的与使用这个方法的类分离开</code>。这样才能进一步增加代码的复用性。同时实现了不同对象的隔离。</p>
<h4 id="5、具体实现"><a href="#5、具体实现" class="headerlink" title="5、具体实现"></a>5、具体实现</h4><p>   首先我们从最上层考虑，对于这些对象，他们都有同一个父类(Animals)，但是这里我们不在这个父类中声明或者实现任何关于eat/sleep/fly这些操作。对于这些动作，我们设置多个接口（这里使用eat举例）。考虑现存的eat方法有几种（eatvg,eatmeat）,我们新建两个类分别为eatvg,eatmeat。这两个类遵守关于eat的协议并且实现eat协议中的eat方法。</p>
<p>   通过上面这一步，我们基本可以把对象和方法做了彻底的分离，那么我们如何在对象中调用其所需要的方法呢？</p>
<p>   1、在父类animals中声明一个变量，表明这个animals的eat方法</p>
<p>   2、在初始化的时候 给父类中的这个方法赋值（eatvb或是eatmeat）</p>
<p>   3、如果需要执行eat的方法可以直接调用初始化的时候给eat赋值的方法</p>
<p>  这样我们通过属性的方式，做了绑定，在做到代码最大限度复用的情况下，解决了继承给我们带来的种种问题。</p>
<p><img src="https://i.niupic.com/images/2016/09/12/g0c0bQ.png" alt="策略模式"></p>
<p><a href="https://github.com/LeeWongSnail/Head-First-DesignPattern">代码放在这里了</a></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>策略模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Swift tableview 静态页面纯代码</title>
    <url>/2017/09/15/swift-tableview-%E9%9D%99%E6%80%81%E9%A1%B5%E9%9D%A2%E7%BA%AF%E4%BB%A3%E7%A0%81/</url>
    <content><![CDATA[<p>相信好多APP中都有 <code>我的</code> 这种界面,这种界面的特点是 样式相对固定,但是具体的每一行可能需要根据身份或者由服务端去控制显隐,这里我们有一种方法 来控制界面的显示</p>
<a id="more"></a>

<h3 id="资源配置-颜色、图片"><a href="#资源配置-颜色、图片" class="headerlink" title="资源配置(颜色、图片)"></a>资源配置(颜色、图片)</h3><p>对于图片和颜色绝大多数情况都是写死的,我们可以写一个专门的配置文件,UI的展示内容都是从这个文件中读取</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public struct Specs &#123;</span><br><span class="line">  public struct Color &#123;</span><br><span class="line">    public let tint &#x3D; UIColor(hex: 0x3b5998)</span><br><span class="line">    public let red &#x3D; UIColor.red</span><br><span class="line">    public let white &#x3D; UIColor.white</span><br><span class="line">    public let black &#x3D; UIColor.black</span><br><span class="line">    public let gray &#x3D; UIColor.lightGray</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public struct FontSize &#123;</span><br><span class="line">    public let tiny: CGFloat &#x3D; 10</span><br><span class="line">    public let small: CGFloat &#x3D; 12</span><br><span class="line">    public let regular: CGFloat &#x3D; 14</span><br><span class="line">    public let large: CGFloat &#x3D; 16</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public struct Font &#123;</span><br><span class="line">    private static let regularName &#x3D; &quot;Helvetica Neue&quot;</span><br><span class="line">    private static let boldName &#x3D; &quot;Helvetica Neue Bold&quot;</span><br><span class="line">    public let tiny &#x3D; UIFont(name: regularName, size: Specs.fontSize.tiny)</span><br><span class="line">    public let small &#x3D; UIFont(name: regularName, size: Specs.fontSize.small)</span><br><span class="line">    public let regular &#x3D; UIFont(name: regularName, size: Specs.fontSize.regular)</span><br><span class="line">    public let large &#x3D; UIFont(name: regularName, size: Specs.fontSize.large)</span><br><span class="line">    public let smallBold &#x3D; UIFont(name: boldName, size: Specs.fontSize.small)</span><br><span class="line">    public let regularBold &#x3D; UIFont(name: boldName, size: Specs.fontSize.regular)</span><br><span class="line">    public let largeBold &#x3D; UIFont(name: boldName, size: Specs.fontSize.large)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public struct ImageName &#123;</span><br><span class="line">    public let friends &#x3D; &quot;fb_friends&quot;</span><br><span class="line">    public let events &#x3D; &quot;fb_events&quot;</span><br><span class="line">    public let groups &#x3D; &quot;fb_groups&quot;</span><br><span class="line">    public let education &#x3D; &quot;fb_education&quot;</span><br><span class="line">    public let townHall &#x3D; &quot;fb_town_hall&quot;</span><br><span class="line">    public let instantGames &#x3D; &quot;fb_games&quot;</span><br><span class="line">    public let settings &#x3D; &quot;fb_settings&quot;</span><br><span class="line">    public let privacyShortcuts &#x3D; &quot;fb_privacy_shortcuts&quot;</span><br><span class="line">    public let helpSupport &#x3D; &quot;fb_help_and_support&quot;</span><br><span class="line">    public let placeholder &#x3D; &quot;fb_placeholder&quot;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public static var color: Color &#123;</span><br><span class="line">    return Color()</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public static var fontSize: FontSize &#123;</span><br><span class="line">    return FontSize()</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public static var font: Font &#123;</span><br><span class="line">    return Font()</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public static var imageName: ImageName &#123;</span><br><span class="line">    return ImageName()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="tableview-样式控制"><a href="#tableview-样式控制" class="headerlink" title="tableview 样式控制"></a>tableview 样式控制</h3><p>tableview 共多少组 多少行,每一行的内容是什么,这就是对于tableview的样式的控制,同样我们可以单独配置这个文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public struct TableKeys &#123;</span><br><span class="line">  static let Section &#x3D; &quot;section&quot;</span><br><span class="line">  static let Rows &#x3D; &quot;rows&quot;</span><br><span class="line">  static let ImageName &#x3D; &quot;imageName&quot;</span><br><span class="line">  static let Title &#x3D; &quot;title&quot;</span><br><span class="line">  static let SubTitle &#x3D; &quot;subTitle&quot;</span><br><span class="line">  static let seeMore &#x3D; &quot;See More...&quot;</span><br><span class="line">  static let addFavorites &#x3D; &quot;Add Favorites...&quot;</span><br><span class="line">  static let logout &#x3D; &quot;Log Out&quot;</span><br><span class="line">  </span><br><span class="line">  static func populate(withUser user: FBMeUser) -&gt; [[String: Any]] &#123;</span><br><span class="line">    return [</span><br><span class="line">      [</span><br><span class="line">        TableKeys.Rows: [</span><br><span class="line">          [TableKeys.ImageName: user.avatarName, TableKeys.Title: user.name, TableKeys.SubTitle: &quot;View your profile&quot;]</span><br><span class="line">        ]</span><br><span class="line">      ],</span><br><span class="line">      [</span><br><span class="line">        TableKeys.Rows: [</span><br><span class="line">          [TableKeys.ImageName: Specs.imageName.friends, TableKeys.Title: &quot;Friends&quot;],</span><br><span class="line">          [TableKeys.ImageName: Specs.imageName.events, TableKeys.Title: &quot;Events&quot;],</span><br><span class="line">          [TableKeys.ImageName: Specs.imageName.groups, TableKeys.Title: &quot;Groups&quot;],</span><br><span class="line">          [TableKeys.ImageName: Specs.imageName.education, TableKeys.Title: user.education],</span><br><span class="line">          [TableKeys.ImageName: Specs.imageName.townHall, TableKeys.Title: &quot;Town Hall&quot;],</span><br><span class="line">          [TableKeys.ImageName: Specs.imageName.instantGames, TableKeys.Title: &quot;Instant Games&quot;],</span><br><span class="line">          [TableKeys.Title: TableKeys.seeMore]</span><br><span class="line">        ]</span><br><span class="line">      ],</span><br><span class="line">      [</span><br><span class="line">        TableKeys.Section: &quot;FAVORITES&quot;,</span><br><span class="line">        TableKeys.Rows: [</span><br><span class="line">          [TableKeys.Title: TableKeys.addFavorites]</span><br><span class="line">        ]</span><br><span class="line">      ],</span><br><span class="line">      [</span><br><span class="line">        TableKeys.Rows: [</span><br><span class="line">          [TableKeys.ImageName: Specs.imageName.settings, TableKeys.Title: &quot;Settings&quot;],</span><br><span class="line">          [TableKeys.ImageName: Specs.imageName.privacyShortcuts, TableKeys.Title: &quot;Privacy Shortcuts&quot;],</span><br><span class="line">          [TableKeys.ImageName: Specs.imageName.helpSupport, TableKeys.Title: &quot;Help and Support&quot;]</span><br><span class="line">        ]</span><br><span class="line">      ],</span><br><span class="line">      [</span><br><span class="line">        TableKeys.Rows: [</span><br><span class="line">          [TableKeys.Title: TableKeys.logout]</span><br><span class="line">        ]</span><br><span class="line">      ]</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="tableview-代理和数据源方法"><a href="#tableview-代理和数据源方法" class="headerlink" title="tableview 代理和数据源方法"></a>tableview 代理和数据源方法</h3><p>代理方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">extension FBMeViewController: UITableViewDelegate &#123;</span><br><span class="line">  func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -&gt; CGFloat &#123;</span><br><span class="line">    let modelForRow &#x3D; rowModel(at: indexPath)</span><br><span class="line">    </span><br><span class="line">    guard let title &#x3D; modelForRow[TableKeys.Title] else &#123;</span><br><span class="line">      return 0.0</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if title &#x3D;&#x3D; user.name &#123;</span><br><span class="line">      return 64.0</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      return 44.0</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  func tableView(_ tableView: UITableView, willDisplay cell: UITableViewCell, forRowAt indexPath: IndexPath) &#123;</span><br><span class="line">    let modelForRow &#x3D; rowModel(at: indexPath)</span><br><span class="line">    </span><br><span class="line">    guard let title &#x3D; modelForRow[TableKeys.Title] else &#123;</span><br><span class="line">      return</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if title &#x3D;&#x3D; TableKeys.seeMore || title &#x3D;&#x3D; TableKeys.addFavorites &#123;</span><br><span class="line">      cell.textLabel?.textColor &#x3D; Specs.color.tint</span><br><span class="line">      cell.accessoryType &#x3D; .none</span><br><span class="line">    &#125; else if title &#x3D;&#x3D; TableKeys.logout &#123;</span><br><span class="line">      cell.textLabel?.centerXAnchor.constraint(equalTo: cell.centerXAnchor).isActive &#x3D; true</span><br><span class="line">      cell.textLabel?.textColor &#x3D; Specs.color.red</span><br><span class="line">      cell.textLabel?.textAlignment &#x3D; .center</span><br><span class="line">      cell.accessoryType &#x3D; .none</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      cell.accessoryType &#x3D; .disclosureIndicator</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>数据源方法  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">extension FBMeViewController: UITableViewDataSource &#123;</span><br><span class="line">  func numberOfSections(in tableView: UITableView) -&gt; Int &#123;</span><br><span class="line">    return tableViewDataSource.count</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int &#123;</span><br><span class="line">    return rows(at: section).count</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  func tableView(_ tableView: UITableView, titleForHeaderInSection section: Int) -&gt; String? &#123;</span><br><span class="line">    return title(at: section)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell &#123;</span><br><span class="line">    let modelForRow &#x3D; rowModel(at: indexPath)</span><br><span class="line">    var cell &#x3D; UITableViewCell()</span><br><span class="line">    </span><br><span class="line">    guard let title &#x3D; modelForRow[TableKeys.Title] else &#123;</span><br><span class="line">      return cell</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if title &#x3D;&#x3D; user.name &#123;</span><br><span class="line">      cell &#x3D; UITableViewCell.init(style: .subtitle, reuseIdentifier: nil)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      cell &#x3D; tableView.dequeueReusableCell(withIdentifier: FBMeBaseCell.identifier, for: indexPath)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cell.textLabel?.text &#x3D; title</span><br><span class="line">    </span><br><span class="line">    if let imageName &#x3D; modelForRow[TableKeys.ImageName] &#123;</span><br><span class="line">      cell.imageView?.image &#x3D; UIImage(named: imageName)</span><br><span class="line">    &#125; else if title !&#x3D; TableKeys.logout &#123;</span><br><span class="line">      cell.imageView?.image &#x3D; UIImage(named: Specs.imageName.placeholder)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if title &#x3D;&#x3D; user.name &#123;</span><br><span class="line">      cell.detailTextLabel?.text &#x3D; modelForRow[TableKeys.SubTitle]</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return cell</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>控制器中的设置 </p>
<p>主要是展示部分,根据封装好的数据源,去灵活的展示,不同的展示可以根据数据源中数据的值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typealias RowModel &#x3D; [String: String]</span><br><span class="line"> </span><br><span class="line"> fileprivate var user: FBMeUser &#123;</span><br><span class="line">   get &#123;</span><br><span class="line">     return FBMeUser(name: &quot;BayMax&quot;, education: &quot;CMU&quot;)</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> &#x2F;&#x2F;数据源的初始化</span><br><span class="line"> fileprivate var tableViewDataSource: [[String: Any]] &#123;</span><br><span class="line">   get &#123;</span><br><span class="line">    return TableKeys.populate(withUser: user)</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> private let tableView: UITableView &#x3D; &#123;</span><br><span class="line">   let view &#x3D; UITableView(frame: .zero, style: .grouped)</span><br><span class="line">   &#x2F;&#x2F;cell的注册可以使用这种方法</span><br><span class="line">   view.register(FBMeBaseCell.self, forCellReuseIdentifier: FBMeBaseCell.identifier)</span><br><span class="line">   return view</span><br><span class="line"> &#125;()</span><br><span class="line"> </span><br><span class="line"> override func viewDidLoad() &#123;</span><br><span class="line">   super.viewDidLoad()</span><br><span class="line">   </span><br><span class="line">   title &#x3D; &quot;Facebook&quot;</span><br><span class="line">   navigationController?.navigationBar.barTintColor &#x3D; Specs.color.tint</span><br><span class="line">   </span><br><span class="line">   tableView.delegate &#x3D; self</span><br><span class="line">   tableView.dataSource &#x3D; self</span><br><span class="line">   view.addSubview(tableView)</span><br><span class="line">   </span><br><span class="line">   &#x2F;&#x2F; Set layout for tableView.</span><br><span class="line">   tableView.translatesAutoresizingMaskIntoConstraints &#x3D; false</span><br><span class="line">   view.addConstraints(NSLayoutConstraint.constraints(withVisualFormat: &quot;H:|-0-[tableView]-0-|&quot;, options: .directionLeadingToTrailing, metrics: nil, views: [&quot;tableView&quot;: tableView]))</span><br><span class="line">   view.addConstraints(NSLayoutConstraint.constraints(withVisualFormat: &quot;V:|-0-[tableView]-0-|&quot;, options: .directionLeadingToTrailing, metrics: nil, views: [&quot;tableView&quot;: tableView]))</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> &#x2F;&#x2F;获取某个分组的行信息</span><br><span class="line"> fileprivate func rows(at section: Int) -&gt; [Any] &#123;</span><br><span class="line">   return tableViewDataSource[section][TableKeys.Rows] as! [Any]</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> &#x2F;&#x2F; 获取每一个分组的标题</span><br><span class="line"> fileprivate func title(at section: Int) -&gt; String? &#123;</span><br><span class="line">   return tableViewDataSource[section][TableKeys.Section] as? String</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> &#x2F;&#x2F;获取每一行的具体信息</span><br><span class="line"> fileprivate func rowModel(at indexPath: IndexPath) -&gt; RowModel &#123;</span><br><span class="line">   return rows(at: indexPath.section)[indexPath.row] as! RowModel</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>tableview,静态页面,纯代码</tag>
      </tags>
  </entry>
  <entry>
    <title>有用的文章积累</title>
    <url>/2015/10/16/useful-article/</url>
    <content><![CDATA[<p>一些设计各个方面的文章的汇总</p>
<a id="more"></a>

<p>一、内购相关</p>
<p>1、<a href="http://www.jianshu.com/p/86ac7d3b593a">iOS开发内购全套图文教程</a></p>
<p>2、<a href="http://www.jianshu.com/p/690a7c68664e">iOS内购(iap)</a></p>
<p>二、常用的过滤</p>
<p><a href="http://www.jianshu.com/p/b65b0d2e1899">常用的过滤</a></p>
<p>三、第三方登陆苦逼的上线经历</p>
<p><a href="http://www.jianshu.com/p/c382c9413495">4次被拒</a></p>
<p>四、良心App可添加的暖心功能</p>
<p><a href="http://www.cnblogs.com/ludashi/p/4867511.html">支持Spotlight</a></p>
<p>五、支付</p>
<p><a href="http://www.jianshu.com/p/97d38b00e53d">微信、支付宝、银联</a></p>
<p>六、自定义控件</p>
<p><a href="http://www.cocoachina.com/ios/20160331/15808.html">图片轮播器</a></p>
<p>七、运行时</p>
<p><a href="http://tech.glowing.com/cn/objective-c-runtime/">Objective-C Runtime</a></p>
<p>八、架构相关</p>
<p><a href="http://limboy.me/ios/2016/03/10/mgj-components.html">蘑菇街APP组件化</a></p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzA3ODg4MDk0Ng==&mid=403009403&idx=1&sn=d19264fa1d06b9c5a9dfb1d192a0ed8e&scene=0#wechat_redirect">携程移动App架构优化</a></p>
<p><a href="http://reviewcode.cn/article.html?hmsr=toutiao.io&reviewId=20&utm_medium=toutiao.io&utm_source=toutiao.io">叶孤城 组件化浅谈</a></p>
<p><a href="http://blog.cnbang.net/tech/3080/">bang的组件化</a></p>
<p><a href="http://casatwy.com/iOS-Modulization.html">casa taloyum 组件化详解</a></p>
<p>九、性能优化<br><a href="http://ios.jobbole.com/84360/">UITableView性能优化</a><br><a href="http://www.cocoachina.com/cms/wap.php?action=article&id=12237">Instrument使用</a></p>
]]></content>
      <categories>
        <category>收藏文章</category>
      </categories>
      <tags>
        <tag>有用的博客</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS 控制器 代码结构规范</title>
    <url>/2017/09/01/view%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<p>一个良好的代码风格有助于提高代码的可读性,防止错误发生几率，每个公司可能都有自己的一套规范，这里推荐一种通用的 可读性较高的规范</p>
<a id="more"></a>

<p><a href="https://casatwy.com/iosying-yong-jia-gou-tan-viewceng-de-zu-zhi-he-diao-yong-fang-an.html">iOS应用架构谈 view层的组织和调用方案</a></p>
<p>为了防止控制器过于复杂，指定控制器的规范势在必行,制定一个良好的代码结构可以：</p>
<pre><code>* 1、提高业务方View层的可读性可维护性
* 2、防止业务代码对架构产生腐蚀
* 3、确保传承</code></pre>
<h1 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h1><ul>
<li>1、整体结构</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/225849-4c34758cae04a973.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240/q/100" alt="icon"></p>
<ul>
<li><p>2、细节</p>
<p>  &lt;1&gt; 、视图的创建和加载: 视图的创建可以使用懒加载的方式，视图的加载可以在ViewDidLoad中完成</p>
<p>  &lt;2&gt; 、每一个delegate都把对应的protocol名字带上，delegate方法不要到处乱写，写到一块区域里面去</p>
<p>  &lt;3&gt; 、关于private methods，正常情况下ViewController里面不应该写，这个private methods一般是用于日期换算、图片裁剪啥的这种小功能。这种小功能要么把它写成一个category，要么把他做成一个模块，哪怕这个模块只有一个函数也行。</p>
</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>相信大家各自公司里面也都有一套自己的规范，具体怎么个规范法其实也是根据各位架构师的经验而定，我这边只是建议各位在各自规范的基础上再加上这几点。</p>
]]></content>
      <categories>
        <category>iOS优化</category>
      </categories>
      <tags>
        <tag>代码规范</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS webP.framework制作</title>
    <url>/2020/02/20/webpframework/</url>
    <content><![CDATA[<p>相信目前大部分APP都已经支持了WebP格式的图片,下面我们通过这种图片简单介绍下WebP格式图片的优点。</p>
<a id="more"></a>

<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>WebP 的优势体现在它具有更优的图像数据压缩算法，能带来更小的图片体积，而且拥有肉眼识别无差异的图像质量；同时具备了无损和有损的压缩模式、Alpha 透明以及动画的特性，在 JPEG 和 PNG 上的转化效果都相当优秀、稳定和统一。</p>
<p>下面我们看下官网介绍的对于JPEG格式的图片和Gif图片压缩对比！</p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gbc6ha4mv7j31p80dkgwp.jpg"></p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gbc6hzbo21j30nw0oydkv.jpg"></p>
<p>从上面的图中我们看到webP的压缩效果还是很明显的！</p>
<h3 id="现有方案"><a href="#现有方案" class="headerlink" title="现有方案"></a>现有方案</h3><p>熟悉iOS的开发者都知道图片下载和展示的主要框架有<code>SDWebImage</code>和<code>YYWebImage</code>。当然这两个库也都支持了WebP的图片展示,下面我们先介绍下这两个现有的方案。</p>
<h4 id="SDWebImage"><a href="#SDWebImage" class="headerlink" title="SDWebImage"></a>SDWebImage</h4><p>在github的简介上我们看到<br><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gbc6mz3lpxj31em0fqdkj.jpg"></p>
<p>SD实际上支持多种图片格式的扩展!</p>
<p>如果项目中我们使用了SD那么我们想增加对WebP格式的图片支持,只需要增加</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pod &#39;SDWebImage&#x2F;WebP&#39;</span><br></pre></td></tr></table></figure>
<p><code>注意</code>： 因为libwebp(0.5.1)是谷歌的库，下载需要翻墙。SD中webP的库默认是0.5.1版本的</p>
<h4 id="YYWebImage"><a href="#YYWebImage" class="headerlink" title="YYWebImage"></a>YYWebImage</h4><p>导入方式与SD类似直接通过pod的方式导入</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">pod <span class="string">&#x27;YYWebImage&#x27;</span></span><br><span class="line">pod <span class="string">&#x27;YYImage/WebP`</span></span><br></pre></td></tr></table></figure>

<p>一般情况下我们直接使用上面两种方法就可以解决webP的集成使用,但是还存在两个问题：</p>
<ul>
<li>1、webP库的版本控制依赖三方</li>
<li>2、webP库为谷歌的库直接pod集成需要翻墙 成本较高</li>
</ul>
<h3 id="自己制作WebP"><a href="#自己制作WebP" class="headerlink" title="自己制作WebP"></a>自己制作WebP</h3><p>首先我们可以登录谷歌的<a href="https://developers.google.com/speed/webp/docs/using">WebP官网</a></p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gbca27ik2fj319s0tyqha.jpg"></p>
<p>通过上面的图我们可以看到WebP的最新版本已经到了 1.1.0(SDWebImage还是0.5.1)</p>
<p>我们直接去下载并解压</p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gbca48vq3yj30mk0za7dx.jpg"></p>
<p>在文件夹中我们可以看到一个<code>iosbuild.sh</code>文件,我们在终端执行这个shell脚本</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">sh iosbuild.sh</span><br></pre></td></tr></table></figure>
<p>执行完成后你会发现文件夹中多了下面几个文件</p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gbcabyxc1dj30by04cdgg.jpg"></p>
<p>这就是我们需要继承的webP相关的framework</p>
<h4 id="多个framework合成"><a href="#多个framework合成" class="headerlink" title="多个framework合成"></a>多个framework合成</h4><p>我们在查看YYWebImage的时候,YY实际上重写了我们在官网下载的demo中的iosbuild.sh</p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gbcagkifxhj31qk0cugou.jpg"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> This script generates <span class="string">&#x27;WebP.framework&#x27;</span> (static library).</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> An iOS app can decode WebP images by including <span class="string">&#x27;WebP.framework&#x27;</span>.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 1. Download the latest libwebp <span class="built_in">source</span> code from</span></span><br><span class="line"><span class="meta">#</span><span class="bash">    http://downloads.webmproject.org/releases/webp/index.html</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. Use this script instead of the original <span class="string">&#x27;iosbuild.sh&#x27;</span> to build the WebP.framework.</span></span><br><span class="line"><span class="meta">#</span><span class="bash">    It will build all modules, include mux, demux, coder and decoder.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Notice: You should use Xcode 7 (or above) to support bitcode.</span></span><br><span class="line"></span><br><span class="line">set -e</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Extract the latest SDK version from the final field of the form: iphoneosX.Y</span></span><br><span class="line">readonly SDK=$(xcodebuild -showsdks \</span><br><span class="line">  | grep iphoneos | sort | tail -n 1 | awk &#x27;&#123;print substr($NF, 9)&#125;&#x27;</span><br><span class="line">)</span><br><span class="line"><span class="meta">#</span><span class="bash"> Extract Xcode version.</span></span><br><span class="line">readonly XCODE=$(xcodebuild -version | grep Xcode | cut -d &quot; &quot; -f2)</span><br><span class="line">if [[ -z &quot;$&#123;XCODE&#125;&quot; ]]; then</span><br><span class="line">  echo &quot;Xcode not available&quot;</span><br><span class="line">  exit 1</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">readonly OLDPATH=$&#123;PATH&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Add iPhoneOS-V6 to the list of platforms below <span class="keyword">if</span> you need armv6 support.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Note that iPhoneOS-V6 support is not available with the iOS6 SDK.</span></span><br><span class="line">PLATFORMS=&quot;iPhoneSimulator iPhoneSimulator64&quot;</span><br><span class="line">PLATFORMS+=&quot; iPhoneOS-V7 iPhoneOS-V7s iPhoneOS-V7-arm64&quot;</span><br><span class="line">readonly PLATFORMS</span><br><span class="line">readonly SRCDIR=$(dirname $0)</span><br><span class="line">readonly TOPDIR=$(pwd)</span><br><span class="line">readonly BUILDDIR=&quot;$&#123;TOPDIR&#125;/iosbuild&quot;</span><br><span class="line">readonly TARGETDIR=&quot;$&#123;TOPDIR&#125;/WebP.framework&quot;</span><br><span class="line">readonly DEVELOPER=$(xcode-select --print-path)</span><br><span class="line">readonly PLATFORMSROOT=&quot;$&#123;DEVELOPER&#125;/Platforms&quot;</span><br><span class="line">readonly LIPO=$(xcrun -sdk iphoneos$&#123;SDK&#125; -find lipo)</span><br><span class="line">LIBLIST=&#x27;&#x27;</span><br><span class="line"></span><br><span class="line">if [[ -z &quot;$&#123;SDK&#125;&quot; ]]; then</span><br><span class="line">  echo &quot;iOS SDK not available&quot;</span><br><span class="line">  exit 1</span><br><span class="line">elif [[ $&#123;SDK&#125; &lt; 6.0 ]]; then</span><br><span class="line">  echo &quot;You need iOS SDK version 6.0 or above&quot;</span><br><span class="line">  exit 1</span><br><span class="line">else</span><br><span class="line">  echo &quot;iOS SDK Version $&#123;SDK&#125;&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">rm -rf $&#123;BUILDDIR&#125;</span><br><span class="line">rm -rf $&#123;TARGETDIR&#125;</span><br><span class="line">mkdir -p $&#123;BUILDDIR&#125;</span><br><span class="line">mkdir -p $&#123;TARGETDIR&#125;/Headers/</span><br><span class="line"></span><br><span class="line">if [[ ! -e $&#123;SRCDIR&#125;/configure ]]; then</span><br><span class="line">  if ! (cd $&#123;SRCDIR&#125; &amp;&amp; sh autogen.sh); then</span><br><span class="line">    cat &lt;&lt;EOT</span><br><span class="line">Error creating configure script!</span><br><span class="line">This script requires the autoconf/automake and libtool to build. MacPorts can</span><br><span class="line">be used to obtain these:</span><br><span class="line">http://www.macports.org/install.php</span><br><span class="line">EOT</span><br><span class="line">    exit 1</span><br><span class="line">  fi</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">for PLATFORM in $&#123;PLATFORMS&#125;; do</span><br><span class="line">  ARCH2=&quot;&quot;</span><br><span class="line">  if [[ &quot;$&#123;PLATFORM&#125;&quot; == &quot;iPhoneOS-V7-arm64&quot; ]]; then</span><br><span class="line">    PLATFORM=&quot;iPhoneOS&quot;</span><br><span class="line">    ARCH=&quot;aarch64&quot;</span><br><span class="line">    ARCH2=&quot;arm64&quot;</span><br><span class="line">  elif [[ &quot;$&#123;PLATFORM&#125;&quot; == &quot;iPhoneOS-V7s&quot; ]]; then</span><br><span class="line">    PLATFORM=&quot;iPhoneOS&quot;</span><br><span class="line">    ARCH=&quot;armv7s&quot;</span><br><span class="line">  elif [[ &quot;$&#123;PLATFORM&#125;&quot; == &quot;iPhoneOS-V7&quot; ]]; then</span><br><span class="line">    PLATFORM=&quot;iPhoneOS&quot;</span><br><span class="line">    ARCH=&quot;armv7&quot;</span><br><span class="line">  elif [[ &quot;$&#123;PLATFORM&#125;&quot; == &quot;iPhoneOS-V6&quot; ]]; then</span><br><span class="line">    PLATFORM=&quot;iPhoneOS&quot;</span><br><span class="line">    ARCH=&quot;armv6&quot;</span><br><span class="line">  elif [[ &quot;$&#123;PLATFORM&#125;&quot; == &quot;iPhoneSimulator64&quot; ]]; then</span><br><span class="line">    PLATFORM=&quot;iPhoneSimulator&quot;</span><br><span class="line">    ARCH=&quot;x86_64&quot;</span><br><span class="line">  else</span><br><span class="line">    ARCH=&quot;i386&quot;</span><br><span class="line">  fi</span><br><span class="line"></span><br><span class="line">  ROOTDIR=&quot;$&#123;BUILDDIR&#125;/$&#123;PLATFORM&#125;-$&#123;SDK&#125;-$&#123;ARCH&#125;&quot;</span><br><span class="line">  mkdir -p &quot;$&#123;ROOTDIR&#125;&quot;</span><br><span class="line"></span><br><span class="line">  DEVROOT=&quot;$&#123;DEVELOPER&#125;/Toolchains/XcodeDefault.xctoolchain&quot;</span><br><span class="line">  SDKROOT=&quot;$&#123;PLATFORMSROOT&#125;/&quot;</span><br><span class="line">  SDKROOT+=&quot;$&#123;PLATFORM&#125;.platform/Developer/SDKs/$&#123;PLATFORM&#125;$&#123;SDK&#125;.sdk/&quot;</span><br><span class="line">  CFLAGS=&quot;-arch $&#123;ARCH2:-$&#123;ARCH&#125;&#125; -pipe -isysroot $&#123;SDKROOT&#125; -O3 -DNDEBUG&quot;</span><br><span class="line">  CFLAGS+=&quot; -miphoneos-version-min=6.0 -fembed-bitcode&quot;</span><br><span class="line"></span><br><span class="line">  set -x</span><br><span class="line">  export PATH=&quot;$&#123;DEVROOT&#125;/usr/bin:$&#123;OLDPATH&#125;&quot;</span><br><span class="line"><span class="meta">  $</span><span class="bash">&#123;SRCDIR&#125;/configure --host=<span class="variable">$&#123;ARCH&#125;</span>-apple-darwin --prefix=<span class="variable">$&#123;ROOTDIR&#125;</span> \</span></span><br><span class="line">    --build=$($&#123;SRCDIR&#125;/config.guess) \</span><br><span class="line">    --disable-shared --enable-static \</span><br><span class="line">    --enable-libwebpmux \</span><br><span class="line">    --enable-libwebpdemux \</span><br><span class="line">    --enable-swap-16bit-csp \</span><br><span class="line">    CFLAGS=&quot;$&#123;CFLAGS&#125;&quot;</span><br><span class="line">  set +x</span><br><span class="line"></span><br><span class="line"><span class="meta">  #</span><span class="bash"> run make only <span class="keyword">in</span> the src/ directory to create libwebpdecoder.a</span></span><br><span class="line">  cd src/</span><br><span class="line">  make V=0</span><br><span class="line">  make install</span><br><span class="line"></span><br><span class="line">  MAKEPATH=$(pwd)</span><br><span class="line">  cd $&#123;ROOTDIR&#125;/lib/</span><br><span class="line">  ar x libwebp.a</span><br><span class="line">  ar x libwebpmux.a</span><br><span class="line">  ar x libwebpdemux.a</span><br><span class="line">  ar q webp.a *.o</span><br><span class="line"></span><br><span class="line">  LIBLIST+=&quot; $&#123;ROOTDIR&#125;/lib/webp.a&quot;</span><br><span class="line">  cd $&#123;MAKEPATH&#125;</span><br><span class="line"></span><br><span class="line">  make clean</span><br><span class="line">  cd ..</span><br><span class="line"></span><br><span class="line">  export PATH=$&#123;OLDPATH&#125;</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">cp -a $&#123;SRCDIR&#125;/src/webp/*.h $&#123;TARGETDIR&#125;/Headers/</span><br><span class="line"><span class="meta">$</span><span class="bash">&#123;LIPO&#125; -create <span class="variable">$&#123;LIBLIST&#125;</span> -output <span class="variable">$&#123;TARGETDIR&#125;</span>/WebP</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>iOS优化</category>
      </categories>
      <tags>
        <tag>webP</tag>
      </tags>
  </entry>
  <entry>
    <title>探秘NSProxy</title>
    <url>/2018/06/02/what-s-nsproxy/</url>
    <content><![CDATA[<p>之前一直知道有一个与NSObject平级的类存在,但是日常的开发中好像一直都没有用到过。那么他存在的意义究竟是什么呢？这篇文章我们一起来探秘NSProxy。</p>
<a id="more"></a>

<h3 id="先看代码"><a href="#先看代码" class="headerlink" title="先看代码"></a>先看代码</h3><p>我们先看一下<code>NSProxy</code>这个类的声明</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSProxy</span> &lt;<span class="title">NSObject</span>&gt; </span>&#123;</span><br><span class="line">    Class	isa;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>这个类遵守了<code>&lt;NSObject&gt;</code>这个协议,我们来看一下这个协议究竟都做了什么呢？</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)isEqual:(<span class="keyword">id</span>)object;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>) <span class="built_in">NSUInteger</span> hash;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>) Class superclass;</span><br><span class="line">- (Class)<span class="keyword">class</span> OBJC_SWIFT_UNAVAILABLE(<span class="string">&quot;use &#x27;type(of: anObject)&#x27; instead&quot;</span>);</span><br><span class="line">- (<span class="keyword">instancetype</span>)<span class="keyword">self</span>;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)performSelector:(SEL)aSelector;</span><br><span class="line">- (<span class="keyword">id</span>)performSelector:(SEL)aSelector withObject:(<span class="keyword">id</span>)object;</span><br><span class="line">- (<span class="keyword">id</span>)performSelector:(SEL)aSelector withObject:(<span class="keyword">id</span>)object1 withObject:(<span class="keyword">id</span>)object2;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)isProxy;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)isKindOfClass:(Class)aClass;</span><br><span class="line">- (<span class="built_in">BOOL</span>)isMemberOfClass:(Class)aClass;</span><br><span class="line">- (<span class="built_in">BOOL</span>)conformsToProtocol:(Protocol *)aProtocol;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)respondsToSelector:(SEL)aSelector;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)<span class="keyword">retain</span> OBJC_ARC_UNAVAILABLE;</span><br><span class="line">- (<span class="keyword">oneway</span> <span class="keyword">void</span>)release OBJC_ARC_UNAVAILABLE;</span><br><span class="line">- (<span class="keyword">instancetype</span>)autorelease OBJC_ARC_UNAVAILABLE;</span><br><span class="line">- (<span class="built_in">NSUInteger</span>)retainCount OBJC_ARC_UNAVAILABLE;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">struct</span> _NSZone *)zone OBJC_ARC_UNAVAILABLE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *description;</span><br><span class="line"><span class="keyword">@optional</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *debugDescription;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>这个协议主要定义了一些类的一些基本方法。</p>
<p>这样看 感觉跟NSObject没什么太大的区别。我们在进一步看看这个类中的方法。</p>
<h4 id="init方法"><a href="#init方法" class="headerlink" title="init方法"></a>init方法</h4><p>在跟NSObject做了简单对比之后发现,<code>NSProxy</code>没有init方法。我们都知道NSObject在alloc方法内申请内存空间 init方法进行初始化。 从这个角度来看的话NSProxy是没有办法被直接创建和初始化的。</p>
<h4 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h4><p>对于class NSObject而言，接收到消息后先去自身的方法列表里找匹配的selector，如果找不到，会沿着继承体系去superclass的方法列表找；如果还找不到，先后会经过<code>+resolveInstanceMethod:</code>和<code>-forwardingTargetForSelector:</code>处理，处理失败后，才会到<code>-methodSignatureForSelector:</code>/<code>-forwardInvocation:</code>进行最后的挣扎。更详细的叙述，详见NSObject的消息转发机制。</p>
<p>但对于NSProxy，接收unknown selector后，直接回调<code>-methodSignatureForSelector:/-forwardInvocation:</code>，消息转发过程比class NSObject要简单得多。</p>
<h4 id="API-注释"><a href="#API-注释" class="headerlink" title="API 注释"></a>API 注释</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//一个抽象的超类,为那些以替身的身份存在的对象或者还没存在的对象定义了一套API。</span></span><br><span class="line">An abstract superclass defining an API <span class="keyword">for</span> objects that act as stand-ins <span class="keyword">for</span></span><br><span class="line"> other objects or <span class="keyword">for</span> objects that don’t exist yet.</span><br><span class="line"></span><br><span class="line"><span class="comment">//通常,向NSProxy发送一条消息会被转发给一个对象或者会让NSProxy去加载一个对象.NSProxy的子类可以用来实现透明的消息分发(例如NSDistantObject) 或者对创建昂贵的对象进行懒加载。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里的意思大概是NSProxy的子类可以用来做消息的分发</span></span><br><span class="line">Typically, a message to a proxy is forwarded to the real object or causes the</span><br><span class="line"> proxy to load (or transform itself into) the real object. Subclasses of </span><br><span class="line"> <span class="built_in">NSProxy</span> can be used to implement transparent distributed messaging (<span class="keyword">for</span></span><br><span class="line">  example, <span class="built_in">NSDistantObject</span>) or <span class="keyword">for</span> lazy instantiation of objects that are </span><br><span class="line">  expensive to create.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//NSProxy实现了作为根类的一些基本的方法,包括在NSObject协议中定义的。然而，作为一个抽象类他没有提供一个实例化方法，在接收到任何他没有实现的方法时都会抛出异常。</span></span><br><span class="line"><span class="built_in">NSProxy</span> implements the basic methods required of a root <span class="keyword">class</span>, including those</span><br><span class="line"> defined <span class="keyword">in</span> the <span class="built_in">NSObject</span> protocol. However, as an abstract <span class="keyword">class</span> it doesn’t </span><br><span class="line"> provide an initialization method, and it raises an exception upon receiving </span><br><span class="line"> any message it doesn’t respond to. </span><br><span class="line"></span><br><span class="line"><span class="comment">//因此 一个具体的子类必提供一个实例化方法或者创建方法。并且覆盖`forwardInvocation`方法和`methodSignatureForSelector`方法来处理类本身没有实现的方法。</span></span><br><span class="line">A concrete subclass must therefore provide an initialization or creation </span><br><span class="line">method and override the forwardInvocation: and methodSignatureForSelector: </span><br><span class="line">methods to handle messages that it doesn’t implement itself.</span><br><span class="line"></span><br><span class="line"><span class="comment">//子类中`forwardInvocation`的实现中应该做任何需要的来处理invocation,比如通过网络转发这个invocation，或者加载一个的对象并将这个invocation转发给他。</span></span><br><span class="line"> A subclass’s implementation of forwardInvocation: should <span class="keyword">do</span> whatever is</span><br><span class="line">  needed to process the invocation, such as forwarding the invocation over the</span><br><span class="line">   network or loading the real object and passing it the invocation. </span><br><span class="line"> </span><br><span class="line"><span class="comment">//`methodSignatureForSelector`是用来获取给定消息的参数类型；在子类的实现中可以获取这个将要被转发的消息的参数类型。同时应该创建一个相对应的NSMethodSignature对象。</span></span><br><span class="line">methodSignatureForSelector: is required to provide argument type information </span><br><span class="line"><span class="keyword">for</span> a given message; a subclass’s implementation should be able to determine</span><br><span class="line"> the argument types <span class="keyword">for</span> the messages it needs to forward and should construct</span><br><span class="line">  an <span class="built_in">NSMethodSignature</span> object accordingly. See the <span class="built_in">NSDistantObject</span>, </span><br><span class="line">  <span class="built_in">NSInvocation</span>, and <span class="built_in">NSMethodSignature</span> <span class="keyword">class</span> specifications <span class="keyword">for</span> more </span><br><span class="line">  information.</span><br></pre></td></tr></table></figure>

<p>通过上面的这段解释,我们能大概的了解到NSProxy的作用:</p>
<p>因为NSProxy没有init方法,因此所有的操作必须是通过子类实现,而且 因为子类也同样没有init方法,那就决定了NSProxy以及子类都无法直接去相应某一个方法。因此NSProxy的子类一般是讲调用的方法转发给对应的某些对象。因此其扮演的实际上是一个分发者的角色。</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>为了对比他和NSObject的区别 我们这里创建两个类分别继承自NSObject和NSProxy.</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ProxyObject</span> : <span class="title">NSProxy</span></span></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithObject:(<span class="keyword">id</span>)object;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NormalObject</span> : <span class="title">NSObject</span></span></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithObject:(<span class="keyword">id</span>)object;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>我们在这两个类中都创建了一个对象.当当前类对象没有实现对应方法的时候,统一转发给这个对象。</p>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><ul>
<li>1、<a href="https://zhangbuhuai.com/nsproxy/">NSProxy</a></li>
<li>2、<a href="https://blog.sunnyxx.com/2014/08/24/objc-duck/">objc与鸭子对象</a></li>
<li>3、<a href="http://www.tanhao.me/code/160702.html/">使用NSProxy和NSObject设计代理类的差异</a></li>
<li>4、<a href="https://www.jianshu.com/p/a7187e014c03">用 NSProxy 实现面向切面编程</a></li>
<li>5、<a href="https://www.jianshu.com/p/8e700673202b">NSProxy——少见却神奇的类</a></li>
</ul>
]]></content>
      <categories>
        <category>iOS优化</category>
      </categories>
      <tags>
        <tag>NSProxy</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS 开发中常用的快捷键</title>
    <url>/2018/09/30/xcode-shortcuts/</url>
    <content><![CDATA[<p>在我们日常的开发工作中,我们会经常使用一些快捷键,其中的一些快捷键可以很大程度上提高我们开发效率,所以在此对常用的快捷键进行整理！</p>
<a id="more"></a>


<h3 id="删除一行代码"><a href="#删除一行代码" class="headerlink" title="删除一行代码"></a>删除一行代码</h3><p><code>ctrl+k</code> 删除光标之后的内容<br>如果要删除整行代码 那么需要保证光标在行首 </p>
<p><img src="https://ws1.sinaimg.cn/large/006tNc79ly1fvrrr4tzmtg30h505kaai.gif" alt="删除一行"></p>
<h3 id="将光标跳转至行首"><a href="#将光标跳转至行首" class="headerlink" title="将光标跳转至行首"></a>将光标跳转至行首</h3><p><code>ctrl+a</code><br><code>cmd+&lt;- cmd+-&gt;</code> 光标跳转至行首或者行尾</p>
<p><img src="https://ws4.sinaimg.cn/large/006tNc79ly1fvrrvlx9wag30su0e6gop.gif" alt="回到行首或者行尾"></p>
<h3 id="查看工程文件"><a href="#查看工程文件" class="headerlink" title="查看工程文件"></a>查看工程文件</h3><p><code>command+1</code></p>
<p><img src="https://ws4.sinaimg.cn/large/006tNc79ly1fvrrym88nbg30nf07ct9a.gif" alt="切换到文件目录"></p>
<h3 id="全局查找"><a href="#全局查找" class="headerlink" title="全局查找"></a>全局查找</h3><p><code>command+3</code></p>
<p><img src="https://ws1.sinaimg.cn/large/006tNc79ly1fvrrtc4a0ag308o0k80vp.gif" alt="全局搜索"></p>
<h3 id="快速跳转到类的特定行"><a href="#快速跳转到类的特定行" class="headerlink" title="快速跳转到类的特定行"></a>快速跳转到类的特定行</h3><p><code>command + L</code></p>
<p><img src="https://ws3.sinaimg.cn/large/006tNc79ly1fvrrtx9pu8g30qu0ct76v.gif" alt="跳转到某一行"></p>
<h3 id="快速查找打开类"><a href="#快速查找打开类" class="headerlink" title="快速查找打开类"></a>快速查找打开类</h3><p><code>command+ shift+ O</code></p>
<p><img src="https://ws1.sinaimg.cn/large/006tNc79ly1fvrrtkugwog30tu0fiaqy.gif" alt="跳到某各类后者某个方法"></p>
<h3 id="快速定位当前类在项目文件中的位置"><a href="#快速定位当前类在项目文件中的位置" class="headerlink" title="快速定位当前类在项目文件中的位置"></a>快速定位当前类在项目文件中的位置</h3><p><code>command + shift + J</code></p>
<p><img src="https://ws4.sinaimg.cn/large/006tNc79ly1fvrrvueioig30tu0fi76j.gif" alt="定位当前类的位置"></p>
<h3 id="类文件”-h”与“-m”之间切换"><a href="#类文件”-h”与“-m”之间切换" class="headerlink" title="类文件”.h”与“.m”之间切换"></a>类文件”.h”与“.m”之间切换</h3><p><code>control+command+↑/control+command+↓</code></p>
<p><img src="https://ws4.sinaimg.cn/large/006tNc79ly1fvrrwrq14cg30tu0figv3.gif" alt=".h和.m之间的切换"></p>
<h3 id="清除工程"><a href="#清除工程" class="headerlink" title="清除工程"></a>清除工程</h3><p><code>Command + Shift + K</code></p>
<p><img src="https://ws3.sinaimg.cn/large/006tNc79ly1fvrrs29nizg30tu0fiqae.gif" alt="cleanproject"></p>
<h3 id="当前类-方法-变量查找"><a href="#当前类-方法-变量查找" class="headerlink" title="当前类 方法/变量查找"></a>当前类 方法/变量查找</h3><p><code>Control+6（键入方法/变量名+Enter跳转）</code></p>
<p><img src="https://ws2.sinaimg.cn/large/006tNc79ly1fvrrwf1gxgg30tu0fi7bf.gif" alt="方法查找"></p>
<h3 id="撤销-反撤销："><a href="#撤销-反撤销：" class="headerlink" title="撤销/反撤销："></a>撤销/反撤销：</h3><p><code>command+z /command +shift +z</code></p>
<p><img src="https://ws3.sinaimg.cn/large/006tNc79ly1fvrrw3xvueg30su0e6aht.gif" alt="撤销和反撤销"></p>
<h2 id="光标操作"><a href="#光标操作" class="headerlink" title="光标操作"></a>光标操作</h2><h3 id="向右一个字符（forward）"><a href="#向右一个字符（forward）" class="headerlink" title="向右一个字符（forward）"></a>向右一个字符（forward）</h3><p><code>control+F</code></p>
<h3 id="向左一个字符（backward）"><a href="#向左一个字符（backward）" class="headerlink" title="向左一个字符（backward）"></a>向左一个字符（backward）</h3><p><code>control+B</code></p>
<p><img src="https://ws1.sinaimg.cn/large/006tNc79ly1fvrsfyof3dg30i406ggma.gif" alt="左边字符"></p>
<h3 id="前一行（previous）"><a href="#前一行（previous）" class="headerlink" title="前一行（previous）"></a>前一行（previous）</h3><p><code>control+P</code></p>
<h3 id="后一行（next）"><a href="#后一行（next）" class="headerlink" title="后一行（next）"></a>后一行（next）</h3><p><code>control+N</code></p>
<p><img src="https://ws3.sinaimg.cn/large/006tNc79ly1fvrrxd231zg30su0e6gpo.gif" alt="上下切换一行代码"></p>
<h3 id="去行首"><a href="#去行首" class="headerlink" title="去行首"></a>去行首</h3><p><code>control+A</code></p>
<p><img src="https://ws3.sinaimg.cn/large/006tNc79ly1fvrrsvsv4lg30h505kt9e.gif" alt="行首或者行尾"></p>
<h3 id="到行尾（end）"><a href="#到行尾（end）" class="headerlink" title="到行尾（end）"></a>到行尾（end）</h3><p><code>control+E</code></p>
<p><img src="https://ws2.sinaimg.cn/large/006tNc79ly1fvrrvc847pg30su0e6gpb.gif" alt="回到行尾"></p>
<h3 id="删除光标右侧字符（delete）"><a href="#删除光标右侧字符（delete）" class="headerlink" title="删除光标右侧字符（delete）"></a>删除光标右侧字符（delete）</h3><p><code>control+D</code></p>
<p><img src="https://ws3.sinaimg.cn/large/006tNc79ly1fvrrsidgh6g30su0e6jvx.gif" alt="deleteright"></p>
<h2 id="整体位移代码"><a href="#整体位移代码" class="headerlink" title="整体位移代码:"></a>整体位移代码:</h2><h3 id="向左位移"><a href="#向左位移" class="headerlink" title="向左位移"></a>向左位移</h3><p><code>选中的代码 + command+[ </code></p>
<h3 id="向右位移"><a href="#向右位移" class="headerlink" title="向右位移"></a>向右位移</h3><p><code>选中的代码 + command+]</code></p>
<p><img src="https://ws2.sinaimg.cn/large/006tNc79ly1fvrruvvuuzg30su0e60x2.gif" alt="Xcode格式规范 缩进修改"></p>
<h3 id="向上位移"><a href="#向上位移" class="headerlink" title="向上位移"></a>向上位移</h3><p><code>选中的代码 + command+option+[ </code></p>
<h3 id="向下位移"><a href="#向下位移" class="headerlink" title="向下位移"></a>向下位移</h3><p><code>选中的代码 + command+option+]</code></p>
<p><img src="https://ws1.sinaimg.cn/large/006tNc79ly1fvrrujmyn7g30su0e6wik.gif" alt="上一行或者下一行"></p>
<h2 id="xcode-整体"><a href="#xcode-整体" class="headerlink" title="xcode 整体"></a>xcode 整体</h2><h3 id="回到上一个-下一个打开的页面"><a href="#回到上一个-下一个打开的页面" class="headerlink" title="回到上一个/下一个打开的页面"></a>回到上一个/下一个打开的页面</h3><p><code>control + command + ← / control + command + →</code></p>
<p><img src="https://ws3.sinaimg.cn/large/006tNc79ly1fvrru6e5f3g30su0e67eu.gif" alt="返回到上一个页面"></p>
<h3 id="新建文件"><a href="#新建文件" class="headerlink" title="新建文件"></a>新建文件</h3><p><code>command + N</code></p>
<p><img src="https://ws3.sinaimg.cn/large/006tNc79ly1fvrsg8i4j6g30tc0f8wjg.gif" alt="新建文件"></p>
<h3 id="创建新工程"><a href="#创建新工程" class="headerlink" title="创建新工程:"></a>创建新工程:</h3><p><code>command + shift + N</code></p>
<p><img src="https://ws1.sinaimg.cn/large/006tNc79ly1fvrsgj63h3g30tc0f8n50.gif" alt="新建项目"></p>
]]></content>
      <categories>
        <category>iOS基础</category>
      </categories>
      <tags>
        <tag>快捷键</tag>
      </tags>
  </entry>
  <entry>
    <title>看代码 学习Swift</title>
    <url>/2017/09/14/%E7%9C%8B%E4%BB%A3%E7%A0%81-%E5%AD%A6%E4%B9%A0Swift/</url>
    <content><![CDATA[<p>本篇文章主要是在看 其他人代码的过程中 看到的一些知识点 这里做一下总结</p>
<a id="more"></a>

<h2 id="调用对象的方法"><a href="#调用对象的方法" class="headerlink" title="调用对象的方法"></a>调用对象的方法</h2><p>这里是对Selector写了个分类,让代码看起来更简单</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">extension Selector &#123;</span><br><span class="line">  static let endEditing &#x3D; #selector(UIView.endEditing(_:))</span><br><span class="line">&#125;</span><br><span class="line">    &#x2F;&#x2F; dismiss keyboard</span><br><span class="line">    self.view.addGestureRecognizer(UITapGestureRecognizer(target: self.view, action: Selector.endEditing))</span><br></pre></td></tr></table></figure>

<h2 id="方法的参数判断"><a href="#方法的参数判断" class="headerlink" title="方法的参数判断"></a>方法的参数判断</h2><p>对于常见的一些方法为Optional的参数 判断方式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func getLabelsInfo() -&gt; (name: String?, work: String?, salary: String?) &#123;</span><br><span class="line">  guard let name &#x3D; nameTextField.text,</span><br><span class="line">    let work &#x3D; workTextField.text,</span><br><span class="line">    let salary &#x3D; salaryLabel.text</span><br><span class="line">    else &#123;</span><br><span class="line">      return (nil, nil, nil)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  if name.isEmpty || work.isEmpty || salary.isEmpty &#123;</span><br><span class="line">    return (nil, nil, nil)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  return (name, work, salary)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="对象的判空"><a href="#对象的判空" class="headerlink" title="对象的判空"></a>对象的判空</h2><p>.some 表示对象有值 .none表示对象为空</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">switch tweet &#123;</span><br><span class="line">case .some(let tweet):</span><br><span class="line">  showAlert(title: &quot;Love Tweet&quot;,</span><br><span class="line">            message: tweet.info,</span><br><span class="line">            buttonTitle: &quot;OK&quot;)</span><br><span class="line">  </span><br><span class="line">case .none:</span><br><span class="line">  showAlert(title: &quot;Info miss or invalid&quot;,</span><br><span class="line">            message: &quot;Please fill out correct personal info&quot;,</span><br><span class="line">            buttonTitle: &quot;OK&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="属性声明"><a href="#属性声明" class="headerlink" title="属性声明"></a>属性声明</h2><p>private 私有 类内部私有<br>fileprivate 文件内部私有 一个文件有多个类<br>public 外部可使用 类可以继承 方法可以重载<br>open   外部可使用 类不可以继承 方法不可以重载</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fileprivate let mainStopwatch: Stopwatch &#x3D; Stopwatch()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="代理声明"><a href="#代理声明" class="headerlink" title="代理声明"></a>代理声明</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">weak var delegate: PokemonSelectionDelegate?</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(cell.titleLabel.text, cell.descriptionLabel.text, cell.dateLabel.text) &#x3D; (item.title, item.description, item.pubDate)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="注册cell"><a href="#注册cell" class="headerlink" title="注册cell"></a>注册cell</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">view.register(FBMeBaseCell.self, forCellReuseIdentifier: FBMeBaseCell.identifier)</span><br></pre></td></tr></table></figure>

<h3 id="UI配置文件"><a href="#UI配置文件" class="headerlink" title="UI配置文件"></a>UI配置文件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public struct Specs &#123;</span><br><span class="line">  public struct Color &#123;</span><br><span class="line">    public let tint &#x3D; UIColor(hex: 0x3b5998)</span><br><span class="line">    public let red &#x3D; UIColor.red</span><br><span class="line">    public let white &#x3D; UIColor.white</span><br><span class="line">    public let black &#x3D; UIColor.black</span><br><span class="line">    public let gray &#x3D; UIColor.lightGray</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public struct FontSize &#123;</span><br><span class="line">    public let tiny: CGFloat &#x3D; 10</span><br><span class="line">    public let small: CGFloat &#x3D; 12</span><br><span class="line">    public let regular: CGFloat &#x3D; 14</span><br><span class="line">    public let large: CGFloat &#x3D; 16</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public struct Font &#123;</span><br><span class="line">    private static let regularName &#x3D; &quot;Helvetica Neue&quot;</span><br><span class="line">    private static let boldName &#x3D; &quot;Helvetica Neue Bold&quot;</span><br><span class="line">    public let tiny &#x3D; UIFont(name: regularName, size: Specs.fontSize.tiny)</span><br><span class="line">    public let small &#x3D; UIFont(name: regularName, size: Specs.fontSize.small)</span><br><span class="line">    public let regular &#x3D; UIFont(name: regularName, size: Specs.fontSize.regular)</span><br><span class="line">    public let large &#x3D; UIFont(name: regularName, size: Specs.fontSize.large)</span><br><span class="line">    public let smallBold &#x3D; UIFont(name: boldName, size: Specs.fontSize.small)</span><br><span class="line">    public let regularBold &#x3D; UIFont(name: boldName, size: Specs.fontSize.regular)</span><br><span class="line">    public let largeBold &#x3D; UIFont(name: boldName, size: Specs.fontSize.large)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public struct ImageName &#123;</span><br><span class="line">    public let friends &#x3D; &quot;fb_friends&quot;</span><br><span class="line">    public let events &#x3D; &quot;fb_events&quot;</span><br><span class="line">    public let groups &#x3D; &quot;fb_groups&quot;</span><br><span class="line">    public let education &#x3D; &quot;fb_education&quot;</span><br><span class="line">    public let townHall &#x3D; &quot;fb_town_hall&quot;</span><br><span class="line">    public let instantGames &#x3D; &quot;fb_games&quot;</span><br><span class="line">    public let settings &#x3D; &quot;fb_settings&quot;</span><br><span class="line">    public let privacyShortcuts &#x3D; &quot;fb_privacy_shortcuts&quot;</span><br><span class="line">    public let helpSupport &#x3D; &quot;fb_help_and_support&quot;</span><br><span class="line">    public let placeholder &#x3D; &quot;fb_placeholder&quot;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public static var color: Color &#123;</span><br><span class="line">    return Color()</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public static var fontSize: FontSize &#123;</span><br><span class="line">    return FontSize()</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public static var font: Font &#123;</span><br><span class="line">    return Font()</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public static var imageName: ImageName &#123;</span><br><span class="line">    return ImageName()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="16进制颜色"><a href="#16进制颜色" class="headerlink" title="16进制颜色"></a>16进制颜色</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">convenience init(hex: Int) &#123;</span><br><span class="line">  self.init(r: (hex &amp; 0xff0000) &gt;&gt; 16, g: (hex &amp; 0xff00) &gt;&gt; 8, b: (hex &amp; 0xff), a: 1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="多个判断条件叠加"><a href="#多个判断条件叠加" class="headerlink" title="多个判断条件叠加"></a>多个判断条件叠加</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">guard let index &#x3D; viewController.photoIndex, index !&#x3D; photos.count - 1 else &#123;</span><br><span class="line">        return nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="常量的位置"><a href="#常量的位置" class="headerlink" title="常量的位置"></a>常量的位置</h3><p>文件中共用的常量要放到类的外面,否则可能无法在某些类方法或者对象方法中使用</p>
<h3 id="控制器代码结构"><a href="#控制器代码结构" class="headerlink" title="控制器代码结构"></a>控制器代码结构</h3><p><img src="http://og0h689k8.bkt.clouddn.com/17-9-18/45832775.jpg" alt="控制器结构"></p>
]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title>[转]Swift:利用Enum灵活映射多重类型Data model</title>
    <url>/2017/09/10/%E8%BD%AC-Swift-%E5%88%A9%E7%94%A8Enum%E7%81%B5%E6%B4%BB%E6%98%A0%E5%B0%84%E5%A4%9A%E9%87%8D%E7%B1%BB%E5%9E%8BData-model/</url>
    <content><![CDATA[<p>利用Enum灵活映射多重类型Data model</p>
<a id="more"></a>

<p><a href="http://www.jianshu.com/p/87255dc14331">中文译文</a><br><a href="https://medium.com/swift-programming/swift-typecasing-3cd156c323e#.rfhar1edp">原文</a></p>
<h2 id="一个字段中返回了多种相似的类型"><a href="#一个字段中返回了多种相似的类型" class="headerlink" title="一个字段中返回了多种相似的类型"></a>一个字段中返回了多种相似的类型</h2><p>先来看下项目中我遇到的一个情况，服务端在人物中返回了一组数据。这些人物有几个相同的属性，但是又有各自不同的角色各有的属性。json数据如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;characters&quot; : [</span><br><span class="line">    &#123;</span><br><span class="line">        type: &quot;hero&quot;,</span><br><span class="line">        name: &quot;Jake&quot;,</span><br><span class="line">        power: &quot;Shapeshift&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        type: &quot;hero&quot;,</span><br><span class="line">        name: &quot;Finn&quot;,</span><br><span class="line">        power: &quot;Grass sword&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        type: &quot;princess&quot;,</span><br><span class="line">        name: &quot;Lumpy Space Princess&quot;,</span><br><span class="line">        kingdom: &quot;Lumpy Space&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        type: &quot;civilian&quot;,</span><br><span class="line">        name: &quot;BMO&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        type: &quot;princess&quot;,</span><br><span class="line">        name: &quot;Princess Bubblegum&quot;,</span><br><span class="line">        kingdom: &quot;Candy&quot;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>那么我们可以怎么解析这样的数据呢？</p>
<h2 id="利用类和继承"><a href="#利用类和继承" class="headerlink" title="利用类和继承"></a>利用类和继承</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Character &#123;</span><br><span class="line">    type: String</span><br><span class="line">    name: String</span><br><span class="line">&#125;</span><br><span class="line">class Hero : Character &#123;</span><br><span class="line">    power: String</span><br><span class="line">&#125;</span><br><span class="line">class Princess : Character &#123;</span><br><span class="line">    kingdom: String</span><br><span class="line">&#125;</span><br><span class="line">class Civilian : Character &#123; </span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">struct Model &#123;</span><br><span class="line">    characters: [Character]</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这其实就是项目中我原来使用的方案。但是很快就会觉得有点苦逼，因为使用的时候要不断的类型判断，然后类型转换后才能访问到某个具体类型的属性：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Type checking</span><br><span class="line">if model.characters[indexPath.row] is Hero &#123;</span><br><span class="line">    print(model.characters[indexPath.row].name)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; Type checking and Typecasting</span><br><span class="line">if let hero &#x3D; model.characters[indexPath.row] as? Hero &#123;</span><br><span class="line">    print(hero.power)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="利用结构体和协议"><a href="#利用结构体和协议" class="headerlink" title="利用结构体和协议"></a>利用结构体和协议</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protocol Character &#123;</span><br><span class="line">    var type: String &#123; get set &#125;</span><br><span class="line">    var name: String &#123; get set &#125;</span><br><span class="line">&#125;</span><br><span class="line">struct Hero : Character &#123;</span><br><span class="line">    power: String</span><br><span class="line">&#125;</span><br><span class="line">struct Princess : Character &#123;</span><br><span class="line">    kingdom: String</span><br><span class="line">&#125;</span><br><span class="line">struct Civilian : Character &#123; </span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">struct Model &#123;</span><br><span class="line">    characters: [Character]</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里我们使用了结构体，解析的性能会好一些。但是看起来和前面类的方案差不多。我们并没有利用上protocol的特点，使用的时候我们还是要进行类型判断：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Type checking</span><br><span class="line">if model.characters[indexPath.row] is Hero &#123;</span><br><span class="line">    print(model.characters[indexPath.row].name)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; Type checking and Typecasting</span><br><span class="line">if let hero &#x3D; model.characters[indexPath.row] as? Hero &#123;</span><br><span class="line">    print(hero.power)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="类型转换的潜在问题"><a href="#类型转换的潜在问题" class="headerlink" title="类型转换的潜在问题"></a>类型转换的潜在问题</h2><p>上面的这种类型转换可能引入潜在的问题。如果后台此时增加了一个类型对代码会产生什么样的影响呢？可能想到这种情况提前做了处理，也可能没有处理导致崩溃。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    type: &quot;king&quot;</span><br><span class="line">    name: &quot;Ice King&quot;</span><br><span class="line">    power: &quot;Frost&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>当我们在写代码的时候，应该考虑到这样的场景，当有新类型出现时能不能友好的提示哪里需要处理呢？毕竟swift的设计目标之一就是更安全的语言。</p>
<h2 id="另外一种可能：Enum"><a href="#另外一种可能：Enum" class="headerlink" title="另外一种可能：Enum"></a>另外一种可能：Enum</h2><p>我们如何创建一个包含不同类型数据的数组，然后访问他们的属性的时候不用类型转换呢？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">enum Character &#123;</span><br><span class="line">    case hero, princess, civilian</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当switch一个枚举时，每种case都需要被照顾到，所以使用enum可以很好的避免一些潜在的问题。但是如果只是这样依然不够好，我们可以更进一步：</p>
<h2 id="Associated-values：关联值"><a href="#Associated-values：关联值" class="headerlink" title="Associated values：关联值"></a>Associated values：关联值</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">enum Character &#123;</span><br><span class="line">    case hero(Hero) </span><br><span class="line">    case princess(Princess)</span><br><span class="line">    case civilian(Civilian)</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">switch characters[indexPath.row] &#123;</span><br><span class="line">    case .hero(let hero):</span><br><span class="line">        print(hero.power)</span><br><span class="line">    case .princess(let princess):</span><br><span class="line">        print(princess.kingdom)</span><br><span class="line">    case .civilian(let civilian):</span><br><span class="line">        print(civilian.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>现在使用的时候不再需要类型转换了。并且如果增加一种新类型，只要在enum中增加一个case，你就不会遗漏需要再修改何处的代码，消除了潜在的问题。</p>
<h2 id="Raw-Value"><a href="#Raw-Value" class="headerlink" title="Raw Value"></a>Raw Value</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">enum Character : String &#123; &#x2F;&#x2F; Error: ❌</span><br><span class="line">    case hero(Hero) </span><br><span class="line">    case princess(Princess)</span><br><span class="line">    case civilian(Civilian)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你可能会发现这个枚举没有实现RawRepresentable协议，这是因为关联值类型的枚举不能同时遵从RawRepresentable协议，他们是互斥的。</p>
<h2 id="如何初始化"><a href="#如何初始化" class="headerlink" title="如何初始化"></a>如何初始化</h2><p>如果实现了RawRepresentable协议，就会自带一个利用raw value 初始化的方法。但是我们现在没有实现这个协议，所以我们需要自定义一个初始化方法。<br>先定义一个内部使用的枚举表示类型：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">enum Character &#123;</span><br><span class="line"></span><br><span class="line">    private enum Type : String &#123;</span><br><span class="line">        case hero, princess, civilian</span><br><span class="line">        static let key &#x3D; &quot;type&quot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Failable-initializers"><a href="#Failable-initializers" class="headerlink" title="Failable initializers"></a>Failable initializers</h2><p>因为传回来的json可能出现映射失败的情况，比如增加的一个新类型，所以这里的初始化方法是可失败的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; enum Character</span><br><span class="line">init?(json: [String : AnyObject]) &#123;</span><br><span class="line">    guard let </span><br><span class="line">        string &#x3D; json[Type.key] as? String,</span><br><span class="line">        type &#x3D; Type(rawValue: string)</span><br><span class="line">        else &#123; return nil &#125;</span><br><span class="line">    switch type &#123;</span><br><span class="line">        case .hero:</span><br><span class="line">            guard let hero &#x3D; Hero(json: json) </span><br><span class="line">            else &#123; return nil &#125;</span><br><span class="line">            self &#x3D; .hero(hero)</span><br><span class="line">        case .princess:</span><br><span class="line">            guard let princess &#x3D; Princess(json: json) </span><br><span class="line">            else &#123; return nil &#125;</span><br><span class="line">            self &#x3D; .princess(princess)      </span><br><span class="line">        case .civilian:</span><br><span class="line">            guard let civilian &#x3D; Civilian(json: json) </span><br><span class="line">            else &#123; return nil &#125;</span><br><span class="line">            self &#x3D; .civilian(civilian)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="使用枚举解析json"><a href="#使用枚举解析json" class="headerlink" title="使用枚举解析json"></a>使用枚举解析json</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Model initialisation</span><br><span class="line">if let characters &#x3D; json[&quot;characters&quot;] as? [[String : AnyObject]] &#123;</span><br><span class="line">    self.characters &#x3D; characters.flatMap &#123; Character(json: $0) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意这里使用了flatMap。当一条数据的type不在我们已经定义的范围内时，Character(json: [String : AnyObject])返回一个nil。我们当然希望过滤掉这些无法处理的数据。所以使用flatMap，flatMap过程中会抛弃为nil的值，所以这里使用了flapMap。</p>
<h2 id="完成"><a href="#完成" class="headerlink" title="完成"></a>完成</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">switch model.characters[indexPath.row] &#123;</span><br><span class="line">    case .hero(let hero):</span><br><span class="line">        print(hero.power)</span><br><span class="line"></span><br><span class="line">    case .princess(let princess):</span><br><span class="line">        print(princess.kingdom)</span><br><span class="line"></span><br><span class="line">    case .civilian(let civilian):</span><br><span class="line">        print(civilian.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>现在可以像最前面展示的那样使用了。<br>可以告别那些将数组类型声明为 Any, AnyObject或者泛型，继承组合的model，使用时再转换类型的日子了。</p>
<h2 id="One-More-Thing-模式匹配"><a href="#One-More-Thing-模式匹配" class="headerlink" title="One More Thing: 模式匹配"></a>One More Thing: 模式匹配</h2><p>如果只处理枚举中的一种类型，我们会这么写：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func printPower(character: Character) &#123;</span><br><span class="line">    switch character &#123;</span><br><span class="line">        case .hero(let hero):</span><br><span class="line">            print(hero.power)</span><br><span class="line">        default: </span><br><span class="line">            break</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然而我们可以利用swift提供的模式匹配，用这种更优雅的写法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func printPower(character: Character) &#123;</span><br><span class="line">    if case .hero(let hero) &#x3D; character &#123;</span><br><span class="line">        print(hero.power)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>Enum,字典转模型</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么要存在MetaClass</title>
    <url>/2018/05/02/why-metaclass/</url>
    <content><![CDATA[<p>最近去外面面试了一次,有一个问题觉得很有意思:OC中为什么要存在metaClass,在类的结构上这么设计的原因是什么？metaClass中都有什么？有什么优点？</p>
<p>这篇文章我们就来讨论一下上面的这几个问题！</p>
<a id="more"></a>

<h2 id="了解-MetaClass"><a href="#了解-MetaClass" class="headerlink" title="了解 MetaClass"></a>了解 MetaClass</h2><h3 id="MetaClass结构"><a href="#MetaClass结构" class="headerlink" title="MetaClass结构"></a>MetaClass结构</h3><p>下面我们先来看看这个类的结构:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_class &#123;</span><br><span class="line">    Class isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">if</span> !__OBJC2__</span></span><br><span class="line">    Class super_class   OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name    OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">long</span> version        OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">long</span> info           OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">long</span> instance_size  OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">struct</span> objc_ivar_list *ivars    OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">struct</span> objc_method_list **methodLists   OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">struct</span> objc_cache *cache                OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">struct</span> objc_protocol_list *protocols    OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125; OBJC2_UNAVAILABLE;</span><br></pre></td></tr></table></figure>

<p>metaClass 也是objc_class 因此结构大概也是这样的！,不过就目前所知到的<code>metaClass</code>是用来存放类方法的！ 因为OC中没有类属性因此 objc_ivar_list 为空！</p>
<h3 id="MetaClass的创建"><a href="#MetaClass的创建" class="headerlink" title="MetaClass的创建"></a>MetaClass的创建</h3><p>首先了解一点,在OC中每一个类都有一个对应的MetaClass！ 因此 我们在创建一个类的时候,就会一起创建这个类的元类。</p>
<p>因此,我们可以看一下当我们动态创建一个类的时候 运行时实际上都做了什么！</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">Class objc_allocateClassPair(Class superclass, <span class="keyword">const</span> <span class="keyword">char</span> *name, </span><br><span class="line">                             size_t extraBytes)</span><br><span class="line">&#123;</span><br><span class="line">    Class cls, meta;</span><br><span class="line"></span><br><span class="line">    rwlock_writer_t lock(runtimeLock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Fail if the class name is in use.</span></span><br><span class="line">    <span class="comment">// Fail if the superclass isn&#x27;t kosher.</span></span><br><span class="line">    <span class="keyword">if</span> (getClass(name)  ||  !verifySuperclass(superclass, <span class="literal">true</span><span class="comment">/*rootOK*/</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allocate new classes.</span></span><br><span class="line">    cls  = alloc_class_for_subclass(superclass, extraBytes);</span><br><span class="line">    meta = alloc_class_for_subclass(superclass, extraBytes);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// fixme mangle the name if it looks swift-y?</span></span><br><span class="line">    objc_initializeClassPair_internal(superclass, name, cls, meta);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cls;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的代码中我们可以很明显的看出:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">cls  = alloc_class_for_subclass(superclass, extraBytes);</span><br><span class="line">meta = alloc_class_for_subclass(superclass, extraBytes);</span><br></pre></td></tr></table></figure>
<p><code>cls</code>和<code>meta</code>的创建方法和参数完全一致！</p>
<h3 id="怎么获取一个类的MetaClass"><a href="#怎么获取一个类的MetaClass" class="headerlink" title="怎么获取一个类的MetaClass"></a>怎么获取一个类的MetaClass</h3><p><code>objc_getMetaClass(const char * _Nonnull name)</code></p>
<p>我们来看一下这个方法的实现</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">Class objc_getMetaClass(<span class="keyword">const</span> <span class="keyword">char</span> *aClassName)</span><br><span class="line">&#123;</span><br><span class="line">    Class cls;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!aClassName) <span class="keyword">return</span> Nil;</span><br><span class="line"></span><br><span class="line">    cls = objc_getClass (aClassName);</span><br><span class="line">    <span class="keyword">if</span> (!cls)</span><br><span class="line">    &#123;</span><br><span class="line">        _objc_inform (<span class="string">&quot;class `%s&#x27; not linked into application&quot;</span>, aClassName);</span><br><span class="line">        <span class="keyword">return</span> Nil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cls-&gt;ISA();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先是使用<code>objc_getClass</code>获取类名对应的类 然后直接利用<code>cls-&gt;ISA()</code>获取这个类对应的元类</p>
<h3 id="判断一个类是否为元类"><a href="#判断一个类是否为元类" class="headerlink" title="判断一个类是否为元类"></a>判断一个类是否为元类</h3><p><code>bool class_isMetaClass(Class _Nullable cls)</code></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">BOOL</span> class_isMetaClass(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!cls) <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    <span class="keyword">return</span> cls-&gt;isMetaClass();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> isMetaClass() &#123;</span><br><span class="line">   assert(<span class="keyword">this</span>);</span><br><span class="line">   assert(isRealized());</span><br><span class="line">   <span class="keyword">return</span> data()-&gt;ro-&gt;flags &amp; RO_META;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的代码我们可以看出 判断是否为元类的条件是 <code>data()-&gt;ro-&gt;flags &amp; RO_META</code>。那么这个类的flags是什么时候设置的呢？</p>
<p>找了好久,我们在<code>objc_initializeClassPair_internal</code>方法中找到了下面这段代码</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">cls_ro_w-&gt;flags = <span class="number">0</span>;</span><br><span class="line">meta_ro_w-&gt;flags = RO_META;</span><br><span class="line"><span class="keyword">if</span> (!superclass) &#123;</span><br><span class="line">   cls_ro_w-&gt;flags |= RO_ROOT;</span><br><span class="line">   meta_ro_w-&gt;flags |= RO_ROOT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么这个方法什么时候被调用呢? 追踪了一下我们发现 是在<code>objc_initializeClassPair_internal</code>这个方法中被调用的！ 这个方法是不是很熟悉呢！ 他就是<code>objc_allocateClassPair</code>中的最后一句代码。</p>
<h2 id="MetaClass-存在的意义是什么呢？"><a href="#MetaClass-存在的意义是什么呢？" class="headerlink" title="MetaClass 存在的意义是什么呢？"></a>MetaClass 存在的意义是什么呢？</h2><p>实际上如果没有元类的存在,而是在class中增加一个classmethodlist用来存放这个类的类方法,也是可以达到我们想要实现的目的。</p>
<p>那么MetaClass存在的意义到底是什么呢？</p>
<p>为了更好的了解MetaClass存在的原因,我们先看一下他的作用:</p>
<p>先看一下下面这张图片:</p>
<p><img src="https://upload-images.jianshu.io/upload_images/967869-f15ff2bc1baf88d2.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt="metaclass"></p>
<h4 id="一切皆对象的思想"><a href="#一切皆对象的思想" class="headerlink" title="一切皆对象的思想"></a>一切皆对象的思想</h4><p>我们都知道对象里有一个isa指针</p>
<p><code>ISA指针 实际上就是 is a 的缩写。表示这个对象是一个什么</code></p>
<p>从上面的图上我们也可以看出最顶层的RootMetaClass的isa指向知己superClass指向RootClass,这就形成了一个闭环。</p>
<p>加入 我们将元类去掉,那么我们类的ISA指针应该指向什么呢？如果没办法指向一个RootMetaClass那表明这个类是一个什么类型的对象呢？</p>
<p>当然这个是根据结论反推原因,是不太合逻辑的,但是 更容易被我们理解。</p>
<h4 id="从Smalltalk重新认识面向对象"><a href="#从Smalltalk重新认识面向对象" class="headerlink" title="从Smalltalk重新认识面向对象"></a>从Smalltalk重新认识面向对象</h4><p>以前谈到面向对象，总会提到，面向对象三特征：封装、继承、多态。但其实，面向对象中也分流派，如C++这种来自Simula的设计思想的，更注重的是类的划分，因为方法调用是静态的。而如Objective-C这种借鉴Smalltalk的，更注重的是消息传递，是动态响应消息。</p>
<p>而面向对象三种特征，更基于的是类的划分而提出的。</p>
<p>这两种思想最大的不同，我认为是自上而下和自下而上的思考方式。</p>
<ul>
<li>类的划分，要求类的设计者是以一个很高的层次去设计这个类，提取出类的特性和本质，进行类的构建。<code>知道类型才可以去发送消息给对象</code>。</li>
<li>消息传递，要求的是类的设计者以消息为起点去构建类，也就是对外界的变化进行响应，而不关心自身的类型，设计接口。尝试理解消息，无法处理则进行特殊处理。</li>
</ul>
<p>消息传递对于面向对象的设计，其实在于给出一种对消息的解决方案。而面向对象优点之一的复用，在这种设计里，更多在于复用解决方案，而不是单纯的类本身。这种思想就如设计组件一般，关心接口，关心组合而非类本身。其实之所以有MetaClass这种设计，我的理解并不是先有MetaClass，而是在万物都是对象的Smalltalk里，向对象发送消息的基本解决方案是统一的，希望复用的。而实例和类之间用的这一套通过isa指针指向的Class单例中存储方法列表和查询方法的解决方案的流程，是应该在类上复用的，而MetaClass就顺理成章出现罢了。</p>
<p>上面这部分是摘自:<a href="https://www.jianshu.com/p/ea7c42e16da8">Why is MetaClass in Objective-C</a></p>
<h3 id="维基百科的解释"><a href="#维基百科的解释" class="headerlink" title="维基百科的解释"></a>维基百科的解释</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Metaclasses in Objective-C are almost the same as those in Smalltalk-80—not surprising since Objective-C borrows a lot from Smalltalk. Like Smalltalk, in Objective-C, the instance variables and methods are defined by an object&#39;s class. A class is an object, hence it is an instance of a metaclass.(OC中的Metaclasses 基本上和Smalltalk-80相同,鉴于OC从Smalltalk中借鉴了很多因此这并不令人干到奇怪。类似Smalltalk 在OC中实例的变量和方法被定义在对象的类中,class也是一个对象,于是class是mataclass的一个实例。)</span><br><span class="line"></span><br><span class="line">Like Smalltalk, in Objective-C, class methods are simply methods called on the class object, hence a class&#39;s class methods must be defined as instance methods in its metaclass. Because different classes can have different sets of class methods, each class must have its own separate metaclass. Classes and metaclasses are always created as a pair: the runtime has functions objc_allocateClassPair() and objc_registerClassPair() to create and register class-metaclass pairs, respectively.(类似Smalltalk,在OC中类方法通过类对象调用,于是一个类的类方法必须在metaclass中以实例方法的形式定义。因为不同的类可以后不同的类方法集合，每一个类必须有自己独立的metaClass。Class和class-metaClass一起被创建和注册)</span><br><span class="line"></span><br><span class="line">There are no names for the metaclasses; however, a pointer to any class object can be referred to with the generic type Class (similar to the type id being used for a pointer to any object). (metaClass没有名字,然而,指向任何类对象的指针可以用泛型类型引用)（类似id可以指向所有的对象）</span><br><span class="line"></span><br><span class="line">Because class methods are inherited through inheritance, like Smalltalk, metaclasses must follow an inheritance scheme paralleling that of classes (e.g. if class A&#39;s parent class is class B, then A&#39;s metaclass&#39;s parent class is B&#39;s metaclass), except that of the root class.(因为,类方法通过继承获取,类似Smalltalk,元类必须遵循与类类似的继承方案</span><br><span class="line"></span><br><span class="line">Unlike Smalltalk, the metaclass of the root class inherits from the root class (usually NSObject using the Cocoa framework) itself. This ensures that all class objects are ultimately instances of the root class, so that you can use the instance methods of the root class, usually useful utility methods for objects, on class objects themselves.(与Smalltalk不同,根类的metaclass继承自根类本身,这就确保了所有的类对象都是根类的对象。以便您可以使用根类的实例方法，通常是对象的有用实用工具方法，以及类对象本身。)</span><br><span class="line"></span><br><span class="line">Since metaclass objects do not behave differently (you cannot add class methods for a metaclass, so metaclass objects all have the same methods), they are all instances of the same class—the metaclass of the root class (unlike Smalltalk). Thus, the metaclass of the root class is an instance of itself. The reason for this is that all metaclasses inherit from root class; hence, they must inherit the class methods of the root class.</span><br><span class="line">(由于元类对象行为不同(你不能为元类添加类方法，所以元类对象都有相同的方法),它们都是同一类的实例 - 根类的元类（与Smalltalk不同）因此，根类的元类是它自己的一个实例。原因是所有元类都继承自根类;因此，他们必须继承根类的类方法。)</span><br></pre></td></tr></table></figure>

<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>回到一开始那个问题，为什么要设计MetaClass，去掉把类方法放到类里面行不行？</p>
<p>我的理解是，可以，但不Smalltalk。这样的设计是C++那种自上而下的设计方式，类方法也是类的一种特征描述。而Smalltalk的精髓正在于消息传递，复用消息传递才是根本目的，而MetaClass只不过是因此需要的一个工具罢了。</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://www.jianshu.com/p/ea7c42e16da8">Why is MetaClass in Objective-C</a><br><a href="https://blog.csdn.net/myan/article/details/5928531">function/bind的救赎（上）</a></p>
]]></content>
      <categories>
        <category>iOS优化</category>
      </categories>
      <tags>
        <tag>metaClass</tag>
      </tags>
  </entry>
  <entry>
    <title>SDWebImage - 缓存管理</title>
    <url>/2016/01/27/SDWebImage-4/</url>
    <content><![CDATA[<p>这篇文章主要是介绍了一下SDWebImage提供的一写关于缓存的其他功能，也提供了清除缓存的方法，这里粗略的介绍一下，希望对大家在以后的文件操作中有一定的帮助。</p>
<a id="more"></a>


<h4 id="磁盘空间的初始化方法"><a href="#磁盘空间的初始化方法" class="headerlink" title="磁盘空间的初始化方法"></a>磁盘空间的初始化方法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (id)initWithNamespace:(NSString *)ns &#123;</span><br><span class="line">    &#x2F;&#x2F; iOS使用的是沙盒机制，此处makeDiskCachePath就是获取Cache目录，并</span><br><span class="line">    	在Cache目录下创建default目录</span><br><span class="line">   &#x2F;&#x2F; 比如我的mac上就显示&#x2F;Users&#x2F;poloby&#x2F;Library&#x2F;Developer&#x2F;</span><br><span class="line">   CoreSimulator&#x2F;Devices&#x2F;4404872F-4DDD-4AEA-AAD3-71BA1931D4C1&#x2F;</span><br><span class="line">   data&#x2F;Containers&#x2F;Data&#x2F;Application&#x2F;9C7E5D14-FBF0-41F1-A533-</span><br><span class="line">   E8ACC59FCBAC&#x2F;Library&#x2F;Caches&#x2F;default</span><br><span class="line">   &#x2F;&#x2F; 后面详解</span><br><span class="line">    NSString *path &#x3D; [self makeDiskCachePath:ns];</span><br><span class="line">   &#x2F;&#x2F; 最终的初始化，后面详解</span><br><span class="line">return [self initWithNamespace:ns diskCacheDirectory:path];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>makeDiskCachePath</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-(NSString *)makeDiskCachePath:(NSString*)fullNamespace&#123;</span><br><span class="line">    &#x2F;&#x2F; 获取当前用户应用下的Caches目录</span><br><span class="line">    &#x2F;&#x2F; 返回了一个包含用户Caches目录作为第一元素的数组，所以底下用的是</span><br><span class="line">    	paths[0]</span><br><span class="line">    &#x2F;&#x2F; 即&#x2F;Users&#x2F;poloby&#x2F;Library&#x2F;Developer&#x2F;CoreSimulator&#x2F;Devices&#x2F;</span><br><span class="line">    4404872F-4DDD-4AEA-AAD3-71BA1931D4C1&#x2F;data&#x2F;Containers&#x2F;Data&#x2F;</span><br><span class="line">    Application&#x2F;9C7E5D14-FBF0-41F1-A533-E8ACC59FCBAC&#x2F;Library&#x2F;</span><br><span class="line">    Caches&#x2F;</span><br><span class="line">    </span><br><span class="line">    NSArray *paths &#x3D; </span><br><span class="line">    NSSearchPathForDirectoriesInDomains(NSCachesDirectory, </span><br><span class="line">    								NSUserDomainMask, YES);</span><br><span class="line">   &#x2F;&#x2F; 在Caches目录下构建一个fullNamespace目录，此处默认是default目录</span><br><span class="line">    return [paths[0] </span><br><span class="line">    		stringByAppendingPathComponent:fullNamespace];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>initWithNamespace:diskCacheDirectory:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(id)initWithNamespace:(NSString *)ns diskCacheDirectory:</span><br><span class="line">									(NSString *)directory &#123;</span><br><span class="line">									</span><br><span class="line">    if ((self &#x3D; [super init])) &#123;</span><br><span class="line">        &#x2F;&#x2F; 再给Caches&#x2F;default&#x2F;后面加上fullNamspace</span><br><span class="line">        &#x2F;&#x2F; 最终可能获得的diskCachePath可能为</span><br><span class="line">        NSString *fullNamespace &#x3D; </span><br><span class="line">        [@&quot;com.hackemist.SDWebImageCache.&quot;</span><br><span class="line">        							 stringByAppendingString:ns];</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 初始化kPNGSignatureData为PNG前8字节的标志：&#123;0x89, 0x50,</span><br><span class="line">        		 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A&#125;</span><br><span class="line">        &#x2F;&#x2F; 用于ImageDataHasPNGPreffix这个C函数中，判断该data是不是PNG</span><br><span class="line">        	格式</span><br><span class="line">        	</span><br><span class="line">        kPNGSignatureData &#x3D; [NSData </span><br><span class="line">        			dataWithBytes:kPNGSignatureBytes length:8];</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 创建名为com.hackemist.SDWebImageCache的IO的串行队列</span><br><span class="line">        </span><br><span class="line">        _ioQueue &#x3D;</span><br><span class="line">         dispatch_queue_create(&quot;com.hackemist.SDWebImageCache&quot;, </span><br><span class="line">         							DISPATCH_QUEUE_SERIAL);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; cache存储的最长时间为60 * 60 * 24 * 7，即一个星期</span><br><span class="line">        _maxCacheAge &#x3D; kDefaultCacheMaxCacheAge;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 注意此处不是直接使用[[NSCache alloc] init]进行初始化的，而</span><br><span class="line">        	是使用了一个AutoPurgeCache</span><br><span class="line">        &#x2F;&#x2F; AutoPurgeCache和NSCache不同之处在于，如果AutoPurgeCache收</span><br><span class="line">        	到一个内存警告，就会自动释放内存，调用NSCache的</span><br><span class="line">        	removeAllObjects</span><br><span class="line">        	</span><br><span class="line">        _memCache &#x3D; [[AutoPurgeCache alloc] init];</span><br><span class="line">        _memCache.name &#x3D; fullNamespace;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 初始化disk cache，一般情况下directory，除非你把Caches删除了</span><br><span class="line">        if (directory !&#x3D; nil) &#123;</span><br><span class="line">            &#x2F;&#x2F; 最终结果是&#x2F;Users&#x2F;poloby&#x2F;Library&#x2F;Developer&#x2F;</span><br><span class="line">            CoreSimulator&#x2F;Devices&#x2F;4404872F-4DDD-4AEA-</span><br><span class="line">            AAD3-71BA1931D4C1&#x2F;data&#x2F;Containers&#x2F;Data&#x2F;Application&#x2F;</span><br><span class="line">            9C7E5D14-FBF0-41F1-A533-E8ACC59FCBAC&#x2F;Library&#x2F;Caches&#x2F;</span><br><span class="line">            default&#x2F;com.hackemist.SDWebImageCache.default</span><br><span class="line">            </span><br><span class="line">            _diskCachePath &#x3D; [directory </span><br><span class="line">            	stringByAppendingPathComponent:fullNamespace];</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F; 如果没有找到Caches目录，或者新建default目录失败。就重新</span><br><span class="line">            	使用makeCachePath新建一个缓存目录</span><br><span class="line">            NSString *path &#x3D; [self makeDiskCachePath:ns];</span><br><span class="line">            _diskCachePath &#x3D; path;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 默认需要解压缩图片</span><br><span class="line">        _shouldDecompressImages &#x3D; YES;</span><br><span class="line">       &#x2F;&#x2F; 新建一个NSFileManager也是放在ioQueue中的</span><br><span class="line">        dispatch_sync(_ioQueue, ^&#123;</span><br><span class="line">            _fileManager &#x3D; [NSFileManager new];</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">	#if TARGET_OS_IPHONE</span><br><span class="line">        &#x2F;&#x2F; 订阅了app可能发生的时间</span><br><span class="line">        &#x2F;&#x2F; 出现内存警告</span><br><span class="line">        (UIApplicationDidReceiveMemoryWarningNotification)，调用</span><br><span class="line">        	clearMemory</span><br><span class="line">        	</span><br><span class="line">        [[NSNotificationCenter defaultCenter] addObserver:self</span><br><span class="line">                           selector:@selector(clearMemory)                                                   		name:UIApplicationDidReceiveMemoryWarningNotification                           </span><br><span class="line">                           object:nil];</span><br><span class="line">                           </span><br><span class="line">        &#x2F;&#x2F; 程序终止(UIApplicationWillTerminateNotification)，调用</span><br><span class="line">        	cleanDisk</span><br><span class="line">        	</span><br><span class="line">        [[NSNotificationCenter defaultCenter] addObserver:self</span><br><span class="line">								selector:@selector(cleanDisk)</span><br><span class="line">                name:UIApplicationWillTerminateNotification</span><br><span class="line">                               object:nil];</span><br><span class="line">        &#x2F;&#x2F; 程序进入后台运行</span><br><span class="line">        (UIApplicationDidEnterBackgroundNotification)，调用</span><br><span class="line">        backgroundCleanDisk</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; backgroundCleanDisk就不赘述了，其实现了在后台注册了</span><br><span class="line">        	cleanDiskWithCompletionBlock函数来处理后台的磁盘缓存</span><br><span class="line">        	</span><br><span class="line">        [[NSNotificationCenter defaultCenter] addObserver:self</span><br><span class="line">						selector:@selector(backgroundCleanDisk)</span><br><span class="line">				name:UIApplicationDidEnterBackgroundNotification</span><br><span class="line">                       object:nil];</span><br><span class="line">	#endif</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="计算缓存文件的大小"><a href="#计算缓存文件的大小" class="headerlink" title="计算缓存文件的大小"></a>计算缓存文件的大小</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)calculateSizeWithCompletionBlock:(SDWebImageCalculateSizeBlock)completionBlock &#123;</span><br><span class="line">    NSURL *diskCacheURL &#x3D; [NSURL fileURLWithPath:</span><br><span class="line">    									self.diskCachePath</span><br><span class="line">     									isDirectory:YES];</span><br><span class="line"></span><br><span class="line">    dispatch_async(self.ioQueue, ^&#123;</span><br><span class="line">        NSUInteger fileCount &#x3D; 0;</span><br><span class="line">        NSUInteger totalSize &#x3D; 0;</span><br><span class="line">        </span><br><span class="line">   NSDirectoryEnumerator *fileEnumerator &#x3D; </span><br><span class="line">        			[_fileManager enumeratorAtURL:diskCacheURL</span><br><span class="line">					includingPropertiesForKeys:@[NSFileSize]</span><br><span class="line">					options: </span><br><span class="line">					 NSDirectoryEnumerationSkipsHiddenFiles</span><br><span class="line">					 errorHandler:NULL];</span><br><span class="line"></span><br><span class="line">   for (NSURL *fileURL in fileEnumerator) &#123;</span><br><span class="line">       NSNumber *fileSize;</span><br><span class="line">       &#x2F;&#x2F;获取单个文件大小的方法</span><br><span class="line">       [fileURL getResourceValue:&amp;fileSize </span><br><span class="line">       						forKey:NSURLFileSizeKey error:NULL];</span><br><span class="line">       totalSize +&#x3D; [fileSize unsignedIntegerValue];</span><br><span class="line">       &#x2F;&#x2F;文件个数累加</span><br><span class="line">       fileCount +&#x3D; 1;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   if (completionBlock) &#123;</span><br><span class="line">       dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">          completionBlock(fileCount, totalSize);</span><br><span class="line">       &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="获取磁盘文件个数"><a href="#获取磁盘文件个数" class="headerlink" title="获取磁盘文件个数"></a>获取磁盘文件个数</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (NSUInteger)getDiskCount &#123;</span><br><span class="line">    __block NSUInteger count &#x3D; 0;</span><br><span class="line">    dispatch_sync(self.ioQueue, ^&#123;</span><br><span class="line">        NSDirectoryEnumerator *fileEnumerator &#x3D; [_fileManager enumeratorAtPath:self.diskCachePath];</span><br><span class="line">        count &#x3D; [[fileEnumerator allObjects] count];</span><br><span class="line">    &#125;);</span><br><span class="line">    return count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="SDWebImage定期清理缓存"><a href="#SDWebImage定期清理缓存" class="headerlink" title="SDWebImage定期清理缓存"></a>SDWebImage定期清理缓存</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)cleanDiskWithCompletionBlock:</span><br><span class="line">					(SDWebImageNoParamsBlock)completionBlock &#123;</span><br><span class="line">  dispatch_async(self.ioQueue, ^&#123;</span><br><span class="line">      &#x2F;&#x2F; 这两个变量主要是为了下面生成NSDirectoryEnumerator准备的</span><br><span class="line">      &#x2F;&#x2F; 一个是记录遍历的文件目录，一个是记录遍历需要预先获取文件的哪些属性</span><br><span class="line">      </span><br><span class="line">        NSURL *diskCacheURL &#x3D; [NSURL fileURLWithPath:</span><br><span class="line">        									self.diskCachePath</span><br><span class="line">        					 				isDirectory:YES];</span><br><span class="line">        					 				</span><br><span class="line">        NSArray *resourceKeys &#x3D; @[NSURLIsDirectoryKey, </span><br><span class="line">        						NSURLContentModificationDateKey,</span><br><span class="line">        						 NSURLTotalFileAllocatedSizeKey];</span><br><span class="line"></span><br><span class="line">		</span><br><span class="line">        &#x2F;&#x2F; 递归地遍历diskCachePath这个文件夹中的所有目录，此处不是直接使</span><br><span class="line">        	用diskCachePath，而是使用其生成的NSURL</span><br><span class="line">        &#x2F;&#x2F; 此处使用includingPropertiesForKeys:resourceKeys，这样每</span><br><span class="line">        	个file的resourceKeys对应的属性也会在遍历时预先获取到</span><br><span class="line">        NSDirectoryEnumerator *fileEnumerator &#x3D;</span><br><span class="line">        			 [_fileManager enumeratorAtURL:diskCacheURL</span><br><span class="line">        			    includingPropertiesForKeys:resourceKeys</span><br><span class="line">        		options:NSDirectoryEnumerationSkipsHiddenFiles</span><br><span class="line">				errorHandler:NULL];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 获取文件的过期时间，SDWebImage中默认是一个星期</span><br><span class="line">        &#x2F;&#x2F; 不过这里虽然称*expirationDate为过期时间，但是实质上并不是这</span><br><span class="line">        	样。</span><br><span class="line">        &#x2F;&#x2F; 其实是这样的，比如在2015&#x2F;12&#x2F;12&#x2F;00:00:00最后一次修改文件，对</span><br><span class="line">        	应的过期时间应该是</span><br><span class="line">        &#x2F;&#x2F; 2015&#x2F;12&#x2F;19&#x2F;00:00:00，不过现在时间是2015&#x2F;12&#x2F;27&#x2F;00:00:00，</span><br><span class="line">        	我先将当前时间减去1个星期，得到</span><br><span class="line">        &#x2F;&#x2F; 2015&#x2F;12&#x2F;20&#x2F;00:00:00，这个时间才是我们函数中的</span><br><span class="line">        	expirationDate。</span><br><span class="line">        &#x2F;&#x2F; 用这个expirationDate和最后一次修改时间modificationDate比较</span><br><span class="line">        	看谁更晚就行。</span><br><span class="line">        	</span><br><span class="line">        NSDate *expirationDate &#x3D; [NSDate</span><br><span class="line">        		dateWithTimeIntervalSinceNow:-self.maxCacheAge];</span><br><span class="line">        </span><br><span class="line">        NSMutableDictionary *cacheFiles &#x3D; </span><br><span class="line">        						[NSMutableDictionary dictionary];</span><br><span class="line">        						</span><br><span class="line">        NSUInteger currentCacheSize &#x3D; 0;</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F; 在缓存的目录开始遍历文件.  此次遍历有两个目的:</span><br><span class="line">        &#x2F;&#x2F;</span><br><span class="line">        &#x2F;&#x2F;  1. 移除过期的文件</span><br><span class="line">        &#x2F;&#x2F;  2. 同时存储每个文件的属性（比如该file是否是文件夹、该file所</span><br><span class="line">        		需磁盘大小，修改时间）</span><br><span class="line">        </span><br><span class="line">        NSMutableArray *urlsToDelete &#x3D;</span><br><span class="line">        						 [[NSMutableArray alloc] init];</span><br><span class="line">        						 </span><br><span class="line">        for (NSURL *fileURL in fileEnumerator) &#123;</span><br><span class="line">            NSDictionary *resourceValues &#x3D; </span><br><span class="line">            	[fileURL resourceValuesForKeys:resourceKeys </span><br><span class="line">            							  error:NULL];</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; Skip directories.</span><br><span class="line">            if ([resourceValues[NSURLIsDirectoryKey] boolValue]) </span><br><span class="line">            &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 移除过期文件</span><br><span class="line">            &#x2F;&#x2F; 这里判断过期的方式：对比文件的最后一次修改日期和</span><br><span class="line">            	expirationDate谁更晚，如果expirationDate更晚，就认为</span><br><span class="line">            	该文件已经过期，具体解释见上面</span><br><span class="line">            NSDate *modificationDate &#x3D; </span><br><span class="line">            	resourceValues[NSURLContentModificationDateKey];</span><br><span class="line">            	</span><br><span class="line">            if ([[modificationDate laterDate:expirationDate]</span><br><span class="line">            				 isEqualToDate:expirationDate]) &#123;</span><br><span class="line">                [urlsToDelete addObject:fileURL];</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          	&#x2F;&#x2F; 计算当前已经使用的cache大小，</span><br><span class="line">            &#x2F;&#x2F; 并将对应file的属性存到cacheFiles中</span><br><span class="line">            NSNumber *totalAllocatedSize &#x3D;</span><br><span class="line">            	 resourceValues[NSURLTotalFileAllocatedSizeKey];</span><br><span class="line">            </span><br><span class="line">            currentCacheSize +&#x3D; [totalAllocatedSize</span><br><span class="line">             							unsignedIntegerValue];</span><br><span class="line">            [cacheFiles setObject:resourceValues </span><br><span class="line">            									forKey:fileURL];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        for (NSURL *fileURL in urlsToDelete) &#123;</span><br><span class="line">            [_fileManager removeItemAtURL:fileURL error:nil];</span><br><span class="line">        &#125;</span><br><span class="line">	    &#x2F;&#x2F; 如果我们当前cache的大小已经超过了允许配置的缓存大小，</span><br><span class="line">	    	那就删除已经缓存的文件。</span><br><span class="line">        &#x2F;&#x2F; 删除策略就是，首先删除修改时间更早的缓存文件</span><br><span class="line">         </span><br><span class="line">        if (self.maxCacheSize &gt; 0 </span><br><span class="line">        	&amp;&amp; currentCacheSize &gt; self.maxCacheSize)</span><br><span class="line">        &#123;</span><br><span class="line">            &#x2F;&#x2F; 直接将当前cache大小降到允许最大的cache大小的一般</span><br><span class="line">            const NSUInteger desiredCacheSize &#x3D; </span><br><span class="line">            							self.maxCacheSize &#x2F; 2;</span><br><span class="line"></span><br><span class="line">			&#x2F;&#x2F; 根据文件修改时间来给所有缓存文件排序，按照修改时间越早越在</span><br><span class="line">				前的规则排序            		</span><br><span class="line">            NSArray *sortedFiles &#x3D; [cacheFiles </span><br><span class="line">            	keysSortedByValueWithOptions:NSSortConcurrent</span><br><span class="line">				usingComparator:^NSComparisonResult(id obj1, id </span><br><span class="line">				obj2) &#123;</span><br><span class="line">				 return [obj1[NSURLContentModificationDateKey]</span><br><span class="line">				  		compare:</span><br><span class="line">				 		obj2[NSURLContentModificationDateKey]];</span><br><span class="line">             &#125;];</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 每次删除file后，就计算此时的cache的大小</span><br><span class="line">            &#x2F;&#x2F; 如果此时的cache大小已经降到期望的大小了，就停止删除文件了</span><br><span class="line">            for (NSURL *fileURL in sortedFiles) &#123;</span><br><span class="line">                if ([_fileManager </span><br><span class="line">               		 removeItemAtURL:</span><br><span class="line">                	fileURL error:nil])</span><br><span class="line">                &#123;</span><br><span class="line">                    NSDictionary *resourceValues &#x3D; </span><br><span class="line">                    						cacheFiles[fileURL];</span><br><span class="line">                    &#x2F;&#x2F; 根据resourceValues获取该文件所需磁盘空间大小</span><br><span class="line">                    NSNumber *totalAllocatedSize &#x3D; </span><br><span class="line">                resourceValues[NSURLTotalFileAllocatedSizeKey];</span><br><span class="line">                	&#x2F;&#x2F; 计算当前cache大小</span><br><span class="line">                    currentCacheSize -&#x3D; [totalAllocatedSize </span><br><span class="line">                    					  unsignedIntegerValue];</span><br><span class="line"></span><br><span class="line">                    if (currentCacheSize &lt; desiredCacheSize) &#123;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (completionBlock) &#123;</span><br><span class="line">            dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                completionBlock();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>总结一下：</p>
<p>清理缓存的时机：</p>
<p>清除磁盘缓存<br>UIApplicationWillTerminateNotification<br>UIApplicationDidEnterBackgroundNotification</p>
<p>清除Cache缓存</p>
<p>UIApplicationDidReceiveMemoryWarningNotification<br>当收到这三个通知的时候回到用对应的清理缓存的方法</p>
<p>清理过程：</p>
<p>1、按照用户设置的maxCacheAge图片被缓存的最长时间</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * The maximum length of time to keep an image in the cache, in seconds</span><br><span class="line"> *&#x2F;</span><br><span class="line">@property (assign, nonatomic) NSInteger maxCacheAge;</span><br></pre></td></tr></table></figure>
<p>将所有modificationDate时间晚于maxCacheAge时间的文件删除</p>
<p>2、如果经过第一步的删除之后，图片的缓存仍然大于maxCacheSize,那么需要进一步的删除图片文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * The maximum size of the cache, in bytes.</span><br><span class="line"> *&#x2F;</span><br><span class="line">@property (assign, nonatomic) NSUInteger maxCacheSize;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这一步的删除，最终的目的是将最终的缓存大小降低到maxCacheSize的一半，方式也是根据最后的修改时间先将所有的文件排序，然后依次删除，每一次删除都要确认是否当前的缓存大小是否小鱼maxCacheSize的一半</p>
<p>3、清理Cache缓存</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)clearMemory &#123;</span><br><span class="line">    [self.memCache removeAllObjects];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="手动清理磁盘图片缓存"><a href="#手动清理磁盘图片缓存" class="headerlink" title="手动清理磁盘图片缓存"></a>手动清理磁盘图片缓存</h4><p>直接清除，磁盘缓存目录下的所有文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)clearDiskOnCompletion:</span><br><span class="line">					 (SDWebImageNoParamsBlock)completion</span><br><span class="line">&#123;</span><br><span class="line">    dispatch_async(self.ioQueue, ^&#123;</span><br><span class="line">    	 &#x2F;&#x2F; 先将存储在diskCachePath中缓存全部移除，然后新建一个空的</span><br><span class="line">    	 	diskCachePath</span><br><span class="line">        [_fileManager removeItemAtPath:self.diskCachePath </span><br><span class="line">        					      error:nil];</span><br><span class="line">        					      </span><br><span class="line">        [_fileManager createDirectoryAtPath:self.diskCachePath</span><br><span class="line">                withIntermediateDirectories:YES</span><br><span class="line">                                 attributes:nil</span><br><span class="line">                                      error:NULL];</span><br><span class="line"></span><br><span class="line">        if (completion) &#123;</span><br><span class="line">            dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                completion();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="通过cacheKey获取某张图片"><a href="#通过cacheKey获取某张图片" class="headerlink" title="通过cacheKey获取某张图片"></a>通过cacheKey获取某张图片</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (UIImage *)imageFromDiskCacheForKey:(NSString *)key &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; First check the in-memory cache...</span><br><span class="line">    UIImage *image &#x3D; [self imageFromMemoryCacheForKey:key];</span><br><span class="line">    if (image) &#123;</span><br><span class="line">        return image;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Second check the disk cache...</span><br><span class="line">    UIImage *diskImage &#x3D; [self diskImageForKey:key];</span><br><span class="line">    if (diskImage &amp;&amp; self.shouldCacheImagesInMemory) &#123;</span><br><span class="line">        NSUInteger cost &#x3D; SDCacheCostForImage(diskImage);</span><br><span class="line">        [self.memCache setObject:diskImage forKey:key cost:cost];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return diskImage;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>注意：</code>这里在磁盘中找到这张图片之后，会将这张图片放到缓存中 用来表示他最近使用了</p>
<h4 id="通过搜索全路径获取图片数据-NSData"><a href="#通过搜索全路径获取图片数据-NSData" class="headerlink" title="通过搜索全路径获取图片数据(NSData)"></a>通过搜索全路径获取图片数据(NSData)</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (NSData *)diskImageDataBySearchingAllPathsForKey:(NSString *)key &#123;</span><br><span class="line">    NSString *defaultPath &#x3D; [self defaultCachePathForKey:key];</span><br><span class="line">    NSData *data &#x3D; [NSData dataWithContentsOfFile:defaultPath];</span><br><span class="line">    if (data) &#123;</span><br><span class="line">        return data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; fallback because of https:&#x2F;&#x2F;github.com&#x2F;rs&#x2F;SDWebImage&#x2F;</span><br><span class="line">    	pull&#x2F;976 that added the extension to the disk file name</span><br><span class="line">    &#x2F;&#x2F; checking the key with and without the extension</span><br><span class="line">    </span><br><span class="line">    data &#x3D; [NSData dataWithContentsOfFile:</span><br><span class="line">    			[defaultPath stringByDeletingPathExtension]];</span><br><span class="line">    			</span><br><span class="line">    if (data) &#123;</span><br><span class="line">        return data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    NSArray *customPaths &#x3D; [self.customPaths copy];</span><br><span class="line">    for (NSString *path in customPaths) &#123;</span><br><span class="line">        NSString *filePath &#x3D; [self cachePathForKey:key</span><br><span class="line">        									 inPath:path];</span><br><span class="line">        NSData *imageData &#x3D; [NSData </span><br><span class="line">        						dataWithContentsOfFile:filePath];</span><br><span class="line">        						</span><br><span class="line">        if (imageData) &#123;</span><br><span class="line">            return imageData;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; fallback because of https:&#x2F;&#x2F;github.com&#x2F;rs&#x2F;SDWebImage&#x2F;</span><br><span class="line">        pull&#x2F;976 that added the extension to the disk file name</span><br><span class="line">        &#x2F;&#x2F; checking the key with and without the extension</span><br><span class="line">        </span><br><span class="line">        imageData &#x3D; [NSData dataWithContentsOfFile:</span><br><span class="line">        			[filePath stringByDeletingPathExtension]];</span><br><span class="line">        			</span><br><span class="line">        if (imageData) &#123;</span><br><span class="line">            return imageData;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return nil;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>customPaths:是在搜索完缓存以及磁盘都没有找到的时候，查找一个只读的空间，判断图片是否存在</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Add a read-only cache path to search for images pre-cached by SDImageCache</span><br><span class="line"> * Useful if you want to bundle pre-loaded images with your app</span><br><span class="line"> *</span><br><span class="line"> * @param path The path to use for this read-only cache path</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (void)addReadOnlyCachePath:(NSString *)path;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>当用户调用这个方法设置只读的路径时，会向customPaths中添加路径</p>
<h4 id="获取一张磁盘中缓存的图片（UIImage）"><a href="#获取一张磁盘中缓存的图片（UIImage）" class="headerlink" title="获取一张磁盘中缓存的图片（UIImage）"></a>获取一张磁盘中缓存的图片（UIImage）</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (UIImage *)diskImageForKey:(NSString *)key &#123;</span><br><span class="line">    NSData *data &#x3D; [self </span><br><span class="line">    			diskImageDataBySearchingAllPathsForKey:key];</span><br><span class="line">    if (data) &#123;</span><br><span class="line">        UIImage *image &#x3D; [UIImage sd_imageWithData:data];</span><br><span class="line">        image &#x3D; [self scaledImageForKey:key image:image];</span><br><span class="line">        if (self.shouldDecompressImages) &#123;</span><br><span class="line">            image &#x3D; [UIImage decodedImageWithImage:image];</span><br><span class="line">        &#125;</span><br><span class="line">        return image;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>从磁盘中取出图片要经历的几个过程：</p>
<p>1、取出NSData</p>
<p>2、将NSData转换为UIImage</p>
<p>3、做scale适配</p>
<p>4、图片是否需要解码，如果需要执行解码操作</p>
<p>5、返回这张图片</p>
]]></content>
      <categories>
        <category>源码分析</category>
      </categories>
      <tags>
        <tag>SDWebImage</tag>
        <tag>缓存</tag>
        <tag>磁盘管理</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS内存管理之AutoreleasePool</title>
    <url>/2018/03/20/iOS%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B9%8BAutoreleasePool/</url>
    <content><![CDATA[<p>每个线程（包括主线程），都维护了一个管理 NSAutoreleasePool 的栈。当创先新的 Pool 时，他们会被添加到栈顶。当 Pool 被销毁时，他们会被从栈中移除。<br>autorelease 的对象会被添加到当前线程的栈顶的 Pool 中。当 Pool 被销毁，其中的对象也会被释放。当线程结束时，所有的 Pool 被销毁释放。</p>
<a id="more"></a>

<h2 id="AutoreleasePool"><a href="#AutoreleasePool" class="headerlink" title="AutoreleasePool"></a>AutoreleasePool</h2><p>autorelease 本质上就是延迟调用 release ，那 autoreleased 对象究竟会在什么时候释放呢？为了弄清楚这个问题，我们先来做一个小实验。</p>
<h4 id="先看代码："><a href="#先看代码：" class="headerlink" title="先看代码："></a>先看代码：</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">__<span class="keyword">weak</span> <span class="built_in">NSString</span> *string_weak_ = <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 场景 1</span></span><br><span class="line">    <span class="built_in">NSString</span> *string = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;leichunfeng&quot;</span>];</span><br><span class="line">    string_weak_ = string;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 场景 2</span></span><br><span class="line"><span class="comment">//    @autoreleasepool &#123;</span></span><br><span class="line"><span class="comment">//        NSString *string = [NSString stringWithFormat:@&quot;leichunfeng&quot;];</span></span><br><span class="line"><span class="comment">//        string_weak_ = string;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 场景 3</span></span><br><span class="line"><span class="comment">//    NSString *string = nil;</span></span><br><span class="line"><span class="comment">//    @autoreleasepool &#123;</span></span><br><span class="line"><span class="comment">//        string = [NSString stringWithFormat:@&quot;leichunfeng&quot;];</span></span><br><span class="line"><span class="comment">//        string_weak_ = string;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;string: %@&quot;</span>, string_weak_);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewWillAppear:(<span class="built_in">BOOL</span>)animated &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewWillAppear:animated];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;string: %@&quot;</span>, string_weak_);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidAppear:(<span class="built_in">BOOL</span>)animated &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidAppear:animated];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;string: %@&quot;</span>, string_weak_);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>思考一下 输出结果</p>
<p>———————————–这是分割线———————————</p>
<h5 id="答案："><a href="#答案：" class="headerlink" title="答案："></a>答案：</h5><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 场景 1</span></span><br><span class="line"><span class="number">2015</span><span class="number">-05</span><span class="number">-30</span> <span class="number">10</span>:<span class="number">32</span>:<span class="number">20.837</span> AutoreleasePool[<span class="number">33876</span>:<span class="number">1448343</span>] string: leichunfeng</span><br><span class="line"><span class="number">2015</span><span class="number">-05</span><span class="number">-30</span> <span class="number">10</span>:<span class="number">32</span>:<span class="number">20.838</span> AutoreleasePool[<span class="number">33876</span>:<span class="number">1448343</span>] string: leichunfeng</span><br><span class="line"><span class="number">2015</span><span class="number">-05</span><span class="number">-30</span> <span class="number">10</span>:<span class="number">32</span>:<span class="number">20.845</span> AutoreleasePool[<span class="number">33876</span>:<span class="number">1448343</span>] string: (null)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 场景 2</span></span><br><span class="line"><span class="number">2015</span><span class="number">-05</span><span class="number">-30</span> <span class="number">10</span>:<span class="number">32</span>:<span class="number">50.548</span> AutoreleasePool[<span class="number">33915</span>:<span class="number">1448912</span>] string: (null)</span><br><span class="line"><span class="number">2015</span><span class="number">-05</span><span class="number">-30</span> <span class="number">10</span>:<span class="number">32</span>:<span class="number">50.549</span> AutoreleasePool[<span class="number">33915</span>:<span class="number">1448912</span>] string: (null)</span><br><span class="line"><span class="number">2015</span><span class="number">-05</span><span class="number">-30</span> <span class="number">10</span>:<span class="number">32</span>:<span class="number">50.555</span> AutoreleasePool[<span class="number">33915</span>:<span class="number">1448912</span>] string: (null)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 场景 3</span></span><br><span class="line"><span class="number">2015</span><span class="number">-05</span><span class="number">-30</span> <span class="number">10</span>:<span class="number">33</span>:<span class="number">07.075</span> AutoreleasePool[<span class="number">33984</span>:<span class="number">1449418</span>] string: leichunfeng</span><br><span class="line"><span class="number">2015</span><span class="number">-05</span><span class="number">-30</span> <span class="number">10</span>:<span class="number">33</span>:<span class="number">07.075</span> AutoreleasePool[<span class="number">33984</span>:<span class="number">1449418</span>] string: (null)</span><br><span class="line"><span class="number">2015</span><span class="number">-05</span><span class="number">-30</span> <span class="number">10</span>:<span class="number">33</span>:<span class="number">07.094</span> AutoreleasePool[<span class="number">33984</span>:<span class="number">1449418</span>] string: (null)</span><br></pre></td></tr></table></figure>


<h5 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h5><p>3 种场景下，我们都通过 <code>[NSString stringWithFormat:@&quot;leichunfeng&quot;]</code> 创建了一个 <code>autoreleased</code> 对象，这是我们实验的前提。并且，为了能够在 <code>viewWillAppear</code> 和 <code>viewDidAppear</code> 中继续访问这个对象，我们使用了一个全局的 <code>__weak </code>变量 <code>string_weak_</code> 来指向它。因为 <code>__weak</code> 变量有一个特性就是它不会影响所指向对象的生命周期，这里我们正是利用了这个特性。</p>
<h6 id="场景-1："><a href="#场景-1：" class="headerlink" title="场景 1："></a>场景 1：</h6><p>当使用 <code>[NSString stringWithFormat:@&quot;leichunfeng&quot;]</code> 创建一个对象时，这个对象的引用计数为 1 ，并且这个对象被系统自动添加到了当前的 autoreleasepool 中。当使用局部变量 string 指向这个对象时，这个对象的引用计数 +1 ，变成了 <code>2 </code>(这里后面会在看一下)。因为在 ARC 下 <code>NSString *string</code> 本质上就是 <code>__strong NSString *string</code> 。所以在 <code>viewDidLoad</code> 方法返回前，这个对象是一直存在的，且引用计数为 2 。而当 <code>viewDidLoad</code> 方法返回时，局部变量 string 被回收，指向了 nil 。因此，其所指向对象的引用计数 -1 ，变成了 1 。</p>
<p>而在 <code>viewWillAppear</code> 方法中，我们仍然可以打印出这个对象的值，说明这个对象并没有被释放。咦，这不科学吧？不是一直都说当函数返回的时候，函数内部产生的对象就会被释放的吗？前面我们提到了，这个对象是一个 <code>autoreleased</code> 对象，<code>autoreleased</code> 对象是被添加到了当前最近的 <code>autoreleasepool </code>中的，只有当这个 <code>autoreleasepool</code> 自身 <code>drain</code> 的时候，<code>autoreleasepool </code>中的 <code>autoreleased</code> 对象才会被 <code>release </code></p>
<p>另外，我们注意到当在<code>viewDidAppear</code> 中再打印这个对象的时候，对象的值变成了 nil ，说明此时对象已经被释放了。因此，我们可以大胆地猜测一下，这个对象一定是在 viewWillAppear 和 viewDidAppear 方法之间的某个时候被释放了，并且是由于它所在的 autoreleasepool 被 drain 的时候释放的。</p>
<p>####### 下面我们要证明这个问题</p>
<p>在开始前，我先简单地说明一下原理，我们可以通过使用 <code>lldb</code> 的 <code>watchpoint</code> 命令来设置观察点，观察全局变量 <code>string_weak_</code> 的值的变化，<code>string_weak_ </code>变量保存的就是我们创建的 <code>autoreleased</code> 对象的地址。在这里，我们再次利用了 <code>__weak</code> 变量的另外一个特性，就是当它所指向的对象被释放时，<code>__weak</code> 变量的值会被置为 nil 。了解了基本原理后，我们开始验证上面的猜测。</p>
<p>我们先在第 35 行打一个断点，当程序运行到这个断点时，我们通过 lldb 命令<code> watchpoint set v string_weak_</code> 设置观察点，观察 <code>string_weak_</code> 变量的值的变化。如下图所示，我们将在 console 中看到类似的输出，说明我们已经成功地设置了一个观察点：<br><img src="http://blog.leichunfeng.com/images/watchpoint1.jpg" alt="设置一个观察点"></p>
<p>点击继续执行</p>
<p><img src="http://blog.leichunfeng.com/images/watchpoint2.jpg" alt="继续执行"></p>
<p>我们先看 console 中的输出，注意到 string_weak_ 变量的值由 <code>0x00007f9b886567d0</code> 变成了 <code>0x0000000000000000</code> ，也就是 nil.</p>
<p>说明此时它所指向的对象被释放了。另外，我们也可以注意到一个细节，那就是 console 中打印了两次对象的值，说明此时 <code>viewWillAppear</code> 也已经被调用了，而 <code>viewDidAppear</code> 还没有被调用。</p>
<p>接着，我们来看看左侧的线程堆栈。我们看到了一个非常敏感的方法调用 <code>-[NSAutoreleasePool release] </code>，这个方法最终通过调用 <code>AutoreleasePoolPage::pop(void *)</code> 函数来负责对 autoreleasepool 中的 autoreleased 对象执行 release 操作。</p>
<p>结合前面的分析，我们知道在 viewDidLoad 中创建的 autoreleased 对象在方法返回后引用计数为 1 ，所以经过这里的 release 操作后，这个对象的引用计数 -1 ，变成了 0 ，该 autoreleased 对象最终被释放，猜测得证。</p>
<p>另外，我们在代码中并没有手动添加 autoreleasepool ，那这个 autoreleasepool 究竟是哪里来的呢？看完后面的章节你就明白了。</p>
<h6 id="场景-2："><a href="#场景-2：" class="headerlink" title="场景 2："></a>场景 2：</h6><p>当通过 <code>[NSString stringWithFormat:@&quot;leichunfeng&quot;] </code>创建一个对象时，这个对象的引用计数为 1 。而当使用局部变量 string 指向这个对象时，这个对象的引用计数 +1 ，变成了 2 。而出了当前作用域时，局部变量 string 变成了 nil ，所以其所指向对象的引用计数变成 1 。</p>
<p>另外，我们知道当出了 <code>@autoreleasepool &#123;&#125; </code>的作用域时，当前 autoreleasepool 被 <code>drain</code> ，其中的 autoreleased 对象被 release 。所以这个对象的引用计数变成了 0 ，对象最终被释放。</p>
<h6 id="场景-3："><a href="#场景-3：" class="headerlink" title="场景 3："></a>场景 3：</h6><p>当出了 <code>@autoreleasepool &#123;&#125;</code> 的作用域时，其中的 autoreleased 对象被 release ，对象的引用计数变成 1 。当出了局部变量 string 的作用域，即 viewDidLoad 方法返回时，string 指向了 nil ，其所指向对象的引用计数变成 0 ，对象最终被释放。</p>
<p>理解在这 3 种场景下，autoreleased 对象什么时候释放对我们理解 Objective-C 的内存管理机制非常有帮助。其中，场景 1 出现得最多，就是不需要我们手动添加 <code>@autoreleasepool &#123;&#125;</code> 的情况，直接使用系统维护的 autoreleasepool ；场景 2 就是需要我们手动添加 <code>@autoreleasepool &#123;&#125; </code>的情况，手动干预 autoreleased 对象的释放时机；场景 3 是为了区别场景 2 而引入的，在这种场景下并不能达到出了 <code>@autoreleasepool &#123;&#125;</code> 的作用域时 autoreleased 对象被释放的目的。</p>
<h2 id="AutoreleasePoolPage"><a href="#AutoreleasePoolPage" class="headerlink" title="AutoreleasePoolPage"></a>AutoreleasePoolPage</h2><p>细心的读者应该已经有所察觉，我们在上面已经提到了 <code>-[NSAutoreleasePool release]</code> 方法最终是通过调用 <code>AutoreleasePoolPage::pop(void *)</code> 函数来负责对 autoreleasepool 中的 autoreleased 对象执行 release 操作的</p>
<p>那这里的 AutoreleasePoolPage 是什么东西呢？其实，autoreleasepool 是没有单独的内存结构的，它是通过以 <code>AutoreleasePoolPage </code>为结点的<code>双向链表</code>来实现的(分别对应结构中的parent指针和child指针)。我们打开 runtime 的源码工程，在 NSObject.mm 文件的第 438-932 行可以找到 autoreleasepool 的实现源码。通过阅读源码，我们可以知道</p>
<ul>
<li>1、每一个线程的 autoreleasepool 其实就是一个指针的堆栈；</li>
<li>2、每一个指针代表一个需要 release 的对象或者 POOL_SENTINEL（哨兵对象，代表一个 autoreleasepool 的边界）</li>
<li>3、一个 pool token 就是这个 pool 所对应的 <code>POOL_SENTINEL</code> 的内存地址。当这个 pool 被 pop 的时候，所有内存地址在 <code>pool token</code> 之后的对象都会被 release </li>
<li>4、这个堆栈被划分成了一个以 page 为结点的双向链表。pages 会在必要的时候动态地增加或删除</li>
<li>5、<code>Thread-local storage</code>（线程局部存储）指向 <code>hot page</code> ，即最新添加的 autoreleased 对象所在的那个 page</li>
<li>6、AutoreleasePool是按线程一一对应的（结构中的thread指针指向当前线程</li>
<li>7、AutoreleasePoolPage每个对象会开辟<code>4096</code>字节内存（也就是虚拟内存一页的大小），除了上面的实例变量所占空间，剩下的空间全部用来储存autorelease对象的地</li>
<li>8、上面的id *next指针作为游标指向栈顶最新add进来的autorelease对象的下一个位置</li>
</ul>
<p>一个空的 AutoreleasePoolPage 的内存结构如下图所示：</p>
<p><img src="http://blog.leichunfeng.com/images/AutoreleasePoolPage.png" alt="AutoreleasePoolPage内存结构"></p>
<p>字段释义：</p>
<blockquote>
<p><code>magic</code> 用来校验 AutoreleasePoolPage 的结构是否完整；<br><code>next</code> 指向最新添加的 autoreleased 对象的下一个位置，初始化时指向 begin()<br><code>thread</code> 指向当前线程<br><code>parent</code> 指向父结点，第一个结点的 parent 值为 nil<br><code>child</code> 指向子结点，最后一个结点的 child 值为 nil<br><code>depth</code> 代表深度，从 0 开始，往后递增 1<br><code>hiwat</code> 代表 high water mark 。</p>
</blockquote>
<p><code>注意</code>:当 <code>next == begin()</code> 时，表示 AutoreleasePoolPage 为<code>空</code>；当 <code>next == end() </code>时，表示 AutoreleasePoolPage <code>已满</code></p>
<h3 id="Autorelease-Pool-Blocks"><a href="#Autorelease-Pool-Blocks" class="headerlink" title="Autorelease Pool Blocks"></a>Autorelease Pool Blocks</h3><p>我们使用 <code>clang -rewrite-objc</code> 命令将下面的 Objective-C 代码重写成 C++ 代码：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将会得到以下输出结果（只保留了相关代码）：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> __declspec(dllimport) <span class="keyword">void</span> * objc_autoreleasePoolPush(<span class="keyword">void</span>);</span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> __declspec(dllimport) <span class="keyword">void</span> objc_autoreleasePoolPop(<span class="keyword">void</span> *);</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> __AtAutoreleasePool &#123;</span><br><span class="line">  __AtAutoreleasePool() &#123;atautoreleasepoolobj = objc_autoreleasePoolPush();&#125;</span><br><span class="line">  ~__AtAutoreleasePool() &#123;objc_autoreleasePoolPop(atautoreleasepoolobj);&#125;</span><br><span class="line">  <span class="keyword">void</span> * atautoreleasepoolobj;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* @autoreleasepool */</span> &#123; __AtAutoreleasePool __autoreleasepool;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不得不说，苹果对 <code>@autoreleasepool &#123;&#125;</code> 的实现真的是非常巧妙，真正可以称得上是代码的艺术。苹果通过声明一个 <code>__AtAutoreleasePool</code> 类型的局部变量 <code>__autoreleasepool</code> 来实现 <code>@autoreleasepool &#123;&#125;</code> 。当声明 <code>__autoreleasepool</code> 变量时，构造函数 <code>__AtAutoreleasePool()</code> 被调用，即执行 <code>atautoreleasepoolobj = objc_autoreleasePoolPush();</code> ；当出了当前作用域时，析构函数 <code>~__AtAutoreleasePool() </code>被调用，即执行 <code>objc_autoreleasePoolPop(atautoreleasepoolobj);</code> 。也就是说 <code>@autoreleasepool &#123;&#125; </code>的实现代码可以进一步简化如下</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* @autoreleasepool */</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> *atautoreleasepoolobj = objc_autoreleasePoolPush();</span><br><span class="line">    <span class="comment">// 用户代码，所有接收到 autorelease 消息的对象会被添加到这个 autoreleasepool 中</span></span><br><span class="line">    objc_autoreleasePoolPop(atautoreleasepoolobj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="push-操作"><a href="#push-操作" class="headerlink" title="push 操作"></a>push 操作</h3><p>上面提到的 <code>objc_autoreleasePoolPush()</code> 函数本质上就是调用的 AutoreleasePoolPage 的 push 函数</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> *</span><br><span class="line">objc_autoreleasePoolPush(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (UseGC) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">return</span> AutoreleasePoolPage::push();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此，我们接下来看看 AutoreleasePoolPage 的 push 函数的作用和执行过程。一个 push 操作其实就是<code>创建</code>一个新的 autoreleasepool ，对应 AutoreleasePoolPage 的具体实现就是往 AutoreleasePoolPage 中的 <code>next</code> 位置插入一个 <code>POOL_SENTINEL</code> ，并且返回插入的 <code>POOL_SENTINEL</code> 的内存地址。这个地址也就是我们前面提到的 <code>pool token</code> ，在执行 pop 操作的时候作为函数的入参</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> *push()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">id</span> *dest = autoreleaseFast(POOL_SENTINEL);</span><br><span class="line">    assert(*dest == POOL_SENTINEL);</span><br><span class="line">    <span class="keyword">return</span> dest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>push 函数通过调用 <code>autoreleaseFast</code> 函数来执行具体的插入操作。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">id</span> *autoreleaseFast(<span class="keyword">id</span> obj)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//创建的时候插入一个POOL_SENTINEL表示一个新的自动pool的创建</span></span><br><span class="line">    AutoreleasePoolPage *page = hotPage();</span><br><span class="line">    <span class="comment">//下面是将新建的这个pool插入page中</span></span><br><span class="line">    <span class="keyword">if</span> (page &amp;&amp; !page-&gt;full()) &#123;</span><br><span class="line">        <span class="keyword">return</span> page-&gt;add(obj);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (page) &#123;</span><br><span class="line">        <span class="keyword">return</span> autoreleaseFullPage(obj, page);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> autoreleaseNoPage(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>autoreleaseFast 函数在执行一个具体的插入操作时，分别对三种情况进行了不同的处理：</p>
<ul>
<li>1、当前 page 存在且没有满时，直接将对象添加到当前 page 中，即 next 指向的位置；</li>
<li>2、当前 page 存在且已满时，创建一个新的 page ，并将对象添加到新创建的 page 中；</li>
<li>3、当前 page 不存在时，即还没有 page 时，创建第一个 page ，并将对象添加到新创建的 page 中。</li>
</ul>
<p>每调用一次 push 操作就会创建一个新的 autoreleasepool ，即往 <code>AutoreleasePoolPage </code>中插入一个 <code>POOL_SENTINEL</code> ，并且返回插入的 <code>POOL_SENTINEL</code> 的内存地址。</p>
<h3 id="autorelease-操作"><a href="#autorelease-操作" class="headerlink" title="autorelease 操作"></a>autorelease 操作</h3><p>通过 <code>NSObject.mm</code> 源文件，我们可以找到 <code>-autorelease</code> 方法的实现：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)autorelease &#123;</span><br><span class="line">    <span class="keyword">return</span> ((<span class="keyword">id</span>)<span class="keyword">self</span>)-&gt;rootAutorelease();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过查看 <code>((id)self)-&gt;rootAutorelease()</code> 的方法调用，我们发现最终调用的就是 AutoreleasePoolPage 的 autorelease 函数。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">__attribute__((noinline,used))</span><br><span class="line"><span class="keyword">id</span></span><br><span class="line">objc_object::rootAutorelease2()</span><br><span class="line">&#123;</span><br><span class="line">    assert(!isTaggedPointer());</span><br><span class="line">    <span class="keyword">return</span> AutoreleasePoolPage::autorelease((<span class="keyword">id</span>)<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>AutoreleasePoolPage</code> 的 autorelease 函数的实现对我们来说就比较容量理解了，它跟 push 操作的实现非常相似。只不过 push 操作插入的是一个 <code>POOL_SENTINEL </code>，而 autorelease 操作插入的是一个具体的 autoreleased 对象。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">id</span> autorelease(<span class="keyword">id</span> obj)</span><br><span class="line">&#123;</span><br><span class="line">    assert(obj);</span><br><span class="line">    assert(!obj-&gt;isTaggedPointer());</span><br><span class="line">    <span class="keyword">id</span> *dest __unused = autoreleaseFast(obj);</span><br><span class="line">    assert(!dest  ||  *dest == obj);</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="pop-操作"><a href="#pop-操作" class="headerlink" title="pop 操作"></a>pop 操作</h3><p>同理，前面提到的 <code>objc_autoreleasePoolPop(void *)</code> 函数本质上也是调用的 AutoreleasePoolPage 的 pop 函数。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">objc_autoreleasePoolPop(<span class="keyword">void</span> *ctxt)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (UseGC) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// fixme rdar://9167170</span></span><br><span class="line">    <span class="keyword">if</span> (!ctxt) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    AutoreleasePoolPage::pop(ctxt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>pop 函数的入参就是 push 函数的返回值，也就是 <code>POOL_SENTINEL</code> 的内存地址，即 <code>pool token</code> 。当执行 pop 操作时，内存地址在<code> pool token</code> 之后的所有 autoreleased 对象都会被 release 。直到<code> pool token</code> 所在 page 的<code> next</code> 指向 <code>pool token</code> 为止。</p>
<p>根绝上面的内容我们可以大致猜测 AutoreleasePoolPage类的结构 如下：</p>
<h3 id="AutoreleasePoolPage-类的结构"><a href="#AutoreleasePoolPage-类的结构" class="headerlink" title="AutoreleasePoolPage 类的结构"></a>AutoreleasePoolPage 类的结构</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">objc4/<span class="built_in">NSObject</span>.mm AutoreleasePoolPage</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> AutoreleasePoolPage </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> *push() </span><br><span class="line">    &#123;</span><br><span class="line">        生成或者持有 <span class="built_in">NSAutoreleasePool</span> 类对象</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> pop(<span class="keyword">void</span> *token) </span><br><span class="line">    &#123;</span><br><span class="line">        废弃 <span class="built_in">NSAutoreleasePool</span> 类对象</span><br><span class="line">        releaseAll();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">id</span> autorelease(<span class="keyword">id</span> obj)</span><br><span class="line">    &#123;</span><br><span class="line">        相当于 <span class="built_in">NSAutoreleasePool</span> 类的 addObject 类方法</span><br><span class="line">        AutoreleasePoolPage *page = 取得正在使用的 AutoreleasePoolPage 实例;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">id</span> *add(<span class="keyword">id</span> obj)</span><br><span class="line">    &#123;</span><br><span class="line">        将对象追加到内部数组</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> releaseAll() </span><br><span class="line">    &#123;</span><br><span class="line">        调用内部数组中对象的 release 方法</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> *</span><br><span class="line">objc_autoreleasePoolPush(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (UseGC) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">return</span> AutoreleasePoolPage::push();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">objc_autoreleasePoolPop(<span class="keyword">void</span> *ctxt)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (UseGC) <span class="keyword">return</span>;</span><br><span class="line">    AutoreleasePoolPage::pop(ctxt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>下面是某个线程的 autoreleasepool 堆栈的内存结构图，在这个 autoreleasepool 堆栈中总共有两个 POOL_SENTINEL ，即有两个 autoreleasepool 。该堆栈由三个 AutoreleasePoolPage 结点组成，第一个 AutoreleasePoolPage 结点为 coldPage() ，最后一个 AutoreleasePoolPage 结点为 hotPage() 。其中，前两个结点已经满了，最后一个结点中保存了最新添加的 autoreleased 对象 objr3 的内存地址。</p>
<p><img src="http://blog.leichunfeng.com/images/AutoreleasePoolPage1.png" alt="内存结构图"></p>
<p>此时，如果执行 <code>pop(token1)</code> 操作，那么该 autoreleasepool 堆栈的内存结构将会变成如下图所示</p>
<p><img src="http://blog.leichunfeng.com/images/AutoreleasePoolPage2.png" alt="内存结构图"></p>
<h3 id="Autorelease对象什么时候释放？"><a href="#Autorelease对象什么时候释放？" class="headerlink" title="Autorelease对象什么时候释放？"></a>Autorelease对象什么时候释放？</h3><p>这个问题拿来做面试题，问过很多人，没有几个能答对的。很多答案都是“当前作用域大括号结束时释放”，显然木有正确理解Autorelease机制。<br>在没有手加Autorelease Pool的情况下，Autorelease对象是在当前的runloop迭代结束时释放的，而它能够释放的原因是系统在每个runloop迭代中都加入了自动释放池Push和Pop</p>
<h3 id="嵌套的AutoreleasePool"><a href="#嵌套的AutoreleasePool" class="headerlink" title="嵌套的AutoreleasePool"></a>嵌套的AutoreleasePool</h3><p>知道了上面的原理，嵌套的AutoreleasePool就非常简单了，pop的时候总会释放到上次push的位置为止，多层的pool就是多个哨兵对象而已，就像剥洋葱一样，每次一层，互不影响。</p>
<h3 id="其他Autorelease相关知识点"><a href="#其他Autorelease相关知识点" class="headerlink" title="其他Autorelease相关知识点"></a>其他Autorelease相关知识点</h3><p>使用容器的block版本的枚举器时，内部会自动添加一个AutoreleasePool：</p>
<p>[array enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop) {<br>    // 这里被一个局部@autoreleasepool包围着<br>}];<br>当然，在普通for循环和for in循环中没有，所以，还是新版的block版本枚举器更加方便。for循环中遍历产生大量autorelease变量时，就需要手加局部AutoreleasePool咯。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="http://blog.sunnyxx.com/2014/10/15/behind-autorelease/">黑幕背后的Autorelease</a><br><a href="http://blog.leichunfeng.com/blog/2015/05/31/objective-c-autorelease-pool-implementation-principle/#jtss-tsina">Objective-C Autorelease Pool 的实现原理</a></p>
]]></content>
      <categories>
        <category>iOS优化</category>
      </categories>
      <tags>
        <tag>ARC RetainCount AutoreleasePool AutoreleasePoolPage</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS内存管理基础篇</title>
    <url>/2018/03/22/iOS%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80%E7%AF%87/</url>
    <content><![CDATA[<p>本文是iOS 内存管理的基础篇,从最基本的堆栈开始一步步的了解iOS的内存管理。</p>
<a id="more"></a>

<h2 id="内存管理基础结构"><a href="#内存管理基础结构" class="headerlink" title="内存管理基础结构"></a>内存管理基础结构</h2><h3 id="程序可执行文件的结构"><a href="#程序可执行文件的结构" class="headerlink" title="程序可执行文件的结构"></a>程序可执行文件的结构</h3><p>一个程序的可执行文件在内存中的结果，从大的角度可以分为两个部分：只读部分和可读写部分。只读部分包括程序代码（.text）和程序中的常量（.rodata）。可读写部分（也就是变量）大致可以分成下面几个部分：</p>
<ul>
<li>.data： 初始化了的全局变量和静态变量</li>
<li>.bss： 即 Block Started by Symbol， 未初始化的全局变量和静态变量</li>
<li>heap： 堆，使用 malloc, realloc, 和 free 函数控制的变量，堆在所有的线程，共享库，和动态加载的模块中被共享使用</li>
<li>stack： 栈，函数调用时使用栈来保存函数现场，自动变量（即生命周期限制在某个 scope 的变量）也存放在栈中</li>
</ul>
<p><img src="https://www.processon.com/chart_image/586f3b1fe4b067ce8566dc70.png" alt="架构图"></p>
<p>下面来具体解释一下：</p>
<h3 id="data-和-bss-区"><a href="#data-和-bss-区" class="headerlink" title="data 和 bss 区"></a>data 和 bss 区</h3><p>这两个都是存放全局变量的 他们之间的区别是：<br><code>data区存放的是初始化了的全局变量和静态变量,而bss区存放的是未初始化过得</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="keyword">int</span> val = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">char</span> <span class="built_in">string</span>[] = <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//未初始化</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> i;</span><br></pre></td></tr></table></figure>

<p>已经初始化的变量最开始会被放在.text中 因为值是卸载代码中的，程序运行起来之后就会被拷贝到.data区或者bss区。</p>
<p><font size="5" color=red>答疑一</font>: 静态变量和全局变量</p>
<p><code>全局变量</code>:在一个代码文件（具体说应该一个 translation unit/compilation unit)）当中，一个变量要么定义在函数中，要么定义在在函数外面。当定义在函数外面时，这个变量就有了全局作用域，成为了全局变量。全局变量不光意味着这个变量可以在整个文件中使用，也意味着这个变量可以在其他文件中使用（这种叫做 external linkage）。当有如下两个文件时</p>
<p>a.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compute</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, a, compute());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>b.c</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int a;</span><br><span class="line">int compute(void)</span><br><span class="line">&#123;</span><br><span class="line">    a &#x3D; 0;</span><br><span class="line">    return a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 Link 过程中会产生重复定义错误，因为有两个全局的 a 变量，Linker 不知道应该使用哪一个。为了避免这种情况，就需要引入 static</p>
<p><code>静态变量</code>： 指使用 static 关键字修饰的变量，static 关键字对变量的作用域进行了限制，具体的</p>
<p>限制如下：</p>
<ul>
<li>在函数外定义：全局变量，但是只在当前文件中可见（叫做 internal linkage）</li>
<li>在函数内定义：全局变量，但是只在此函数内可见（同时，在多次函数调用中，变量的值不会丢失）<br>（C++）在类中定义：全局变量，但是只在此类中可见</li>
</ul>
<p>对于全局变量来说，为了避免上面提到的重复定义错误，我们可以在一个文件中使用 static，另一个不使用。这样使用 static 的就会使用自己的 a 变量，而没有用 static 的会使用全局的 a 变量。当然，最好两个都使用 static，避免更多可能的命名冲突。</p>
<p><font color='black' size = '6'>注意</font>：’静态’这个中文翻译实在是有些莫名其妙，给人的感觉像是不可改变的，而实际上 static 跟不可改变没有关系，不可改变的变量使用 const 关键字修饰，注意不要混淆。</p>
<p><font color="blue">Bonus 部分</font> —— extern： extern 是 C 语言中另一个关键字，用来指示变量或函数的定义在别的文件中，使用 extern 可以在多个源文件中共享某个变量，例如这里的例子。 extern 跟 static 在含义上是“水火不容”的，一个表示不能在别的地方用，一个表示要去别的地方找。如果同时使用的话，有两种情况，一种是先使用 static，后使用 extern ，即：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> m;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> m;</span><br></pre></td></tr></table></figure>
<p>这种情况，后面的 m 实际上就是前面的 m 。如果反过来：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> m;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> m;</span><br></pre></td></tr></table></figure>
<p>这种情况的行为是未定义的，编译器也会给出警告。</p>
<p><font color='red' size='6'>答疑二</font> 程序在内存和硬盘上不同的存在形式（不懂！！！）</p>
<p>这里我们提到的几个区，是指程序在内存中的存在形式。和程序在硬盘上存储的格式不是完全对应的。程序在硬盘上存储的格式更加复杂，而且是和操作系统有关的，具体可以参考这里。一个比较明显的例子可以帮你区分这个差别：之前我们提到过未定义的全局变量存储在 .bss 区，这个区域不会占用可执行文件的空间（一般只存储这个区域的长度），但是却会占用内存空间。这些变量没有定义，因此可执行文件中不需要存储（也不知道）它们的值，在程序启动过程中，它们的值会被初始化成 0 ，存储在内存中</p>
<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>栈是用于存放本地变量，内部临时变量以及有关上下文的内存区域。程序在调用函数时，操作系统会自动通过压栈和弹栈完成保存函数现场等操作，不需要程序员手动干预。</p>
<p>栈是一块<code>连续的内存区域</code>，栈顶的地址和栈的最大容量是系统预先规定好的。能从栈获得的空间较小。如果申请的空间超过栈的剩余空间时，例如递归深度过深，将提示stackoverflow。</p>
<p>栈是机器系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高</p>
<h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>堆是用于存放除了栈里的东西之外所有其他东西的内存区域，当使用<code>malloc</code>和<code>free</code>时就是在操作堆中的内存。对于堆来说<code>·释放工作由程序员控制</code>，容易产生<code>memory leak</code>。</p>
<p>堆是向高地址扩展的数据结构，<code>是不连续的内存区域</code>。这是由于系统是用<code>链表</code>来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，<code>堆获得的空间比较灵活，也比较大</code>。</p>
<p>对于堆来讲，频繁的<code>new/delete</code>势必会造成内存空间的不连续，从而造成大量的<code>碎片</code>，使程序效率降低。对于栈来讲，则不会存在这个问题，因为栈是先进后出的队列，永远都不可能有一个内存块从栈中间弹出。</p>
<p>堆都是<code>动态分配的</code>，没有静态分配的堆。栈有2种分配方式：静态分配和动态分配。<code>静态分配是编译器完成的，比如局部变量的分配</code>。<code>动态分配由alloca函数进行分配</code>，但是栈的动态分配和堆是不同的，他的动态分配是<code>由编译器进行释放，无需我们手工实现</code>。</p>
<p>计算机底层并没有对堆的支持，堆则是C/C++函数库提供的，同时由于上面提到的碎片问题，都会导致堆的效率比栈要低。</p>
<h3 id="全局区-静态区"><a href="#全局区-静态区" class="headerlink" title="全局区 / 静态区"></a>全局区 / 静态区</h3><p>存储全局变量和静态变量，程序结束后由系统释放</p>
<blockquote>
<p>初始化区 非初始化区分开存放</p>
</blockquote>
<h3 id="文字常量区"><a href="#文字常量区" class="headerlink" title="文字常量区"></a>文字常量区</h3><blockquote>
<p>存储字符串常量，程序结束后由系统释放</p>
</blockquote>
<h3 id="程序代码区"><a href="#程序代码区" class="headerlink" title="程序代码区"></a>程序代码区</h3><blockquote>
<p>存储函数体的二进制代码</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//main.cpp</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>; <span class="comment">// 全局初始化区</span></span><br><span class="line"><span class="keyword">char</span> *p1; <span class="comment">// 全局未初始化区</span></span><br><span class="line">main &#123;</span><br><span class="line">    <span class="keyword">int</span> b; <span class="comment">// 栈</span></span><br><span class="line">    <span class="keyword">char</span> s[] = <span class="string">&quot;abc&quot;</span>; <span class="comment">// 栈</span></span><br><span class="line">    <span class="keyword">char</span> *p2; <span class="comment">// 栈</span></span><br><span class="line">    <span class="keyword">char</span> *p3 = <span class="string">&quot;123456&quot;</span>; <span class="comment">// 123456\0在常量区，p3在栈上</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> c =<span class="number">0</span>； <span class="comment">// 全局静态初始化区</span></span><br><span class="line">    p1 = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">10</span>);</span><br><span class="line">    p2 = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">20</span>); <span class="comment">// 分配得来的10和20字节的区域就在堆区</span></span><br><span class="line">    <span class="built_in">strcpy</span>(p1, <span class="string">&quot;123456&quot;</span>); <span class="comment">// 123456\0在常量区，这个函数的作用是将&quot;123456&quot; 这串字符串复制一份放在p1申请的10个字节的堆区域中。</span></span><br><span class="line">    <span class="comment">// p3指向的&quot;123456&quot;与这里的&quot;123456&quot;可能会被编译器优化成一个地址。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="结构体-Struct"><a href="#结构体-Struct" class="headerlink" title="结构体(Struct)"></a>结构体(Struct)</h3><h4 id="1、定义"><a href="#1、定义" class="headerlink" title="1、定义"></a>1、定义</h4><blockquote>
<p>struct tag { member-list } variable-list;</p>
</blockquote>
<h4 id="2、成员访问"><a href="#2、成员访问" class="headerlink" title="2、成员访问"></a>2、成员访问</h4><blockquote>
<p>直接访问： 变量名.成员名<br>间接访问： 结构体指针名-&gt;成员名</p>
</blockquote>
<h5 id="3、成员存储"><a href="#3、成员存储" class="headerlink" title="3、成员存储"></a>3、成员存储</h5><blockquote>
<p>获得EXAMPLE类型结构体所占内存大小: int size_example = sizeof( struct EXAMPLE );<br>获得成员b相对于EXAMPLE储存地址的偏移量: int offset_b = offsetof( struct EXAMPLE, b );</p>
</blockquote>
<h3 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h3><ul>
<li><p>虚拟地址：用户编程时将代码（或数据）分成若干个段，每条代码或每个数据的地址由段名称 + 段内相对地址构成，这样的程序地址称为虚拟地址</p>
</li>
<li><p>逻辑地址：虚拟地址中，段内相对地址部分称为逻辑地址</p>
</li>
<li><p>物理地址：实际物理内存中所看到的存储地址称为物理地址</p>
</li>
<li><p>逻辑地址空间：在实际应用中，将虚拟地址和逻辑地址经常不加区分，通称为逻辑地址。逻辑地址的集合称为逻辑地址空间</p>
</li>
<li><p>线性地址空间：CPU地址总线可以访问的所有地址集合称为线性地址空间</p>
</li>
<li><p>物理地址空间：实际存在的可访问的物理内存地址集合称为物理地址空间</p>
</li>
<li><p>MMU(Memery Management Unit内存管理单元)：实现将用户程序的虚拟地址（逻辑地址） → 物理地址映射的CPU中的硬件电路</p>
</li>
<li><p>基地址：在进行地址映射时，经常以段或页为单位并以其最小地址（即起始地址）为基值来进行计算</p>
</li>
<li><p>偏移量：在以段或页为单位进行地址映射时，相对于基地址的地址值<br>虚拟地址先经过分段机制映射到线性地址，然后线性地址通过分页机制映射到物理地址。</p>
</li>
</ul>
<h3 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h3><h4 id="FIFO算法"><a href="#FIFO算法" class="headerlink" title="FIFO算法"></a>FIFO算法</h4><p>先入先出，即淘汰最早调入的页面。</p>
<h4 id="OPT-MIN-算法"><a href="#OPT-MIN-算法" class="headerlink" title="OPT(MIN)算法"></a>OPT(MIN)算法</h4><p>选未来最远将使用的页淘汰，是一种最优的方案，可以证明缺页数最小。<br>可惜，MIN需要知道将来发生的事，只能在理论中存在，实际不可应用。</p>
<h4 id="LRU-Least-Recently-Used-算法"><a href="#LRU-Least-Recently-Used-算法" class="headerlink" title="LRU(Least-Recently-Used)算法"></a>LRU(Least-Recently-Used)算法</h4><p>用过去的历史预测将来，选最近最长时间没有使用的页淘汰(也称最近最少使用)。<br>LRU准确实现：计数器法，页码栈法。<br>由于代价较高，通常不使用准确实现，而是采用近似实现，例如Clock算法。</p>
<p><code>内存抖动现象</code>：页面的频繁更换，导致整个系统效率急剧下降，这个现象称为内存抖动（或颠簸）。抖动一般是内存分配算法不好，内存太小引或者程序的算法不佳引起的</p>
<p><code>Belady现象</code>：对有的页面置换算法，页错误率可能会随着分配帧数增加而增加。<br>FIFO会产生Belady异常。<br>栈式算法无Belady异常，LRU，LFU（最不经常使用），OPT都属于栈式算法。</p>
<h1 id="OC的内存管理"><a href="#OC的内存管理" class="headerlink" title="OC的内存管理"></a>OC的内存管理</h1><h3 id="MRC于ARC-环境设置"><a href="#MRC于ARC-环境设置" class="headerlink" title="MRC于ARC 环境设置"></a>MRC于ARC 环境设置</h3><p><img src="https://blog.devtang.com/images/memory-fno-objc-arc.png" alt="参数配置"></p>
<h2 id="Reference-Counting"><a href="#Reference-Counting" class="headerlink" title="Reference Counting"></a>Reference Counting</h2><table>
<thead>
<tr>
<th>对象操作</th>
<th>Objective-C方法</th>
</tr>
</thead>
<tbody><tr>
<td>生成并持有对象</td>
<td>alloc/new/copy/mutableCopy等方法</td>
</tr>
<tr>
<td>持有对象</td>
<td>retain方法</td>
</tr>
<tr>
<td>释放对象</td>
<td>release方法</td>
</tr>
<tr>
<td>废弃对象</td>
<td>dealloc方法</td>
</tr>
</tbody></table>
<h3 id="alloc-retain-release-dealloc-实现"><a href="#alloc-retain-release-dealloc-实现" class="headerlink" title="alloc/retain/release/dealloc 实现"></a>alloc/retain/release/dealloc 实现</h3><p>在 Xcode 中 设置 Debug -&gt; Debug Workflow -&gt; Always Show Disassenbly 打开。这样在打断点后，可以看到更详细的方法调用。</p>
<h4 id="alloc"><a href="#alloc" class="headerlink" title="alloc"></a>alloc</h4><p>通过设置断点追踪程序的执行，下面列出了执行所调用的方法和函数：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">+alloc</span><br><span class="line">+allocWithZone:</span><br><span class="line">class_createInstance</span><br><span class="line">calloc</span><br></pre></td></tr></table></figure>

<p>下面我们来看这几个跟retainCount相关的方法到底都做了什么！</p>
<h4 id="retainCount"><a href="#retainCount" class="headerlink" title="retainCount"></a>retainCount</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">__CFdoExternRefOperation</span><br><span class="line"><span class="built_in">CFBasicHashGetCountOfKey</span></span><br></pre></td></tr></table></figure>

<h4 id="retain"><a href="#retain" class="headerlink" title="retain"></a>retain</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">__CFdoExternRefOperation</span><br><span class="line"><span class="built_in">CFBasicHashAddValue</span></span><br></pre></td></tr></table></figure>

<h4 id="release"><a href="#release" class="headerlink" title="release"></a>release</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">__CFdoExternRefOperation</span><br><span class="line"><span class="built_in">CFBasicHashRemoveValue</span></span><br></pre></td></tr></table></figure>

<p>很明显 这几个方法都调用了<code>__CFdoExternRefOperation</code>这个方法,下面我们来看一下这个方法的实现：</p>
<p>CFRuntime.c __CFDoExternRefOperation:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> __CFDoExternRefOperation(uintptr_t op, <span class="keyword">id</span> obj) &#123;</span><br><span class="line">    <span class="built_in">CFBasicHashRef</span> table = 取得对象的散列表(obj);</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">switch</span> (op) &#123;</span><br><span class="line">        <span class="keyword">case</span> OPERATION_retainCount:</span><br><span class="line">        count = <span class="built_in">CFBasicHashGetCountOfKey</span>(table, obj);</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> OPERATION_retain:</span><br><span class="line">        count = <span class="built_in">CFBasicHashAddValue</span>(table, obj);</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">        <span class="keyword">case</span> OPERATION_release:</span><br><span class="line">        count = <span class="built_in">CFBasicHashRemoveValue</span>(table, obj);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> == count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从<code>BasicHash</code>这样的方法名可以看出，其实引用计数表就是散列表。<code>key 为 hash(对象的地址) value为引用计数</code></p>
<h3 id="所有的修饰符"><a href="#所有的修饰符" class="headerlink" title="所有的修饰符"></a>所有的修饰符</h3><h4 id="strong-修饰符"><a href="#strong-修饰符" class="headerlink" title="_strong 修饰符"></a>_strong 修饰符</h4><p>是id类型和对象类型默认的所有权修饰符</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">id</span> obj = [[<span class="built_in">NSObject</span> alloc] init];</span><br></pre></td></tr></table></figure>

<p>上面的源码与下面的相同</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">id</span> _<span class="keyword">strong</span> obj = [[<span class="built_in">NSObject</span> alloc] init];</span><br></pre></td></tr></table></figure>

<h4 id="weak修饰符"><a href="#weak修饰符" class="headerlink" title="_weak修饰符"></a>_weak修饰符</h4><p>_weak修饰符出现是为了避免发生循环引用,循环引用容易发生内存泄漏.所为内存泄漏就是应当废弃的对象在超出其生存周期后继续存在。</p>
<p>即使只有一个对象也有可能发生循环引用</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">id</span> test = [[Test alloc] init];</span><br><span class="line">[test setObject:test];</span><br></pre></td></tr></table></figure>

<p>__weak修饰符还有一个优点：在持有某对象的弱引用时,若该对象被废弃则弱引用将自动失效且处于nil被赋值的状态(空弱引用)。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">id</span> __<span class="keyword">weak</span> obj1 = <span class="literal">nil</span>;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">id</span> __<span class="keyword">strong</span> obj0 = [[<span class="built_in">NSObject</span> alloc] init];</span><br><span class="line">    </span><br><span class="line">    obj1 = obj0;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;A:%@&quot;</span>,obj1);</span><br><span class="line">&#125;</span><br><span class="line"> <span class="built_in">NSLog</span>(<span class="string">@&quot;A:%@&quot;</span>,obj1);</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A:&lt;NSObject:ox753e180&gt;</span><br><span class="line">B:null</span><br></pre></td></tr></table></figure>

<h4 id="unsafe-unretained修饰符"><a href="#unsafe-unretained修饰符" class="headerlink" title="_unsafe_unretained修饰符"></a>_unsafe_unretained修饰符</h4><p>是不安全的所有权修饰符，因此：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">id</span> __<span class="keyword">unsafe_unretained</span> obj = [[<span class="built_in">NSObject</span> alloc] init];</span><br></pre></td></tr></table></figure>
<p>仍然会提示</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">Assigning retained object to <span class="keyword">unsafe_unretained</span> variable; object will be released after assignment</span><br></pre></td></tr></table></figure>
<p>这一点跟__weak是一样 因为自己无法持有自己创建的对象 创建完成之后就会被销毁</p>
<h4 id="autoreleasing-修饰符"><a href="#autoreleasing-修饰符" class="headerlink" title="_autoreleasing 修饰符"></a>_autoreleasing 修饰符</h4><p>ARC有效时，要通过将对象赋值给附加了__autoreleaseing修饰符的变量来替代调用autorelease方法，对象赋值给附有__autoreleaseing修饰符的变量等价于在ARC无效时调用对象的autorelease方法，即对象被注册到autoreleasepool中</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSAutoreleasePool</span> *pool = [[<span class="built_in">NSAutoreleasePool</span> alloc] init];</span><br><span class="line">[obj autorelease];</span><br><span class="line"></span><br><span class="line">[pool drain];</span><br></pre></td></tr></table></figure>
<p>等价于</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@autoreleasepool</span>&#123;</span><br><span class="line">    <span class="keyword">id</span> __autoreleasing obj2;</span><br><span class="line">    obj2 = obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="MRC-Manual-Reference-Counting"><a href="#MRC-Manual-Reference-Counting" class="headerlink" title="MRC(Manual Reference Counting)"></a>MRC(Manual Reference Counting)</h2><h4 id="dealloc"><a href="#dealloc" class="headerlink" title="dealloc"></a>dealloc</h4><p>[super dealloc];一定在最后一行<br>不能直接调用<br>一旦对象被回收，继续使用会野指针</p>
<h4 id="野指针-amp-空指针"><a href="#野指针-amp-空指针" class="headerlink" title="野指针 &amp; 空指针"></a>野指针 &amp; 空指针</h4><ul>
<li>野指针即一个指针指向了“僵尸对象（不能再使用的对象）”</li>
<li>给野指针发消息报错：EXC_BAD_ACCESS</li>
<li>避免野指针发消息报错，对象释放后，将指针置为空指针<br>  空指针即没有指向任何存储空间（存的nil）<br>  向空指针发送消息没有任何反应</li>
</ul>
<h4 id="MRC-property参数"><a href="#MRC-property参数" class="headerlink" title="MRC @property参数"></a>MRC @property参数</h4><p>成员变量前加上@property，自动生成基本的setter/getter<br>property加上retain，自动生成有内存管理的setter/getter<br>property加上assign，自动生成基本的setter/getter，默认什么都不加就是assign</p>
<h4 id="MRC-循环引用"><a href="#MRC-循环引用" class="headerlink" title="MRC 循环引用"></a>MRC 循环引用</h4><p>当两端互相引用时，应该一端用retain，一端用assign</p>
<h4 id="autoreleasepool"><a href="#autoreleasepool" class="headerlink" title="autoreleasepool"></a>autoreleasepool</h4><ul>
<li>[p autorelease] 给p发送一条autorelease消息，将p放到autoreleasepool，在autoreleasepool释放时做一次release操作</li>
<li>autorelease方法返回对象本身，引用计数不会变化</li>
</ul>
<h4 id="autoreleasepool-注意"><a href="#autoreleasepool-注意" class="headerlink" title="autoreleasepool 注意"></a>autoreleasepool 注意</h4><p>并不是放到autoreleasepool代码中,都会自动加入到自动释放池</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">    <span class="comment">// 因为没有调用 autorelease 方法,所以对象没有加入到自动释放池</span></span><br><span class="line">    Person *p = [[Person alloc] init];</span><br><span class="line">    [p run];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>autorelease是一个方法, 只有在autoreleasepool中调用才有效</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 没有与之对应的自动释放池, 只有在自动释放池中调用autorelease才会放到释放池</span></span><br><span class="line">Person *p = [[[Person alloc] init] autorelease];</span><br><span class="line">[p run];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确写法</span></span><br><span class="line"><span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">    Person *p = [[[Person alloc] init] autorelease];</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确写法</span></span><br><span class="line">Person *p = [[Person alloc] init];</span><br><span class="line"><span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">    [p autorelease];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="autoreleasepool-循环"><a href="#autoreleasepool-循环" class="headerlink" title="autoreleasepool 循环"></a>autoreleasepool 循环</h4><ul>
<li>尽量避免对大内存使用autorelease</li>
<li>不要把for循环放在@autoreleasepool之间，会造成内存峰值上升</li>
</ul>
<h4 id="autoreleasepool-错误用法"><a href="#autoreleasepool-错误用法" class="headerlink" title="autoreleasepool 错误用法"></a>autoreleasepool 错误用法</h4><p>不能连续调用autorelease<br>调用autorelease后又调用release</p>
<h2 id="ARC-Automatic-Reference-Counting"><a href="#ARC-Automatic-Reference-Counting" class="headerlink" title="ARC(Automatic Reference Counting)"></a>ARC(Automatic Reference Counting)</h2><p>ARC自动引用计数内存管理，通过编译器（Clang Complier），本质上还是会使用到retain、release等关键字方法，只是不是开发者手动添加，而是编译器在编译过程中添加retain、release等关键字方法到相应的代码行。</p>
<p><img src="https://developer.apple.com/library/content/releasenotes/ObjectiveC/RN-TransitioningToARC/Art/ARC_Illustration.jpg" alt="ARC"></p>
<h3 id="ARC-property"><a href="#ARC-property" class="headerlink" title="ARC @property"></a>ARC @property</h3><ul>
<li>strong : 用于OC对象，相当于MRC中的retain</li>
<li>weak : 用于OC对象，相当于MRC中的assign</li>
<li>assign : 用于基本数据类型，跟MRC中的assign一样</li>
</ul>
<h3 id="ARC-注意"><a href="#ARC-注意" class="headerlink" title="ARC 注意"></a>ARC 注意</h3><p>不能调用release<br>不能调用autorelease<br>不能调用[super dealloc]</p>
<h3 id="NSThread-amp-NSRunLoop-amp-NSAutoreleasePool"><a href="#NSThread-amp-NSRunLoop-amp-NSAutoreleasePool" class="headerlink" title="NSThread &amp; NSRunLoop &amp; NSAutoreleasePool"></a>NSThread &amp; NSRunLoop &amp; NSAutoreleasePool</h3><ul>
<li>1、每个线程（包括主线程）都拥有一个专属的NSRunLoop，并在需要时自动创建</li>
<li>2、主线程的NSRunLoop对象（包括系统级别的其它线程）的每个event loop开始前，自动创建一个autoreleasepool，并在event loop结束时drain</li>
<li>3、每个autoreleasepool对应且只对应一个线程</li>
</ul>
<h3 id="需要手动添加autoreleasepool的情况"><a href="#需要手动添加autoreleasepool的情况" class="headerlink" title="需要手动添加autoreleasepool的情况"></a>需要手动添加autoreleasepool的情况</h3><ul>
<li>编写的程序不是基于UI框架的，比如命令行工具</li>
<li>编写的循环中创建了大量的临时对象</li>
<li>创建了一个辅助线程</li>
</ul>
<h2 id="内存管理的实际应用"><a href="#内存管理的实际应用" class="headerlink" title="内存管理的实际应用"></a>内存管理的实际应用</h2><h3 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h3><ul>
<li>1、YYKit ：解决循环中创建的大量临时对象</li>
<li>2、AFNetworking： 创建了辅助线程</li>
<li>3、XX会 混编时， 标注MRC文件：-fno-objc-arc</li>
</ul>
<h3 id="ARC-实例"><a href="#ARC-实例" class="headerlink" title="ARC 实例"></a>ARC 实例</h3><ul>
<li>1、ARC想要主动释放，最好是提前置为nil</li>
<li>2、ARC下获取引用计数<br>  KVC [obj valueForKey:@”retainCount”]<br>  私有API _objc_rootRetainCount(obj)<br>  CFGetRetainCount((__bridge CFTypeRef)(obj))</li>
</ul>
<h3 id="MRC-实例"><a href="#MRC-实例" class="headerlink" title="MRC 实例"></a>MRC 实例</h3><h4 id="NSString的引用计数是随机值，NSMutableString的引用计数是正常值"><a href="#NSString的引用计数是随机值，NSMutableString的引用计数是正常值" class="headerlink" title="NSString的引用计数是随机值，NSMutableString的引用计数是正常值"></a>NSString的引用计数是随机值，NSMutableString的引用计数是正常值</h4><blockquote>
<p>NSString的class是__NSCFConstantString，字符串常量<br>NSMutableString的class是__NSCFString，有引用计数</p>
</blockquote>
<h4 id="对于字符串常量、NSNumber做常量时"><a href="#对于字符串常量、NSNumber做常量时" class="headerlink" title="对于字符串常量、NSNumber做常量时?"></a>对于字符串常量、NSNumber做常量时?</h4><blockquote>
<p>retain 和 release都不会有影响，因为系统不会回收，也不会对其做引用计数</p>
</blockquote>
<h4 id="stringWithFormat创建的string"><a href="#stringWithFormat创建的string" class="headerlink" title="stringWithFormat创建的string?"></a>stringWithFormat创建的string?</h4><blockquote>
<p>为变量，所以会有引用计数<br>现在返回的已经是常量，见后面的例子</p>
</blockquote>
<h4 id="stringWithString创建的string"><a href="#stringWithString创建的string" class="headerlink" title="stringWithString创建的string?"></a>stringWithString创建的string?</h4><blockquote>
<p>取决于它后面的string对象，如果是常量则不做计数，如果是变量则做计数</p>
</blockquote>
<h4 id="除了alloc-new-copy-mutableCopy-retain显示增加retainCount以外还有哪些看不到的能够增加引用计数的操作？"><a href="#除了alloc-new-copy-mutableCopy-retain显示增加retainCount以外还有哪些看不到的能够增加引用计数的操作？" class="headerlink" title="除了alloc new copy mutableCopy retain显示增加retainCount以外还有哪些看不到的能够增加引用计数的操作？"></a>除了alloc new copy mutableCopy retain显示增加retainCount以外还有哪些看不到的能够增加引用计数的操作？</h4><blockquote>
<p>容器类array、dic addObject；release时，里面的成员都会release一次，和autorelease pool一致<br>addsubview, 因为view有栈(subviews)，加入栈中retainCount+1<br>navcontroller的push, 因为nav有栈(viewcontrollers)，加入栈中retainCount+1<br>performSelector 调用时target和info都会加1，结束时减1</p>
</blockquote>
<h4 id="苹果不推荐使用retainCount方法，因为他对程序本身没有作用，retainCount可能永远不会反回0，有时候系统会优化对象的释放行为，在保留计数还是1的时候就释放了。"><a href="#苹果不推荐使用retainCount方法，因为他对程序本身没有作用，retainCount可能永远不会反回0，有时候系统会优化对象的释放行为，在保留计数还是1的时候就释放了。" class="headerlink" title="苹果不推荐使用retainCount方法，因为他对程序本身没有作用，retainCount可能永远不会反回0，有时候系统会优化对象的释放行为，在保留计数还是1的时候就释放了。"></a>苹果不推荐使用retainCount方法，因为他对程序本身没有作用，retainCount可能永远不会反回0，有时候系统会优化对象的释放行为，在保留计数还是1的时候就释放了。</h4><h4 id="retainCount-关于NSString和NSMutableString的例子"><a href="#retainCount-关于NSString和NSMutableString的例子" class="headerlink" title="retainCount 关于NSString和NSMutableString的例子"></a>retainCount 关于NSString和NSMutableString的例子</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line">   <span class="built_in">NSMutableString</span> *str = [[<span class="built_in">NSMutableString</span> alloc] init];</span><br><span class="line">   <span class="built_in">NSMutableString</span> *str2 = [[<span class="built_in">NSMutableString</span> alloc] init];</span><br><span class="line">   <span class="built_in">NSLog</span>(<span class="string">@&quot;%ld, %ld&quot;</span>, [str retainCount], [str2 retainCount]);<span class="comment">//1,1</span></span><br><span class="line">   </span><br><span class="line">   str2 = [str <span class="keyword">copy</span>];         <span class="comment">//copy返回一个不可变对象属于常量</span></span><br><span class="line">   <span class="built_in">NSLog</span>(<span class="string">@&quot;%ld, %ld&quot;</span>, [str retainCount], [str2 retainCount]);<span class="comment">//1,-1</span></span><br></pre></td></tr></table></figure>

<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="built_in">NSString</span> *str = [[<span class="built_in">NSString</span> alloc] init];</span><br><span class="line"><span class="built_in">NSString</span> *str2 = [[<span class="built_in">NSString</span> alloc] init];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%ld, %ld&quot;</span>, [str retainCount], [str2 retainCount]); <span class="comment">//-1,-1</span></span><br><span class="line"></span><br><span class="line">str2 = [str <span class="keyword">copy</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%ld, %ld&quot;</span>, [str retainCount], [str2 retainCount]);<span class="comment">//-1,-1</span></span><br></pre></td></tr></table></figure>

<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="built_in">NSString</span> *str = [[<span class="built_in">NSString</span> alloc] initWithFormat:<span class="string">@&quot;abc%@&quot;</span>, <span class="string">@&quot;hehe&quot;</span>];</span><br><span class="line"><span class="built_in">NSString</span> *str2 = [[<span class="built_in">NSString</span> alloc] initWithFormat:<span class="string">@&quot;bbc%@&quot;</span>, <span class="string">@&quot;hehe&quot;</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%ld, %ld&quot;</span>, [str retainCount], [str2 retainCount]); <span class="comment">//-1,-1</span></span><br><span class="line"></span><br><span class="line">str2 = [str mutableCopy];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%ld, %ld&quot;</span>, [str retainCount], [str2 retainCount]);<span class="comment">//-1,1</span></span><br></pre></td></tr></table></figure>

<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://hit-alibaba.github.io/interview/basic/arch/Memory-Management.html">阿里面试基础</a><br><a href="http://zhoulingyu.com/2017/02/15/Advanced-iOS-Study-objc-Memory-2/"></a><br><a href="http://yolynn.com/2015/07/20/ios_arc_mrc/">内存管理基础到进阶</a></p>
]]></content>
      <categories>
        <category>iOS进阶</category>
      </categories>
      <tags>
        <tag>堆 栈 RetainCount</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS面试笔记 （上）</title>
    <url>/2015/07/23/interview-note/</url>
    <content><![CDATA[<p>本文是 看了github上 《招聘一个靠谱的iOS程序员》提供的面试题之后做的一些总结，内容大多为其中的一些摘抄。</p>
<a id="more"></a>

<h3 id="1、枚举的定义"><a href="#1、枚举的定义" class="headerlink" title="1、枚举的定义"></a>1、枚举的定义</h3><pre><code>NS_ENUM和NS_OPTIONS本质是一样的，仅仅从字面上来区分其用途。NS_ENUM是通用情况，NS_OPTIONS一般用来定义具有位移操作或特点的情况（bitmask)。
typedef NS_ENUM(NSInteger, UIViewAnimationTransition) &#123;  
UIViewAnimationTransitionNone,//默认从0开始  
UIViewAnimationTransitionFlipFromLeft,  
UIViewAnimationTransitionFlipFromRight,  
UIViewAnimationTransitionCurlUp,  
UIViewAnimationTransitionCurlDown,  
&#125;;  

typedef NS_OPTIONS(NSUInteger, UIViewAutoresizing) &#123;  
    UIViewAutoresizingNone                 = 0,  
    UIViewAutoresizingFlexibleLeftMargin   = 1 &lt;&lt; 0,  
    UIViewAutoresizingFlexibleWidth        = 1 &lt;&lt; 1,  
    UIViewAutoresizingFlexibleRightMargin  = 1 &lt;&lt; 2,  
    UIViewAutoresizingFlexibleTopMargin    = 1 &lt;&lt; 3,  
    UIViewAutoresizingFlexibleHeight       = 1 &lt;&lt; 4,  
    UIViewAutoresizingFlexibleBottomMargin = 1 &lt;&lt; 5  
&#125;;</code></pre>
<h3 id="2、方法名中间的连词"><a href="#2、方法名中间的连词" class="headerlink" title="2、方法名中间的连词"></a>2、方法名中间的连词</h3><pre><code>//错误，不要使用&quot;and&quot;来连接参数
- (int)runModalForDirectory:(NSString *)path andFile:    (NSString *)name andTypes:(NSArray *)fileTypes;
//错误，不要使用&quot;and&quot;来阐明有多个参数
- (instancetype)initWithName:(CGFloat)width andAge:    (CGFloat)height;
//正确，使用&quot;and&quot;来表示两个相对独立的操作
- (BOOL)openFile:(NSString *)fullPath withApplication:    (NSString *)appName andDeactivate:(BOOL)flag;</code></pre>
<h3 id="3、编程规范的问题"><a href="#3、编程规范的问题" class="headerlink" title="3、编程规范的问题"></a>3、编程规范的问题</h3><pre><code>在-和(void)之间应该有一个空格
enum 中驼峰命名法和下划线命名法混用错误：枚举类型的命名规则和函数的    命名规则相同：命名时使用驼峰命名法，勿使用下划线命名法。
enum 左括号前加一个空格，或者将左括号换到下一行
enum 右括号后加一个空格
UserModel :NSObject 应为UserModel : NSObject，也就是:右侧少    了一个空格。
@interface 与 @property 属性声明中间应当间隔一行。
两个方法定义之间不需要换行，有时为了区分方法的功能也可间隔一行，但示    例代码中间隔了两行。
-(id)initUserModelWithUserName: (NSString*)name withAge:    (int)age;方法中方法名与参数之间多了空格。而且 - 与 (id) 之间少了    空格。
-(id)initUserModelWithUserName: (NSString*)name withAge:    (int)age;方法中方法名与参数之间多了空格：(NSString*)name 前多了    空格。
-(id)initUserModelWithUserName: (NSString*)name withAge:    (int)age; 方法中 (NSString*)name,应为 (NSString *)name，少    了空格。</code></pre>
<h3 id="4、什么情况使用-weak-关键字，相比-assign-有什么不同？"><a href="#4、什么情况使用-weak-关键字，相比-assign-有什么不同？" class="headerlink" title="4、什么情况使用 weak 关键字，相比 assign 有什么不同？"></a>4、什么情况使用 weak 关键字，相比 assign 有什么不同？</h3><pre><code>什么情况使用 weak 关键字？

在 ARC 中,在有可能出现循环引用的时候,往往要通过让其中一端使用 weak     来解决,比如: delegate 代理属性

自身已经对它进行一次强引用,没有必要再强引用一次,此时也会使用 weak,    自定义 IBOutlet 控件属性一般也使用 weak；当然，也可以使用    strong。在下文也有论述：《IBOutlet连出来的视图属性为什么可以被设    置成weak?》

不同点：
weak 此特质表明该属性定义了一种非拥有关系 (nonowning     relationship)。为这种属性设置新值时，设置方法既不保留新值，也不释    放旧值。此特质同assign类似， 然而在属性所指的对象遭到摧毁时，属性值    也会清空(nil out)。 而 assign 的“设置方法”只会执行针对纯量类    型” (scalar type，例如 CGFloat 或 NSlnteger 等)的简赋值操    。
assigin 可以用非 OC 对象,而 weak 必须用于 OC 对象</code></pre>
<h3 id="5、怎么用-copy-关键字？"><a href="#5、怎么用-copy-关键字？" class="headerlink" title="5、怎么用 copy 关键字？"></a>5、怎么用 copy 关键字？</h3><pre><code>1、block使用copy
    block 使用 copy 是从 MRC 遗留下来的“传统”,在 MRC 中,方法内部的 block 是在栈区的,使用 copy 可以把它放到堆区.在 ARC 中写不写都行对于 block 使用 copy 还是 strong 效果是一样的
使用copy的意义：
    编译器自动对 block 进行了 copy 操作。如果不写 copy ，该类的调用者有可能会忘记或者根本不知道“编译器会自动对 block 进行了 copy 操作”，他们有可能会在调用之前自行拷贝属性值。这种操作多余而低效。</code></pre>
<p><img src="https://camo.githubusercontent.com/8a5fa34435801cc4c2715d8880f3abd45be6a6c5/687474703a2f2f692e696d6775722e636f6d2f566c564b6c384c2e706e67" alt="Mou icon"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">下面做下解释： copy 此特质所表达的所属关系与 strong 类似。然而设置方法并不保留新值，而是将其“拷贝” (copy)。 当属性类型为 NSString 时，经常用此特质来保护其封装性，因为传递给设置方法的新值有可能指向一个 NSMutableString 类的实例。这个类是 NSString 的子类，表示一种可修改其值的字符串，此时若是不拷贝字符串，那么设置完属性之后，字符串的值就可能会在对象不知情的情况下遭人更改。所以，这时就要拷贝一份“不可变” (immutable)的字符串，确保对象中的字符串值不会无意间变动。只要实现属性所用的对象是“可变的” (mutable)，就应该在设置新属性值时拷贝一份。</span><br><span class="line">用 @property 声明 NSString、NSArray、NSDictionary 经常使用 copy 关键字，是因为他们有对应的可变类型：NSMutableString、NSMutableArray、NSMutableDictionary，他们之间可能进行赋值操作，为确保对象中的字符串值不会无意间变动，应该在设置新属性值时拷贝一份。</span><br></pre></td></tr></table></figure>
<h3 id="6、这个写法会出什么问题：-property-copy-NSMutableArray-array"><a href="#6、这个写法会出什么问题：-property-copy-NSMutableArray-array" class="headerlink" title="6、这个写法会出什么问题： @property (copy) NSMutableArray *array;"></a>6、这个写法会出什么问题： @property (copy) NSMutableArray *array;</h3><pre><code>两个问题：1、添加,删除,修改数组内的元素的时候,程序会因为找不到对应的方法而崩溃.因为 copy 就是复制一个不可变 NSArray 的对象；2、使用了 atomic 属性会严重影响性能 ；
1、NSMutableArray *array = [NSMutableArray                                 arrayWithObjects:@1,@2,nil];
    self.mutableArray = array;
    [self.mutableArray removeObjectAtIndex:0];
    执行会崩溃
2、该属性使用了同步锁，会在创建时生成一些额外的代码用于帮助编写多线程程序，这会带来性能问题，通过声明 nonatomic 可以节省这些虽然很小但是不必要额外开销</code></pre>
<h3 id="7、-property-的本质是什么？ivar、getter、setter-是如何生成并添加到这个类中的"><a href="#7、-property-的本质是什么？ivar、getter、setter-是如何生成并添加到这个类中的" class="headerlink" title="7、@property 的本质是什么？ivar、getter、setter 是如何生成并添加到这个类中的"></a>7、@property 的本质是什么？ivar、getter、setter 是如何生成并添加到这个类中的</h3><pre><code>@property 的本质是什么？
@property = ivar + getter + setter;
下面解释下：
“属性” (property)有两大概念：ivar（实例变量）、存取方法（access method ＝ getter + setter）。
ivar、getter、setter 是如何生成并添加到这个类中的?
“自动合成”( autosynthesis)

完成属性定义后，编译器会自动编写访问这些属性所需的方法，此过程叫做“自动合成”(autosynthesis)。需要强调的是，这个过程由编译 器在编译期执行，所以编辑器里看不到这些“合成方法”(synthesized method)的源代码。除了生成方法代码 getter、setter 之外，编译器还要自动向类中添加适当类型的实例变量，并且在属性名前面加下划线，以此作为实例变量的名字。在前例中，会生成两个实例变量，其名称分别为 _firstName 与 _lastName。也可以在类的实现代码里通过 @synthesize 语法来指定实例变量的名字.
@implementation Person
@synthesize firstName = _myFirstName;
@synthesize lastName = _myLastName;
@end
我为了搞清属性是怎么实现的,曾经反编译过相关的代码,他大致生成了五个东西

OBJC_IVAR_$类名$属性名称 ：该属性的“偏移量” (offset)，这个偏移    量是“硬编码” (hardcode)，表示该变量距离存放对象的内存区域的起始地    址有多远。
setter 与 getter 方法对应的实现函数
ivar_list ：成员变量列表
method_list ：方法列表
prop_list ：属性列表
也就是说我们每次在增加一个属性,系统都会在 ivar_list 中添加一个成员变量的描述,在 method_list 中增加 setter 与 getter 方法的描述,在属性列表中增加一个属性的描述,然后计算该属性在对象中的偏移量,然后给出 setter 与 getter 方法对应的实现,在 setter 方法中从偏移量的位置开始赋值,在 getter 方法中从偏移量开始取值,为了能够读取正确字节数,系统对象偏移量的指针类型进行了类型强转.</code></pre>
<h3 id="8-protocol-和-category-中如何使用-property"><a href="#8-protocol-和-category-中如何使用-property" class="headerlink" title="8 @protocol 和 category 中如何使用 @property"></a>8 @protocol 和 category 中如何使用 @property</h3><pre><code>1、在 protocol 中使用 property 只会生成 setter 和 getter 方法声明,我们使用属性的目的,是希望遵守我协议的对象能实现该属性
2、category 使用 @property 也是只会生成 setter 和 getter 方法的声明,如果我们真的需要给 category 增加属性的实现,需要借助于运行时的两个函数：

objc_setAssociatedObject
objc_getAssociatedObject</code></pre>
<h3 id="10-property中有哪些属性关键字？-property-后面可以有哪些修饰符？"><a href="#10-property中有哪些属性关键字？-property-后面可以有哪些修饰符？" class="headerlink" title="10  @property中有哪些属性关键字？ @property 后面可以有哪些修饰符？"></a>10  @property中有哪些属性关键字？ @property 后面可以有哪些修饰符？</h3><pre><code>1、原子性--- nonatomic 特质
2、读/写权限---readwrite(读写)、readonly (只读)
3、内存管理语义---assign、strong、 weak、unsafe_unretained、copy
4、方法名---getter=&lt;name&gt; 、setter=&lt;name&gt;

        getter=&lt;name&gt;的样式：

  @property (nonatomic, getter=isOn) BOOL on;

  setter=&lt;name&gt;一般用在特殊的情境下，比如：
      在数据反序列化、转模型的过程中，服务器返回的字段如果以 init 开头，所以你需要定义一个 init 开头的属性，但默认生成的 setter 与 getter 方法也会以 init 开头，而编译器会把所有以 init 开头的方法当成初始化方法，而初始化方法只能返回 self 类型，因此编译器会报错。
      避免方法：
      @property(nonatomic, strong, getter=p_initBy, setter=setP_initBy:)NSString *initBy;</code></pre>
<h3 id="11、weak属性需要在dealloc中置nil么？"><a href="#11、weak属性需要在dealloc中置nil么？" class="headerlink" title="11、weak属性需要在dealloc中置nil么？"></a>11、weak属性需要在dealloc中置nil么？</h3><pre><code>不需要
在ARC环境无论是强指针还是弱指针都无需在 dealloc 设置为 nil ， ARC 会自动帮我们处理
在属性所指的对象遭到摧毁时，属性值也会清空(nil out)。</code></pre>
<h3 id="12、-synthesize和-dynamic分别有什么作用？"><a href="#12、-synthesize和-dynamic分别有什么作用？" class="headerlink" title="12、 @synthesize和@dynamic分别有什么作用？"></a>12、 @synthesize和@dynamic分别有什么作用？</h3><pre><code>@property有两个对应的词，一个是 @synthesize，一个是 @dynamic。如果 @synthesize和 @dynamic都没写，那么默认的就是@syntheszie var = _var;
@synthesize 的语义是如果你没有手动实现 setter 方法和 getter 方法，那么编译器会自动为你加上这两个方法。
@dynamic 告诉编译器：属性的 setter 与 getter 方法由用户自己实现，不自动生成。（当然对于 readonly 的属性只需提供 getter 即可）。假如一个属性被声明为 @dynamic var，然后你没有提供 @setter方法和 @getter 方法，编译的时候没问题，但是当程序运行到 instance.var = someVar，由于缺 setter 方法会导致程序崩溃；或者当运行到 someVar = var 时，由于缺 getter 方法同样会导致崩溃。编译时没问题，运行时才执行相应的方法，这就是所谓的动态绑定。</code></pre>
<h3 id="13、ARC下，不显式指定任何属性关键字时，默认的关键字都有哪些"><a href="#13、ARC下，不显式指定任何属性关键字时，默认的关键字都有哪些" class="headerlink" title="13、ARC下，不显式指定任何属性关键字时，默认的关键字都有哪些"></a>13、ARC下，不显式指定任何属性关键字时，默认的关键字都有哪些</h3><pre><code>1、对应基本数据类型默认关键字是

atomic,readwrite,assign

2、对于普通的 Objective-C 对象

atomic,readwrite,strong</code></pre>
<h3 id="14、用-property声明的NSString（或NSArray，NSDictionary）经常使用copy关键字，为什么？如果改用strong关键字，可能造成什么问题"><a href="#14、用-property声明的NSString（或NSArray，NSDictionary）经常使用copy关键字，为什么？如果改用strong关键字，可能造成什么问题" class="headerlink" title="14、用@property声明的NSString（或NSArray，NSDictionary）经常使用copy关键字，为什么？如果改用strong关键字，可能造成什么问题"></a>14、用@property声明的NSString（或NSArray，NSDictionary）经常使用copy关键字，为什么？如果改用strong关键字，可能造成什么问题</h3><pre><code>1、因为父类指针可以指向子类对象,使用 copy 的目的是为了让本对象的属性不受外界影响,使用 copy 无论给我传入是一个可变对象还是不可对象,我本身持有的就是一个不可变的副本.
2、如果我们使用是 strong ,那么这个属性就有可能指向一个可变对象,如果这个可变对象在外部被修改了,那么会影响该属性.
对非集合类对象的copy操作：
[immutableObject copy] // 浅复制
[immutableObject mutableCopy] //深复制
[mutableObject copy] //深复制
[mutableObject mutableCopy] //深复制
集合类对象的copy与mutableCopy：
[immutableObject copy] // 浅复制
[immutableObject mutableCopy] //单层深复制
[mutableObject copy] //单层深复制
[mutableObject mutableCopy] //单层深复制
在集合类对象中，对 immutable 对象进行 copy，是指针复制， mutableCopy 是内容复制；对 mutable 对象进行 copy 和 mutableCopy 都是内容复制。但是：集合对象的内容复制仅限于对象本身，对象元素仍然是指针复制</code></pre>
<h3 id="15、-synthesize合成实例变量的规则是什么？假如property名为foo，存在一个名为-foo的实例变量，那么还会自动合成新变量么？"><a href="#15、-synthesize合成实例变量的规则是什么？假如property名为foo，存在一个名为-foo的实例变量，那么还会自动合成新变量么？" class="headerlink" title="15、@synthesize合成实例变量的规则是什么？假如property名为foo，存在一个名为_foo的实例变量，那么还会自动合成新变量么？"></a>15、@synthesize合成实例变量的规则是什么？假如property名为foo，存在一个名为_foo的实例变量，那么还会自动合成新变量么？</h3><p>.h</p>
<pre><code>@interface CYLPerson : NSObject 
@property NSString *firstName; 
@property NSString *lastName; 
@end</code></pre>
<p>在上例中，会生成两个实例变量，其名称分别为 _firstName 与 _lastName。也可以在类的实现代码里通过 @synthesize 语法来指定实例变量的名字:<br>.m</p>
<pre><code>@implementation CYLPerson 
@synthesize firstName = _myFirstName; 
@synthesize lastName = _myLastName; 
@end</code></pre>
<p>上述语法会将生成的实例变量命名为 _myFirstName 与 _myLastName ，而不再使用默认的名字</p>
<p>@synthesize 合成实例变量的规则:</p>
<pre><code>如果指定了成员变量的名称,会生成一个指定的名称的成员变量,
如果这个成员已经存在了就不再生成了.
如果是 @synthesize foo; 还会生成一个名称为foo的成员变量，也就是说：如果没有指定成员变量的名称会自动生成一个属性同名的成员变量
如果是 @synthesize foo = _foo; 就不会生成成员变量了.</code></pre>
<p>假如 property 名为 foo，存在一个名为 _foo 的实例变量，那么还会自动合成新变量么？</p>
<pre><code>不会，</code></pre>
<p><img src="https://camo.githubusercontent.com/8e11101c9fe0b3defc7fbd144c0dca9fdf0471d0/687474703a2f2f692e696d6775722e636f6d2f743238676534572e706e67" alt="icon"></p>
<h3 id="16、在有了自动合成属性实例变量之后，-synthesize还有哪些使用场景？"><a href="#16、在有了自动合成属性实例变量之后，-synthesize还有哪些使用场景？" class="headerlink" title="16、在有了自动合成属性实例变量之后，@synthesize还有哪些使用场景？"></a>16、在有了自动合成属性实例变量之后，@synthesize还有哪些使用场景？</h3><pre><code>不会autosynthesis的场景：
    同时重写了 setter 和 getter 时
    重写了只读属性的 getter 时
    使用了 @dynamic 时
    在 @protocol 中定义的所有属性
    在 category 中定义的所有属性
    重载的属性
        当你在子类中重载了父类中的属性，你必须 使用 @synthesize             来手动合成ivar。
        在子类中重写父类的属性时，编译的时候会提示问题！！！</code></pre>
<p><img src="https://camo.githubusercontent.com/a569a90281598d8cc74156fe5f0e3a6ddbf8fc6b/687474703a2f2f692e696d6775722e636f6d2f6641454748496f2e706e67" alt="icon"></p>
<pre><code>当你同时重写了 setter 和 getter 时，系统就不会生成 ivar（实例变量/成员变量）。这时候有两种选择
要么如第14行：手动创建 ivar
要么如第17行：使用@synthesize foo = _foo; ，关联 @property 与 ivar。</code></pre>
<h3 id="17、objc中向一个nil对象发送消息将会发生什么"><a href="#17、objc中向一个nil对象发送消息将会发生什么" class="headerlink" title="17、objc中向一个nil对象发送消息将会发生什么"></a>17、objc中向一个nil对象发送消息将会发生什么</h3><pre><code>在 Objective-C 中向 nil 发送消息是完全有效的——只是在运行时不会有任何作用:
1、如果一个方法返回值是一个对象，那么发送给nil的消息将返回0(nil)
2、如果方法返回值为指针类型，其指针大小为小于或者等于sizeof(void*)，float，double，long double 或者 long long 的整型标量，发送给 nil 的消息将返回0
3、如果方法返回值为结构体,发送给 nil 的消息将返回0。结构体中各个字段的值将都是0。
4、如果方法的返回值不是上述提到的几种情况，那么发送给 nil 的消息的返回值将是未定义的。
原因：
objc是动态语言，每个方法在运行时会被动态转为消息发送，即：objc_msgSend(receiver, selector)。

objc在向一个对象发送消息时，runtime库会根据对象的isa指针找到该对象实际所属的类，然后在该类中的方法列表以及其父类方法列表中寻找方法运行，然后在发送消息的时候，objc_msgSend方法不会返回值，所谓的返回内容都是具体调用时执行的。 那么，回到本题，如果向一个nil对象发送消息，首先在寻找对象的isa指针时就是0地址返回了，所以不会出现任何错误。</code></pre>
<h3 id="18、objc中向一个对象发送消息-obj-foo-和objc-msgSend-函数之间有什么关系？"><a href="#18、objc中向一个对象发送消息-obj-foo-和objc-msgSend-函数之间有什么关系？" class="headerlink" title="18、objc中向一个对象发送消息[obj foo]和objc_msgSend()函数之间有什么关系？"></a>18、objc中向一个对象发送消息[obj foo]和objc_msgSend()函数之间有什么关系？</h3><pre><code>该方法编译之后就是objc_msgSend()函数调用
[obj foo];在objc动态编译时，会被转意为：objc_msgSend(obj,     @selector(foo));。
    int main(int argc, char * argv[]) &#123;
    @autoreleasepool &#123;
        CYLTest *test = [[CYLTest alloc] init];
        [test performSelector:(@selector(iOSinit))];
        return 0;
    &#125;
&#125;
具体实现：</code></pre>
<p><img src="https://camo.githubusercontent.com/bf346edc21ab4b3387906602249b357d250ab1c2/687474703a2f2f692e696d6775722e636f6d2f6541483559576e2e706e67" alt="icon"></p>
<h3 id="12、-什么时候会报unrecognized-selector的异常？"><a href="#12、-什么时候会报unrecognized-selector的异常？" class="headerlink" title="12、 什么时候会报unrecognized selector的异常？"></a>12、 什么时候会报unrecognized selector的异常？</h3><pre><code>当调用该对象上某个方法,而该对象上没有实现这个方法的时候， 可以通过“消息转发”进行解决。
objc是动态语言，每个方法在运行时会被动态转为消息发送，即：objc_msgSend(receiver, selector)。
objc在向一个对象发送消息时，runtime库会根据对象的isa指针找到该对象实际所属的类，然后在该类中的方法列表以及其父类方法列表中寻找方法运行，如果，在最顶层的父类中依然找不到相应的方法时，程序在运行时会挂掉并抛出异常unrecognized selector sent to XXX 。但是在这之前，objc的运行时会给出三次拯救程序崩溃的机会：</code></pre>
<p>1、Method resolution</p>
<pre><code>objc运行时会调用+resolveInstanceMethod:或者 +resolveClassMethod:，让你有机会提供一个函数实现。如果你添加了函数，那运行时系统就会重新启动一次消息发送的过程，否则 ，运行时就会移到下一步，消息转发（Message Forwarding）。</code></pre>
<p>2、Fast forwarding</p>
<pre><code>如果目标对象实现了-forwardingTargetForSelector:，Runtime 这时就会调用这个方法，给你把这个消息转发给其他对象的机会。 只要这个方法返回的不是nil和self，整个消息发送的过程就会被重启，当然发送的对象会变成你返回的那个对象。否则，就会继续Normal Fowarding。 这里叫Fast，只是为了区别下一步的转发机制。因为这一步不会创建任何新的对象，但下一步转发会创建一个NSInvocation对象，所以相对更快点。</code></pre>
<p>3、Normal forwarding</p>
<pre><code>这一步是Runtime最后一次给你挽救的机会。首先它会发送-methodSignatureForSelector:消息获得函数的参数和返回值类型。如果-methodSignatureForSelector:返回nil，Runtime则会发出-doesNotRecognizeSelector:消息，程序这时也就挂掉了。如果返回了一个函数签名，Runtime就会创建一个NSInvocation对象并发送-forwardInvocation:消息给目标对象。</code></pre>
<h3 id="13、一个objc对象如何进行内存布局？（考虑有父类的情况）"><a href="#13、一个objc对象如何进行内存布局？（考虑有父类的情况）" class="headerlink" title="13、一个objc对象如何进行内存布局？（考虑有父类的情况）"></a>13、一个objc对象如何进行内存布局？（考虑有父类的情况）</h3><pre><code>所有父类的成员变量和自己的成员变量都会存放在该对象所对应的存储空间中.
每一个对象内部都有一个isa指针,指向他的类对象,类对象中存放着本对象的
    对象方法列表（对象能够接收的消息列表，保存在它所对应的类对象中）
    成员变量的列表,
    属性列表,
它内部也有一个isa指针指向元对象(meta class),元对象内部存放的是类方法列表,类对象内部还有一个superclass的指针,指向他的父类对象</code></pre>
<p><img src="https://camo.githubusercontent.com/cdc02fffae7a70aa00cbb6c0f3675d00728cdaad/687474703a2f2f692e696d6775722e636f6d2f7736747a46787a2e706e67" alt="icon"></p>
<h3 id="14、一个objc对象的isa的指针指向什么？有什么作用？"><a href="#14、一个objc对象的isa的指针指向什么？有什么作用？" class="headerlink" title="14、一个objc对象的isa的指针指向什么？有什么作用？"></a>14、一个objc对象的isa的指针指向什么？有什么作用？</h3><pre><code>指向他的类对象,从而可以找到对象上的方法</code></pre>
<h3 id="15、下面的代码输出什么？"><a href="#15、下面的代码输出什么？" class="headerlink" title="15、下面的代码输出什么？"></a>15、下面的代码输出什么？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@implementation Son : Father</span><br><span class="line">    - (id)init</span><br><span class="line">    &#123;</span><br><span class="line">        self &#x3D; [super init];</span><br><span class="line">        if (self) &#123;</span><br><span class="line">            NSLog(@&quot;%@&quot;, NSStringFromClass([self class]));</span><br><span class="line">            NSLog(@&quot;%@&quot;, NSStringFromClass([super class]));</span><br><span class="line">        &#125;</span><br><span class="line">        return self;</span><br><span class="line">    &#125;</span><br><span class="line">    @end</span><br></pre></td></tr></table></figure>
<pre><code>都输出 Son

这个题目主要是考察关于 Objective-C 中对 self 和 super 的理解。
我们都知道：self 是类的隐藏参数，指向当前调用方法的这个类的实例。那 super 呢？

很多人会想当然的认为“ super 和 self 类似，应该是指向父类的指针吧！”。这是很普遍的一个误区。其实 super 是一个 Magic Keyword， 它本质是一个编译器标示符，和 self 是指向的同一个消息接受者！他们两个的不同点在于：super 会告诉编译器，调用 class 这个方法时，要去父类的方法，而不是本类里的。

上面的例子不管调用[self class]还是[super class]，接受消息的对象都是当前 Son ＊xxx 这个对象。

当使用 self 调用方法时，会从当前类的方法列表中开始找，如果没有，就从父类中再找；而当使用 super 时，则从父类的方法列表中开始找。然后调用父类的这个方法。

这也就是为什么说“不推荐在 init 方法中使用点语法”，如果想访问实例变量 iVar 应该使用下划线（ _iVar ），而非点语法（ self.iVar ）</code></pre>
<h3 id="16、runtime如何通过selector找到对应的IMP地址？（分别考虑类方法和实例方法"><a href="#16、runtime如何通过selector找到对应的IMP地址？（分别考虑类方法和实例方法" class="headerlink" title="16、runtime如何通过selector找到对应的IMP地址？（分别考虑类方法和实例方法"></a>16、runtime如何通过selector找到对应的IMP地址？（分别考虑类方法和实例方法</h3><pre><code>每一个类对象中都一个方法列表,方法列表中记录着方法的名称,方法实现,以及参数类型,其实selector本质就是方法名称,通过这个方法名称就可以在方法列表中找到对应的方法实现.</code></pre>
<h3 id="17、-使用runtime-Associate方法关联的对象，需要在主对象dealloc的时候释放么"><a href="#17、-使用runtime-Associate方法关联的对象，需要在主对象dealloc的时候释放么" class="headerlink" title="17、. 使用runtime Associate方法关联的对象，需要在主对象dealloc的时候释放么"></a>17、. 使用runtime Associate方法关联的对象，需要在主对象dealloc的时候释放么</h3><pre><code>无论在MRC下还是ARC下均不需要。</code></pre>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 对象的内存销毁时间表</span><br><span class="line">&#x2F;&#x2F; http:&#x2F;&#x2F;weibo.com&#x2F;luohanchenyilong&#x2F; (微博@iOS程序犭袁)</span><br><span class="line">&#x2F;&#x2F; https:&#x2F;&#x2F;github.com&#x2F;ChenYilong</span><br><span class="line">&#x2F;&#x2F; 根据 WWDC 2011, Session 322 (36分22秒)中发布的内存销毁时间表 </span><br><span class="line"></span><br><span class="line"> 1. 调用 -release ：引用计数变为零</span><br><span class="line">     * 对象正在被销毁，生命周期即将结束.</span><br><span class="line">     * 不能再有新的 __weak 弱引用， 否则将指向 nil.</span><br><span class="line">     * 调用 [self dealloc] </span><br><span class="line"> 2. 父类 调用 -dealloc</span><br><span class="line">     * 继承关系中最底层的父类 在调用 -dealloc</span><br><span class="line">     * 如果是 MRC 代码 则会手动释放实例变量们（iVars）</span><br><span class="line">     * 继承关系中每一层的父类 都在调用 -dealloc</span><br><span class="line"> 3. NSObject 调 -dealloc</span><br><span class="line">     * 只做一件事：调用 Objective-C runtime 中的 object_dispose() 方法</span><br><span class="line"> 4. 调用 object_dispose()</span><br><span class="line">     * 为 C++ 的实例变量们（iVars）调用 destructors </span><br><span class="line">     * 为 ARC 状态下的 实例变量们（iVars） 调用 -release </span><br><span class="line">     * 解除所有使用 runtime Associate方法关联的对象</span><br><span class="line">     * 解除所有 __weak 引用</span><br><span class="line">     * 调用 free()</span><br></pre></td></tr></table></figure>

<h3 id="18、-objc中的类方法和实例方法有什么本质区别和联系？"><a href="#18、-objc中的类方法和实例方法有什么本质区别和联系？" class="headerlink" title="18、 objc中的类方法和实例方法有什么本质区别和联系？"></a>18、 objc中的类方法和实例方法有什么本质区别和联系？</h3><pre><code>类方法：

类方法是属于类对象的
类方法只能通过类对象调用
类方法中的self是类对象
类方法可以调用其他的类方法
类方法中不能访问成员变量
类方法中不定直接调用对象方法

实例方法：
实例方法是属于实例对象的
实例方法只能通过实例对象调用
实例方法中的self是实例对象
实例方法中可以访问成员变量
实例方法中直接调用实例方法
实例方法中也可以调用类方法(通过类名)</code></pre>
<h3 id="9-runtime-如何实现-weak-属性"><a href="#9-runtime-如何实现-weak-属性" class="headerlink" title="9  runtime 如何实现 weak 属性"></a>9  runtime 如何实现 weak 属性</h3><pre><code>weak属性的特点：
weak 此特质表明该属性定义了一种“非拥有关系” (nonowning relationship)。为这种属性设置新值时，设置方法既不保留新值，也不释放旧值。此特质同 assign 类似， 然而在属性所指的对象遭到摧毁时，属性值也会清空(nil out)。</code></pre>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>靠谱的iOS程序员</tag>
      </tags>
  </entry>
  <entry>
    <title>基于响应者链条的事件传递方式</title>
    <url>/2020/07/02/responsechainevent/</url>
    <content><![CDATA[<p>随着业务越来越负责，APP中的页面也变得越来越负责，层级变的越来越深，不论项目是MVC还是MVVM架构，我们都倾向于将事件的处理放到控制器中。随着层级越来越复杂，事件处理方法越来越多，为此我们的解决方案一般都是将部分处理事件放到viewmodel中或者给控制器添加分类。但这些方法都不能避免事件一层层的传递。那么有没有更好的方法呢？</p>
<a id="more"></a>

<p>随着业务越来越负责，APP中的页面也变得越来越负责，层级变的越来越深，不论项目是MVC还是MVVM架构，我们都倾向于将事件的处理放到控制器中。随着层级越来越复杂，事件处理方法越来越多，为此我们的解决方案一般都是将部分处理事件放到viewmodel中或者给控制器添加分类。但这些方法都不能避免事件一层层的传递。那么有没有更好的方法呢？</p>
<p>我们都知道屏幕上的某个按钮被点击之后，系统会先寻找最佳响应者然后在将事件交给最佳响应者去处理。这里我们可以看到其实每个事件的处理，系统也是在通过某些方法去找到一个最佳的响应者，那么我们是否可以利用这个过程呢？</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggn0pu39ooj31080lywgd.jpg" alt="响应者链条"></p>
<p>响应者链的链路是: </p>
<p>subview -&gt; view –&gt; (viewController) –&gt; parentView –&gt; … –&gt; UIWindow –&gt; UIApplication</p>
<p>有没有感觉 这个其实跟我们的事件传递是一样的，我们在处理事件的时候也是想将子视图中的某些响应事件一层一层的传到控制器中，最终在控制器中处理这个事件。</p>
<h2 id="现有的传递方式和弊端"><a href="#现有的传递方式和弊端" class="headerlink" title="现有的传递方式和弊端"></a>现有的传递方式和弊端</h2><p>目前我们事件传递的方式主要有：</p>
<ul>
<li>代理</li>
<li>block</li>
<li>通知</li>
<li>KVO</li>
<li>直接property传值</li>
</ul>
<p>很明显，除了通知其他几种一对一的传递方式，在层次比较深的场景下我们都需要做大量的事件传递，这就导致我们创建了大量的作用相似的block或者代理。</p>
<p>那么到底有没有更好的方法呢？</p>
<p>首先我们再次明确下，我们的目的: <code>优化复杂场景下事件传递方式，简化事件传递时的代码。</code></p>
<p>下面 我们通过下面的例子来具体分析下：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ggn1cvmukhj30je0km0td.jpg" alt="示例"></p>
<p>下面是上图展示视图的层级结构：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ggn1f8szz9j30v00u0jth.jpg" alt="层次结构"></p>
<p>上面的示例中我们有两个按钮，这两个按钮的点击事件我们都需要像外部传递。</p>
<p>下面先来看下传统的方式我们是如何向外部传递的(以delegate为例):</p>
<h3 id="声明协议"><a href="#声明协议" class="headerlink" title="声明协议"></a>声明协议</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">LWCyanViewDelegate</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 按钮的点击事件</span></span><br><span class="line"><span class="comment">/// @param cyanView cyanView description</span></span><br><span class="line">- (<span class="keyword">void</span>)cyanViewButtonDidClick:(LWCyanView *_Nullable)cyanView;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="代理调用"><a href="#代理调用" class="headerlink" title="代理调用"></a>代理调用</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)buttonDidClick &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.delegate &amp;&amp; [<span class="keyword">self</span>.delegate respondsToSelector:<span class="keyword">@selector</span>(cyanViewButtonDidClick:)]) &#123;</span><br><span class="line">        [<span class="keyword">self</span>.delegate cyanViewButtonDidClick:<span class="keyword">self</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="设置代理"><a href="#设置代理" class="headerlink" title="设置代理"></a>设置代理</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="keyword">id</span> &lt;LWCyanViewDelegate&gt; delegate;</span><br></pre></td></tr></table></figure>

<p>按照上面的步骤 我们要在示例中的<br>[purpleView] -&gt; [LWGreenView] -&gt; [LWBlueView] -&gt; [subController.view] -&gt; [ViewController.view] 中每层都要实现上面的三个步骤。</p>
<p>这种实现过于复杂，而我们想要做的只是响应按钮的点击事件。</p>
<p>导致的问题：</p>
<p>由于这种方式需要层层传递，所以有些偷懒的同事就直接将事件的处理放到了view视图里，这样我们就不用传递事件了。但是这将导致更加严重的问题:视图复用。如果这个视图我们需要在其他位置复用，但是点击的响应事件我们不在是之前的那个，这样我们应该如何修改？</p>
<p>还有些同事，不希望层层的实现和调用方法，因此选择将最外层的控制器作为代理 一层层的向内传递。但是这种做法同样存在一些问题，比如控制器遵守了某些层次较深的子视图的协议，但是这些视图实际上并不是直接加载当前控制器视图上的，而且当我们重用这个控制器的某些子视图时 我们不知道要处理那些事件，相反我们必须传递一个代理，但是起初我们是并不知道这个代理需要实现那些方法的。</p>
<p>同时，因为代理的方法如果是<code>required</code>的方法但是未实现时，还会导致方法调用的崩溃。</p>
<p>针对上面使用代理进行事件传递存在的问题,我们希望比较好的事件传递方式应该具备:</p>
<ul>
<li>省略层层的协议声明、代理方法调用、代理的设置</li>
<li>在最外部的控制器中我们可以知道我们需要处理那些方法，以及如何处理</li>
<li>如果外部方法不存在，内部调用时不会导致崩溃</li>
</ul>
<h2 id="如何利用响应者链条进行事件传递"><a href="#如何利用响应者链条进行事件传递" class="headerlink" title="如何利用响应者链条进行事件传递"></a>如何利用响应者链条进行事件传递</h2><h3 id="查找最佳响应者"><a href="#查找最佳响应者" class="headerlink" title="查找最佳响应者"></a>查找最佳响应者</h3><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ggn2npr3bpj312o0sa406.jpg"></p>
<p>查找最佳响应者的过程如上图，而其中最主要依赖的方法是</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>：- (<span class="keyword">nullable</span> <span class="built_in">UIView</span> *)hitTest:(<span class="built_in">CGPoint</span>)point withEvent:(<span class="keyword">nullable</span> <span class="built_in">UIEvent</span> *)event;</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>: - (<span class="built_in">BOOL</span>)pointInside:(<span class="built_in">CGPoint</span>)point withEvent:(<span class="keyword">nullable</span> <span class="built_in">UIEvent</span> *)event;</span><br></pre></td></tr></table></figure>

<p>通过上面方法的递归调用 我们就可以找到某个事件的最佳响应者。</p>
<h3 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h3><p>Application 已经找到了第一响应者对象，接下来 UIWindow 会将封装好的 <code>UIEvent</code> 对象，直接交给第一响应者，让其处理</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ggn2npkq8fj315a0oojt8.jpg"></p>
<p>但是 如果第一响应者选择不处理这个事件，那么这个事件会根据响应者联调一次向上寻找下一个最佳响应者。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ggn2tyyrc4j310n0lhwfu.jpg"></p>
<p>具体过程如上图的左边部分：</p>
<p>当第一响应者不能处理 <code>UIEvent</code> 的时候，事件会被转发给下一个响应者(next Responder)，下一个响应者不能处理，则继续传递给 next Responder ，以此类推下去，便形成了响应者链。<code>UIResponder</code> 的属性 <code>nextResponder</code> 是建立响应者链的桥梁:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">nullable</span>) <span class="built_in">UIResponder</span> *nextResponder;</span><br></pre></td></tr></table></figure>

<p>既然当最佳响应者选择不处理某个事件时，系统会自动向上查找下一个最佳响应者。那么我们是否可以利用这个机制来帮我们实现自定义的方法的数据传递。</p>
<p>当A按钮被点击时，我们调用某个方法(方法参数可以确定是A按钮被点击)，如果这个方法没有实现，我们就去调用下一个响应者的这个方法，如果仍未实现那么继续向下查找，直到找到这个方法为止，如果到了<code>UIApplication</code>仍未能处理这个方法，那么直接丢弃。</p>
<p>但是有一个明显的问题，我们的时间传递依赖<code>UIResponder</code>，那如果某些控件不继承自<code>UIResponder</code>呢？</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">Responder objects—that is, instances of </span><br><span class="line"><span class="built_in">UIResponder</span>—constitute the event-handling </span><br><span class="line">backbone of a <span class="built_in">UIKit</span> app. Many key objects are also responders, including the </span><br><span class="line"><span class="built_in">UIApplication</span> object, <span class="built_in">UIViewController</span> objects, and all <span class="built_in">UIView</span> objects (which</span><br><span class="line"> includes <span class="built_in">UIWindow</span>). As events occur, <span class="built_in">UIKit</span> dispatches them to your app<span class="string">&#x27;s </span></span><br><span class="line"><span class="string"> responder objects for handling.</span></span><br></pre></td></tr></table></figure>

<p>从上面的介绍中，我们可以看出我们平时使用的类基本都是继承<code>UIResponder</code>，他是仅次于NSObject的基类存在。</p>
<p>既然不用考虑某些控件可能不继承自UIResponder的问题，那么该如何实现呢？</p>
<h2 id="如何实现利用响应者链条实现事件传递"><a href="#如何实现利用响应者链条实现事件传递" class="headerlink" title="如何实现利用响应者链条实现事件传递"></a>如何实现利用响应者链条实现事件传递</h2><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>因为上面我们说了要利用响应者链条，那么我们先给<code>UIResponder</code>做一个分类</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UIResponder</span>+LW.h</span><br><span class="line">- (<span class="keyword">void</span>)routerEventWithName:(<span class="built_in">NSString</span> *)eventName userInfo:(<span class="built_in">NSDictionary</span> *)userInfo;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UIResponder</span>+LW..m</span><br><span class="line">- (<span class="keyword">void</span>)routerEventWithName:(<span class="built_in">NSString</span> *)eventName userInfo:(<span class="built_in">NSDictionary</span> *)userInfo</span><br><span class="line">&#123;</span><br><span class="line">    [[<span class="keyword">self</span> nextResponder] routerEventWithName:eventName userInfo:userInfo];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样我们在按钮响应事件时调用分类中的方法</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)buttonDidClick &#123;</span><br><span class="line">    [<span class="keyword">self</span> routerEventWithName:<span class="string">@&quot;:LWButton DidClick&quot;</span> userInfo:@&#123;<span class="string">@&quot;test&quot;</span>:<span class="string">@&quot;test&quot;</span>&#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么这个方法就会顺着相应者链条依次调用，那么到了控制器中我们该如何处理呢？</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)routerEventWithName:(<span class="built_in">NSString</span> *)eventName userInfo:(<span class="built_in">NSDictionary</span> *)userInfo &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;event name %@  info%@&quot;</span>,eventName,userInfo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们只需要实现这个方法，同时保证不再继续调用下一个响应者的这个方法。就表示这里已经将对应事件处理完成。不需要外部的响应者继续处理。</p>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>对于复杂的页面来说，我们要处理的事件肯定会非常多，不同的事件需要处理的方式也不同。那么在最终控制器里的<code>routerEventWithName</code>方法中 我们可能会写大量的<code>if/else</code>。</p>
<p>大量的<code>if/else</code>虽然逻辑比较清晰，但是维护起来非常复杂，那么该如何解决这个问题呢？</p>
<p>其实对于了解设计模式的人来说，有一种设计模式叫做策略模式，这种模式是专门用来解决类似问题的。下面我们来具体看下改怎么实现。</p>
<p>首先，对于策略模式我们要确定的是策略。我们可以根据类型进行区分，这个类型最好可以一对多，这样策略模式作用才能最大的提现。</p>
<p>例如我们可以根据视图作为策略进行区分。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggnacf0cmtj30jg090mxa.jpg"></p>
<p>上图父视图中有两个子视图，每个子视图都有4个事件需要处理。<br>这里我们有两种方式指定策略</p>
<p>1、以视图作为区分策略</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (A || B || C || D)</span><br><span class="line">    <span class="keyword">return</span> Strategy1</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (F || G || H || I ) </span><br><span class="line">    <span class="keyword">return</span> Strategy2</span><br></pre></td></tr></table></figure>

<p>2、根据预定规范的方法名</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ([eventName hasPrefix:A])</span><br><span class="line">    <span class="keyword">return</span> Strategy1</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ([eventName hasPrefix:B]) </span><br><span class="line">    <span class="keyword">return</span> Strategy2</span><br></pre></td></tr></table></figure>

<p>实际应用<br>普通视图方法解耦 （一对一）<br>假设我们有6个事件需要处理，那么我们首先需要维护6个事件名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kULAViewEventA,kULAViewEventB,kULAViewEventC,kULAViewEventD</span><br><span class="line">kULBViewEventF,kULBViewEventG,kULBViewEventH,kULBViewEventI</span><br></pre></td></tr></table></figure>

<p>其次我们需要维护一个映射表或者条件转换方法</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">NSDictionary</span> &lt;<span class="built_in">NSString</span> *, <span class="built_in">NSInvocation</span> *&gt; *)eventStrategy</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (_eventStrategy == <span class="literal">nil</span>) &#123;</span><br><span class="line">        _eventStrategy = @&#123;</span><br><span class="line">                               kULAViewEventA:[<span class="keyword">self</span> createInvocationWithSelector:<span class="keyword">@selector</span>(aViewEventA:)],</span><br><span class="line">                               kULAViewEventB:[<span class="keyword">self</span> createInvocationWithSelector:<span class="keyword">@selector</span>(aViewEventB:)],</span><br><span class="line">                               kULAViewEventC:[<span class="keyword">self</span> createInvocationWithSelector:<span class="keyword">@selector</span>(aViewEventC:)],</span><br><span class="line">                               kULAViewEventD:[<span class="keyword">self</span> createInvocationWithSelector:<span class="keyword">@selector</span>(aViewEventD:)],</span><br><span class="line">                               kULBViewEventF:[<span class="keyword">self</span> createInvocationWithSelector:<span class="keyword">@selector</span>(bViewEventA:)],</span><br><span class="line">                               kULBViewEventG:[<span class="keyword">self</span> createInvocationWithSelector:<span class="keyword">@selector</span>(bViewEventB:)],</span><br><span class="line">                               kULBViewEventH:[<span class="keyword">self</span> createInvocationWithSelector:<span class="keyword">@selector</span>(bViewEventC:)],</span><br><span class="line">                               kULBViewEventI:[<span class="keyword">self</span> createInvocationWithSelector:<span class="keyword">@selector</span>(bViewEventD:)]</span><br><span class="line">                               &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _eventStrategy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这个方法，我们可以在调用的时候通过下面的方法完成转换 然后进行方法的执行</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)routerEventWithName:(<span class="built_in">NSString</span> *)eventName userInfo:(<span class="built_in">NSDictionary</span> *)userInfo</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSInvocation</span> *invocation = <span class="keyword">self</span>.eventStrategy[eventName];</span><br><span class="line">    [invocation setArgument:&amp;userInfo atIndex:<span class="number">2</span>];</span><br><span class="line">    [invocation invoke];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样我们我们就可以将大量的<code>if/else</code>转换为上面的几句代码实现，但是不可否认的是，这个过程中我们需要维护一个<code>映射表</code>，所以我们每次添加方法的时候都需要添加一个对应的事件名。这里实际上是有可以继续优化的，如果大家有好的方法可以给我留言。</p>
<h3 id="schema处理（一对多）"><a href="#schema处理（一对多）" class="headerlink" title="schema处理（一对多）"></a>schema处理（一对多）</h3><p>每个APP可能都维护了大量的scheme跳转路径，比如 <code>a://b/c?id=1</code>这个scheme，我们通过这个scheme就知道我们应该跳转到b业务c页面参数为id=1。但是我们在处理scheme的位置可能会有大量的判断。而且这些判断的位置都集中在一起，也给我们组件化造成了一定的困扰。</p>
<p>下面我们就尝试使用策略模式进行优化 我们先看下之前的逻辑</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)handleOpenScheme:(<span class="built_in">NSString</span> *)scheme</span><br><span class="line"><span class="keyword">if</span>([scheme hasPrefix:<span class="string">@&quot;http&quot;</span>]) &#123;</span><br><span class="line">    <span class="comment">// 跳转到网页</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> ([scheme hasPrefix:<span class="string">@&quot;projectName&quot;</span>]) &#123;</span><br><span class="line">    <span class="comment">// 项目自身的scheme</span></span><br><span class="line">    <span class="keyword">if</span>([scheme isEqualToString:<span class="string">@&quot;APage&quot;</span>]) &#123;</span><br><span class="line">        <span class="comment">// 跳转到A页面</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>([scheme isEqualToString:<span class="string">@&quot;BPage&quot;</span>]) &#123;</span><br><span class="line">        <span class="comment">// 跳转到B页面</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>([scheme isEqualToString:<span class="string">@&quot;CPage&quot;</span>]) &#123;</span><br><span class="line">        <span class="comment">// 跳转到C页面</span></span><br><span class="line">    &#125;</span><br><span class="line">    .....</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 暂不支持的方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的代码我们可以看出 基本上APP有多少个页面这里就会有多少个if/else。随着我们项目组件化的进程我们也需要将这些跳转方法分散到各个模块当中。</p>
<p>假设我们的项目中目前有四大模块：</p>
<ul>
<li>小说模块</li>
<li>直播间模块</li>
<li>广播剧模块</li>
<li>个人主页模块</li>
</ul>
<p>那么我们先声明一个协议，协议中是处理跳转的方法</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">ULHandleSchemeDelegate</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)handleScheme:(<span class="built_in">NSString</span> *)scheme;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们实现四个实体类：<code>NovelSchemeHandler</code>、<code>LiveSchemeHandler</code>、<code>DramaSchemeHandler</code>、<code>UserProfileSchemeHandler</code></p>
<p>这四个类都遵守了<code>ULHandleSchemeDelegate</code>这个协议并实现了方法。</p>
<p>下面我们来重新实现下之前的方法</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)handleOpenScheme:(<span class="built_in">NSString</span> *)scheme</span><br><span class="line">    <span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:scheme];</span><br><span class="line">    <span class="keyword">if</span>([scheme hasPrefix:<span class="string">@&quot;http&quot;</span>]) &#123;</span><br><span class="line">        <span class="comment">// 跳转到网页</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ([url isEqualToString:<span class="string">@&quot;Live&quot;</span>]) &#123;</span><br><span class="line">            <span class="comment">// 直播模块处理 请忽略这里直接创建对应模块实例的方式</span></span><br><span class="line">            <span class="keyword">return</span> [[LiveSchemeHandler new] handleScheme:scheme];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([url.host isEqualToString:<span class="string">@&quot;Novel&quot;</span>]) &#123;</span><br><span class="line">            <span class="comment">// 小说模块 请忽略这里直接创建对应模块实例的方式</span></span><br><span class="line">            <span class="keyword">return</span> [[NovelSchemeHandler new] handleScheme:scheme];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([url.host isEqualToString:<span class="string">@&quot;Drama&quot;</span>]) &#123;</span><br><span class="line">            <span class="comment">// 话剧模块 请忽略这里直接创建对应模块实例的方式</span></span><br><span class="line">            <span class="keyword">return</span> [[DramaSchemeHandler new] handleScheme:scheme];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([url.host isEqualToString:<span class="string">@&quot;Novel&quot;</span>]) &#123;</span><br><span class="line">            <span class="comment">// 个人主页 请忽略这里直接创建对应模块实例的方式</span></span><br><span class="line">            <span class="keyword">return</span> [[UserProfileSchemeHandler new] handleScheme:scheme];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 暂不支持的方法</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过这中方式进行修改后，scheme的跳转变的更加清晰也更加容易维护了。当然我们还可以进行进一步的维护，添加一个映射方法</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">id</span> &lt;ULHandleSchemeDelegate&gt; )schemeHandlerForScheme:(<span class="built_in">NSString</span> *)scheme &#123;</span><br><span class="line">    <span class="keyword">if</span> ([url isEqualToString:<span class="string">@&quot;Live&quot;</span>]) &#123;</span><br><span class="line">        <span class="comment">// 直播模块处理</span></span><br><span class="line">        <span class="keyword">return</span> [LiveSchemeHandler new];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([url.host isEqualToString:<span class="string">@&quot;Novel&quot;</span>]) &#123;</span><br><span class="line">        <span class="comment">// 小说模块</span></span><br><span class="line">        <span class="keyword">return</span> [NovelSchemeHandler new];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([url.host isEqualToString:<span class="string">@&quot;Drama&quot;</span>]) &#123;</span><br><span class="line">        <span class="comment">// 话剧模块</span></span><br><span class="line">        <span class="keyword">return</span> [DramaSchemeHandler new];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([url.host isEqualToString:<span class="string">@&quot;Novel&quot;</span>]) &#123;</span><br><span class="line">        <span class="comment">// 个人主页</span></span><br><span class="line">        <span class="keyword">return</span> [UserProfileSchemeHandler new];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 暂不支持的方法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样上面的<code>handleOpenScheme</code>方法可进一步简化为：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)handleOpenScheme:(<span class="built_in">NSString</span> *)scheme</span><br><span class="line">    <span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:scheme];</span><br><span class="line">    <span class="keyword">if</span>([scheme hasPrefix:<span class="string">@&quot;http&quot;</span>]) &#123;</span><br><span class="line">        <span class="comment">// 跳转到网页</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">id</span> &lt;ULHandleSchemeDelegate&gt; handler = [<span class="keyword">self</span> schemeHandlerForScheme:scheme];</span><br><span class="line">        [handler handleScheme:scheme];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过上面的方法我们可以将包含大量<code>if/else</code>语句的方法进行精简，而且根据自己的业务模块指定更好的策略，能达到更好的效果。</p>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>对于基于相应者链条的事件传递，其实还有其他的应用场景</p>
<p>控件id 我们埋点的时候有时候希望可以在埋点中携带控件的唯一id，而这个id我们通常是根据路径获取的。我们对分类中的方法稍加改造</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)routerEventWithName:(<span class="built_in">NSString</span> *)eventName userInfo:(<span class="built_in">NSDictionary</span> *)userInfo</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSString</span> *newName = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;%@--%@&quot;</span>,<span class="built_in">NSStringFromClass</span>(<span class="keyword">self</span>.class),eventName];</span><br><span class="line">    [[<span class="keyword">self</span> nextResponder] routerEventWithName:newName userInfo:userInfo];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样当我们处理点击事件的时候是否就可以获取到被点击这个控件在当前页面的id了呢？而这个过程当中是否有其他信息可以通过事件传递携带呢？大家可以根据自己的业务进行发挥！！！</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇文章我们主要介绍了一种新的基于响应者链条的事件传递机制，同时针对这种问题存在的弊端，我们使用策略模式进行简化，让这种方式更具有实用价值，当然对于视图的点击事件这种方法还存在下面两个问题</p>
<p>1、需要维护事件名称<br>2、需要维护不同事件名称与对应处理方法的映射表<br>不过在scheme处理的例子中，这种方式还是有很明显的效果的。</p>
<p>参考文档</p>
<p><a href="https://juejin.im/post/5e77135e6fb9a07ca714dbc4#heading-23">调试iOS用户交互事件响应流程</a></p>
<p><a href="https://www.xiaobotalk.com/2020/03/responder-chain/">iOS 响应者链与事件处理</a></p>
<p><a href="https://casatwy.com/responder_chain_communication.html">一种基于ResponderChain的对象交互方式</a></p>
<p><a href="https://juejin.im/post/5e77135e6fb9a07ca714dbc4#heading-23">调试iOS用户交互事件响应流程</a></p>
]]></content>
      <categories>
        <category>组件化</category>
      </categories>
      <tags>
        <tag>ResponseChain</tag>
      </tags>
  </entry>
  <entry>
    <title>swift知识点(网络搜集)</title>
    <url>/2017/09/05/swift%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<p>近期在学习swift,本篇文章是在网络上看到的一些知识和总结,非原创文章</p>
<a id="more"></a>


<h2 id="一、Swift-常识"><a href="#一、Swift-常识" class="headerlink" title="一、Swift 常识"></a>一、Swift 常识</h2><h2 id="新的访问控制fileprivate和open"><a href="#新的访问控制fileprivate和open" class="headerlink" title="新的访问控制fileprivate和open"></a>新的访问控制fileprivate和open</h2><p>在原有的swift中的 private其实并不是真正的私有，如果一个变量定义为private，在<code>同一个文件</code>中的<code>其他类</code>依然是可以访问到的。这</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class User &#123;</span><br><span class="line">    private var name &#x3D; &quot;private&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extension User&#123;</span><br><span class="line">    var accessPrivate: String &#123;</span><br><span class="line">        return name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样带来了两个问题：</p>
<ul>
<li>1、当我们标记为private时，意为真的私有还是文件内可共享呢？</li>
<li>2、当我们如果意图为真正的私有时，必须保证这个类或者结构体在一个单独的文件里。否则可能同文件里其他的代码访问到。</li>
</ul>
<p>由此，在swift 3中，新增加了一个 fileprivate来显式的表明，这个元素的访问权限为文件内私有。过去的private对应现在的fileprivate。现在的private则是真正的私有，离开了这个类或者结构体的作用域外面就无法访问。</p>
<p>open则是弥补public语义上的不足。</p>
<p>现在的pubic有两层含义：</p>
<ul>
<li>1、这个元素可以在其他作用域被访问</li>
<li>2、这个元素可以在其他作用域被继承或者override</li>
</ul>
<p>继承是一件危险的事情。尤其对于一个framework或者module的设计者而言。在自身的module内，类或者属性对于作者而言是清晰的，能否被继承或者override都是可控的。但是对于使用它的人，作者有时会希望传达出这个类或者属性不应该被继承或者修改。这个对应的就是 <code>final</code>。</p>
<p> <code>final</code>的问题在于在标记之后，在任何地方都不能override。而对于lib的设计者而言，希望得到的是在module内可以被override，在被import到其他地方后其他用户使用的时候不能被override。</p>
<p>这就是 <code>open</code>产生的初衷。通过open和public标记区别一个元素在其他module中是只能被访问还是可以被override。</p>
<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; ModuleA:</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 这个类在ModuleA的范围外是不能被继承的，只能被访问</span><br><span class="line">public class NonSubclassableParentClass &#123;</span><br><span class="line"></span><br><span class="line">    public func foo() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 这是错误的写法，因为class已经不能被继承，</span><br><span class="line">    &#x2F;&#x2F; 所以他的方法的访问权限不能大于类的访问权限</span><br><span class="line">    open func bar() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; final的含义保持不变</span><br><span class="line">    public final func baz() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 在ModuleA的范围外可以被继承</span><br><span class="line">open class SubclassableParentClass &#123;</span><br><span class="line">    &#x2F;&#x2F; 这个属性在ModuleA的范围外不能被override</span><br><span class="line">    public var size : Int</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 这个方法在ModuleA的范围外不能被override</span><br><span class="line">    public func foo() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 这个方法在任何地方都可以被override</span><br><span class="line">    open func bar() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;&#x2F;final的含义保持不变</span><br><span class="line">    public final func baz() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x2F; final的含义保持不变</span><br><span class="line">public final class FinalClass &#123; &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; ModuleB:</span><br><span class="line"></span><br><span class="line">import ModuleA</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 这个写法是错误的，编译会失败</span><br><span class="line">&#x2F;&#x2F; 因为NonSubclassableParentClass类访问权限标记的是public，只能被访问不能被继承</span><br><span class="line">class SubclassA : NonSubclassableParentClass &#123; &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 这样写法可以通过，因为SubclassableParentClass访问权限为 &#96;open&#96;.</span><br><span class="line">class SubclassB : SubclassableParentClass &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 这样写也会编译失败</span><br><span class="line">    &#x2F;&#x2F; 因为这个方法在SubclassableParentClass 中的权限为public，不是&#96;open&#39;.</span><br><span class="line">    override func foo() &#123; &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 这个方法因为在SubclassableParentClass中标记为open，所以可以这样写</span><br><span class="line">    &#x2F;&#x2F; 这里不需要再声明为open，因为这个类是internal的</span><br><span class="line">    override func bar() &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">open class SubclassC : SubclassableParentClass &#123;</span><br><span class="line">    &#x2F;&#x2F; 这种写法会编译失败，因为这个类已经标记为open</span><br><span class="line">    &#x2F;&#x2F; 这个方法override是一个open的方法，则也需要表明访问权限</span><br><span class="line">    override func bar() &#123; &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">open class SubclassD : SubclassableParentClass &#123;</span><br><span class="line">    &#x2F;&#x2F; 正确的写法，方法也需要标记为open</span><br><span class="line">    open override func bar() &#123; &#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">open class SubclassE : SubclassableParentClass &#123;</span><br><span class="line">    &#x2F;&#x2F; 也可以显式的指出这个方法不能在被override</span><br><span class="line">    public final override func bar() &#123; &#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>现在的访问权限则依次为：open，public，internal，fileprivate，private。<br>有的人会觉得访问权限选择的增加加大了语言的复杂度。但是如果我们思考swift语言的设计目标之一就是一门安全的语言（“Designed for Safety”）就能理解这次的改动。更加明确清晰的访问权限控制可以使程序员表达出更准确的意图，当然也迫使在编码时思考的更加深入。</p>
<h2 id="Swift中被忽略的-noescape"><a href="#Swift中被忽略的-noescape" class="headerlink" title="Swift中被忽略的@noescape"></a>Swift中被忽略的@noescape</h2><p>这里需要先介绍一下escape的概念。当一个闭包当做一个参数传进函数里，这个闭包是在这个函数执行完后执行的，这个时候我们就说这个闭包从函数逃出来了（escape）。这种场景很常见，比如我们进行一个异步的请求，请求时会传入一个handler，比如当请求成功后执行达到回调的目的。</p>
<p>众所周知swift的内存管理是引用计数。闭包里用到的数据都需要捕捉到闭包里，保证闭包执行时这些数据不会被释放还在内存里。Xcode为了让我们意识到闭包里用到的对象其实已经被retain了，就要求我们访问当前属性时显示声明self。</p>
<p>这个时候如果新手就很容易犯引用循环的错误。闭包retain了self，self如果又持有retain了闭包。最后就谁都释放不了，内存就泄露了。</p>
<p>这是swift中默认闭包的使用场景。<br>但是这里是有另外一种可能，假设有一个闭包是传入用于sort用的，或者比如作为map参数的闭包。当这行代码执行完成时，这个闭包也就使用完了，之后不会再被执行。这个情况下，闭包就不必再持有里面用到的对象。<br>这就是非escape闭包。</p>
<p>swift里针对非escape用@noescape表示。<br>比如map函数就使用了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func map&lt;T&gt;(@noescape transform: (Self.Generator.Element) throws -&gt; T) rethrows -&gt; [T]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这样标记之后能看到的好处就是这个闭包里如果再使用self的属性不需要加self.了。对于编译器而言，在知道是noescape闭包后可以进行一些内存的优化。</p>
<h2 id="struct和class的区别"><a href="#struct和class的区别" class="headerlink" title="struct和class的区别"></a>struct和class的区别</h2><p>swift中，class是引用类型，struct是值类型。值类型在传递和赋值时将进行复制，而引用类型则只会使用引用对象的一个”指向”。所以他们两者之间的区别就是两个类型的区别。</p>
<p>class有这几个功能struct没有的：</p>
<p>class可以继承，这样子类可以使用父类的特性和方法<br>类型转换可以在runtime的时候检查和解释一个实例的类型<br>可以用deinit来释放资源<br>一个类可以被多次引用</p>
<p>struct也有这样几个优势：</p>
<p>结构较小，适用于复制操作，相比于一个class的实例被多次引用更加安全。<br>无须担心内存memory leak或者多线程冲突问题</p>
<p>顺便提一下，array在swift中是用struct实现的。Apple重写过一次array，然后复制就是深度拷贝了。猜测复制是类似参照那样，通过栈上指向堆上位置的指针来实现的。而对于它的复制操作，也是在相对空间较为宽裕的堆上来完成的，所以性能上还是不错的。</p>
<p>下面引用猫神OneV的博客：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var arr &#x3D; [0,0,0]</span><br><span class="line">var newArr &#x3D; arr</span><br><span class="line">arr[0] &#x3D; 1</span><br><span class="line">&#x2F;&#x2F;Check arr and newArr</span><br><span class="line">arr &#x2F;&#x2F;[1, 0, 0]</span><br><span class="line">newArr &#x2F;&#x2F; before beta3:[1, 0, 0], after beta3:[0, 0, 0]</span><br></pre></td></tr></table></figure>

<p>所以可以猜测其实在背后 Array和 Dictionary的行为并不是像其他 struct 那样简单的在栈上分配，而是类似参照那样，通过栈上指向堆上位置的指针来实现的。而对于它的复制操作，也是在相对空间较为宽裕的堆上来完成的。当然，现在还无法（或者说很难）拿到最后的汇编码，所以这只是一个猜测而已。<br>补充：<br>C语言中，struct与的class的区别：<br>struct只是作为一种复杂数据类型定义，不能用于面向对象编程。</p>
<p>C++中，struct和class的区别：<br>对于成员访问权限以及继承方式，class中默认的是private的，而struct中则是public的。class还可以用于表示模板类型，struct则不行</p>
<h2 id="介绍一下观察者模式"><a href="#介绍一下观察者模式" class="headerlink" title="介绍一下观察者模式"></a>介绍一下观察者模式</h2><p>观察者模式(Observer Pattern)：定义对象间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新。<br>在IOS中典型的推模型实现方式为NSNotificationCenter和KVO。</p>
<p>NSNotificationCenter</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1721232-dd65f5d099b64955.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240/format/jpg" alt="observe"></p>
<p>NSNotificationCenter</p>
<p>观察者Observer，通过NSNotificationCenter的addObserver:selector:name:object接口来注册对某一类型通知感兴趣。在注册时候一定要注意，NSNotificationCenter不会对观察者进行引用计数+1的操作，我们在程序中释放观察者的时候，一定要去报从center中将其注销了。<br>通知中心NSNotificationCenter，通知的枢纽。<br>被观察的对象，通过postNotificationName:object:userInfo:发送某一类型通知，广播改变。<br>通知对象NSNotification，当有通知来的时候，Center会调用观察者注册的接口来广播通知，同时传递存储着更改内容的NSNotification对象。</p>
<p>KVO</p>
<p>KVO的全称是Key-Value Observer，即键值观察。是一种没有中心枢纽的观察者模式的实现方式。一个主题对象管理所有依赖于它的观察者对象，并且在自身状态发生改变的时候主动通知观察者对象。</p>
<p>注册观察者<br>[object addObserver:self forKeyPath:property options:NSKeyValueObservingOptionNew context:]。<br>更改主题对象属性的值，即触发发送更改的通知。<br>在制定的回调函数中，处理收到的更改通知。<br>注销观察者 [object removeObserver:self forKeyPath:property]。</p>
<h2 id="在一个app中间有一个button，在你手触摸屏幕点击后，到这个button收到点击事件，中间发生了什么"><a href="#在一个app中间有一个button，在你手触摸屏幕点击后，到这个button收到点击事件，中间发生了什么" class="headerlink" title="在一个app中间有一个button，在你手触摸屏幕点击后，到这个button收到点击事件，中间发生了什么"></a>在一个app中间有一个button，在你手触摸屏幕点击后，到这个button收到点击事件，中间发生了什么</h2><p>响应链大概有以下几个步骤</p>
<ul>
<li>1、设备将touch到的UITouch和UIEvent对象打包, 放到当前活动的Application的事件队列中</li>
<li>2、单例的UIApplication会从事件队列中取出触摸事件并传递给单例UIWindow</li>
<li>3、UIWindow使用hitTest:withEvent:方法查找touch操作的所在的视图view</li>
</ul>
<h2 id="swiftTip-String还是NSString"><a href="#swiftTip-String还是NSString" class="headerlink" title="swiftTip String还是NSString?"></a>swiftTip String还是NSString?</h2><p>建议尽可能使用原生的String类型，原因有三：</p>
<ul>
<li>1、Cocoa所有的API都接受和返回String类型的参数</li>
<li>2、Swift中String是基于struct，更切合于String <code>不变</code>的特性，这种不变的特性在多线程编程时非常重要，他从原理上将程序员从内存访问和操作顺序的担忧中解放出来,另外在不触及NSString特有的操作和动态特性的时候String性能也有一定提升</li>
<li>3、Swift 实现了像CollectionType这样的接口 因此一些语法特性只有String才有</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let levels &#x3D; &quot;ABCDE&quot;</span><br><span class="line">for level in levels &#123;</span><br><span class="line">    print(level)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用String的唯一比较麻烦的地方在于他和Range的配合</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">“let levels &#x3D; &quot;ABCDE&quot;</span><br><span class="line"></span><br><span class="line">let nsRange &#x3D; NSMakeRange(1, 4)</span><br><span class="line">&#x2F;&#x2F; 编译错误</span><br><span class="line">&#x2F;&#x2F; &#39;NSRange&#39; is not convertible to &#39;Range&lt;String.Index&gt;&#39;</span><br><span class="line">levels.stringByReplacingCharactersInRange(nsRange, withString: &quot;AAAA&quot;)</span><br><span class="line"></span><br><span class="line">let indexPositionOne &#x3D; levels.startIndex.successor()</span><br><span class="line">let swiftRange &#x3D; indexPositionOne..&lt;advance(indexPositionOne, 4)</span><br><span class="line">levels.stringByReplacingCharactersInRange(swiftRange, withString: &quot;AAAA&quot;)</span><br><span class="line">&#x2F;&#x2F; 输出：</span><br><span class="line">&#x2F;&#x2F; AAAAA”</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这种情况下可以将String转换为NSString使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">“let nsRange &#x3D; NSMakeRange(1, 4)</span><br><span class="line">(levels as NSString).stringByReplacingCharactersInRange(</span><br><span class="line">    nsRange, withString: &quot;AAAA&quot;)”</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="从使用场景了解GCD新API"><a href="#从使用场景了解GCD新API" class="headerlink" title="从使用场景了解GCD新API"></a>从使用场景了解GCD新API</h2><p>参考:<a href="http://www.jianshu.com/p/fc78dab5736f">原文</a></p>
<h3 id="dispatch-async"><a href="#dispatch-async" class="headerlink" title="dispatch_async"></a>dispatch_async</h3><p>一个常见的场景就是在一个全局队列进行一些操作后切换到主线程配置UI。现在是这么写</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DispatchQueue.global().async &#123;</span><br><span class="line">    &#x2F;&#x2F; code</span><br><span class="line">    DispatchQueue.main.async &#123;</span><br><span class="line">        &#x2F;&#x2F; 主线程中</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="sync"><a href="#sync" class="headerlink" title="sync"></a>sync</h3><p>如果想同步执行操作，和async类似，调用sync就可以了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DispatchQueue.global().sync &#123;</span><br><span class="line">    &#x2F;&#x2F; 同步执行</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="创建队列"><a href="#创建队列" class="headerlink" title="创建队列"></a>创建队列</h3><p>DispatchQueue的默认初始化方法创建的就是一个同步队列，如果要创建并发的队列，在attributes中声明concurrent。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 同步队列</span><br><span class="line">let serialQueue &#x3D; DispatchQueue(label: &quot;queuename&quot;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 并发队列</span><br><span class="line">let concurrentQueue &#x3D; DispatchQueue(label: &quot;queuename&quot;, attributes: .concurrent)</span><br></pre></td></tr></table></figure>

<h3 id="推迟时间后执行"><a href="#推迟时间后执行" class="headerlink" title="推迟时间后执行"></a>推迟时间后执行</h3><p>原先的dispatch_time_t现在由DispatchTime对象表示。可以用静态方法now获得当前时间，然后再通过加上一个DispatchTimeInterval枚举来获得一个需要延迟的时间。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let delay &#x3D; DispatchTime.now() + DispatchTimeInterval.seconds(60)</span><br><span class="line">DispatchQueue.main.asyncAfter(deadline: delay) &#123; </span><br><span class="line">    &#x2F;&#x2F; 延迟执行</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里也可以直接加上一个秒数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let three &#x3D; DispatchTime.now() + 3.0</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>因为DispatchTime中自定义了+号。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public func +(time: DispatchTime, seconds: Double) -&gt; DispatchTime</span><br></pre></td></tr></table></figure>

<h3 id="DispatchGroup"><a href="#DispatchGroup" class="headerlink" title="DispatchGroup"></a>DispatchGroup</h3><p>如果想在dispatch_queue中所有的任务执行完成后再做某种操作可以使用DispatchGroup。原先的dispatch_group_t由现在的DispatchGroup对象代替。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let group &#x3D; DispatchGroup()</span><br><span class="line"></span><br><span class="line">let queueBook &#x3D; DispatchQueue(label: &quot;book&quot;)</span><br><span class="line">queueBook.async(group: group) &#123;</span><br><span class="line">    &#x2F;&#x2F; 下载图书</span><br><span class="line">&#125;</span><br><span class="line">let queueVideo &#x3D; DispatchQueue(label: &quot;video&quot;)</span><br><span class="line">queueVideo.async(group: group) &#123;</span><br><span class="line">    &#x2F;&#x2F; 下载视频</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">group.notify(queue: DispatchQueue.main) &#123; </span><br><span class="line">    &#x2F;&#x2F; 下载完成</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>DispatchGroup会在组里的操作都完成后执行notify。<br>如果有多个并发队列在一个组里，我们想在这些操作执行完了再继续，调用wait</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">group.wait()</span><br></pre></td></tr></table></figure>


<h3 id="dispatch-once被废弃"><a href="#dispatch-once被废弃" class="headerlink" title="dispatch_once被废弃"></a>dispatch_once被废弃</h3><p>在swift 3中已经被废弃了。<br>简单的建议就是一些初始化场景就用懒加载吧。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Examples of dispatch_once replacements with global or static constants and variables. </span><br><span class="line">&#x2F;&#x2F; In all three, the initialiser is called only once. </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Static properties (useful for singletons).</span><br><span class="line">class Object &#123;</span><br><span class="line">    static let sharedInstance &#x3D; Object()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Global constant.</span><br><span class="line">let constant &#x3D; Object()</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Global variable.</span><br><span class="line">var variable: Object &#x3D; &#123;</span><br><span class="line">    let variable &#x3D; Object()</span><br><span class="line">    variable.doSomething()</span><br><span class="line">    return variable</span><br><span class="line">&#125;()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Swift函数编程之Map、Filter、Reduce"><a href="#Swift函数编程之Map、Filter、Reduce" class="headerlink" title="Swift函数编程之Map、Filter、Reduce"></a>Swift函数编程之Map、Filter、Reduce</h2><h3 id="Swift函数编程之Map"><a href="#Swift函数编程之Map" class="headerlink" title="Swift函数编程之Map"></a>Swift函数编程之Map</h3><p>在Swift语言中使用Map、Filter、Reduce对Array、Dictionary等集合类型（collection type）进行操作可能对一部分人来说还不是那么的习惯。对于没有接触过函数式编程的开发者来说，对集合类型中的数据进行处理的时候第一反应可能就是采用for in遍历。本文将介绍一些Swift中可以采用的新方法</p>
<p>Map函数会遍历集合类型并对其中的每一个元素进行同一种的操作。Map的返回值是一个所得结果的数组。例如：我们要对一个数组里面的数据进行平方操作，常见的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let values: [Double]&#x3D; [2.0,4.0,6.0,8.0]</span><br><span class="line">var squares: [Double] &#x3D; []</span><br><span class="line">for value in values &#123;</span><br><span class="line">    squares.append(value * value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码中，我们使用了常规的for in遍历操作对其中的元素进行了平方操作，然后将计算的结果追加到一个变量数组里面。虽然该部分的代码很好的完成了要求，但是在Swift中我们还有更简洁和安全的代码（上面的squaers是一个变量可能出现无意的数据修改）。下面来看看使用Map进行操作的代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let values: [Double]&#x3D; [2.0,4.0,6.0,8.0]</span><br><span class="line">let squares: [Double] &#x3D; values.map&#123;$0 * $0&#125;</span><br></pre></td></tr></table></figure>

<p>该段代码不仅更加简洁而且squares是一个不可变的常量。</p>
<p>上面代码中的map函数的闭包语法可能对于新手比较难以理解，该闭包中只有一行对集合中数据进行处理的代码并且最终返回了结果数组。为了大家更好的理解map的操作上面的代码可以改写为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let values: [Double]&#x3D; [2.0,4.0,6.0,8.0]</span><br><span class="line">let squares: [Double] &#x3D; values.map(&#123;</span><br><span class="line">    (value: Double)-&gt; Double in</span><br><span class="line">    return value * value</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><code>上面这段改写的代码中闭包里面传入了一个Double类型的参数，并且返回了一个相同类型的处理结果。因为map只需要一个闭包最为参数，所以我们可以使用尾随闭包的特性去除()，而且闭包里面的代码也只有一行我们可以利用单表达式的隐式返回省略return：</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let squares: [Double] &#x3D; values.map&#123;value in value * value&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面value也可以直接使用闭包的参数缩写功能给替换掉：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let squares: [Double] &#x3D; values.map&#123;$0 * $0&#125;</span><br></pre></td></tr></table></figure>

<p>map操作返回的结果数组中元素的类型并不要求与原来的元素类型一致，例如我们可以将一个常见的数字数组转为对应的单词数组：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let scores &#x3D; [0,28,124]</span><br><span class="line">let words &#x3D; scores.map &#123; NSNumberFormatter.localizedStringFromNumber($0, numberStyle: .SpellOutStyle) &#125;</span><br><span class="line">&#x2F;&#x2F;[&quot;zero&quot;, &quot;twenty-eight&quot;, &quot;one hundred twenty-four&quot;]</span><br></pre></td></tr></table></figure>
<p><code>当然除了上面的Array，Set和Dictionary也能应用map操作。</code></p>
<h3 id="Swift函数编程之Filter"><a href="#Swift函数编程之Filter" class="headerlink" title="Swift函数编程之Filter"></a>Swift函数编程之Filter</h3><p>Filter函数操作会对集合类型进行遍历并将其中的满足条件的元素作为结果数组中的元素进行返回。该函数里面只有一个作为条件判断的语句，闭包会遍历集合里面的元素并将满足条件的结果放在一起：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let digits &#x3D; [1,4,10,15] let even &#x3D; digits.filter &#123; $0 % 2 &#x3D;&#x3D; 0 &#125; </span><br><span class="line">&#x2F;&#x2F; [4, 10]</span><br></pre></td></tr></table></figure>

<h3 id="Swift函数编程之Reduce"><a href="#Swift函数编程之Reduce" class="headerlink" title="Swift函数编程之Reduce"></a>Swift函数编程之Reduce</h3><p>Reduce函数操作会将集合类型里面的所有元素组合成一个新值并返回。reduce中的参数为两个：一个初始值、一个combine闭包。例如下面的代码将数组中的元素相加并且其中的初始值为10：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let items &#x3D; [2.0,4.0,5.0,7.0] </span><br><span class="line">let total &#x3D; items.reduce(10.0,combine: +) </span><br><span class="line">&#x2F;&#x2F;28.0</span><br></pre></td></tr></table></figure>

<p>除了上面的数字类型之外也可以对字符串进行处理：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let codes &#x3D; [&quot;Big&quot;,&quot;nerd&quot;,&quot;coding&quot;] </span><br><span class="line">let text &#x3D; codes.reduce(&quot;&quot;, combine: +) </span><br><span class="line">&#x2F;&#x2F;  &quot;Bignerdcoding&quot;</span><br></pre></td></tr></table></figure>

<p>reduce中第二个参数是一个闭包，所有你可以使用尾随闭包来自我特定操作：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let codes &#x3D; [&quot;Big&quot;,&quot;nerd&quot;,&quot;coding&quot;] </span><br><span class="line">let text &#x3D; codes.reduce(&quot;v2ex&quot;) &#123;text, name in &quot;\(text),\(name)&quot;&#125;</span><br><span class="line">&#x2F;&#x2F;  &quot;v2ex,Big,nerd,coding&quot;</span><br></pre></td></tr></table></figure>

<h3 id="Swift函数编程之FlatMap"><a href="#Swift函数编程之FlatMap" class="headerlink" title="Swift函数编程之FlatMap"></a>Swift函数编程之FlatMap</h3><p>该函数会将那些多维集合类型转换为一维集合类型，实例如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let collections &#x3D; [[5,2,7],[4,8],[9,1,3]] let flat &#x3D; collections.flatMap &#123; $0 &#125; </span><br><span class="line">&#x2F;&#x2F; [5, 2, 7, 4, 8, 9, 1, 3]</span><br></pre></td></tr></table></figure>

<p>另外对于可选类型的集合类型来说该函数还能将其中的空值移除掉：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let codes: [String?] &#x3D; [&quot;Big&quot;,nil,&quot;nerd&quot;,nil,&quot;coding&quot;] </span><br><span class="line">let values &#x3D; codes.flatMap &#123;$0&#125; </span><br><span class="line">&#x2F;&#x2F; [&quot;Big&quot;,&quot;nerd&quot;,&quot;coding&quot;]</span><br></pre></td></tr></table></figure>

<p>正在体现flatMap强大功能的地方是与上面一个函数进行组合操作：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let collections &#x3D; [[5,2,7],[4,8],[9,1,3]] </span><br><span class="line">let onlyEven &#x3D; collections.flatMap &#123; </span><br><span class="line">    intArray in intArray.filter &#123; $0 % 2 &#x3D;&#x3D; 0 &#125; </span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; [2, 4, 8]</span><br></pre></td></tr></table></figure>

<p>上面的代码实现了将多维整形数组里面的偶数筛选出来并且组合成了一个一位数组。flatMap操作的参数是一个以[Int]数组作为参数的闭包。当然我们也可以使用隐含参数对其进行简写：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let collections &#x3D; [[5,2,7],[4,8],[9,1,3]] </span><br><span class="line">let onlyEven &#x3D; collections.flatMap &#123; </span><br><span class="line">   $0 in $0.filter &#123; $0 % 2 &#x3D;&#x3D; 0 &#125; </span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; [2, 4, 8]</span><br></pre></td></tr></table></figure>
<p><code>注意：上面简写中第一个和第二个$0表示collections中类似[5,2,7]的字数组，而第三个则表示子数组里面的每个整数</code></p>
<p>与其它操作进行组合的实例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;与map操作的组合以及简写</span><br><span class="line">let allSquared &#x3D; collections.flatMap &#123; </span><br><span class="line">    intArray in intArray.map &#123; $0 * $0 &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; [25, 4, 49, 16, 64, 81, 1, 9]</span><br><span class="line"></span><br><span class="line">let allSquared &#x3D; collections.flatMap &#123; </span><br><span class="line">    $0.map &#123; $0 * $0 &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;与reduce操作的组合以及对等的组合操作</span><br><span class="line">let sums &#x3D; collections.flatMap &#123; $0.reduce(0, combine: +) &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;对应的组合操作，两者结果是一样的</span><br><span class="line">let sums &#x3D; collections.map &#123; $0.reduce(0, combine: +) &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Swift函数编程-链式组合"><a href="#Swift函数编程-链式组合" class="headerlink" title="Swift函数编程 链式组合"></a>Swift函数编程 链式组合</h3><p>我们在上面已经看到了flatMap的闭包里面可以与另一操作的组合。我们还可以在闭包的外面对这些操作进行合理的组合来实现我们的目标。例如将数组中大于某个数字的所有数字进行求和操作：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let marks &#x3D; [4,5,8,2,9,7] </span><br><span class="line">let totalPass &#x3D; marks.filter&#123;$0 &gt;&#x3D; 7&#125;.reduce(0,combine: +) </span><br><span class="line">&#x2F;&#x2F; 24</span><br></pre></td></tr></table></figure>

<p>或者对某一个数组里面的数字进行平方操作然后在进行筛选：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let numbers &#x3D; [20,17,35,4,12] </span><br><span class="line">let evenSquares &#x3D; numbers.map&#123;$0 * $0&#125;.filter&#123;$0 % 2 &#x3D;&#x3D; 0&#125; </span><br><span class="line">&#x2F;&#x2F; [400, 16, 144]</span><br></pre></td></tr></table></figure>

<h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><h3 id="表示和抛出错误"><a href="#表示和抛出错误" class="headerlink" title="表示和抛出错误"></a>表示和抛出错误</h3><p>错误处理是相应和接收来自你程序中错误条件的过程。Swift 给运行时可恢复错误的抛出、捕获、传递和操纵提供了一类支持</p>
<p>在 Swift 中，错误表示为遵循 Error协议类型的值。这个空的协议明确了一个类型可以用于错误处理。<br>Swift 枚举是典型的为一组相关错误条件建模的完美配适类型，关联值还允许错误错误通讯携带额外的信息。比如说，这是你可能会想到的游戏里自动售货机会遇到的错误条件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">enum VendingMachineError: Error &#123;</span><br><span class="line">    case invalidSelection</span><br><span class="line">    case insufficientFunds(coinsNeeded: Int)</span><br><span class="line">    case outOfStock</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>抛出一个错误允许你明确某些意外的事情发生了并且正常的执行流不能继续下去。你可以使用 throw 语句来抛出一个错误。比如说，下面的代码通过抛出一个错误来明确自动售货机需要五个额外的金币：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">throw VendingMachineError.insufficientFunds(coinsNeeded: 5)</span><br></pre></td></tr></table></figure>

<h3 id="处理错误"><a href="#处理错误" class="headerlink" title="处理错误"></a>处理错误</h3><p>当一个错误被抛出，周围的某些代码必须为处理错误响应——比如说，为了纠正错误，尝试替代方案，或者把错误通知用户。</p>
<p>在 Swift 中有四种方式来处理错误。你可以将来自函数的错误传递给调用函数的代码中，使用 do-catch 语句来处理错误，把错误作为可选项的值，或者错误不会发生的断言。每一种方法都在下边的章节中有详细叙述。</p>
<p>当函数抛出一个错误，它就改变了你程序的流，所以能够快速定位错误就显得格外重要。要定位你代码中的这些位置，使用 try 关键字——或者 <code>try?</code> 或 <code>try!</code> 变体——放在调用函数、方法或者会抛出错误的初始化器代码之前。这些关键字在下面的章节中有详细的描述</p>
<p><code>注意：Swift 中的错误处理， try, catch  和 throw 的使用与其他语言中的异常处理很相仿。不同于许多语言中的异常处理——包括 Objective-C ——Swift 中的错误处理并不涉及调用堆栈展开，一个高占用过程。因此， throw 语句的性能特征与 return 比不差多少。</code></p>
<h3 id="使用抛出函数传递错误"><a href="#使用抛出函数传递错误" class="headerlink" title="使用抛出函数传递错误"></a>使用抛出函数传递错误</h3><p>为了明确一个函数或者方法可以抛出错误，你要在它的声明当中的形式参数后边写上 <code>throws</code>关键字。使用 <code>throws</code>标记的函数叫做抛出函数。如果它明确了一个返回类型，那么 throws关键字要在返回箭头 ( -&gt;)之前。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func canThrowErrors() throws -&gt; String</span><br><span class="line"> </span><br><span class="line">func cannotThrowErrors() -&gt; String</span><br></pre></td></tr></table></figure>

<p>抛出函数可以把它内部抛出的错误传递到它被调用的生效范围之内。<br><code>注意：只有抛出函数可以传递错误。任何在非抛出函数中抛出的错误都必须在该函数内部处理。 </code></p>
<p>在抛出函数体内的任何地方，你都可以用 throw语句来抛出错误。</p>
<p>在下边的栗子中， <code>VendingMachine</code>类拥有一个如果请求的物品不存在、卖光了或者比押金贵了就会抛出对应的 <code>VendingMachineError</code>错误的 <code>vend(itemNamed:)</code>方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct Item &#123;</span><br><span class="line">    var price: Int</span><br><span class="line">    var count: Int</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">class VendingMachine &#123;</span><br><span class="line">    var inventory &#x3D; [</span><br><span class="line">        &quot;Candy Bar&quot;: Item(price: 12, count: 7),</span><br><span class="line">        &quot;Chips&quot;: Item(price: 10, count: 4),</span><br><span class="line">        &quot;Pretzels&quot;: Item(price: 7, count: 11)</span><br><span class="line">    ]</span><br><span class="line">    var coinsDeposited &#x3D; 0</span><br><span class="line">    </span><br><span class="line">    func vend(itemNamed name: String) throws &#123;</span><br><span class="line">        guard let item &#x3D; inventory[name] else &#123;</span><br><span class="line">            throw VendingMachineError.invalidSelection</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        guard item.count &gt; 0 else &#123;</span><br><span class="line">            throw VendingMachineError.outOfStock</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        guard item.price &lt;&#x3D; coinsDeposited else &#123;</span><br><span class="line">            throw VendingMachineError.insufficientFunds(coinsNeeded: item.price - coinsDeposited)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        coinsDeposited -&#x3D; item.price</span><br><span class="line">        </span><br><span class="line">        var newItem &#x3D; item</span><br><span class="line">        newItem.count -&#x3D; 1</span><br><span class="line">        inventory[name] &#x3D; newItem</span><br><span class="line">        </span><br><span class="line">        print(&quot;Dispensing \(name)&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>vend(itemNamed:)方法的实现使用了 guard语句来提前退出并抛出错误，如果购买零食的条件不符合的话。因为 throw语句立即传送程序控制，所以只有所有条件都达到，物品才会售出。</p>
<p>由于 vend(itemNamed:)方法传递它抛出的任何错误，所以你调用它的代码要么直接处理错误——使用 do-catch语句， try?或者 try!——要么继续传递它们。比如说，下边栗子中的 buyFavoriteSnack(person:vendingMachine:)同样是一个抛出函数，任何 vend(itemNamed:)方法抛出的函数都会向上传递给调用 buyFavoriteSnack(person:vendingMachine:)函数的地方。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">let favoriteSnacks &#x3D; [</span><br><span class="line">    &quot;Alice&quot;: &quot;Chips&quot;,</span><br><span class="line">    &quot;Bob&quot;: &quot;Licorice&quot;,</span><br><span class="line">    &quot;Eve&quot;: &quot;Pretzels&quot;,</span><br><span class="line">]</span><br><span class="line">func buyFavoriteSnack(person: String, vendingMachine: VendingMachine) throws &#123;</span><br><span class="line">    let snackName &#x3D; favoriteSnacks[person] ?? &quot;Candy Bar&quot;</span><br><span class="line">    try vendingMachine.vend(itemNamed: snackName)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; Dispensing Chips</span><br></pre></td></tr></table></figure>

<p>在这个栗子中， <code>buyFavoriteSnack(person:vendingMachine:)</code>函数查找给定人的最爱零食并且尝试通过调用 <code>vend(itemNamed:)</code>方法来购买它们。由于 <code>vend(itemNamed:)</code> 方法会抛出错误，调用的时候要在前边用 try关键字。</p>
<h3 id="使用-Do-Catch-处理错误"><a href="#使用-Do-Catch-处理错误" class="headerlink" title="使用 Do-Catch 处理错误"></a>使用 Do-Catch 处理错误</h3><p>使用 do-catch语句来通过运行一段代码处理错误。如果do分句中抛出了一个错误，它就会与 catch分句匹配，以确定其中之一可以处理错误。</p>
<p>这是 do-catch语句的通常使用姿势：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">do &#123;</span><br><span class="line">    try expression</span><br><span class="line">    statements</span><br><span class="line">&#125; catch pattern 1 &#123;</span><br><span class="line">    statements</span><br><span class="line">&#125; catch pattern 2 where condition &#123;</span><br><span class="line">    statements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 catch后写一个模式来明确分句可以处理哪个错误。如果一个 catch分句没有模式，这个分句就可以匹配所有错误并且绑定这个错误到本地常量 error上。更多关于模式匹配的信息，见模式。<br>catch分句没有处理 do分句可能抛出的所有错误。如果没有 catch分句能处理这个错误，那错误就会传递到周围的生效范围当中。总之，错误总得在周围某个范围内被处理。举例来说，接下来的代码处理了 VendingMachineError枚举里的所有三个错误，但其他所有错误得通过范围内其他代码处理：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var vendingMachine &#x3D; VendingMachine()</span><br><span class="line">vendingMachine.coinsDeposited &#x3D; 8</span><br><span class="line">do &#123;</span><br><span class="line">    try buyFavoriteSnack(&quot;Alice&quot;, vendingMachine: vendingMachine)</span><br><span class="line">    &#x2F;&#x2F; Enjoy delicious snack</span><br><span class="line">&#125; catch VendingMachineError.invalidSelection &#123;</span><br><span class="line">    print(&quot;Invalid Selection.&quot;)</span><br><span class="line">&#125; catch VendingMachineError.outOfStock &#123;</span><br><span class="line">    print(&quot;Out of Stock.&quot;)</span><br><span class="line">&#125; catch VendingMachineError.insufficientFunds(let coinsNeeded) &#123;</span><br><span class="line">    print(&quot;Insufficient funds. Please insert an additional \(coinsNeeded) coins.&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; prints &quot;Insufficient funds. Please insert an additional 2 coins.&quot;</span><br></pre></td></tr></table></figure>

<p>在上面的栗子当中，函数 <code>buyFavoriteSnack(person:vendingMachine:)</code>在 try表达式中被调用，因为它会抛出错误。如果抛出错误，执行会立即切换到 catch分句，它决定是否传递来继续。如果没有错误抛出， do语句中剩下的语句将会被执行。</p>
<h3 id="转换错误为可选项"><a href="#转换错误为可选项" class="headerlink" title="转换错误为可选项"></a>转换错误为可选项</h3><p>使用 <code>try?</code>通过将错误转换为可选项来处理一个错误。如果一个错误在 <code>try?</code>表达式中抛出，则表达式的值为 nil。比如说下面的代码x和y拥有同样的值和行为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">func someThrowingFunction() throws -&gt; Int &#123;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">let x &#x3D; try? someThrowingFunction()</span><br><span class="line"> </span><br><span class="line">let y: Int?</span><br><span class="line">do &#123;</span><br><span class="line">    y &#x3D; try someThrowingFunction()</span><br><span class="line">&#125; catch &#123;</span><br><span class="line">    y &#x3D; nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果 someThrowingFunction()抛出一个错误， x和 y的值就是 nil。另一方面，x和y的值是函数返回的值。注意 x和 y是可选的无论 someThrowingFunction()返回什么类型，这里函数返回了一个整数，所以x和y是可选整数。<br>当你想要在同一句里处理所有错误时，使用 try?能让你的错误处理代码更加简洁。比如，下边的代码使用了一些方法来获取数据，或者在所有方式都失败后返回 nil。    </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func fetchData() -&gt; Data? &#123;</span><br><span class="line">    if let data &#x3D; try? fetchDataFromDisk() &#123; return data &#125;</span><br><span class="line">    if let data &#x3D; try? fetchDataFromServer() &#123; return data &#125;</span><br><span class="line">    return nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="取消错误传递"><a href="#取消错误传递" class="headerlink" title="取消错误传递"></a>取消错误传递</h3><p>事实上有时你已经知道一个抛出错误或者方法不会在运行时抛出错误。在这种情况下，你可以在表达式前写 try!来取消错误传递并且把调用放进不会有错误抛出的运行时断言当中。如果错误真的抛出了，你会得到一个运行时错误。</p>
<p>比如说，下面的代码使用了 loadImage(_:)函数，它在给定路径下加载图像资源，如果图像不能被加载则抛出一个错误。在这种情况下，由于图像跟着应用走，运行时不会有错误抛出，所以取消错误传递是合适的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">	</span><br><span class="line">let photo &#x3D; try! loadImage(&quot;.&#x2F;Resources&#x2F;John Appleseed.jpg&quot;)</span><br></pre></td></tr></table></figure>

<h3 id="指定清理操作"><a href="#指定清理操作" class="headerlink" title="指定清理操作"></a>指定清理操作</h3><p>使用 defer语句来在代码离开当前代码块前执行语句合集。这个语句允许你在以任何方式离开当前代码块前执行必须要的清理工作——无论是因为抛出了错误还是因为 return或者 break这样的语句。比如，你可以使用 defer语句来保证文件描述符都关闭并且手动指定的内存到被释放。</p>
<p>defer语句延迟执行直到当前范围退出。这个语句由 defer关键字和需要稍后执行的语句组成。被延迟执行的语句可能不会包含任何会切换控制出语句的代码，比如 break或 return语句，或者通过抛出一个错误。延迟的操作与其指定的顺序相反执行——就是说，第一个 defer语句中的代码会在第二个中代码执行完毕后执行，以此类推。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func processFile(filename: String) throws &#123;</span><br><span class="line">    if exists(filename) &#123;</span><br><span class="line">        let file &#x3D; open(filename)</span><br><span class="line">        defer &#123;</span><br><span class="line">            close(file)</span><br><span class="line">        &#125;</span><br><span class="line">        while let line &#x3D; try file.readline() &#123;</span><br><span class="line">            &#x2F;&#x2F; Work with the file.</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; close(file) is called here, at the end of the scope.</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面的离子使用 defer语句来保证 open(<em>:)函数能调用 close(</em>:)。</p>
<p><code>注意：就算没有涉及错误处理代码，你也可以使用 defer语句。</code></p>
]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>内存管理之Tagged pointer</title>
    <url>/2020/08/08/tagpointer/</url>
    <content><![CDATA[<p>iOS开发者对<code>引用计数</code>这个名词肯定不陌生,引用计数是苹果为了方便开发者管理内存而引入的一个概念,当引用计数为0时，对象就会被释放。但是，真的是所有对象都是这样吗？</p>
<a id="more"></a>

<h3 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h3><p>iOS将虚拟内存按照地址由低到高划分为如下五个区：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghjbitqd60j30cn09ljrw.jpg"></p>
<p>在程序运行时，代码区，常量区以及全局静态区的大小是固定的，会变化的只有栈和堆的大小。而栈的内存是有操作系统自动释放的，我们平常说所的iOS内存引用计数，其实是就堆上的对象来说的。</p>
<h3 id="如何引入tagged-pointer"><a href="#如何引入tagged-pointer" class="headerlink" title="如何引入tagged pointer"></a>如何引入tagged pointer</h3><p>自2013年苹果推出iphone5s之后，iOS的寻址空间扩大到了64位。我们可以用63位来表示一个数字(一位做符号位)。那么这个数字的范围是2^63 ,很明显我们一般不会用到这么大的数字，那么在我们定义一个数字时<code>NSNumber *num = @100</code>,实际上内存中浪费了很多的内存空间。</p>
<p>当然苹果肯定也认识到了这个问题，于是就引入了<code>tagged pointer</code>,<code>tagged pointer</code>是一种特殊的“指针”，其特殊在于，其实它存储的并不是地址，而是真实的数据和一些附加的信息。</p>
<p>我们可以在WWDC2013的《Session 404 Advanced in Objective-C》视频中，看到苹果对于Tagged Pointer特点的介绍：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghjdbgf38nj31el0u0afd.jpg"></p>
<ul>
<li>Tagged Pointer专门用来存储小的对象，例如NSNumber, NSDate, NSString。</li>
<li>Tagged Pointer指针的值不再是地址了，而是真正的值。所以，实际上它不再是一个对象了，它只是一个披着对象皮的普通变量而已。所以，它的内存并不存储在堆中，也不需要malloc和free。</li>
<li>在内存读取上有着3倍的效率，创建时比以前快106倍。</li>
</ul>
<h3 id="NSTaggedPointer"><a href="#NSTaggedPointer" class="headerlink" title="NSTaggedPointer"></a>NSTaggedPointer</h3><p>我们先看下下面这段代码：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSMutableString</span> *mutableStr = [<span class="built_in">NSMutableString</span> string];</span><br><span class="line"><span class="built_in">NSString</span> *immutable = <span class="literal">nil</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _OBJC_TAG_MASK (1UL&lt;&lt;63)</span></span><br><span class="line"><span class="keyword">char</span> c = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    [mutableStr appendFormat:<span class="string">@&quot;%c&quot;</span>, c++];</span><br><span class="line">    immutable = [mutableStr <span class="keyword">copy</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%p %@ %@&quot;</span>, immutable, immutable, immutable.class);</span><br><span class="line">&#125;<span class="keyword">while</span>(((uintptr_t)immutable &amp; _OBJC_TAG_MASK) == _OBJC_TAG_MASK);</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2020-08-08 14:15:54.480862+0800 TaggedPointerDemo[55468:2078125] 0xdc5050684e86e57c a NSTaggedPointerString</span><br><span class="line">2020-08-08 14:15:54.481719+0800 TaggedPointerDemo[55468:2078125] 0xdc5050684e80c57f ab NSTaggedPointerString</span><br><span class="line">2020-08-08 14:15:54.482480+0800 TaggedPointerDemo[55468:2078125] 0xdc50506848b0c57e abc NSTaggedPointerString</span><br><span class="line">2020-08-08 14:15:54.483342+0800 TaggedPointerDemo[55468:2078125] 0xdc50506e08b0c579 abcd NSTaggedPointerString</span><br><span class="line">2020-08-08 14:15:54.483950+0800 TaggedPointerDemo[55468:2078125] 0xdc50563e08b0c578 abcde NSTaggedPointerString</span><br><span class="line">2020-08-08 14:15:54.484246+0800 TaggedPointerDemo[55468:2078125] 0xdc56363e08b0c57b abcdef NSTaggedPointerString</span><br><span class="line">2020-08-08 14:15:54.484800+0800 TaggedPointerDemo[55468:2078125] 0xda26363e08b0c57a abcdefg NSTaggedPointerString</span><br><span class="line">2020-08-08 14:15:54.485200+0800 TaggedPointerDemo[55468:2078125] 0xdc527050ee978a35 abcdefgh NSTaggedPointerString</span><br><span class="line">2020-08-08 14:15:54.485644+0800 TaggedPointerDemo[55468:2078125] 0xdcd85e404adcb774 abcdefghi NSTaggedPointerString</span><br><span class="line">2020-08-08 14:15:54.486003+0800 TaggedPointerDemo[55468:2078125] 0x28334c2c0 abcdefghij __NSCFString</span><br></pre></td></tr></table></figure>
<p>上图我们可以看到，当字符串的长度为10个以内时，字符串的类型都是<code>NSTaggedPointerString</code>类型，当超过10个时，字符串的类型才是<code>__NSCFString</code></p>
<p>打印结果分析：</p>
<h4 id="NSTaggedPointer标志位"><a href="#NSTaggedPointer标志位" class="headerlink" title="NSTaggedPointer标志位"></a>NSTaggedPointer标志位</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span> </span><br><span class="line">_objc_isTaggedPointer(<span class="keyword">const</span> <span class="keyword">void</span> * _Nullable ptr)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> ((uintptr_t)ptr &amp; _OBJC_TAG_MASK) == _OBJC_TAG_MASK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这个方法我们看到，判断一个对象类型是否为<code>NSTaggedPointerString</code>类型实际上是讲对象的地址与<code>_OBJC_TAG_MASK</code>进行按位与操作,结果在跟<code>_OBJC_TAG_MASK</code>进行对比,我们在看下<code>_OBJC_TAG_MASK</code>的定义:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> OBJC_MSB_TAGGED_POINTERS</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> _OBJC_TAG_MASK (1UL&lt;&lt;63)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> _OBJC_TAG_MASK 1UL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>我们都知道一个对象地址为64位二进制，它表明如果64位数据中，最高位是1的话，则表明当前是一个<code>tagged pointer</code>类型。</p>
<p>那么我们在看下上面打印出的地址，所有<code>NSTaggedPointerString</code>地址都是<code>0xd</code>开头，d转换为二进制<code>1110</code>，根据上面的结论，我们看到首位为1表示为<code>NSTaggedPointerString</code>类型。在这里得到验证。</p>
<p><code>注意</code>:<code>TaggedPointer</code>类型在iOS和MacOS中标志位是不同的iOS为最高位而MacOS为最低位</p>
<h4 id="对象类型"><a href="#对象类型" class="headerlink" title="对象类型"></a>对象类型</h4><p>正常情况下一个对象的类型，是通过这个对象的ISA指针来判断的，那么对于<code>NSTaggedPointer</code>类型我们如何通过地址判断对应数据是什么类型的呢？</p>
<h5 id="objc4-723之前"><a href="#objc4-723之前" class="headerlink" title="objc4-723之前"></a>objc4-723之前</h5><p>在objc4-723之前，我们可以通过与判断<code>TaggedPointer</code>标志位一样根据地址来判断，而类型的标志位就是对象地址的61-63位,比如对象地址为<code>0xa</code>开头，那么转换成二进制位<code>1010</code>,那么去掉最高位标志位后，剩余为<code>010</code>,即10进制中的2。</p>
<p>接着我们看下runtime源码objc-internal.h中有关于标志位的定义如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __has_feature(objc_fixed_enum)  ||  __cplusplus &gt;= 201103L</span></span><br><span class="line"><span class="keyword">enum</span> objc_tag_index_t : uint16_t</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="keyword">typedef</span> uint16_t objc_tag_index_t;</span><br><span class="line"><span class="keyword">enum</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 60-bit payloads</span></span><br><span class="line">    OBJC_TAG_NSAtom            = <span class="number">0</span>, </span><br><span class="line">    OBJC_TAG_1                 = <span class="number">1</span>, </span><br><span class="line">    OBJC_TAG_NSString          = <span class="number">2</span>, </span><br><span class="line">    OBJC_TAG_NSNumber          = <span class="number">3</span>, </span><br><span class="line">    OBJC_TAG_NSIndexPath       = <span class="number">4</span>, </span><br><span class="line">    OBJC_TAG_NSManagedObjectID = <span class="number">5</span>, </span><br><span class="line">    OBJC_TAG_NSDate            = <span class="number">6</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 60-bit reserved</span></span><br><span class="line">    OBJC_TAG_RESERVED_7        = <span class="number">7</span>, </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 52-bit payloads</span></span><br><span class="line">    OBJC_TAG_Photos_1          = <span class="number">8</span>,</span><br><span class="line">    OBJC_TAG_Photos_2          = <span class="number">9</span>,</span><br><span class="line">    OBJC_TAG_Photos_3          = <span class="number">10</span>,</span><br><span class="line">    OBJC_TAG_Photos_4          = <span class="number">11</span>,</span><br><span class="line">    OBJC_TAG_XPC_1             = <span class="number">12</span>,</span><br><span class="line">    OBJC_TAG_XPC_2             = <span class="number">13</span>,</span><br><span class="line">    OBJC_TAG_XPC_3             = <span class="number">14</span>,</span><br><span class="line">    OBJC_TAG_XPC_4             = <span class="number">15</span>,</span><br><span class="line"></span><br><span class="line">    OBJC_TAG_First60BitPayload = <span class="number">0</span>, </span><br><span class="line">    OBJC_TAG_Last60BitPayload  = <span class="number">6</span>, </span><br><span class="line">    OBJC_TAG_First52BitPayload = <span class="number">8</span>, </span><br><span class="line">    OBJC_TAG_Last52BitPayload  = <span class="number">263</span>, </span><br><span class="line"></span><br><span class="line">    OBJC_TAG_RESERVED_264      = <span class="number">264</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __has_feature(objc_fixed_enum)  &amp;&amp;  !defined(__cplusplus)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> objc_tag_index_t objc_tag_index_t;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>那么我们知道2表示的<code>OBJC_TAG_NSString</code>即字符串类型。因为目前已经无法验证这种情况了 所以我们不做其他类型验证。</p>
<h5 id="objc4-750之后"><a href="#objc4-750之后" class="headerlink" title="objc4-750之后"></a>objc4-750之后</h5><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Returns a pointer to the class&#x27;s storage in the tagged class arrays.</span></span><br><span class="line"><span class="comment">// Assumes the tag is a valid basic tag.</span></span><br><span class="line"><span class="keyword">static</span> Class *</span><br><span class="line">classSlotForBasicTagIndex(objc_tag_index_t tag)</span><br><span class="line">&#123;</span><br><span class="line">    uintptr_t tagObfuscator = ((objc_debug_taggedpointer_obfuscator</span><br><span class="line">                                &gt;&gt; _OBJC_TAG_INDEX_SHIFT)</span><br><span class="line">                               &amp; _OBJC_TAG_INDEX_MASK);</span><br><span class="line">    uintptr_t obfuscatedTag = tag ^ tagObfuscator;</span><br><span class="line">    <span class="comment">// Array index in objc_tag_classes includes the tagged bit itself</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SUPPORT_MSB_TAGGED_POINTERS <span class="comment">////高位优先</span></span></span><br><span class="line">    <span class="keyword">return</span> &amp;objc_tag_classes[<span class="number">0x8</span> | obfuscatedTag];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="keyword">return</span> &amp;objc_tag_classes[(obfuscatedTag &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>classSlotForBasicTagIndex() 函数的主要功能就是根据指定索引 tag 从数组objc_tag_classes中获取类指针,而下标的计算方法发是根据外部传递的索引tag。比如字符串 tag = 2。当然这并不是简单的从数组中获取某条数据。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"> uint16_t <span class="built_in">NSString_Tag</span> = <span class="number">2</span>;</span><br><span class="line">uint16_t <span class="built_in">NSNumber_Tag</span> = <span class="number">3</span>;</span><br><span class="line"><span class="comment">// 3 = 0011</span></span><br><span class="line"><span class="comment">// _OBJC_TAG_INDEX_MASK = 0x7 = 0111</span></span><br><span class="line">        uintptr_t string_tagObfuscator = ((objc_debug_taggedpointer_obfuscator</span><br><span class="line">                                           &gt;&gt; _OBJC_TAG_INDEX_SHIFT)</span><br><span class="line">                                          &amp; _OBJC_TAG_INDEX_MASK);</span><br><span class="line"></span><br><span class="line">        uintptr_t number_tagObfuscator = ((objc_debug_taggedpointer_obfuscator</span><br><span class="line">                                           &gt;&gt; _OBJC_TAG_INDEX_SHIFT)</span><br><span class="line">                                          &amp; _OBJC_TAG_INDEX_MASK);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异或操作 相同返回0 不同返回1</span></span><br><span class="line"><span class="comment">// 2 ^ 3 = 0010 ^ 0011 = 0001</span></span><br><span class="line"><span class="comment">// 3^ 3 = 0011 ^ 0011 = 0000</span></span><br><span class="line">        uintptr_t string_obfuscatedTag = <span class="built_in">NSString_Tag</span> ^ string_tagObfuscator;</span><br><span class="line">        uintptr_t number_obfuscatedTag = <span class="built_in">NSNumber_Tag</span> ^ number_tagObfuscator;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按位或</span></span><br><span class="line"><span class="comment">// 1000 | 0001 = 1001 = 9</span></span><br><span class="line"><span class="comment">// 1000 | 0000 = 1000 = 8</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, objc_tag_classes[<span class="number">0x8</span> | string_obfuscatedTag]);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, objc_tag_classes[<span class="number">0x8</span> | number_obfuscatedTag]);</span><br></pre></td></tr></table></figure>

<p>控制台输出为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TaggedPointer[89420:3027642] NSTaggedPointerString</span><br><span class="line">TaggedPointer[89420:3027642] __NSCFNumber</span><br></pre></td></tr></table></figure>

<p>当我们多次运行时,我们发现实际上每次获取到的<code>string_tagObfuscator</code>和<code>number_obfuscatedTag</code>都不一样，但是每次从<code>objc_tag_classes</code>中取出的类型均是一致的，因此实际上每次运行objc_tag_classes中的内容也是不断变化的。</p>
<p>如果你想进一步的了解可以参考<a href="https://jinxuebin.cn/2019/06/Objective-C%E4%B8%AD%E7%9A%84%E4%BC%AA%E6%8C%87%E9%92%88/">Objective-C中伪指针Tagged Pointer</a></p>
<h4 id="NSCFNumber"><a href="#NSCFNumber" class="headerlink" title="NSCFNumber"></a>NSCFNumber</h4><p>下面我们在看下NSNumber类型</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSNumber</span> *number1 = @(<span class="number">0x1</span>);</span><br><span class="line"><span class="built_in">NSNumber</span> *number2 = @(<span class="number">0x20</span>);</span><br><span class="line"><span class="built_in">NSNumber</span> *number3 = @(<span class="number">0x3F</span>);</span><br><span class="line"><span class="built_in">NSNumber</span> *numberFFFF = @(<span class="number">0xFFFFFFFFFFEFE</span>);</span><br><span class="line"><span class="built_in">NSNumber</span> *maxNum = @(MAXFLOAT);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;number1 pointer is %p class is %@&quot;</span>, number1, number1.class);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;number2 pointer is %p class is %@&quot;</span>, number2, number2.class);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;number3 pointer is %p class is %@&quot;</span>, number3, number3.class);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;numberffff pointer is %p class is %@&quot;</span>, numberFFFF, numberFFFF.class);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;maxNum pointer is %p class is %@&quot;</span>, maxNum, maxNum.class);</span><br></pre></td></tr></table></figure>

<p>我们在看下打印结果:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TaggedPointerDemo[59218:2167895] number1 pointer is 0xf7cb914ffb51479a class is __NSCFNumber</span><br><span class="line">TaggedPointerDemo[59218:2167895] number2 pointer is 0xf7cb914ffb51458a class is __NSCFNumber</span><br><span class="line">TaggedPointerDemo[59218:2167895] number3 pointer is 0xf7cb914ffb51447a class is __NSCFNumber</span><br><span class="line">TaggedPointerDemo[59218:2167895] numberffff pointer is 0xf7346eb004aea86b class is __NSCFNumber</span><br><span class="line">TaggedPointerDemo[59218:2167895] maxNum pointer is 0x28172a0c0 class is __NSCFNumber</span><br></pre></td></tr></table></figure>

<p>我们发现对于NSNumber，我们打印出来的数据类型均为<code>__NSCFNumber</code>,但是我们发现对于<code>MAXFLOAT</code>打印出的地址显然与其他几项不符，上面几个NSNumber的地址以<code>0xf</code>开头，根据字符串地址的经验我们可以看出<code>f = 1111</code>,首位标记位为1，表示这个数据类型属于<code>TaggedPointer</code>。而MAXFLOAT不是。</p>
<h4 id="获取TaggedPointer的值"><a href="#获取TaggedPointer的值" class="headerlink" title="获取TaggedPointer的值"></a>获取TaggedPointer的值</h4><h5 id="objc4-723之前-1"><a href="#objc4-723之前-1" class="headerlink" title="objc4-723之前"></a>objc4-723之前</h5><p>字符串：<br><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghki3kum3kj30cw04ljss.jpg"></p>
<p>从上图的地址中我们就可以看出,从低位到高位分别表示的就是字符串的值(在ASCII码表中的值)</p>
<p>数字:<br><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghki3v25qqj30fa02iq3q.jpg"></p>
<p>对于数字来说从地址中也是直接读出存储的值，如上图。</p>
<h5 id="objc4-750之后-1"><a href="#objc4-750之后-1" class="headerlink" title="objc4-750之后"></a>objc4-750之后</h5><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> uintptr_t</span><br><span class="line">_objc_decodeTaggedPointer(<span class="keyword">const</span> <span class="keyword">void</span> * _Nullable ptr)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (uintptr_t)ptr ^ objc_debug_taggedpointer_obfuscator;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> uintptr_t</span><br><span class="line">_objc_getTaggedPointerValue(<span class="keyword">const</span> <span class="keyword">void</span> * _Nullable ptr) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// assert(_objc_isTaggedPointer(ptr));</span></span><br><span class="line">    uintptr_t value = _objc_decodeTaggedPointer(ptr);</span><br><span class="line">    uintptr_t basicTag = (value &gt;&gt; _OBJC_TAG_INDEX_SHIFT) &amp; _OBJC_TAG_INDEX_MASK;</span><br><span class="line">    <span class="keyword">if</span> (basicTag == _OBJC_TAG_INDEX_MASK) &#123;</span><br><span class="line">        <span class="keyword">return</span> (value &lt;&lt; _OBJC_TAG_EXT_PAYLOAD_LSHIFT) &gt;&gt; _OBJC_TAG_EXT_PAYLOAD_RSHIFT;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (value &lt;&lt; _OBJC_TAG_PAYLOAD_LSHIFT) &gt;&gt; _OBJC_TAG_PAYLOAD_RSHIFT;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> intptr_t</span><br><span class="line">_objc_getTaggedPointerSignedValue(<span class="keyword">const</span> <span class="keyword">void</span> * _Nullable ptr) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// assert(_objc_isTaggedPointer(ptr));</span></span><br><span class="line">    uintptr_t value = _objc_decodeTaggedPointer(ptr);</span><br><span class="line">    uintptr_t basicTag = (value &gt;&gt; _OBJC_TAG_INDEX_SHIFT) &amp; _OBJC_TAG_INDEX_MASK;</span><br><span class="line">    <span class="keyword">if</span> (basicTag == _OBJC_TAG_INDEX_MASK) &#123;</span><br><span class="line">        <span class="keyword">return</span> ((intptr_t)value &lt;&lt; _OBJC_TAG_EXT_PAYLOAD_LSHIFT) &gt;&gt; _OBJC_TAG_EXT_PAYLOAD_RSHIFT;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ((intptr_t)value &lt;&lt; _OBJC_TAG_PAYLOAD_LSHIFT) &gt;&gt; _OBJC_TAG_PAYLOAD_RSHIFT;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例代码：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *str1 = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;1&quot;</span>];</span><br><span class="line">      <span class="built_in">NSString</span> *str11 = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;11&quot;</span>];</span><br><span class="line">      <span class="built_in">NSString</span> *str2 = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;2&quot;</span>];</span><br><span class="line">      <span class="built_in">NSString</span> *str22 = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;22&quot;</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 0x31 1 0x32 1</span></span><br><span class="line">      uintptr_t value1 = objc_getTaggedPointerValue((__bridge <span class="keyword">void</span> *)str1);</span><br><span class="line">      uintptr_t value2 = objc_getTaggedPointerValue((__bridge <span class="keyword">void</span> *)str2);</span><br><span class="line">      uintptr_t value11 = objc_getTaggedPointerValue((__bridge <span class="keyword">void</span> *)str11);</span><br><span class="line">      uintptr_t value22 = objc_getTaggedPointerValue((__bridge <span class="keyword">void</span> *)str22);</span><br><span class="line">      <span class="comment">// 以16进制形式输出</span></span><br><span class="line">      <span class="built_in">NSLog</span>(<span class="string">@&quot;%lx&quot;</span>, value1);</span><br><span class="line">      <span class="built_in">NSLog</span>(<span class="string">@&quot;%lx&quot;</span>, value11);</span><br><span class="line">      <span class="built_in">NSLog</span>(<span class="string">@&quot;%lx&quot;</span>, value2);</span><br><span class="line">      <span class="built_in">NSLog</span>(<span class="string">@&quot;%lx&quot;</span>, value22);</span><br></pre></td></tr></table></figure>
<p>控制台输出:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TaggedPointer[89535:3033433] 311</span><br><span class="line">TaggedPointer[89535:3033433] 31312</span><br><span class="line">TaggedPointer[89535:3033433] 321</span><br><span class="line">TaggedPointer[89535:3033433] 32322</span><br></pre></td></tr></table></figure>

<p>即 “1” = 0x31 1,最后一位表示长度，在ASCII码表中31表示的就是字符1。而且从字符串“11”的结果我们也可以验证上面的说法。</p>
<h3 id="isa-指针-NONPOINTER-ISA"><a href="#isa-指针-NONPOINTER-ISA" class="headerlink" title="isa 指针(NONPOINTER_ISA)"></a>isa 指针(NONPOINTER_ISA)</h3><p>上面我们说了，对于一个对象的存储，苹果做了优化，那么对于ISA指针呢？</p>
<p>对象的isa指针，用来表明对象所属的类类型。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">union</span> isa_t &#123;</span><br><span class="line">    isa_t() &#123; &#125;</span><br><span class="line">    isa_t(uintptr_t value) : bits(value) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    Class cls;</span><br><span class="line">    uintptr_t bits;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(ISA_BITFIELD)</span></span><br><span class="line">    <span class="keyword">struct</span> &#123;</span><br><span class="line">        ISA_BITFIELD;  <span class="comment">// defined in isa.h</span></span><br><span class="line">    &#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>同时结合下图，我们可以更清晰的了解isa指针的作用以及类对象的概念。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghjtmvzlxwj30w20j9tas.jpg"></p>
<p>从图中可以看出，我们所谓的isa指针，最后实际上落脚于isa_t的联合类型。那么何为联合类型呢？<br><code>联合类型是C语言中的一种类型，是一种n选1的关系,联合的作用在于，用更少的空间，表示了更多的可能的类型，虽然这些类型是不能够共存的</code>。比如isa_t 中包含有<code>cls</code>，<code>bits</code>， <code>struct</code>三个变量，它们的内存空间是重叠的。在实际使用时，仅能够使用它们中的一种，你把它当做cls，就不能当bits访问，你把它当bits，就不能用cls来访问。</p>
<p>对于<code>isa_t</code>联合类型，主要包含了两个构造函数<code>isa_t()</code>,<code>isa_t(uintptr_t value)</code>和三个变量<code>cls</code>,<code>bits</code>,<code>struct</code>,而<code>uintptr_t</code>的定义为<code>typedef unsigned long</code>。         </p>
<p>当isa_t作为Class cls使用时，这符合了我们之前一贯的认知：isa是一个指向对象所属Class类型的指针。然而，仅让一个64位的指针表示一个类型，显然不划算。</p>
<p>因此，绝大多数情况下，苹果采用了优化的<code>isa策略</code>，即，<code>isa_t</code>类型并不等同而<code>Class cls</code>, 而是<code>struct</code>。</p>
<h4 id="struct"><a href="#struct" class="headerlink" title="struct"></a>struct</h4><p>下面我们先来看下struct的结构体</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ISA_BITFIELD定义如下</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">if</span> __arm64__</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> ISA_MASK        0x0000000ffffffff8ULL</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> ISA_MAGIC_MASK  0x000003f000000001ULL</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> ISA_MAGIC_VALUE 0x000001a000000001ULL</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> ISA_BITFIELD                                                      \</span></span><br><span class="line">      uintptr_t nonpointer        : <span class="number">1</span>;                                       \</span><br><span class="line">      uintptr_t has_assoc         : <span class="number">1</span>;                                       \</span><br><span class="line">      uintptr_t has_cxx_dtor      : <span class="number">1</span>;                                       \</span><br><span class="line">      uintptr_t shiftcls          : <span class="number">33</span>; <span class="comment">/*MACH_VM_MAX_ADDRESS 0x1000000000*/</span> \</span><br><span class="line">      uintptr_t magic             : <span class="number">6</span>;                                       \</span><br><span class="line">      uintptr_t weakly_referenced : <span class="number">1</span>;                                       \</span><br><span class="line">      uintptr_t deallocating      : <span class="number">1</span>;                                       \</span><br><span class="line">      uintptr_t has_sidetable_rc  : <span class="number">1</span>;                                       \</span><br><span class="line">      uintptr_t extra_rc          : <span class="number">19</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> RC_ONE   (1ULL&lt;&lt;45)</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> RC_HALF  (1ULL&lt;&lt;18)</span></span><br></pre></td></tr></table></figure>

<p>注意:<code>成员后面的：表明了该成员占用几个bit</code><br>而每个成员的意义如下表</p>
<h4 id="标志位说明"><a href="#标志位说明" class="headerlink" title="标志位说明"></a>标志位说明</h4><table>
<thead>
<tr>
<th>成员</th>
<th>bit位</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>nonpointer</td>
<td>1bit</td>
<td>标志位。1(奇数)表示开启了isa优化，0(偶数)表示没有启用isa优化。所以，我们可以通过判断isa是否为奇数来判断对象是否启用了isa优化</td>
</tr>
<tr>
<td>has_assoc</td>
<td>1bit</td>
<td>标志位。表明对象是否有关联对象。没有关联对象的对象释放的更快。</td>
</tr>
<tr>
<td>has_cxx_dtor</td>
<td>1bit</td>
<td>标志位。表明对象是否有C++或ARC析构函数。没有析构函数的对象释放的更快</td>
</tr>
<tr>
<td>shiftcls</td>
<td>33bit</td>
<td>类指针的非零位。</td>
</tr>
<tr>
<td>magic</td>
<td>6bit</td>
<td>固定为0x1a，用于在调试时区分对象是否已经初始化。</td>
</tr>
<tr>
<td>weakly_referenced</td>
<td>1bit</td>
<td>标志位。用于表示该对象是否被别的对象弱引用。没有被弱引用的对象释放的更快。</td>
</tr>
<tr>
<td>deallocating</td>
<td>1bit</td>
<td>标志位。用于表示该对象是否正在被释放。</td>
</tr>
<tr>
<td>has_sidetable_rc</td>
<td>1bit</td>
<td>标志位。用于标识是否当前的引用计数过大，无法在isa中存储，而需要借用sidetable来存储。（这种情况大多不会发生）</td>
</tr>
<tr>
<td>extra_rc</td>
<td>19bit</td>
<td>对象的引用计数减1。比如，一个object对象的引用计数为7，则此时extra_rc的值为6。</td>
</tr>
</tbody></table>
<p>从上表我们发现，<code>extra_rc</code>和<code>has_sidetable_rc</code>是和引用计数相关的标志位，当extra_rc 不够用时，还会借助sidetable来存储计数值，这时，has_sidetable_rc会被标志为1。</p>
<p>接下来我们来验证下，这些标志位是否真的如表中介绍那样。</p>
<h4 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h4><p>我们先来看下面这段代码</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)testisa &#123;</span><br><span class="line">    <span class="built_in">NSObject</span> *obj = [[<span class="built_in">NSObject</span> alloc] init];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;1. obj isa_t = %p&quot;</span>, *(<span class="keyword">void</span> **)(__bridge <span class="keyword">void</span>*)obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>控制台输出结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TaggedPointerDemo[59983:2185591] 1. obj isa_t &#x3D; 0x1a1f335beb1</span><br></pre></td></tr></table></figure>
<p>我们将地址<code>0x1a1f335beb1</code>转换过后：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghkfjfbyu0j30fe0dogmb.jpg"></p>
<p>我们看到这时候 对象是<code>nonpointer</code>开启了isa优化，且当前的引用计数器为 extra_rc = 0 + 1 = 1;</p>
<p>下面我们接着测试</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSObject</span> *obj = [[<span class="built_in">NSObject</span> alloc] init];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;1. obj isa_t = %p&quot;</span>, *(<span class="keyword">void</span> **)(__bridge <span class="keyword">void</span>*)obj);</span><br><span class="line">_obj1 = obj;</span><br><span class="line"><span class="built_in">NSObject</span> *tmpObj = obj;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;2. obj isa_t = %p&quot;</span>, *(<span class="keyword">void</span> **)(__bridge <span class="keyword">void</span>*)obj);</span><br></pre></td></tr></table></figure>
<p>控制台输出为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TaggedPointerDemo[63235:2266690] 1. obj isa_t &#x3D; 0x1a1f335beb1</span><br><span class="line">TaggedPointerDemo[63235:2266690] 2. obj isa_t &#x3D; 0x41a1f335beb1</span><br></pre></td></tr></table></figure>
<p>我们将地址<code>0x41a1f335beb1</code>转换过后：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghkfvyc4tkj30fe0dot9f.jpg"></p>
<p>我们看到这时候，我们将obj强引用之后，又实用了一个局部变量对其进行引用，所以这时的引用计数应该为2，当然从图中我们也可以验证这一点。</p>
<h4 id="weakly-referenced"><a href="#weakly-referenced" class="headerlink" title="weakly_referenced"></a>weakly_referenced</h4><p>我们这次添加一个弱引用来验证</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"> _weakRefObj = _obj1;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;3. obj isa_t = %p&quot;</span>, *(<span class="keyword">void</span> **)(__bridge <span class="keyword">void</span>*)_obj1);</span><br></pre></td></tr></table></figure>

<p>控制台输出为</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">TaggedPointerDemo[<span class="number">63235</span>:<span class="number">2266690</span>] <span class="number">3.</span> obj isa_t = <span class="number">0x45a1f335beb1</span></span><br></pre></td></tr></table></figure>

<p>这时候我们仅仅通过地址进行判断 当添加了<code>_obj2 = _obj1</code>后，地址变为<code>0x61a1f335beb1</code>与之前地址<code>0x41a1f335beb1</code>对比</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghkfxt2qagj30fe0doq3n.jpg"></p>
<p>上图我们可以看到<code>weakly_referenced</code>标志位被置为1.表示这个对象有被弱引用。</p>
<h4 id="has-assoc"><a href="#has-assoc" class="headerlink" title="has_assoc"></a>has_assoc</h4><p>然后我们在添加一个关联属性</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSObject</span> *attachObj = [[<span class="built_in">NSObject</span> alloc] init];</span><br><span class="line">objc_setAssociatedObject(_obj1, <span class="string">&quot;attachKey&quot;</span>, attachObj, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;4. obj isa_t = %p&quot;</span>, *(<span class="keyword">void</span> **)(__bridge <span class="keyword">void</span>*)_obj1);</span><br></pre></td></tr></table></figure>

<p>控制台输出为:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">TaggedPointerDemo[<span class="number">63235</span>:<span class="number">2266690</span>] <span class="number">4.</span> obj isa_t = <span class="number">0x45a1f335beb3</span></span><br></pre></td></tr></table></figure>

<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghkfzqpmq2j30fe0doq3n.jpg"></p>
<p>从上图中我们看到<code>has_assoc</code>标志位被置为1.</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>截止到这里，我们通过观察<code>NSTaggedPointer</code>,相关标志位我们基本了解了NSTaggedPointer是如何存储数据以及标志位的作用。</p>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://jinxuebin.cn/2019/06/Objective-C%E4%B8%AD%E7%9A%84%E4%BC%AA%E6%8C%87%E9%92%88/">Objective-C中伪指针Tagged Pointer</a></p>
<p><a href="https://mikeash.com/pyblog/friday-qa-2015-07-31-tagged-pointer-strings.html">Friday Q&amp;A 2015-07-31: Tagged Pointer Strings</a></p>
]]></content>
  </entry>
  <entry>
    <title>retain和release实现探究</title>
    <url>/2020/08/02/retaincount/</url>
    <content><![CDATA[<p>前面一篇文章，我们讲到了系统为了优化数字字符串等类型的数据存储新增了一种<code>NSTaggedPointer</code>类型，同时我们还发现，<code>isa</code>指针在经过优化后，提供了19个bit位用来存储引用计数的个数。但是如果超出了这个限制呢？</p>
<a id="more"></a>

<h3 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h3><p>其实在绝大多数情况下，仅用优化的isa_t来记录对象的引用计数就足够了，但是当对象被引用次数超过 2^19 限制时，就轮到SideTable出场了。</p>
<p>首先，我们先看下超出限制之后，系统是如何将引用计数转移的</p>
<h3 id="retian"><a href="#retian" class="headerlink" title="retian"></a>retian</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 等价于直接使用对象调用retain方法</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">id</span> </span><br><span class="line">objc_object::<span class="keyword">retain</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 如果是TaggedPointer类型 不涉及引用计数</span></span><br><span class="line">    ASSERT(!isTaggedPointer());</span><br><span class="line">    <span class="comment">// fastpath 表示if中的条件是一个大概率事件</span></span><br><span class="line">    <span class="comment">// 如果当前对象没有自定义（override）retain 方法</span></span><br><span class="line">    <span class="keyword">if</span> (fastpath(!ISA()-&gt;hasCustomRR())) &#123;</span><br><span class="line">        <span class="keyword">return</span> rootRetain();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果有自定义的retain方法</span></span><br><span class="line">    <span class="comment">// 通过发消息的方式调用自定义的 retain 方法</span></span><br><span class="line">    <span class="keyword">return</span> ((<span class="keyword">id</span>(*)(objc_object *, SEL))objc_msgSend)(<span class="keyword">this</span>, <span class="keyword">@selector</span>(<span class="keyword">retain</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来我们主要看下 引用计数+1的主要负责函数rootRetain</p>
<h4 id="rootRetain"><a href="#rootRetain" class="headerlink" title="rootRetain"></a>rootRetain</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">ALWAYS_INLINE <span class="keyword">id</span> </span><br><span class="line">objc_object::rootRetain(<span class="keyword">bool</span> tryRetain, <span class="keyword">bool</span> handleOverflow)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 如果如果是taggedPointer直接返回不需要引用计数</span></span><br><span class="line">    <span class="keyword">if</span> (isTaggedPointer()) <span class="keyword">return</span> (<span class="keyword">id</span>)<span class="keyword">this</span>;</span><br><span class="line">    <span class="comment">// 默认不使用sideTable</span></span><br><span class="line">    <span class="keyword">bool</span> sideTableLocked = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 是否需要将引用计数转到sidetable</span></span><br><span class="line">    <span class="keyword">bool</span> transcribeToSideTable = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录新旧两个isa指针</span></span><br><span class="line">    isa_t oldisa;</span><br><span class="line">    isa_t newisa;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        transcribeToSideTable = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//// 通过 LoadExclusive 方法加载 isa 的值，加锁</span></span><br><span class="line">        oldisa = LoadExclusive(&amp;isa.bits);</span><br><span class="line">        <span class="comment">// 此时 newisa = oldisa</span></span><br><span class="line">        newisa = oldisa;</span><br><span class="line">        <span class="comment">// slowpath表示if中的条件是小概率事件</span></span><br><span class="line">        <span class="comment">// 如果newisa(此时和oldisa相等) 如果没有采用isa优化</span></span><br><span class="line">        <span class="keyword">if</span> (slowpath(!newisa.nonpointer)) &#123;</span><br><span class="line">            <span class="comment">// 解锁</span></span><br><span class="line">            ClearExclusive(&amp;isa.bits);</span><br><span class="line">            <span class="comment">//rawISA() = (Class)isa.bits</span></span><br><span class="line">            <span class="comment">// 如果当前对象的 isa 指向的类对象是元类（也就是说当前对象不是实例对象，而是类对象），直接返回</span></span><br><span class="line">            <span class="keyword">if</span> (rawISA()-&gt;isMetaClass()) <span class="keyword">return</span> (<span class="keyword">id</span>)<span class="keyword">this</span>;</span><br><span class="line">            <span class="comment">// 如果不需要retain对象(引用计数+1) 且sideTable是锁上的</span></span><br><span class="line">            <span class="keyword">if</span> (!tryRetain &amp;&amp; sideTableLocked)</span><br><span class="line">                <span class="comment">// sidetable解锁</span></span><br><span class="line">                sidetable_unlock();</span><br><span class="line">            <span class="keyword">if</span> (tryRetain)</span><br><span class="line">                <span class="comment">// sidetable_tryRetain 尝试对引用计数器进行+1的操作 返回+1操作是否成功</span></span><br><span class="line">                <span class="keyword">return</span> sidetable_tryRetain() ? (<span class="keyword">id</span>)<span class="keyword">this</span> : <span class="literal">nil</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">// 将sidetable中保存的引用计数+1同时返回引用计数</span></span><br><span class="line">                <span class="keyword">return</span> sidetable_retain();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果需要尝试 +1 但是当前对象正在销毁中</span></span><br><span class="line">        <span class="keyword">if</span> (slowpath(tryRetain &amp;&amp; newisa.deallocating)) &#123;</span><br><span class="line">            <span class="comment">// 解锁</span></span><br><span class="line">            ClearExclusive(&amp;isa.bits);</span><br><span class="line">            <span class="comment">// 如果不需要去尝试 +1 并且 SideTables 表锁住了，就将其解锁</span></span><br><span class="line">            <span class="comment">// 这里的条件 应该永远都不会被满足</span></span><br><span class="line">            <span class="keyword">if</span> (!tryRetain &amp;&amp; sideTableLocked)</span><br><span class="line">                sidetable_unlock();</span><br><span class="line">            <span class="comment">// 如果对象正在被释放 执行retain是无效的</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 引用计数是否溢出标志位</span></span><br><span class="line">        uintptr_t carry;</span><br><span class="line">        <span class="comment">//为 isa 中的 extra_rc 位 +1 ，并保存引用计数</span></span><br><span class="line">        newisa.bits = addc(newisa.bits, RC_ONE, <span class="number">0</span>, &amp;carry);  <span class="comment">// extra_rc++</span></span><br><span class="line">        <span class="comment">// 如果 isa中的extra_rc 溢出</span></span><br><span class="line">        <span class="keyword">if</span> (slowpath(carry)) &#123;</span><br><span class="line">            <span class="comment">// newisa.extra_rc++ 溢出</span></span><br><span class="line">            <span class="comment">// 是否需要处理溢出 这个变量是rootRetain函数外部传入的参数 是否需要处理溢出时的情况</span></span><br><span class="line">            <span class="keyword">if</span> (!handleOverflow) &#123;</span><br><span class="line">                <span class="comment">//解锁</span></span><br><span class="line">                ClearExclusive(&amp;isa.bits);</span><br><span class="line">                <span class="comment">// rootRetain_overflow 方法实际上就是递归调用了当前方法只是将handleOverflow</span></span><br><span class="line">                <span class="comment">// 置为yes</span></span><br><span class="line">                <span class="keyword">return</span> rootRetain_overflow(tryRetain);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 保留isa中extra_rc一半的值 将另一半转移到sidetable中</span></span><br><span class="line">            <span class="comment">// 如果不需要尝试 +1 并且 sidetable 表未加锁，就将其加锁</span></span><br><span class="line">            <span class="keyword">if</span> (!tryRetain &amp;&amp; !sideTableLocked) sidetable_lock();</span><br><span class="line">            <span class="comment">// sidetable加锁</span></span><br><span class="line">            sideTableLocked = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">// 需要将引用计数转移到sidetable</span></span><br><span class="line">            transcribeToSideTable = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">// 将newisa中的引用计数置为之前的一半 # define RC_HALF  (1ULL&lt;&lt;18)</span></span><br><span class="line">            newisa.extra_rc = RC_HALF;</span><br><span class="line">            <span class="comment">// isa中是否使用sidetable存储retiancount的标志位置为1</span></span><br><span class="line">            newisa.has_sidetable_rc = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//while循环开始 直到 isa.bits 中的值被成功更新成 newisa.bits</span></span><br><span class="line">        <span class="comment">// StoreExclusive(uintptr_t *dst, uintptr_t oldvalue, uintptr_t value)</span></span><br><span class="line">        <span class="comment">// 将更新后的newisa的值更新到isabit中</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (slowpath(!StoreExclusive(&amp;isa.bits, oldisa.bits, newisa.bits)));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果需要转移引用计数到sidetable中</span></span><br><span class="line">    <span class="keyword">if</span> (slowpath(transcribeToSideTable)) &#123;</span><br><span class="line">        <span class="comment">// 将溢出的引用计数加到 sidetable 中</span></span><br><span class="line">        sidetable_addExtraRC_nolock(RC_HALF);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果不需要去尝试 +1 并且 SideTables 表锁住了，就将其解锁</span></span><br><span class="line">    <span class="keyword">if</span> (slowpath(!tryRetain &amp;&amp; sideTableLocked)) sidetable_unlock();</span><br><span class="line">    <span class="comment">// 返回当前对象 引用计数已完成+1操作</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">id</span>)<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当<code>tryRetain</code>标志位为1时，我们会先尝试调用<code>sidetable_tryRetain</code>方法，我们先看下这个方法:</p>
<h5 id="sidetable-tryRetain"><a href="#sidetable-tryRetain" class="headerlink" title="sidetable_tryRetain"></a>sidetable_tryRetain</h5><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//尝试将 SideTable 表中的引用计数 +1</span></span><br><span class="line"><span class="keyword">bool</span></span><br><span class="line">objc_object::sidetable_tryRetain()</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SUPPORT_NONPOINTER_ISA</span></span><br><span class="line">    ASSERT(!isa.nonpointer);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// 根据对象地址获取到引用计数器所在的sideTable</span></span><br><span class="line">    SideTable&amp; table = SideTables()[<span class="keyword">this</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// NO SPINLOCK HERE</span></span><br><span class="line">    <span class="comment">// _objc_rootTryRetain() is called exclusively by _objc_loadWeak(), </span></span><br><span class="line">    <span class="comment">// which already acquired the lock on our behalf.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// fixme can&#x27;t do this efficiently with os_lock_handoff_s</span></span><br><span class="line">    <span class="comment">// if (table.slock == 0) &#123;</span></span><br><span class="line">    <span class="comment">//     _objc_fatal(&quot;Do not call -_tryRetain.&quot;);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> result = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// try_emplace 如果给定的key在容器中不存在，原位构造一个元素 如果在容器中则返回</span></span><br><span class="line">    <span class="comment">// try_emplace 有两个返回值 第一个返回值是一个遍历器 第二个返回值表示 key value 在map中是否已存在</span></span><br><span class="line">    auto it = table.refcnts.try_emplace(<span class="keyword">this</span>, SIDE_TABLE_RC_ONE);</span><br><span class="line">    <span class="comment">// 获取引用计数(含两个标志位)</span></span><br><span class="line">    auto &amp;refcnt = it.first-&gt;second;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (it.second) &#123;</span><br><span class="line">        <span class="comment">//如果这个对象对应的实体第一次插入到sidetable中</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (refcnt &amp; SIDE_TABLE_DEALLOCATING) &#123;</span><br><span class="line">        <span class="comment">// 如果当前对象处于正在被销毁状态SIDE_TABLE_DEALLOCATING标志位为1</span></span><br><span class="line">        result = <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (! (refcnt &amp; SIDE_TABLE_RC_PINNED)) &#123;</span><br><span class="line">        <span class="comment">// 引用计数没有溢出 + 1</span></span><br><span class="line">        refcnt += SIDE_TABLE_RC_ONE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回值为引用计数是否成功+1</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当前的对象没有处于正在被销毁的状态时，我们会将sidetable中的引用计数+1。</p>
<p>如果<code>tryRetain</code>标志位为0,那么我们直接调用<code>sidetable_retain</code>方法对引用计数器进行+1操作，<code>sidetable_retain</code>方法如下：</p>
<h5 id="sidetable-retain"><a href="#sidetable-retain" class="headerlink" title="sidetable_retain"></a>sidetable_retain</h5><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将 SideTable 表中的引用计数 +1</span></span><br><span class="line"><span class="keyword">id</span></span><br><span class="line">objc_object::sidetable_retain()</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SUPPORT_NONPOINTER_ISA</span></span><br><span class="line">    ASSERT(!isa.nonpointer);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// 根据对象获取 存储引用计数的sidetable</span></span><br><span class="line">    SideTable&amp; table = SideTables()[<span class="keyword">this</span>];</span><br><span class="line">    </span><br><span class="line">    table.lock();</span><br><span class="line">    <span class="comment">// 获取sidetable中存储的引用计数值</span></span><br><span class="line">    size_t&amp; refcntStorage = table.refcnts[<span class="keyword">this</span>];</span><br><span class="line">    <span class="comment">// 如果引用计数值没有溢出</span></span><br><span class="line">    <span class="keyword">if</span> (! (refcntStorage &amp; SIDE_TABLE_RC_PINNED)) &#123;</span><br><span class="line">        <span class="comment">// 引用计数值+SIDE_TABLE_RC_ONE</span></span><br><span class="line">        <span class="comment">// #define SIDE_TABLE_RC_ONE            (1UL&lt;&lt;2)</span></span><br><span class="line">        <span class="comment">// SIDE_TABLE_RC_ONE = 4 为什么这里会+4我们下面会介绍</span></span><br><span class="line">        refcntStorage += SIDE_TABLE_RC_ONE;</span><br><span class="line">    &#125;</span><br><span class="line">    table.unlock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">id</span>)<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过上面这个方法，我们对引用计数器完成了+1(实际上是+4)的操作，那么这里为什么会+4呢？<br>那是因为对于<code>table.refcnts</code>,实际上并不完全是表示引用计数的值，refcnts的最后两位有特殊的标示意义：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIDE_TABLE_WEAKLY_REFERENCED (1UL&lt;&lt;0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIDE_TABLE_DEALLOCATING      (1UL&lt;&lt;1) </span></span><br></pre></td></tr></table></figure>

<ul>
<li>倒数第一位标记当前对象是否被weak指针指向(1:有weak指针指向);</li>
<li>倒数第二位标记当前对象是否正在销毁状态(1:处在正在销毁状态); </li>
</ul>
<p>因此，我们每次执行retain方法时，虽然每次都是+4，但是对于引用计数真实的值来说就是+1,64位环境下只有62位是保存溢出的引用计数的.</p>
<p>紧接如果对象没有采用isa优化且对象没有正在销毁，我们通过调用<code>addc</code>方法实现引用计数器+1的操作，这个方法会给我们一个标志值<code>carry</code>,表示进行+1操作后，引用计数是否溢出。</p>
<p>如果发生溢出，但是此时我们不需要处理溢出:</p>
<p>那么我们会直接调用<code>rootRetain_overflow</code>方法，我们先来看下这个方法：</p>
<h5 id="rootRetain-overflow"><a href="#rootRetain-overflow" class="headerlink" title="rootRetain_overflow"></a>rootRetain_overflow</h5><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">NEVER_INLINE <span class="keyword">id</span> </span><br><span class="line">objc_object::rootRetain_overflow(<span class="keyword">bool</span> tryRetain)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> rootRetain(tryRetain, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很明显 这个方法实际是递归调用了<code>rootRetain</code>方法，只是<code>handleOverflow</code>参数值被置为<code>yes</code>。而对于retain操作来说实际上是走出了刚才<code>if (!handleOverflow)</code>判断。那么我们继续往下看。</p>
<p>如果发生溢出，且我么需要处理溢出时：<br>我们需要先设置标志位：</p>
<ul>
<li>sideTableLocked = true;</li>
<li>transcribeToSideTable = true;</li>
<li>newisa.extra_rc = RC_HALF;</li>
<li>newisa.has_sidetable_rc = true;</li>
</ul>
<p>同时将<code>newisa</code>的值更新到<code>isa</code>中，保存成功后，while循环结束。</p>
<p>紧接着我们调用<code>sidetable_addExtraRC_nolock</code>方法，下面我们再来看下这个方法:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (slowpath(transcribeToSideTable)) &#123;</span><br><span class="line"> <span class="comment">//拷贝 平外一半的 引用计数到 side table</span></span><br><span class="line">    sidetable_addExtraRC_nolock(RC_HALF);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>RC_HALF</code>的定义如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define RC_HALF  (1ULL&lt;&lt;18)</span><br></pre></td></tr></table></figure>

<p>我们都知道<code>NSTaggedPointer</code>预留了19个bit位用来存放引用计数，<code>RC_HALF</code>的值刚好为 2^19 次方的一半。</p>
<p>我们下面来看下<code>sidetable_addExtraRC_nolock</code>如何实现的</p>
<h5 id="sidetable-addExtraRC-nolock"><a href="#sidetable-addExtraRC-nolock" class="headerlink" title="sidetable_addExtraRC_nolock"></a>sidetable_addExtraRC_nolock</h5><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Move some retain counts to the side table from the isa field.</span></span><br><span class="line"><span class="comment">// Returns true if the object is now pinned.</span></span><br><span class="line"><span class="comment">// 将isa中的引用计数移动到sidetable中 当引用计数达到最大值(溢出)是返回true</span></span><br><span class="line"><span class="keyword">bool</span> </span><br><span class="line">objc_object::sidetable_addExtraRC_nolock(size_t delta_rc)</span><br><span class="line">&#123;</span><br><span class="line">    ASSERT(isa.nonpointer);</span><br><span class="line">    <span class="comment">// 根据对象地址获取到存放引用计数对应的sidetable</span></span><br><span class="line">    SideTable&amp; table = SideTables()[<span class="keyword">this</span>];</span><br><span class="line">    <span class="comment">// 从table.refcnts中获取当前对象的引用计数</span></span><br><span class="line">    size_t&amp; refcntStorage = table.refcnts[<span class="keyword">this</span>];</span><br><span class="line">    <span class="comment">// 声明一个局部变量存储旧的引用计数</span></span><br><span class="line">    size_t oldRefcnt = refcntStorage;</span><br><span class="line">    <span class="comment">// isa-side bits should not be set here</span></span><br><span class="line">    <span class="comment">// 如果就的引用计数&gt;0或sidetable正在销毁</span></span><br><span class="line">    <span class="comment">// 如果引用计数&gt;0或当前对象再被其他对象弱引用</span></span><br><span class="line">    ASSERT((oldRefcnt &amp; SIDE_TABLE_DEALLOCATING) == <span class="number">0</span>);</span><br><span class="line">    ASSERT((oldRefcnt &amp; SIDE_TABLE_WEAKLY_REFERENCED) == <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// #define SIDE_TABLE_RC_PINNED         (1UL&lt;&lt;(WORD_BITS-1))</span></span><br><span class="line">    <span class="comment">// oldRefcnt &amp; SIDE_TABLE_RC_PINNED = 1 就是 oldRefcnt = 2147483648 （32位情况）</span></span><br><span class="line">    <span class="comment">// 这时候 引用计数已经超过了三十二位所能表达的最大值 直接返回true</span></span><br><span class="line">    <span class="keyword">if</span> (oldRefcnt &amp; SIDE_TABLE_RC_PINNED) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 溢出标志位</span></span><br><span class="line">    uintptr_t carry;</span><br><span class="line">    <span class="comment">// 对oldRefcnt执行+delta_rc操作</span></span><br><span class="line">    size_t newRefcnt = </span><br><span class="line">        addc(oldRefcnt, delta_rc &lt;&lt; SIDE_TABLE_RC_SHIFT, <span class="number">0</span>, &amp;carry);</span><br><span class="line">    <span class="comment">// 如果引用计数溢出 设置标识为已满</span></span><br><span class="line">    <span class="keyword">if</span> (carry) &#123;</span><br><span class="line">        <span class="comment">// 如果是32位的情况 SIDE_TABLE_RC_PINNED = 1&lt;&lt; (32-1)</span></span><br><span class="line">        <span class="comment">// int的最大值 SIDE_TABLE_RC_PINNED = 2147483648</span></span><br><span class="line">        <span class="comment">//  SIDE_TABLE_FLAG_MASK = 3</span></span><br><span class="line">        <span class="comment">// refcntStorage = 2147483648 | (oldRefcnt &amp; 3)</span></span><br><span class="line">        <span class="comment">// 如果溢出，直接把refcntStorage 设置成最大值</span></span><br><span class="line">        refcntStorage =</span><br><span class="line">            SIDE_TABLE_RC_PINNED | (oldRefcnt &amp; SIDE_TABLE_FLAG_MASK);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果没有溢出 那么直接将新的引用计数赋值给refcntStorage</span></span><br><span class="line">        refcntStorage = newRefcnt;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>向右偏移两位的原因是,RefcountMap refcnts的最后两位有特殊的标示意义：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIDE_TABLE_WEAKLY_REFERENCED (1UL&lt;&lt;0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIDE_TABLE_DEALLOCATING      (1UL&lt;&lt;1) </span></span><br></pre></td></tr></table></figure>

<ul>
<li>倒数第一位标记当前对象是否被weak指针指向(1:有weak指针指向);</li>
<li>倒数第二位标记当前对象是否正在销毁状态(1:处在正在销毁状态); </li>
</ul>
<p>所以,64位环境下只有62位是保存溢出的引用计数的.</p>
<p>通过上面的介绍我们了解到了引用计数是如何在sidetable中存储的(retian方法)。那么引用计数-1的操作又是怎么实现的呢？</p>
<h3 id="release"><a href="#release" class="headerlink" title="release"></a>release</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Equivalent to calling [this release], with shortcuts if there is no override</span></span><br><span class="line"><span class="comment">// 等价于直接使用对象调用release方法</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">objc_object::release()</span><br><span class="line">&#123;</span><br><span class="line">    ASSERT(!isTaggedPointer());</span><br><span class="line">    <span class="comment">// 如果没有自定义的release方法 就直接调用rootRelease</span></span><br><span class="line">    <span class="keyword">if</span> (fastpath(!ISA()-&gt;hasCustomRR())) &#123;</span><br><span class="line">        rootRelease();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果有自定义的release方法那么调用对象的release方法</span></span><br><span class="line">    ((<span class="keyword">void</span>(*)(objc_object *, SEL))objc_msgSend)(<span class="keyword">this</span>, <span class="keyword">@selector</span>(release));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的代码我们看到，在没有自定义release方法时，系统默认是调用的<code>rootRelease</code>方法，下面我们来看下这个方法。</p>
<h4 id="rootRelease"><a href="#rootRelease" class="headerlink" title="rootRelease"></a>rootRelease</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">ALWAYS_INLINE <span class="keyword">bool</span> </span><br><span class="line">objc_object::rootRelease()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 调用了私有函数 rootRelease 去实现</span></span><br><span class="line">    <span class="keyword">return</span> rootRelease(<span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这个方法实际上调用了同名函数(两个默认参数),下面我们进一步看下带有两个参数的<code>rootRelease</code>方法:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 真正的release方法</span></span><br><span class="line"><span class="comment">// 两个参数分别是 是否需要调用dealloc函数，是否需要处理 向下溢出的问题</span></span><br><span class="line">ALWAYS_INLINE <span class="keyword">bool</span> </span><br><span class="line">objc_object::rootRelease(<span class="keyword">bool</span> performDealloc, <span class="keyword">bool</span> handleUnderflow)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 如果是TaggedPointer 不需要进行release操作</span></span><br><span class="line">    <span class="keyword">if</span> (isTaggedPointer()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 局部变量sideTable是否上锁 默认false</span></span><br><span class="line">    <span class="keyword">bool</span> sideTableLocked = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 两个局部变量用来记录这个对象的isa指针</span></span><br><span class="line">    isa_t oldisa;</span><br><span class="line">    isa_t newisa;</span><br><span class="line"></span><br><span class="line"> retry:</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 加载这个isa指针</span></span><br><span class="line">        oldisa = LoadExclusive(&amp;isa.bits);</span><br><span class="line">        newisa = oldisa;</span><br><span class="line">        <span class="comment">// 如果没有进行nonpointer优化</span></span><br><span class="line">        <span class="keyword">if</span> (slowpath(!newisa.nonpointer)) &#123;</span><br><span class="line">            ClearExclusive(&amp;isa.bits);</span><br><span class="line">            <span class="comment">// 如果是类对象直接返回false 不需要释放</span></span><br><span class="line">            <span class="keyword">if</span> (rawISA()-&gt;isMetaClass()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">// 如果sideTableLocked 则解锁 这里默认是false</span></span><br><span class="line">            <span class="keyword">if</span> (sideTableLocked)</span><br><span class="line">                sidetable_unlock();</span><br><span class="line">            <span class="comment">// 调用sidetable_release 进行引用计数-1操作</span></span><br><span class="line">            <span class="keyword">return</span> sidetable_release(performDealloc);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 溢出标记位</span></span><br><span class="line">        uintptr_t carry;</span><br><span class="line">        <span class="comment">// newisa 对象的extra_rc 进行-1操作</span></span><br><span class="line">        newisa.bits = subc(newisa.bits, RC_ONE, <span class="number">0</span>, &amp;carry);  <span class="comment">// extra_rc--</span></span><br><span class="line">        <span class="comment">// 如果-1操作后 向下溢出了 结果为负数</span></span><br><span class="line">        <span class="keyword">if</span> (slowpath(carry)) &#123;</span><br><span class="line">            <span class="comment">// don&#x27;t ClearExclusive()</span></span><br><span class="line">            <span class="comment">// 调用underflow 进行向下溢出的处理</span></span><br><span class="line">            <span class="keyword">goto</span> underflow;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//  开启循环，直到 isa.bits 中的值被成功更新成 newisa.bits</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (slowpath(!StoreReleaseExclusive(&amp;isa.bits, </span><br><span class="line">                                             oldisa.bits, newisa.bits)));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//走到这说明引用计数的 -1 操作已完成</span></span><br><span class="line">    <span class="keyword">if</span> (slowpath(sideTableLocked)) sidetable_unlock();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"> underflow:</span><br><span class="line">    <span class="comment">//newisa的extra_rc在执行-1操作后导致了向下溢出</span></span><br><span class="line">    <span class="comment">// 放弃对newisa的修改 使用之前的oldisa</span></span><br><span class="line">    newisa = oldisa;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 isa 的 has_sidetable_rc 标志位标识引用计数已溢出</span></span><br><span class="line">    <span class="comment">// has_sidetable_rc 用于标识是否当前的引用计数过大，无法在isa中存储，</span></span><br><span class="line">    <span class="comment">// 而需要借用sidetable来存储。（这种情况大多不会发生）</span></span><br><span class="line">    <span class="keyword">if</span> (slowpath(newisa.has_sidetable_rc)) &#123;</span><br><span class="line">        <span class="comment">// 是否需要处理下溢</span></span><br><span class="line">        <span class="keyword">if</span> (!handleUnderflow) &#123;</span><br><span class="line">            <span class="comment">// 清除原 isa 中的数据的原子独占</span></span><br><span class="line">            ClearExclusive(&amp;isa.bits);</span><br><span class="line">            <span class="comment">// 如果不需要处理下溢 直接调用 rootRelease_underflow方法</span></span><br><span class="line">            <span class="keyword">return</span> rootRelease_underflow(performDealloc);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果sidetable是上锁状态</span></span><br><span class="line">        <span class="keyword">if</span> (!sideTableLocked) &#123;</span><br><span class="line">            <span class="comment">// 解除清除原 isa 中的数据的原子独占</span></span><br><span class="line">            ClearExclusive(&amp;isa.bits);</span><br><span class="line">            <span class="comment">// sidetable 上锁</span></span><br><span class="line">            sidetable_lock();</span><br><span class="line">            sideTableLocked = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">// 跳转到 retry 重新开始，避免 isa 从 nonpointer 类型转换成原始类型导致的问题</span></span><br><span class="line">            <span class="keyword">goto</span> retry;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// sidetable_subExtraRC_nolock 放回要从sidetable移动到isa的extra_rc的值</span></span><br><span class="line">        <span class="comment">// 默认是获取extra_rc可存储的长度一半的值</span></span><br><span class="line">        size_t borrowed = sidetable_subExtraRC_nolock(RC_HALF);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// To avoid races, has_sidetable_rc must remain set </span></span><br><span class="line">        <span class="comment">// even if the side table count is now zero.</span></span><br><span class="line">        <span class="comment">//  为了避免冲突 has_sidetable_rc 标志位必须保留1的状态 及时sidetable中的个数为0</span></span><br><span class="line">        <span class="keyword">if</span> (borrowed &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 将newisa中引用计数值extra_rc 设置为borrowed - 1</span></span><br><span class="line">            <span class="comment">// -1 是因为 本身这次是release操作</span></span><br><span class="line">            newisa.extra_rc = borrowed - <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 然后将修改同步到isa中</span></span><br><span class="line">            <span class="keyword">bool</span> stored = StoreReleaseExclusive(&amp;isa.bits, </span><br><span class="line">                                                oldisa.bits, newisa.bits);</span><br><span class="line">            <span class="comment">// 如果保存失败</span></span><br><span class="line">            <span class="keyword">if</span> (!stored) &#123;</span><br><span class="line">                <span class="comment">// Inline update failed. </span></span><br><span class="line">                <span class="comment">// Try it again right now. This prevents livelock on LL/SC </span></span><br><span class="line">                <span class="comment">// architectures where the side table access itself may have </span></span><br><span class="line">                <span class="comment">// dropped the reservation.</span></span><br><span class="line">                <span class="comment">// 从新装载isa</span></span><br><span class="line">                isa_t oldisa2 = LoadExclusive(&amp;isa.bits);</span><br><span class="line">                isa_t newisa2 = oldisa2;</span><br><span class="line">                <span class="comment">// 如果newisa2是nonpointer类型</span></span><br><span class="line">                <span class="keyword">if</span> (newisa2.nonpointer) &#123;</span><br><span class="line">                    <span class="comment">// 下溢出标志位</span></span><br><span class="line">                    uintptr_t overflow;</span><br><span class="line">                    <span class="comment">// 将从 SideTables 表中获取的引用计数保存到 newisa2 的 extra_rc 标志位中</span></span><br><span class="line">                    newisa2.bits = </span><br><span class="line">                        addc(newisa2.bits, RC_ONE * (borrowed<span class="number">-1</span>), <span class="number">0</span>, &amp;overflow);</span><br><span class="line">                    <span class="comment">//</span></span><br><span class="line">                    <span class="keyword">if</span> (!overflow) &#123;</span><br><span class="line">                        <span class="comment">// 如果没有溢出再次将 isa.bits 中的值更新为 newisa2.bits</span></span><br><span class="line">                        stored = StoreReleaseExclusive(&amp;isa.bits, oldisa2.bits, </span><br><span class="line">                                                       newisa2.bits);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果重试之后依然失败</span></span><br><span class="line">            <span class="keyword">if</span> (!stored) &#123;</span><br><span class="line">                <span class="comment">// 将从sidetable中取出的引用计数borrowed 重新加到sidetable中</span></span><br><span class="line">                sidetable_addExtraRC_nolock(borrowed);</span><br><span class="line">                <span class="comment">// 重新尝试</span></span><br><span class="line">                <span class="keyword">goto</span> retry;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Decrement successful after borrowing from side table.</span></span><br><span class="line">            <span class="comment">// This decrement cannot be the deallocating decrement - the side </span></span><br><span class="line">            <span class="comment">// table lock and has_sidetable_rc bit ensure that if everyone </span></span><br><span class="line">            <span class="comment">// else tried to -release while we worked, the last one would block.</span></span><br><span class="line">            <span class="comment">// 完成对 SideTables 表中数据的操作后，为其解锁</span></span><br><span class="line">            sidetable_unlock();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 在从Side table拿出一部分引用计数之后 Side table为空</span></span><br><span class="line">            <span class="comment">// Side table is empty after all. Fall-through to the dealloc path.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果当前的对象正在被释放</span></span><br><span class="line">    <span class="keyword">if</span> (slowpath(newisa.deallocating)) &#123;</span><br><span class="line">        ClearExclusive(&amp;isa.bits);</span><br><span class="line">        <span class="comment">// 如果sideTableLocked被锁 那么解锁</span></span><br><span class="line">        <span class="keyword">if</span> (sideTableLocked) sidetable_unlock();</span><br><span class="line">        <span class="comment">// 兑现被过度释放</span></span><br><span class="line">        <span class="keyword">return</span> overrelease_error();</span><br><span class="line">        <span class="comment">// does not actually return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将对象被释放的标志位置为true</span></span><br><span class="line">    newisa.deallocating = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 将newisa同步到isa中 如果失败 进行重试</span></span><br><span class="line">    <span class="keyword">if</span> (!StoreExclusive(&amp;isa.bits, oldisa.bits, newisa.bits))</span><br><span class="line">        <span class="keyword">goto</span> retry;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果sideTableLocked= true</span></span><br><span class="line">    <span class="keyword">if</span> (slowpath(sideTableLocked))</span><br><span class="line">        <span class="comment">// Side table解锁</span></span><br><span class="line">        sidetable_unlock();</span><br><span class="line"></span><br><span class="line">    __c11_atomic_thread_fence(__ATOMIC_ACQUIRE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果需要执行dealloc方法 那么调用该对象的dealloc方法</span></span><br><span class="line">    <span class="keyword">if</span> (performDealloc) &#123;</span><br><span class="line">        ((<span class="keyword">void</span>(*)(objc_object *, SEL))objc_msgSend)(<span class="keyword">this</span>, <span class="keyword">@selector</span>(dealloc));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个方法还是有点长的，我们看到主要是由两个内部方法<code>retry</code>,<code>underflow</code>组成，下面我们来一步步的整理下引用计数-1操作的具体步骤</p>
<h4 id="retry"><a href="#retry" class="headerlink" title="retry"></a>retry</h4><h5 id="sidetable-release"><a href="#sidetable-release" class="headerlink" title="sidetable_release"></a>sidetable_release</h5><p>如果这个对象没有<code>nonpointer</code>优化，且不是一个类对象，那么我们直接通过对sidetable进行-1操作</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将 SideTable 表中的引用计数 -1</span></span><br><span class="line">uintptr_t</span><br><span class="line">objc_object::sidetable_release(<span class="keyword">bool</span> performDealloc)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SUPPORT_NONPOINTER_ISA</span></span><br><span class="line">    ASSERT(!isa.nonpointer);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// 根据对象地址获取SideTable</span></span><br><span class="line">    SideTable&amp; table = SideTables()[<span class="keyword">this</span>];</span><br><span class="line">    <span class="comment">// 是否需要执行dealloc方法 默认是false</span></span><br><span class="line">    <span class="keyword">bool</span> do_dealloc = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    table.lock();</span><br><span class="line">    <span class="comment">// 获取当前对象的销毁状态 方法的返回值有2个</span></span><br><span class="line">    <span class="comment">// 引用计数和当前对象是否已存在与map中</span></span><br><span class="line">    auto it = table.refcnts.try_emplace(<span class="keyword">this</span>, SIDE_TABLE_DEALLOCATING);</span><br><span class="line">    auto &amp;refcnt = it.first-&gt;second;</span><br><span class="line">    <span class="comment">// 如果当前对象之前不存在与map中</span></span><br><span class="line">    <span class="keyword">if</span> (it.second) &#123;</span><br><span class="line">        do_dealloc = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (refcnt &lt; SIDE_TABLE_DEALLOCATING) &#123;</span><br><span class="line">        <span class="comment">// 如果引用计数的值小于 SIDE_TABLE_DEALLOCATING = 2(0010)</span></span><br><span class="line">        <span class="comment">// refcnt 低两位分别是SIDE_TABLE_WEAKLY_REFERENCED 0  SIDE_TABLE_DEALLOCATING 1</span></span><br><span class="line">        <span class="comment">// 这个对象需要被销毁</span></span><br><span class="line">        do_dealloc = <span class="literal">true</span>;</span><br><span class="line">        refcnt |= SIDE_TABLE_DEALLOCATING;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (! (refcnt &amp; SIDE_TABLE_RC_PINNED)) &#123;</span><br><span class="line">        <span class="comment">// 如果引用计数有值且未溢出那么-1</span></span><br><span class="line">        refcnt -= SIDE_TABLE_RC_ONE;</span><br><span class="line">    &#125;</span><br><span class="line">    table.unlock();</span><br><span class="line">    <span class="comment">// 如果需要执行dealloc 那么就调用这个对象的dealloc</span></span><br><span class="line">    <span class="keyword">if</span> (do_dealloc  &amp;&amp;  performDealloc) &#123;</span><br><span class="line">        ((<span class="keyword">void</span>(*)(objc_object *, SEL))objc_msgSend)(<span class="keyword">this</span>, <span class="keyword">@selector</span>(dealloc));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> do_dealloc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相反，如果该对象做了nonpointer优化，那么我们直接对extra_rc进行-1操作，即</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// newisa 对象的extra_rc 进行-1操作</span></span><br><span class="line">newisa.bits = subc(newisa.bits, RC_ONE, <span class="number">0</span>, &amp;carry);  <span class="comment">// extra_rc--</span></span><br><span class="line"><span class="comment">// 如果-1操作后 向下溢出了 结果为负数</span></span><br><span class="line"><span class="keyword">if</span> (slowpath(carry)) &#123;</span><br><span class="line">    <span class="comment">// don&#x27;t ClearExclusive()</span></span><br><span class="line">    <span class="comment">// 调用underflow 进行向下溢出的处理</span></span><br><span class="line">    <span class="keyword">goto</span> underflow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将extra_rc计数-1，如果发现-1操作之后，extra_rc的个数为0，那么就出现了向下溢出，我们需要将sideTable中的部分引用计数拿到extra_rc中记录。如果没有向下溢出，那么我们就直接将修改后的newisa同步到isa中即完成了release操作。</p>
<h4 id="underflow"><a href="#underflow" class="headerlink" title="underflow"></a>underflow</h4><p>如果在将extra_rc进行-1操作时，出现了向下溢出的问题，那么我们需要将sideTable中的引用计数移动到extra_rc中存储。</p>
<p>下面我们来分析下具体过程</p>
<p>先判断<code>has_sidetable_rc</code>是否有sidetable引用计数,如果有我们要确认是否需要处理向下溢出，如果不需要处理向下溢出，那么我们直接调用<code>rootRelease_underflow</code>方法，</p>
<h5 id="rootRelease-underflow"><a href="#rootRelease-underflow" class="headerlink" title="rootRelease_underflow"></a>rootRelease_underflow</h5><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">NEVER_INLINE uintptr_t</span><br><span class="line">objc_object::rootRelease_underflow(<span class="keyword">bool</span> performDealloc)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> rootRelease(performDealloc, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很明显这个方法实际上与retain操作时处理溢出逻辑相同，将<code>rootRelease</code>方法中的<code>handleUnderflow</code>参数置为true,要处理向下溢出。</p>
<p>下面我们再来看下，需要处理向下溢出时,如果当前的sidetable处于未上锁的状态时，将sidetable上锁然后进行重试，如果sidetable未已经上锁了，那么我们会执行下面这句代码:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">size_t</span> borrowed = sidetable_subExtraRC_nolock(RC_HALF);</span><br></pre></td></tr></table></figure>
<p>sidetable_subExtraRC_nolock 返回要从sidetable移动到isa的extra_rc的值，默认是获取extra_rc可存储的长度一半的值。</p>
<p>如果此时从sidetable中拿到的值 &gt; 0,那么我们要将这部分值放到isa的extra_rc中进行存储，如果取到的borrowed的值为0，那么说明sidetable中的引用计数为0，那么我们直接释放该对象即可。</p>
<h5 id="StoreReleaseExclusive"><a href="#StoreReleaseExclusive" class="headerlink" title="StoreReleaseExclusive"></a>StoreReleaseExclusive</h5><p>上面说到如果从sidetable中获取到的值borrowed大于0，那么我们直接将<code>newisa.extra_rc</code>设置为<code>borrowed - 1</code>即可。</p>
<p>然后我们在调用<code>StoreReleaseExclusive</code>方法将<code>newisa</code>同步到<code>isa</code>中。</p>
<p>如果这里<code>StoreReleaseExclusive</code>方法保存失败了，那么我们需要重新调用<code>LoadExclusive</code>重新声明两个变量<code>newisa2</code>,<code>oldisa2</code>。通过<code>addc</code>方法将<code>extra_rc</code>置为<code>borrowed-1</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">newisa2.bits = addc(newisa2.bits, RC_ONE * (borrowed<span class="number">-1</span>), <span class="number">0</span>, &amp;overflow);</span><br></pre></td></tr></table></figure>
<p>然后再次调用<code>StoreReleaseExclusive</code>方法将<code>newisa2</code>的改动同步到<code>isa</code>中。</p>
<p>如果<code>StoreReleaseExclusive</code>方法依然保存失败，那么我们就把从sidetable中获取的<code>borrowed</code>重新加到sideTable中。然后调用retry方法。</p>
<p>经过<code>StoreReleaseExclusive</code>这一步，引用计数更新操作完成。但是如果此时的引用计数为0我们改如何操作呢？</p>
<p>如果引用计数更新成功，那么我们需要先判断，当前对象是否正在被释放，如果正在被释放 那么调用过度释放方法<code>overrelease_error</code></p>
<h5 id="overrelease-error"><a href="#overrelease-error" class="headerlink" title="overrelease_error"></a>overrelease_error</h5><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">NEVER_INLINE uintptr_t</span><br><span class="line">objc_object::overrelease_error()</span><br><span class="line">&#123;</span><br><span class="line">    _objc_inform_now_and_on_crash(<span class="string">&quot;%s object %p overreleased while already deallocating; break on objc_overrelease_during_dealloc_error to debug&quot;</span>, object_getClassName((<span class="keyword">id</span>)<span class="keyword">this</span>), <span class="keyword">this</span>);</span><br><span class="line">    objc_overrelease_during_dealloc_error();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// allow rootRelease() to tail-call this</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法主要是定义了crash信息，当一个用户正在被释放时，再次调用release方法时会导致crash，具体crash信息如上述代码。</p>
<p>如果当前对象没有被正在释放，那么我们将当前对象正在被释放标志位置为true <code>newisa.deallocating = true;</code> 同时将状态的更新同步到<code>isa</code>中。如果同步失败，那么会重复走一次retry。</p>
<p>更新状态成功后，对sidetable的操作也结束了，我们就可以将sidetable解锁(sidetable_unlock),如果需要执行dealloc方法，那么我们调用dealloc方法进行对象释放通知。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>至此我们就看完了objc对于retain和release以及其对引用计数的操作，以及在retain操作时当extra_rc空间不足时，引用计数是如何从extra_rc转移到sidetable中和release操作时引用计数是如何从sidetable转移到extra_rc中的。希望看了这篇文章可以帮你更好的了解引用计数的实现。</p>
]]></content>
  </entry>
  <entry>
    <title>__Block 到底做了什么</title>
    <url>/2018/04/25/what-did-block-do/</url>
    <content><![CDATA[<p>Block默认不允许修改外部变量的值,我们可以通过对要修改的变量添加__block修饰,来达到可以在block内部修改外部变量的目的。那么__block到底都做了什么呢？为什么添加了__block就可以在block内部修改外部变量了呢！</p>
<a id="more"></a>



<h2 id="Block与外部变量"><a href="#Block与外部变量" class="headerlink" title="Block与外部变量"></a>Block与外部变量</h2><h2 id="外部变量"><a href="#外部变量" class="headerlink" title="外部变量"></a>外部变量</h2><ul>
<li>自动变量</li>
<li>静态变量</li>
<li>静态全局变量</li>
<li>全局变量</li>
</ul>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> global_i = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> static_global_j = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> static_k = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> val = <span class="number">4</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> (^myBlock)(<span class="keyword">void</span>) = ^&#123;</span><br><span class="line">        global_i ++;</span><br><span class="line">        static_global_j ++;</span><br><span class="line">        static_k ++;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;Block中 global_i = %d,static_global_j = %d,static_k = %d,val = %d&quot;</span>,global_i,static_global_j,static_k,val);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    global_i ++;</span><br><span class="line">    static_global_j ++;</span><br><span class="line">    static_k ++;</span><br><span class="line">    val ++;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;Block外 global_i = %d,static_global_j = %d,static_k = %d,val = %d&quot;</span>,global_i,static_global_j,static_k,val);</span><br><span class="line">    </span><br><span class="line">    myBlock();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行结果:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Block 外  global_i = <span class="number">2</span>,static_global_j = <span class="number">3</span>,static_k = <span class="number">4</span>,val = <span class="number">5</span></span><br><span class="line">Block 中  global_i = <span class="number">3</span>,static_global_j = <span class="number">4</span>,static_k = <span class="number">5</span>,val = <span class="number">4</span></span><br></pre></td></tr></table></figure>

<p>对于block和外部变量的关系,我们有两个问题需要搞清楚：</p>
<ul>
<li>1.为什么在Block里面不加__bolck不允许更改变量？</li>
<li>2.为什么自动变量的值没有增加，而其他几个变量的值是增加的？自动变量是什么状态下被block捕获进去的？</li>
</ul>
<h3 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> global_i = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> static_global_j = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">main_block_impl_0</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> <span class="title">impl</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span>* <span class="title">Desc</span>;</span></span><br><span class="line">  <span class="keyword">int</span> *static_k;</span><br><span class="line">  <span class="keyword">int</span> val;</span><br><span class="line">  __main_block_impl_0(<span class="keyword">void</span> *fp, struct __main_block_desc_0 *desc, <span class="keyword">int</span> *_static_k, <span class="keyword">int</span> _val, <span class="keyword">int</span> flags=<span class="number">0</span>) : static_k(_static_k), val(_val) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class="line">  <span class="keyword">int</span> *static_k = __cself-&gt;static_k; <span class="comment">// bound by copy</span></span><br><span class="line">  <span class="keyword">int</span> val = __cself-&gt;val; <span class="comment">// bound by copy</span></span><br><span class="line"></span><br><span class="line">        global_i ++;</span><br><span class="line">        static_global_j ++;</span><br><span class="line">        (*static_k) ++;</span><br><span class="line">        NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_45_k1d9q7c52vz50wz1683_hk9r0000gn_T_main_6fe658_mi_0,global_i,static_global_j,(*static_k),val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span> &#123;</span></span><br><span class="line">  <span class="keyword">size_t</span> reserved;</span><br><span class="line">  <span class="keyword">size_t</span> Block_size;</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(struct __main_block_impl_0)&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> static_k = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> val = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> (*myBlock)(<span class="keyword">void</span>) = ((<span class="keyword">void</span> (*)())&amp;__main_block_impl_0((<span class="keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA, &amp;static_k, val));</span><br><span class="line"></span><br><span class="line">    global_i ++;</span><br><span class="line">    static_global_j ++;</span><br><span class="line">    static_k ++;</span><br><span class="line">    val ++;</span><br><span class="line">    NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_45_k1d9q7c52vz50wz1683_hk9r0000gn_T_main_6fe658_mi_1,global_i,static_global_j,static_k,val);</span><br><span class="line"></span><br><span class="line">    ((<span class="keyword">void</span> (*)(__block_impl *))((__block_impl *)myBlock)-&gt;FuncPtr)((__block_impl *)myBlock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在<code>__main_block_func_0</code>方法中,我们可以看到 对于全局变量不论是否是静态的都是直接使用!(内存中有一块区域是专门存放全局变量的这些变量不会被销毁,因此可以不用拷贝 直接使用) 对于局部变量 如果是静态变量:</p>
<p><code>int *static_k = __cself-&gt;static_k; // bound by copy</code></p>
<p>新定义了一个变量指向了这个静态变量,但是注意 这里是 <code>int *</code> 这就说明引用的是静态变量的地址。</p>
<p>我们再来看一下val这个局部变量:</p>
<p><code>int val = __cself-&gt;val; // bound by copy</code></p>
<p>同样新定义了一个变量,这个变量的值等于传入的val的值</p>
<p>其实这个方法的具体参数 我们可以直接通过看main函数中的<code>__main_block_impl_0</code>方法就可以看出来</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> (*myBlock)(<span class="keyword">void</span>) = ((<span class="keyword">void</span> (*)())&amp;__main_block_impl_0((<span class="keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA, &amp;static_k, val));</span><br></pre></td></tr></table></figure>

<p>区别就是静态变量传入的是<code>&amp;static_k</code>,普通局部变量传递的是<code>val</code>.</p>
<p>通过这些,我们可以看出,block内部都是对外部非全局变量进行拷贝,因此如果外部对block内值引用的变量进行了修改不会影响block内变量的值。但是如果是静态变量 那么是会影响的。</p>
<table>
<thead>
<tr>
<th>–</th>
<th>静态变量</th>
<th>静态全局变量</th>
<th>全局变量</th>
<th>自动变量</th>
</tr>
</thead>
<tbody><tr>
<td>block内的传递</td>
<td>地址传递</td>
<td>地址传递</td>
<td>地址传递</td>
<td>值传递</td>
</tr>
</tbody></table>
<p>到此为止，上面提出的第二个问题就解开答案了。</p>
<p>自动变量是以值传递方式传递到Block的构造函数里面去的。Block只捕获Block中会用到的变量。由于只捕获了自动变量的值，并非内存地址，所以Block内部不能改变自动变量的值(block外面变量值的改变也不会影响block内部)。Block捕获的外部变量可以改变值的是静态变量，静态全局变量，全局变量。上面例子也都证明过了。</p>
<p>至此,我们了解 如果要在block内部修改外部的变量,可以使用两种方法:</p>
<ul>
<li>1、传入这个外部变量的内存地址而不是值传递</li>
<li>2、使用__block 修饰</li>
</ul>
<h2 id="Block中外部变量值的修改"><a href="#Block中外部变量值的修改" class="headerlink" title="Block中外部变量值的修改"></a>Block中外部变量值的修改</h2><h3 id="传入内存地址"><a href="#传入内存地址" class="headerlink" title="传入内存地址"></a>传入内存地址</h3><p>先看下面的例子:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    </span><br><span class="line">  <span class="built_in">NSMutableString</span> * str = [[<span class="built_in">NSMutableString</span> alloc]initWithString:<span class="string">@&quot;Hello,&quot;</span>];</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">void</span> (^myBlock)(<span class="keyword">void</span>) = ^&#123;</span><br><span class="line">            [str appendString:<span class="string">@&quot;World!&quot;</span>];</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;Block中 str = %@&quot;</span>,str);</span><br><span class="line">        &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;Block外 str = %@&quot;</span>,str);</span><br><span class="line">    </span><br><span class="line">    myBlock();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Block 外  str = Hello,</span><br><span class="line">Block 中  str = Hello,World!</span><br></pre></td></tr></table></figure>

<h4 id="源码解析-1"><a href="#源码解析-1" class="headerlink" title="源码解析"></a>源码解析</h4><p>下面我们利用clang来看一下上面这段代码的具体实现</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> __main_block_impl_0 &#123;</span><br><span class="line">  <span class="keyword">struct</span> __block_impl impl;</span><br><span class="line">  <span class="keyword">struct</span> __main_block_desc_0* Desc;</span><br><span class="line">  <span class="built_in">NSMutableString</span> *str;</span><br><span class="line">  __main_block_impl_0(<span class="keyword">void</span> *fp, <span class="keyword">struct</span> __main_block_desc_0 *desc, <span class="built_in">NSMutableString</span> *_str, <span class="keyword">int</span> flags=<span class="number">0</span>) : str(_str) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意这里的参数是 *__cself</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(<span class="keyword">struct</span> __main_block_impl_0 *__cself) &#123;</span><br><span class="line">  <span class="built_in">NSMutableString</span> *str = __cself-&gt;str; <span class="comment">// bound by copy</span></span><br><span class="line"></span><br><span class="line">            ((<span class="keyword">void</span> (*)(<span class="keyword">id</span>, SEL, <span class="built_in">NSString</span> *))(<span class="keyword">void</span> *)objc_msgSend)((<span class="keyword">id</span>)str, sel_registerName(<span class="string">&quot;appendString:&quot;</span>), (<span class="built_in">NSString</span> *)&amp;__NSConstantStringImpl__var_folders_45_k1d9q7c52vz50wz1683_hk9r0000gn_T_main_33ff12_mi_1);</span><br><span class="line">            <span class="built_in">NSLog</span>((<span class="built_in">NSString</span> *)&amp;__NSConstantStringImpl__var_folders_45_k1d9q7c52vz50wz1683_hk9r0000gn_T_main_33ff12_mi_2,str);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_copy_0(<span class="keyword">struct</span> __main_block_impl_0*dst, <span class="keyword">struct</span> __main_block_impl_0*src) &#123;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">_Block_object_assign((<span class="keyword">void</span>*)&amp;dst-&gt;str, (<span class="keyword">void</span>*)src-&gt;str, <span class="number">3</span><span class="comment">/*BLOCK_FIELD_IS_OBJECT*/</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_dispose_0(<span class="keyword">struct</span> __main_block_impl_0*src) &#123;_Block_object_dispose((<span class="keyword">void</span>*)src-&gt;str, <span class="number">3</span><span class="comment">/*BLOCK_FIELD_IS_OBJECT*/</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">struct</span> __main_block_desc_0 &#123;</span><br><span class="line">  size_t reserved;</span><br><span class="line">  size_t Block_size;</span><br><span class="line">  <span class="keyword">void</span> (*<span class="keyword">copy</span>)(<span class="keyword">struct</span> __main_block_impl_0*, <span class="keyword">struct</span> __main_block_impl_0*);</span><br><span class="line">  <span class="keyword">void</span> (*dispose)(<span class="keyword">struct</span> __main_block_impl_0*);</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="built_in">NSMutableString</span> * str = ((<span class="built_in">NSMutableString</span> *(*)(<span class="keyword">id</span>, SEL, <span class="built_in">NSString</span> *))(<span class="keyword">void</span> *)objc_msgSend)((<span class="keyword">id</span>)((<span class="built_in">NSMutableString</span> *(*)(<span class="keyword">id</span>, SEL))(<span class="keyword">void</span> *)objc_msgSend)((<span class="keyword">id</span>)objc_getClass(<span class="string">&quot;NSMutableString&quot;</span>), sel_registerName(<span class="string">&quot;alloc&quot;</span>)), sel_registerName(<span class="string">&quot;initWithString:&quot;</span>), (<span class="built_in">NSString</span> *)&amp;__NSConstantStringImpl__var_folders_45_k1d9q7c52vz50wz1683_hk9r0000gn_T_main_33ff12_mi_0);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">void</span> (*myBlock)(<span class="keyword">void</span>) = ((<span class="keyword">void</span> (*)())&amp;__main_block_impl_0((<span class="keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA, str, <span class="number">570425344</span>));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSLog</span>((<span class="built_in">NSString</span> *)&amp;__NSConstantStringImpl__var_folders_45_k1d9q7c52vz50wz1683_hk9r0000gn_T_main_33ff12_mi_3,str);</span><br><span class="line"></span><br><span class="line">    ((<span class="keyword">void</span> (*)(__block_impl *))((__block_impl *)myBlock)-&gt;FuncPtr)((__block_impl *)myBlock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>从 <code>static void __main_block_func_0(struct __main_block_impl_0 *__cself) </code>可以看出 传入的参数是指针 <code> NSMutableString *str = __cself-&gt;str; // bound by copy</code> 新建了一个变量指向的是之前的变量的地址。因此block内部改变的仍然是之前的数据。</p>
<h3 id="使用-block修饰"><a href="#使用-block修饰" class="headerlink" title="使用__block修饰"></a>使用__block修饰</h3><p>为什么使用了<code>__block</code>的修饰之后就可以在block内部修改外部变量了呢？这里肯定是系统根据<code>__block</code>检测,做了一些处理。</p>
<p>这里我们分成基本数据类型和对象类型。</p>
<h4 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#import &lt;Foundation&#x2F;Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    </span><br><span class="line">    __block int i &#x3D; 0;</span><br><span class="line">    </span><br><span class="line">    void (^myBlock)(void) &#x3D; ^&#123;</span><br><span class="line">        i ++;</span><br><span class="line">        NSLog(@&quot;%d&quot;,i);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    myBlock();</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>转换成源码之后:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 外部定义的基本数据类型 变成了这个结构体对象</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">Block_byref_i_0</span> &#123;</span></span><br><span class="line">  <span class="keyword">void</span> *__isa;</span><br><span class="line">__Block_byref_i_0 *__forwarding;    <span class="comment">//这个指针指向的也是这种结构体</span></span><br><span class="line"> <span class="keyword">int</span> __flags;</span><br><span class="line"> <span class="keyword">int</span> __size;</span><br><span class="line"> <span class="keyword">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">main_block_impl_0</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> <span class="title">impl</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span>* <span class="title">Desc</span>;</span></span><br><span class="line">  __Block_byref_i_0 *i; <span class="comment">// 声明这个i</span></span><br><span class="line">  </span><br><span class="line">  __main_block_impl_0(<span class="keyword">void</span> *fp, struct __main_block_desc_0 *desc, __Block_byref_i_0 *_i, <span class="keyword">int</span> flags=<span class="number">0</span>) : i(_i-&gt;__forwarding) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class="line"><span class="comment">//将外部变量的值 赋值给新建的这个结构体</span></span><br><span class="line">  __Block_byref_i_0 *i = __cself-&gt;i; <span class="comment">// bound by ref</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//对这个结构体中__forwarding指向的结构体的值做自加操作</span></span><br><span class="line">        (i-&gt;__forwarding-&gt;i) ++;</span><br><span class="line">        </span><br><span class="line">        NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_45_k1d9q7c52vz50wz1683_hk9r0000gn_T_main_3b0837_mi_0,(i-&gt;__forwarding-&gt;i));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) &#123;_Block_object_assign((<span class="keyword">void</span>*)&amp;dst-&gt;i, (<span class="keyword">void</span>*)src-&gt;i, <span class="number">8</span><span class="comment">/*BLOCK_FIELD_IS_BYREF*/</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_dispose_0(struct __main_block_impl_0*src) &#123;_Block_object_dispose((<span class="keyword">void</span>*)src-&gt;i, <span class="number">8</span><span class="comment">/*BLOCK_FIELD_IS_BYREF*/</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span> &#123;</span></span><br><span class="line">  <span class="keyword">size_t</span> reserved;</span><br><span class="line">  <span class="keyword">size_t</span> Block_size;</span><br><span class="line">  <span class="keyword">void</span> (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);</span><br><span class="line">  <span class="keyword">void</span> (*dispose)(struct __main_block_impl_0*);</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line"><span class="comment">//这里初始化这个__Block_byref_i_0结构体对象 </span></span><br><span class="line"><span class="comment">//这里我们可以看到__forwarding = (__Block_byref_i_0 *)&amp;i 这个指针指向自己</span></span><br><span class="line">    __attribute__((__blocks__(byref))) __Block_byref_i_0 i = &#123;(<span class="keyword">void</span>*)<span class="number">0</span>,(__Block_byref_i_0 *)&amp;i, <span class="number">0</span>, <span class="keyword">sizeof</span>(__Block_byref_i_0), <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> (*myBlock)(<span class="keyword">void</span>) = ((<span class="keyword">void</span> (*)())&amp;__main_block_impl_0((<span class="keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA, (__Block_byref_i_0 *)&amp;i, <span class="number">570425344</span>));</span><br><span class="line"></span><br><span class="line">    ((<span class="keyword">void</span> (*)(__block_impl *))((__block_impl *)myBlock)-&gt;FuncPtr)((__block_impl *)myBlock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面的代码 与我们最初没有使用__block修饰的代码的区别在于:</p>
<ul>
<li>1、外部变量的类型变为了一个<code>__Block_byref_i_0</code>结构体</li>
<li>2、自加操作对应的是<br>  <code>(i-&gt;__forwarding-&gt;i) ++;</code> 默认__forwarding指向自己</li>
</ul>
<p>对于是否可以修改外部变量,我们可以主要集中于这个自加的操作,如果<code>__forwarding</code>永远指向自身那么直接通过i取到i对应的值就可以了为什么中间加一个<code>__forwarding</code>呢？</p>
<p>我们知道, ARC环境下，一旦Block赋值就会触发copy，__block修饰的变量也就会copy到堆上，Block的类型也就变成了__NSMallocBlock。</p>
<p>堆上的Block会持有对象。我们把Block通过copy到了堆上，堆上也会重新复制一份Block，并且该Block也会继续持有该__block修饰的对象。当Block释放的时候，__block修饰的对象因为没有被任何对象引用，也会被释放销毁</p>
<p><code>__forwarding</code>指针这里的作用就是针对堆的Block，把原来<code>__forwarding</code>指针指向自己，换成指向<code>_NSConcreteMallocBlock</code>上复制之后的__block自己。然后堆上的变量的<code>__forwarding</code>再指向自己。这样不管__block怎么复制到堆上，还是在栈上，都可以通过<code>(i-&gt;__forwarding-&gt;i)</code>来访问到变量值。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1194012-5f5f486bab68191f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt="__forwarding"></p>
<p>根据上面的解释,我们可以得出系统使用__block修饰一个外部变量之后为什么就可以在block内部修改外部变量原因：</p>
<p>block创建的时候是在栈上的,对block进行赋值操作之后会将block拷贝到堆上。同时也会将block中使用的对象拷贝到堆上。然后将栈上的__block修饰对象的__forwarding指针指向堆上的拷贝之后的对象。这样我们在block内部修改的时候虽然是修改堆上的对象的值,但是因为栈上的对象的__forwarding指针将堆和栈的对象链接起来。因此达到了修改的目的。</p>
<h4 id="对象类型"><a href="#对象类型" class="headerlink" title="对象类型"></a>对象类型</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以下代码是在ARC下执行的</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">     </span><br><span class="line">    __block <span class="keyword">id</span> block_obj = [[<span class="built_in">NSObject</span> alloc]init];</span><br><span class="line">    <span class="keyword">id</span> obj = [[<span class="built_in">NSObject</span> alloc]init];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;block_obj = [%@ , %p] , obj = [%@ , %p]&quot;</span>,block_obj , &amp;block_obj , obj , &amp;obj);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> (^myBlock)(<span class="keyword">void</span>) = ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;***Block中****block_obj = [%@ , %p] , obj = [%@ , %p]&quot;</span>,block_obj , &amp;block_obj , obj , &amp;obj);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    myBlock();</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>打印结果:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">block_obj = [&lt;NSObject: <span class="number">0x100b027d0</span>&gt; , <span class="number">0x7fff5fbff7e8</span>] , obj = [&lt;NSObject: <span class="number">0x100b03b50</span>&gt; , <span class="number">0x7fff5fbff7b8</span>]</span><br><span class="line"></span><br><span class="line">Block****中********block_obj = [&lt;NSObject: <span class="number">0x100b027d0</span>&gt; , <span class="number">0x100f000a8</span>] , obj = [&lt;NSObject: <span class="number">0x100b03b50</span>&gt; , <span class="number">0x100f00070</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>从打印结果我们可以看出 block内部与外部:</p>
<ul>
<li>对于使用__block修饰的变量 对象的地址没有发生改变,但是指向这个对象的指针的地址发生了变化(copy操作的影响)。</li>
<li>对于没有使用__block修饰的变量 对象的地址也没有发生变化,指向这个对象的指针地址也发生了变化</li>
</ul>
<p>但从打印结果 我们看不出不同 下面我们利用clang在进行源码的分析。</p>
<h5 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">Block_byref_block_obj_0</span> &#123;</span></span><br><span class="line">  <span class="keyword">void</span> *__isa;</span><br><span class="line">__Block_byref_block_obj_0 *__forwarding;</span><br><span class="line"> <span class="keyword">int</span> __flags;</span><br><span class="line"> <span class="keyword">int</span> __size;</span><br><span class="line"> <span class="keyword">void</span> (*__Block_byref_id_object_copy)(<span class="keyword">void</span>*, <span class="keyword">void</span>*);</span><br><span class="line"> <span class="keyword">void</span> (*__Block_byref_id_object_dispose)(<span class="keyword">void</span>*);</span><br><span class="line"> id block_obj; <span class="comment">//值和变量名相同</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">main_block_impl_0</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> <span class="title">impl</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span>* <span class="title">Desc</span>;</span></span><br><span class="line">  id obj;</span><br><span class="line">  __Block_byref_block_obj_0 *block_obj; <span class="comment">// by ref</span></span><br><span class="line">  __main_block_impl_0(<span class="keyword">void</span> *fp, struct __main_block_desc_0 *desc, id _obj, __Block_byref_block_obj_0 *_block_obj, <span class="keyword">int</span> flags=<span class="number">0</span>) : obj(_obj), block_obj(_block_obj-&gt;__forwarding) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class="line"><span class="comment">//这里 对于赋值 可以看出二者的不同之处 一个是值的引用 一个是copy</span></span><br><span class="line">  __Block_byref_block_obj_0 *block_obj = __cself-&gt;block_obj; <span class="comment">// bound by ref</span></span><br><span class="line">  id obj = __cself-&gt;obj; <span class="comment">// bound by copy</span></span><br><span class="line"></span><br><span class="line">        NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_45_k1d9q7c52vz50wz1683_hk9r0000gn_T_main_e64910_mi_1,(block_obj-&gt;__forwarding-&gt;block_obj) , &amp;(block_obj-&gt;__forwarding-&gt;block_obj) , obj , &amp;obj);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) &#123;_Block_object_assign((<span class="keyword">void</span>*)&amp;dst-&gt;block_obj, (<span class="keyword">void</span>*)src-&gt;block_obj, <span class="number">8</span><span class="comment">/*BLOCK_FIELD_IS_BYREF*/</span>);_Block_object_assign((<span class="keyword">void</span>*)&amp;dst-&gt;obj, (<span class="keyword">void</span>*)src-&gt;obj, <span class="number">3</span><span class="comment">/*BLOCK_FIELD_IS_OBJECT*/</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_dispose_0(struct __main_block_impl_0*src) &#123;_Block_object_dispose((<span class="keyword">void</span>*)src-&gt;block_obj, <span class="number">8</span><span class="comment">/*BLOCK_FIELD_IS_BYREF*/</span>);_Block_object_dispose((<span class="keyword">void</span>*)src-&gt;obj, <span class="number">3</span><span class="comment">/*BLOCK_FIELD_IS_OBJECT*/</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span> &#123;</span></span><br><span class="line">  <span class="keyword">size_t</span> reserved;</span><br><span class="line">  <span class="keyword">size_t</span> Block_size;</span><br><span class="line">  <span class="keyword">void</span> (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);</span><br><span class="line">  <span class="keyword">void</span> (*dispose)(struct __main_block_impl_0*);</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    __attribute__((__blocks__(byref))) __Block_byref_block_obj_0 block_obj = &#123;(<span class="keyword">void</span>*)<span class="number">0</span>,(__Block_byref_block_obj_0 *)&amp;block_obj, <span class="number">33554432</span>, <span class="keyword">sizeof</span>(__Block_byref_block_obj_0), __Block_byref_id_object_copy_131, __Block_byref_id_object_dispose_131, ((NSObject *(*)(id, SEL))(<span class="keyword">void</span> *)objc_msgSend)((id)((NSObject *(*)(id, SEL))(<span class="keyword">void</span> *)objc_msgSend)((id)objc_getClass(<span class="string">&quot;NSObject&quot;</span>), sel_registerName(<span class="string">&quot;alloc&quot;</span>)), sel_registerName(<span class="string">&quot;init&quot;</span>))&#125;;</span><br><span class="line"></span><br><span class="line">    id obj = ((NSObject *(*)(id, SEL))(<span class="keyword">void</span> *)objc_msgSend)((id)((NSObject *(*)(id, SEL))(<span class="keyword">void</span> *)objc_msgSend)((id)objc_getClass(<span class="string">&quot;NSObject&quot;</span>), sel_registerName(<span class="string">&quot;alloc&quot;</span>)), sel_registerName(<span class="string">&quot;init&quot;</span>));</span><br><span class="line">    NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_45_k1d9q7c52vz50wz1683_hk9r0000gn_T_main_e64910_mi_0,(block_obj.__forwarding-&gt;block_obj) , &amp;(block_obj.__forwarding-&gt;block_obj) , obj , &amp;obj);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> (*myBlock)(<span class="keyword">void</span>) = ((<span class="keyword">void</span> (*)())&amp;__main_block_impl_0((<span class="keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA, obj, (__Block_byref_block_obj_0 *)&amp;block_obj, <span class="number">570425344</span>));</span><br><span class="line"></span><br><span class="line">    ((<span class="keyword">void</span> (*)(__block_impl *))((__block_impl *)myBlock)-&gt;FuncPtr)((__block_impl *)myBlock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>根据代码中赋值语句的差异 我们可以看到</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">__Block_byref_block_obj_0 *block_obj = __cself-&gt;block_obj; <span class="comment">// bound by ref</span></span><br><span class="line"><span class="keyword">id</span> obj = __cself-&gt;obj; <span class="comment">// bound by copy</span></span><br></pre></td></tr></table></figure>

<p>没有使用__block修饰的是copy的方式传递，使用__block修饰的是采用引用的传递方式。<br>这就很显然了 没有使用。</p>
<h3 id="Block在MRC和ARC下的不同"><a href="#Block在MRC和ARC下的不同" class="headerlink" title="Block在MRC和ARC下的不同"></a>Block在MRC和ARC下的不同</h3><h4 id="block修饰变量的位置"><a href="#block修饰变量的位置" class="headerlink" title="__block修饰变量的位置"></a>__block修饰变量的位置</h4><p>ARC环境下，一旦Block赋值就会触发copy，__block修饰的对象就会copy到堆上，Block的类型也变成__NSMallocBlock。ARC环境下也是存在__NSStackBlock的时候，这种情况下，__block就在栈上。</p>
<p>MRC环境下，只有copy，__block修饰的变量才会被复制到堆上，否则，__block修饰的变量一直都在栈上，block也只是__NSStackBlock，这个时候__forwarding指针就只指向自己了。</p>
<h4 id="block修饰变量的操作"><a href="#block修饰变量的操作" class="headerlink" title="__block修饰变量的操作"></a>__block修饰变量的操作</h4><p>在MRC环境下，__block根本不会对指针所指向的对象执行copy操作，而只是把指针进行的复制。</p>
<p>而在ARC环境下，对于声明为__block的外部对象，在block内部会进行retain，以至于在block环境内能安全的引用外部对象，所以才会产生循环引用的问题！</p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>先看下面这段代码:</p>
<p><img src="http://og0h689k8.bkt.clouddn.com/18-4-25/42976109.jpg" alt="blockerror"></p>
<p>如果我们想在block内部修改外部变量的值 系统会提示缺失__block的修饰符！</p>
<p><img src="http://og0h689k8.bkt.clouddn.com/18-4-25/24371620.jpg" alt="__block"></p>
<p>我们添加了__block之后 就可以在block中修改外部变量的值了。</p>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>__block到底做了什么,让一个原本不可以在block内修改的变量变得可以修改了呢？</p>
<p>我们先来看一下,被block修饰之后的变量到底都发生了什么变化.</p>
<p>先看一下对象的地址：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">__block <span class="built_in">NSInteger</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;定义前：%p&quot;</span>, &amp;a);</span><br><span class="line"><span class="keyword">void</span> (^blockName)(<span class="built_in">NSInteger</span> param) = ^(<span class="built_in">NSInteger</span> param)&#123;</span><br><span class="line">    a = param;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;block内：%p&quot;</span>, &amp;a);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">blockName(<span class="number">11</span>);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;定义后：%p&quot;</span>, &amp;a);  </span><br></pre></td></tr></table></figure>

<p>打印结果：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">2018</span><span class="number">-04</span><span class="number">-25</span> <span class="number">11</span>:<span class="number">51</span>:<span class="number">12.120470</span>+<span class="number">0800</span> Test[<span class="number">9140</span>:<span class="number">975007</span>] 定义前：<span class="number">0x16f4454a8</span></span><br><span class="line"><span class="number">2018</span><span class="number">-04</span><span class="number">-25</span> <span class="number">11</span>:<span class="number">51</span>:<span class="number">12.120601</span>+<span class="number">0800</span> Test[<span class="number">9140</span>:<span class="number">975007</span>] block内：<span class="number">0x100e07c88</span></span><br><span class="line"><span class="number">2018</span><span class="number">-04</span><span class="number">-25</span> <span class="number">11</span>:<span class="number">51</span>:<span class="number">12.120639</span>+<span class="number">0800</span> Test[<span class="number">9140</span>:<span class="number">975007</span>] 定义后：<span class="number">0x100e07c88</span></span><br></pre></td></tr></table></figure>

<p>这里我们看到 定以后以及block内部这两个位置 a的内存地址是相同的 但是跟定义前的地址是不同的！</p>
<p>那么__block 是做了什么操作修改了这个变量的内存地址！</p>
<p>我们先对这两个地址进行分析:<br>将这两个16进制内存地址转换为10进制的</p>
<table>
<thead>
<tr>
<th>title</th>
<th>16进制</th>
<th>10进制</th>
</tr>
</thead>
<tbody><tr>
<td>定义前</td>
<td>0x16f4454a8</td>
<td>6161716392</td>
</tr>
<tr>
<td>block内</td>
<td>0x100e07c88</td>
<td>4309679240</td>
</tr>
<tr>
<td>定义后</td>
<td>0x100e07c88</td>
<td>4309679240</td>
</tr>
</tbody></table>
<p>6161716392-4309679240 = 1852037152 </p>
<p><code>这个字节差的有点多呀 什么鬼</code></p>
<p>这是一个很大的值, 因为我们可以确定局部变量a是存放在栈区的 所以 我们可以确认 a在使用__block修饰后被放到了堆区。</p>
<p>这也证实了：<code>a 在定义前是栈区，但只要进入了 block 区域，就变成了堆区。这才是 __block 关键字的真正作用。</code></p>
<p>当我们使用对象类型的时候呢？</p>
<p>看下面这段代码</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSMutableString</span> *a = [<span class="built_in">NSMutableString</span> stringWithString:<span class="string">@&quot;Tom&quot;</span>];</span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@&quot;\n 定以前：------------------------------------\n\</span></span><br><span class="line"><span class="string">        a指向的堆中地址：%p；a在栈中的指针地址：%p&quot;</span>, a, &amp;a);               <span class="comment">//a在栈区</span></span><br><span class="line">  <span class="keyword">void</span> (^foo)(<span class="keyword">void</span>) = ^&#123;</span><br><span class="line">      a.string = <span class="string">@&quot;Jerry&quot;</span>;</span><br><span class="line">      <span class="built_in">NSLog</span>(<span class="string">@&quot;\n block内部：------------------------------------\n\</span></span><br><span class="line"><span class="string">       a指向的堆中地址：%p；a在栈中的指针地址：%p&quot;</span>, a, &amp;a);               <span class="comment">//a在栈区</span></span><br><span class="line">      <span class="comment">//a = [NSMutableString stringWithString:@&quot;William&quot;];</span></span><br><span class="line">  &#125;;</span><br><span class="line">  foo();</span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@&quot;\n 定以后：------------------------------------\n\</span></span><br><span class="line"><span class="string">        a指向的堆中地址：%p；a在栈中的指针地址：%p&quot;</span>, a, &amp;a);    </span><br></pre></td></tr></table></figure>

<p>打印结果:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">2018</span><span class="number">-04</span><span class="number">-25</span> <span class="number">13</span>:<span class="number">56</span>:<span class="number">00.488632</span>+<span class="number">0800</span> Test[<span class="number">9566</span>:<span class="number">1019521</span>] </span><br><span class="line"> 定以前：------------------------------------</span><br><span class="line">          a指向的堆中地址：<span class="number">0x100c03fb0</span>；a在栈中的指针地址：<span class="number">0x16f7554a8</span></span><br><span class="line"><span class="number">2018</span><span class="number">-04</span><span class="number">-25</span> <span class="number">13</span>:<span class="number">56</span>:<span class="number">00.489045</span>+<span class="number">0800</span> Test[<span class="number">9566</span>:<span class="number">1019521</span>] </span><br><span class="line"> block内部：------------------------------------</span><br><span class="line">              a指向的堆中地址：<span class="number">0x100c03fb0</span>；a在栈中的指针地址：<span class="number">0x100c74f20</span></span><br><span class="line"><span class="number">2018</span><span class="number">-04</span><span class="number">-25</span> <span class="number">13</span>:<span class="number">56</span>:<span class="number">00.489294</span>+<span class="number">0800</span> Test[<span class="number">9566</span>:<span class="number">1019521</span>] </span><br><span class="line"> 定以后：------------------------------------</span><br><span class="line">          a指向的堆中地址：<span class="number">0x100c03fb0</span>；a在栈中的指针地址：<span class="number">0x16f7554a8</span></span><br><span class="line">error in connection_block_invoke_2: Connection interrupted</span><br></pre></td></tr></table></figure>

<p>由打印我们可以看出 定义前和定义后还有block中 <code>a所指向堆中的内存地址是不变的</code>！,但是在block中会对外部的变量做一个copy操作 将栈中的指针a拷贝到堆中！(不改变该指针指向堆中的值)。</p>
<p><code>重点</code>:对于对象a我们没有使用__block进行修饰但是 我们在block中仍然可以修改这个对象的某一个属性。因此 我们可以得出 block中只是不能修改栈中的指针,但是可以修改栈中指针指向堆中的对象的某些属性。</p>
<p>下面再来看</p>
<p><img src="http://og0h689k8.bkt.clouddn.com/18-4-25/75467588.jpg" alt="修改变量的值"></p>
<p>如果我们想修改这个对象的值(修改这个指针指向的位置而不是修改指针指向位置所代表对象的某个属性)。</p>
<p>系统还是会提示我们 必须要使用block修饰！！！</p>
<p>通过上面的这两个例子我们可以得出结论：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Block不允许修改外部变量的值，这里所说的外部变量的值，指的是栈中指针的内存地址。栈区是红灯区，堆区才是绿灯区。</span><br><span class="line"></span><br><span class="line">__block 所起到的作用就是只要观察到该变量被 block 所持有，就将“外部变量”在栈中的内存地址放到了堆中。进而在block内部也可以修改外部变量的值。</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><p><a href="https://www.jianshu.com/p/ee9756f3d5f6">深入研究Block捕获外部变量和__block实现原理</a></p>
]]></content>
      <categories>
        <category>iOS优化</category>
      </categories>
      <tags>
        <tag>Block __block</tag>
      </tags>
  </entry>
  <entry>
    <title>SDWebImage - 图片下载</title>
    <url>/2016/01/27/SDWebImage-2/</url>
    <content><![CDATA[<p>本文是系列文章《SDWebImage源码解析》中的图片下载部分，本文详细的介绍了SDWebImage在图片下载过程中所做的一些处理和对于下载操作的管理。</p>
<a id="more"></a>


<h3 id="外层方法调用"><a href="#外层方法调用" class="headerlink" title="外层方法调用"></a>外层方法调用</h3><h4 id="最外层方法的调用"><a href="#最外层方法的调用" class="headerlink" title="最外层方法的调用"></a>最外层方法的调用</h4><p>首先，看一下使用SD进行图片下载时，调用的代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[cell.imageView sd_setImageWithURL:</span><br><span class="line">			[NSURL URLWithString:</span><br><span class="line">						[_objects objectAtIndex:indexPath.row]]</span><br><span class="line">            placeholderImage:[UIImage imageNamed:@&quot;placeholder&quot;] </span><br><span class="line">            options:indexPath.row &#x3D;&#x3D; 0 ?</span><br><span class="line">				SDWebImageRefreshCached : 0];</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>很简单，需要的参数只有URL、placeholderImage和options三个,从字面的意思就可以看到<br>URL:要下载图片的URL<br>placeholderImage：要显示的占位图<br>options:下载时候的一些条件设置</p>
<h4 id="非必要参数的包装"><a href="#非必要参数的包装" class="headerlink" title="非必要参数的包装"></a>非必要参数的包装</h4><p>方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)sd_setImageWithURL:(NSURL *)url placeholderImage:(UIImage *)placeholder options:(SDWebImageOptions)options progress:(SDWebImageDownloaderProgressBlock)progressBlock completed:(SDWebImageCompletionBlock)completedBlock</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在最外面调用的基础上增加了两个参数<br>progress:下载进度跟进的回调<br>completed:下载完成的进度的回调</p>
<p>下面从这个方法开始，对于图片的下载过程做一个详细的分析</p>
<h3 id="开始下载操作（包括缓存的查找）"><a href="#开始下载操作（包括缓存的查找）" class="headerlink" title="开始下载操作（包括缓存的查找）"></a>开始下载操作（包括缓存的查找）</h3><h4 id="取消现有的图片的下载："><a href="#取消现有的图片的下载：" class="headerlink" title="取消现有的图片的下载："></a>取消现有的图片的下载：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[self sd_cancelCurrentImageLoad];</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>看一下具体实现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)sd_cancelImageLoadOperationWithKey:(NSString *)key &#123;</span><br><span class="line">    &#x2F;&#x2F; 取消下载队列中正在进行的操作 这个方法后面会介绍</span><br><span class="line">    NSMutableDictionary *operationDictionary &#x3D; </span><br><span class="line">    								[self operationDictionary];</span><br><span class="line">    &#x2F;&#x2F;防止重复下载							</span><br><span class="line">    id operations &#x3D; [operationDictionary objectForKey:key];</span><br><span class="line">    </span><br><span class="line">    if (operations) &#123;</span><br><span class="line">        if ([operations isKindOfClass:[NSArray class]]) &#123;</span><br><span class="line">            for (id &lt;SDWebImageOperation&gt; operation</span><br><span class="line">                                               in operations)</span><br><span class="line">             &#123;</span><br><span class="line">                if (operation) &#123;</span><br><span class="line">                    [operation cancel];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else if ([operations  conformsToProtocol:</span><br><span class="line">        						@protocol(SDWebImageOperation)])</span><br><span class="line">        &#123;</span><br><span class="line">            [(id&lt;SDWebImageOperation&gt;) operations cancel];</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;将这个任务移除</span><br><span class="line">        [operationDictionary removeObjectForKey:key];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个方法是在每一次图片下载开始之前，如果存在正在下载的任务，那么现将这个任务取消，目的是为了防止重复下载。</p>
<p>获取当前的操作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (NSMutableDictionary *)operationDictionary &#123;</span><br><span class="line">    NSMutableDictionary *operations &#x3D; </span><br><span class="line">    		objc_getAssociatedObject(self, &amp;loadOperationKey);</span><br><span class="line">    		</span><br><span class="line">    if (operations) &#123;</span><br><span class="line">        return operations;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    operations &#x3D; [NSMutableDictionary dictionary];</span><br><span class="line">    </span><br><span class="line">    objc_setAssociatedObject(self, &amp;loadOperationKey,</span><br><span class="line">    		 operations, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">    		 </span><br><span class="line">    return operations;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p><code>问题</code>：这里为啥非要operations是一个遵守的SDWebImageOperation的对象？</p>
<p><font color = red>这里希望大家指导一下</font></p>
<p><code>问题</code>:operations对象什么情况下会是一个数组？</p>
<p><font color = red>这里希望大家指导一下</font></p>
<p><code>问题：</code></p>
<p>每次下载之前，都把原来的下载给暂停了，是不是以为这一次只能下载一张图片？</p>
<p>解答：并不是这样的，这个方法首先是写在了UIView的分类中的，每一个UIView以及他的子类（UIButton或者UIImageView）都拥有一个operationDictionary，每次之前取消，可以理解为一个UIImageview保证对应一个URL</p>
<p>与取消对应的添加操作：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)sd_setImageLoadOperation:(id)operation forKey:(NSString *)key &#123;</span><br><span class="line">    [self sd_cancelImageLoadOperationWithKey:key];</span><br><span class="line">    NSMutableDictionary *operationDictionary &#x3D; [self </span><br><span class="line">    									operationDictionary];</span><br><span class="line">    [operationDictionary setObject:operation forKey:key];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="占位图片的设置"><a href="#占位图片的设置" class="headerlink" title="占位图片的设置"></a>占位图片的设置</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (!(options &amp; SDWebImageDelayPlaceholder)) &#123;</span><br><span class="line">    dispatch_main_async_safe(^&#123;</span><br><span class="line">        self.image &#x3D; placeholder;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * By default, placeholder images are loaded while the image is loading. This flag will delay the loading</span><br><span class="line"> * of the placeholder image until after the image has finished loading.</span><br><span class="line"> *&#x2F;</span><br><span class="line">&#x2F;&#x2F;默认情况，占位图片在图片加载过程中会显示</span><br><span class="line">&#x2F;&#x2F;如果设置了这个属性，将会延迟占位图片的加载时间（图片加载完成之后）</span><br><span class="line"></span><br><span class="line">SDWebImageDelayPlaceholder &#x3D; 1 &lt;&lt; 9,</span><br><span class="line">主要是设置占位图片显示的时机</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果没有设置为SDWebImageDelayPlaceholder那么立即设置图片的占位图，那么如果设置了SDWebImageDelayPlaceholder这个属性之后什么时间设置占位图片呢</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if ((options &amp; SDWebImageDelayPlaceholder)) &#123;</span><br><span class="line">     wself.image &#x3D; placeholder;</span><br><span class="line">     [wself setNeedsLayout];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在图片下载完成之后，如果下载失败image = nil 时，会将占位图片设置</p>
<p>占位图片设置完成后，就开始了图片的加载，也就是本片文章的重头戏，图片缓存中查找或者图片的下载</p>
<h4 id="创建一个新的下载操作"><a href="#创建一个新的下载操作" class="headerlink" title="创建一个新的下载操作"></a>创建一个新的下载操作</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">id &lt;SDWebImageOperation&gt; operation &#x3D; 			</span><br><span class="line">		[SDWebImageManager.sharedManager downloadImageWithURL:url </span><br><span class="line">		options:options </span><br><span class="line">		progress:progressBlock </span><br><span class="line">		completed:^(UIImage *image, NSError *error, </span><br><span class="line">					SDImageCacheType cacheType, </span><br><span class="line">					BOOL finished, NSURL *imageURL)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>创建一个新的下载操作，并将下载操作添加到下载队列中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;添加到下载队列中</span><br><span class="line">[self sd_setImageLoadOperation:operation </span><br><span class="line">							forKey:@&quot;UIImageViewImageLoad&quot;];</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>下面的代码是在</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">id &lt;SDWebImageOperation&gt; operation &#x3D;</span><br><span class="line">	 	[SDWebImageManager.sharedManager 		</span><br><span class="line">	 					downloadImageWithURL:url </span><br><span class="line">	 					options:options</span><br><span class="line">	 					progress:progressBlock </span><br><span class="line">	 					completed:^(UIImage *image, NSError</span><br><span class="line">	 					 *error, SDImageCacheType cacheType, BOOL</span><br><span class="line">	 					 finished, NSURL *imageURL)</span><br><span class="line">&#123;</span><br><span class="line">	&#x2F;&#x2F;图片下载完成之后的操作</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="操作的执行"><a href="#操作的执行" class="headerlink" title="操作的执行"></a>操作的执行</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 如果缓存中没有给定URL对应的图片，下载这张图片，否则返回缓存的图片</span><br><span class="line"> *</span><br><span class="line"> * @param url            要下载图片的URL</span><br><span class="line"> * @param options        图片下载的request的选项设置</span><br><span class="line"> * @param progressBlock  下载进度监听的回调</span><br><span class="line"> * @param completedBlock 下载完成的回调（必要的参数不可为nil）</span><br><span class="line"> *</span><br><span class="line"> *   completedBlock</span><br><span class="line"> *   </span><br><span class="line"> *&#x2F;</span><br><span class="line">	当使用SDWebImageProgressiveDownload时，参数finished被设置为NO，图片下载的过程中这个回调将会被调用很多次返回的是一个部分图片，当图片完整下载完成的时候这个回调会在最后调用一下，设置一个完整的图片，同事将参数finished设置为YES</span><br><span class="line"></span><br><span class="line">- (id &lt;SDWebImageOperation&gt;)downloadImageWithURL:(NSURL *)url</span><br><span class="line">                                         options:(SDWebImageOptions)options</span><br><span class="line">                                        progress:(SDWebImageDownloaderProgressBlock)progressBlock</span><br><span class="line">                                       completed:(SDWebImageCompletionWithFinishedBlock)completedBlock;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>两个补充的参数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">completedBlock的类型</span><br><span class="line"></span><br><span class="line">typedef void(^SDWebImageCompletionWithFinishedBlock)</span><br><span class="line"> 				(UIImage *image, NSError *error, </span><br><span class="line"> 				SDImageCacheType cacheType,</span><br><span class="line"> 	 			BOOL finished, NSURL *imageURL);</span><br><span class="line"></span><br><span class="line">SDImageCacheType类型：</span><br><span class="line"></span><br><span class="line">	typedef NS_ENUM(NSInteger, SDImageCacheType) &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * The image wasn&#39;t available the SDWebImage caches, but was</span><br><span class="line">     	 downloaded from the web.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    SDImageCacheTypeNone,</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * The image was obtained from the disk cache.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    SDImageCacheTypeDisk,</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * The image was obtained from the memory cache.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    SDImageCacheTypeMemory</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="必要的参数completedBlock"><a href="#必要的参数completedBlock" class="headerlink" title="必要的参数completedBlock"></a>必要的参数completedBlock</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Invoking this method without a completedBlock is </span><br><span class="line">	pointless</span><br><span class="line">NSAssert(completedBlock !&#x3D; nil,</span><br><span class="line">		 @&quot;If you mean to prefetch the image, use -</span><br><span class="line">		 [SDWebImagePrefetcher prefetchURLs] instead&quot;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果传入的completedBlock是nil,将会报错！！！！！<br>解释：如果没有completedBlock，将没办法给imageview设置图片，所以下面的代码就没有意义了</p>
<p><a href="http://www.cnblogs.com/moondark/archive/2012/03/12/2392315.html">断言学习入门</a></p>
<h4 id="对URL做特殊处理"><a href="#对URL做特殊处理" class="headerlink" title="对URL做特殊处理"></a>对URL做特殊处理</h4><p>由于在某些时候，出于某些特殊的原因，Xcode不会对这里的类型匹配做出警告的提示，所以作者在这里增加了一个容错处理，允许这里传递一个字符串类型的URL</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if ([url isKindOfClass:NSString.class]) &#123;</span><br><span class="line">    url &#x3D; [NSURL URLWithString:(NSString *)url];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Prevents app crashing on argument type error like sending NSNull instead of NSURL</span><br><span class="line">if (![url isKindOfClass:NSURL.class]) &#123;</span><br><span class="line">    url &#x3D; nil;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="再次新建一个操作"><a href="#再次新建一个操作" class="headerlink" title="再次新建一个操作"></a>再次新建一个操作</h4><p> 新建了一个SDWebImageCombinedOperation对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">__block SDWebImageCombinedOperation *operation &#x3D; </span><br><span class="line">    				[SDWebImageCombinedOperation new];</span><br><span class="line">    				</span><br><span class="line">__weak SDWebImageCombinedOperation *weakOperation &#x3D; operation;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里看一下SDWebImageCombinedOperation:这是一个遵守了SDWebImageOperation协议的对象继承自NSObject，包含了一个属性cacheOperation为NSOperation类型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@interface SDWebImageCombinedOperation : NSObject </span><br><span class="line">										&lt;SDWebImageOperation&gt;</span><br><span class="line"></span><br><span class="line">@property (assign, nonatomic, getter &#x3D; isCancelled) BOOL </span><br><span class="line">												     cancelled;</span><br><span class="line">												     </span><br><span class="line">@property (copy, nonatomic) SDWebImageNoParamsBlock cancelBlock;</span><br><span class="line"></span><br><span class="line">@property (strong, nonatomic) NSOperation *cacheOperation;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>注意</code>：downloadImageWithURL返回的这个id类型（遵守SDWebImageOperation协议）的对象</p>
<h4 id="黑名单处理"><a href="#黑名单处理" class="headerlink" title="黑名单处理"></a>黑名单处理</h4><p>判断当前要下载的图片的URL是否存在于黑名单中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BOOL isFailedUrl &#x3D; NO;</span><br><span class="line">  @synchronized (self.failedURLs) &#123;</span><br><span class="line">      isFailedUrl &#x3D; [self.failedURLs containsObject:url];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="URL是否合法"><a href="#URL是否合法" class="headerlink" title="URL是否合法"></a>URL是否合法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (url.absoluteString.length &#x3D;&#x3D; 0 </span><br><span class="line">				|| (!(options &amp; SDWebImageRetryFailed)</span><br><span class="line"> 				&amp;&amp; isFailedUrl)) </span><br><span class="line">&#123;</span><br><span class="line">    dispatch_main_sync_safe(^&#123;</span><br><span class="line">        NSError *error &#x3D; [NSError </span><br><span class="line">        	errorWithDomain:NSURLErrorDomain </span><br><span class="line">        	code:NSURLErrorFileDoesNotExist </span><br><span class="line">        	userInfo:nil];</span><br><span class="line">        completedBlock(nil, error, SDImageCacheTypeNone, YES, url);</span><br><span class="line">    &#125;);</span><br><span class="line">    return operation;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><a href="http://blog.sina.com.cn/s/blog_71715bf801019ymq.html">如何自定义错误</a></p>
<h4 id="将操作添加到正在进行的队列中"><a href="#将操作添加到正在进行的队列中" class="headerlink" title="将操作添加到正在进行的队列中"></a>将操作添加到正在进行的队列中</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@synchronized (self.runningOperations) &#123;</span><br><span class="line">    [self.runningOperations addObject:operation];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>@synchronized</code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">　　@synchronized，代表这个方法加锁, 相当于不管哪一个线程（例如线程A），运行到这个方法时,都要检查有没有其它线程例如B正在用这个方法，有的话要等正在使用synchronized方法的线程B运行完这个方法后再运行此线程A,没有的话,直接运行。它包括两种用法：synchronized 方法和 synchronized 块。</span><br><span class="line"></span><br><span class="line">@synchronized 方法控制对类（一般在IOS中用在单例中）的访问：每个类实例对应一把锁，每个 synchronized 方法都必须获得调用该方法锁方能执行，否则所属就会发生线程阻塞，方法一旦执行，就独占该锁，直到从该方法返回时才将锁释放，此后被阻塞的线程方能获得该锁，重新进入可执行状态。这种机制确保了同一时刻对于每一个类，至多只有一个处于可执行状态，从而有效避免了类成员变量的访问冲突（只要所有可能访问类的方法均被声明为 synchronized）</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="获取cachekey"><a href="#获取cachekey" class="headerlink" title="获取cachekey"></a>获取cachekey</h4><p>NSString *key = [self cacheKeyForURL:url];</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (NSString *)cacheKeyForURL:(NSURL *)url &#123;</span><br><span class="line">    if (self.cacheKeyFilter) &#123;</span><br><span class="line">        return self.cacheKeyFilter(url);</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        return [url absoluteString];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>self.cacheKeyFilter</code>是什么东西?</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;cache filter 在SDWebImageManager每次将URL转换为cache key的时候调用，功能是去掉图片URL中的动态部分</span><br><span class="line">[[SDWebImageManager sharedManager] setCacheKeyFilter:^(NSURL *url) &#123;</span><br><span class="line">    url &#x3D; [[NSURL alloc] initWithScheme:url.scheme host:url.host path:url.path];</span><br><span class="line">    return [url absoluteString];</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"> * @endcode</span><br><span class="line"> *&#x2F;</span><br><span class="line"> </span><br><span class="line"> @property (nonatomic, copy) SDWebImageCacheKeyFilterBlock cacheKeyFilter;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>cache filter 是一个SDWebImageManager每次需要讲一个URL转换为cachekey时会调用的一个方法，用来去掉图片URL中的动态部分</p>
<h4 id="图片缓存"><a href="#图片缓存" class="headerlink" title="图片缓存"></a>图片缓存</h4><p>查找这张图片有没有被缓存过，具体的缓存查找策略会在后面单独写一篇文章</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (NSOperation *)queryDiskCacheForKey:(NSString *)key done:(SDWebImageQueryCompletedBlock)doneBlock</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="图片下载"><a href="#图片下载" class="headerlink" title="图片下载"></a>图片下载</h4><p><code>下面就开始了正式的“下载” 根据第一部分的介绍，我们知道，在每次下载之前，我们都会先去缓存中查找一下，看是否存在，所以这里可以先跳到缓存看一下</code></p>
<p>如果，这张图片没有被缓存过，那么就要开始下载这张图片</p>
<h4 id="图片要从网络获取的条件"><a href="#图片要从网络获取的条件" class="headerlink" title="图片要从网络获取的条件"></a>图片要从网络获取的条件</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (operation.isCancelled) &#123;</span><br><span class="line">    @synchronized (self.runningOperations) &#123;</span><br><span class="line">    	[self.runningOperations removeObject:operation];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里的operation是一个SDWebImageCombinedOperation，具体内容跟上面的那个差不多，就不赘述了</p>
<h4 id="图片下载的条件"><a href="#图片下载的条件" class="headerlink" title="图片下载的条件"></a>图片下载的条件</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if ((!image || options &amp; SDWebImageRefreshCached) </span><br><span class="line">&amp;&amp; (![self.delegate respondsToSelector:</span><br><span class="line">			@selector(imageManager:shouldDownloadImageForURL:)] || [self.delegate imageManager:self </span><br><span class="line">			shouldDownloadImageForURL:url]))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>下面来好好分析一下这个条件：<br>!image 图片存在 即缓存中没有找到<br>options &amp; SDWebImageRefreshCached:图片找到了是否需要跟新缓存（重新下载）</p>
<p>是否实现了imageManager:shouldDownloadImageForURL:方法<br>[self.delegate respondsToSelector:<br>            @selector(imageManager:shouldDownloadImageForURL:)<br>如果实现了 就执行这个方法<br>[self.delegate imageManager:self shouldDownloadImageForURL:url]</p>
<h5 id="小插曲"><a href="#小插曲" class="headerlink" title="小插曲"></a>小插曲</h5><p>imageManager:shouldDownloadImageForURL:是干啥的？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Controls which image should be downloaded when the image is not found in the cache.</span><br><span class="line"> *</span><br><span class="line"> * @param imageManager The current &#96;SDWebImageManager&#96;</span><br><span class="line"> * @param imageURL     The url of the image to be downloaded</span><br><span class="line"> *</span><br><span class="line"> * @return Return NO to prevent the downloading of the image on cache misses. If not implemented, YES is implied.</span><br><span class="line"> *&#x2F;</span><br><span class="line"> &#x2F;&#x2F;当缓存中图片不存在的时候，用这个方法来判断是否需要下载这张图片</span><br><span class="line"> &#x2F;&#x2F;返回NO来阻止图片的下载，如果没实现默认返回yes（始终下载）</span><br><span class="line">- (BOOL)imageManager:(SDWebImageManager *)imageManager shouldDownloadImageForURL:(NSURL *)imageURL;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里 我们队这整个的判断做一下分析：<br>如果图片没有缓存或者需要更新缓存 || 如果没实现代理方法则下载，实现代理方法则根据代理方法的返回值进行判断</p>
<p>判断好条件，接下来我们继续看</p>
<h4 id="是否需要更新缓存"><a href="#是否需要更新缓存" class="headerlink" title="是否需要更新缓存"></a>是否需要更新缓存</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (image &amp;&amp; options &amp; SDWebImageRefreshCached) &#123;</span><br><span class="line">   dispatch_main_sync_safe(^&#123;</span><br><span class="line">		&#x2F;&#x2F;缓存中已经有这张图片了，但是因为要更新缓存，所以会有重新下载</span><br><span class="line">		&#x2F;&#x2F;这样是NSURLCache有机会从服务器端刷新自身缓存。</span><br><span class="line">       completedBlock(image, nil, cacheType, YES, url);</span><br><span class="line">   &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果缓存中有这张图片，但是用户设置了需要更新缓存，那么因为已经有这种图片了，所以直接调用completedBlock去显示图片，同时也会继续往后走去下载图片来更新缓存</p>
<h4 id="图片下载的参数设置"><a href="#图片下载的参数设置" class="headerlink" title="图片下载的参数设置"></a>图片下载的参数设置</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (options &amp; SDWebImageProgressiveDownload) </span><br><span class="line">downloaderOptions |&#x3D; SDWebImageDownloaderProgressiveDownload;</span><br><span class="line"></span><br><span class="line">if (options &amp; SDWebImageRefreshCached)</span><br><span class="line"> downloaderOptions |&#x3D; SDWebImageDownloaderUseNSURLCache;</span><br><span class="line"> </span><br><span class="line">if (options &amp; SDWebImageContinueInBackground)</span><br><span class="line"> downloaderOptions |&#x3D; SDWebImageDownloaderContinueInBackground;</span><br><span class="line"> </span><br><span class="line">if (options &amp; SDWebImageHandleCookies)</span><br><span class="line"> downloaderOptions |&#x3D; SDWebImageDownloaderHandleCookies;</span><br><span class="line"> </span><br><span class="line">if (options &amp; SDWebImageAllowInvalidSSLCertificates) </span><br><span class="line">	downloaderOptions |&#x3D; 		</span><br><span class="line">			SDWebImageDownloaderAllowInvalidSSLCertificates;</span><br><span class="line">			</span><br><span class="line">if (options &amp; SDWebImageHighPriority) </span><br><span class="line">		downloaderOptions |&#x3D; SDWebImageDownloaderHighPriority;</span><br><span class="line">		</span><br><span class="line">if (image &amp;&amp; options &amp; SDWebImageRefreshCached) &#123;</span><br><span class="line">     &#x2F;&#x2F;如果设置了SDWebImageRefreshCached就不能设置SDWebImageDownloaderProgressiveDownload属性，因为，SDWebImageRefreshCached说明缓存中存在了，图片会理解执行completion方法</span><br><span class="line">     downloaderOptions &amp;&#x3D; </span><br><span class="line">     					~SDWebImageDownloaderProgressiveDownload;</span><br><span class="line"></span><br><span class="line">     &#x2F;&#x2F;如果图片下载设置了SDWebImageRefreshCached就必须设置SDWebImageDownloaderIgnoreCachedResponse 为了保证更新NSURLCache</span><br><span class="line">     downloaderOptions |&#x3D; </span><br><span class="line">     			SDWebImageDownloaderIgnoreCachedResponse;</span><br><span class="line">&#125;</span><br><span class="line">            </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="开始下载"><a href="#开始下载" class="headerlink" title="开始下载"></a>开始下载</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">id &lt;SDWebImageOperation&gt; subOperation &#x3D; [self.imageDownloader downloadImageWithURL:url options:downloaderOptions progress:progressBlock completed:^(UIImage *downloadedImage, NSData *data, NSError *error, BOOL finished)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里又新起了一个遵守SDWebImageOperation协议的subOperation</p>
<p>下面，我们到这个方法里面去看一下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">__block SDWebImageDownloaderOperation *operation;</span><br><span class="line">__weak __typeof(self)wself &#x3D; self;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里创建的operation是我们图片下载的主力SDWebImageDownloaderOperation</p>
<h4 id="添加进度监听"><a href="#添加进度监听" class="headerlink" title="添加进度监听"></a>添加进度监听</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  - (void)addProgressCallback:(SDWebImageDownloaderProgressBlock)progressBlock completedBlock:(SDWebImageDownloaderCompletedBlock)completedBlock forURL:(NSURL *)url createCallback:(SDWebImageNoParamsBlock)createCallback &#123;</span><br><span class="line">    &#x2F;&#x2F;URL不能为nil，因为在URLCallbacks中URL要作为key值，所以URL不可以为nil,如果为nil那么立即调用completedBlock返回土片数据为nil</span><br><span class="line">    if (url &#x3D;&#x3D; nil) &#123;</span><br><span class="line">        if (completedBlock !&#x3D; nil) &#123;</span><br><span class="line">            completedBlock(nil, nil, nil, NO);</span><br><span class="line">        &#125;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;一个图片的下载progressBlock可能会被执行很多次，而且很多次的执行可能并不是在同一个线程中，所以这里使用一个数组来保存</span><br><span class="line">    dispatch_barrier_sync(self.barrierQueue, ^&#123;</span><br><span class="line">        BOOL first &#x3D; NO;</span><br><span class="line">        &#x2F;&#x2F;数组保存</span><br><span class="line">        if (!self.URLCallbacks[url]) &#123;</span><br><span class="line">            self.URLCallbacks[url] &#x3D; [NSMutableArray new];</span><br><span class="line">            first &#x3D; YES;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        NSMutableArray *callbacksForURL &#x3D; </span><br><span class="line">        							self.URLCallbacks[url];</span><br><span class="line">        NSMutableDictionary *callbacks &#x3D;</span><br><span class="line">        						 [NSMutableDictionary new];</span><br><span class="line">        						 </span><br><span class="line">        if (progressBlock)</span><br><span class="line">         callbacks[kProgressCallbackKey] &#x3D; [progressBlock copy];</span><br><span class="line">         </span><br><span class="line">        if (completedBlock)</span><br><span class="line">       callbacks[kCompletedCallbackKey] &#x3D; [completedBlock copy];</span><br><span class="line">       </span><br><span class="line">        [callbacksForURL addObject:callbacks];</span><br><span class="line">        self.URLCallbacks[url] &#x3D; callbacksForURL;</span><br><span class="line">		&#x2F;&#x2F;每张图片只有在第一次回调的时候会执行createCallback（）；</span><br><span class="line">        if (first) &#123;</span><br><span class="line">            createCallback();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以通过下面这张图片来了解结构层次：<br><img src="http://images2015.cnblogs.com/blog/715314/201512/715314-20151204161948408-1934962430.png" alt="层次结构"></p>
<p><code>问题</code>：</p>
<p>同一个URL,为什么在self.URLCallbacks中对应的是一个数组？有没有可能会造成控件的浪费？<br>解答：暂时还不太清楚 先往后面看看</p>
<h4 id="createCallback回调内容"><a href="#createCallback回调内容" class="headerlink" title="createCallback回调内容"></a>createCallback回调内容</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSTimeInterval timeoutInterval &#x3D; wself.downloadTimeout;</span><br><span class="line">if (timeoutInterval &#x3D;&#x3D; 0.0) &#123;</span><br><span class="line">     timeoutInterval &#x3D; 15.0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果用户没有主动设置下载超时timeoutInterval，则默认为15</p>
<h5 id="创建图片下载的请求"><a href="#创建图片下载的请求" class="headerlink" title="创建图片下载的请求"></a>创建图片下载的请求</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSMutableURLRequest *request &#x3D; [[NSMutableURLRequest alloc] </span><br><span class="line">					initWithURL:url</span><br><span class="line"> 					cachePolicy:</span><br><span class="line"> 				  (options &amp; SDWebImageDownloaderUseNSURLCache ?</span><br><span class="line">					NSURLRequestUseProtocolCachePolicy : </span><br><span class="line">					NSURLRequestReloadIgnoringLocalCacheData) </span><br><span class="line">					timeoutInterval:timeoutInterval];</span><br><span class="line"> 				  </span><br></pre></td></tr></table></figure>
<p>这里主要是设置了缓存策略和超时的时长，其中缓存策略：<br>options &amp; SDWebImageDownloaderUseNSURLCache ?<br>                    NSURLRequestUseProtocolCachePolicy :<br>                    NSURLRequestReloadIgnoringLocalCacheData</p>
<p>是否设置了SDWebImageDownloaderUseNSURLCache属性，并根据这个属性的设置设置NSURLRequest的缓存策略</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;默认情况下不使用NSURLCache，可以通过设置这个属性使用NSURLCache</span><br><span class="line"> SDWebImageDownloaderUseNSURLCache &#x3D; 1 &lt;&lt; 2,</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>三种策略关系的简述：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SDWebImageDownloaderUseNSURLCache：在SDWebImage中，缺省情况下，request是不使用NSURLCache的，但是若使用该选项，就默认使用NSURLCache默认的缓存策略：NSURLRequestUseProtocolCachePolicy。</span><br><span class="line"></span><br><span class="line">NSURLRequestUseProtocolCachePolicy：对特定的 URL 请求使用网络协议（如HTTP）中实现的缓存逻辑。这是默认的策略。该策略表示如果缓存不存在，直接从服务端获取。</span><br><span class="line">如果缓存存在，会根据response中的Cache-Control字段判断 下一步操作，如: Cache-Control字段为must-revalidata, 则 询问服务端该数据是否有更新，无更新话 直接返回给用户缓存数据，若已更新，则请求服务端.</span><br><span class="line">NSURLRequestReloadIgnoringLocalCacheData：数据需要从原始地址(一般就是重新从服务器获取)加载。不使用现有缓存</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="请求的其他参数设置"><a href="#请求的其他参数设置" class="headerlink" title="请求的其他参数设置"></a>请求的其他参数设置</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">request.HTTPShouldHandleCookies &#x3D; (options &amp;</span><br><span class="line">						 SDWebImageDownloaderHandleCookies);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 如果设置HTTPShouldHandleCookies为YES，就处理存储在</span><br><span class="line">	NSHTTPCookieStore中的cookies。</span><br><span class="line">&#x2F;&#x2F; HTTPShouldHandleCookies表示是否应该给request设置cookie并随</span><br><span class="line">	request一起发送出去。</span><br><span class="line">   SDWebImageDownloaderHandleCookies &#x3D; 1 &lt;&lt; 5,</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; HTTPShouldUsePipelining表示receiver(理解为iOS客户端)的下一个信息是否必须等到上一个请求回复才能发送。</span><br><span class="line">&#x2F;&#x2F; 如果为YES表示可以，NO表示必须等receiver收到先前的回复才能发送下个信息。</span><br><span class="line"></span><br><span class="line">request.HTTPShouldUsePipelining &#x3D; YES;</span><br></pre></td></tr></table></figure>

<h5 id="Header的设置"><a href="#Header的设置" class="headerlink" title="Header的设置"></a>Header的设置</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (wself.headersFilter) &#123;</span><br><span class="line">    request.allHTTPHeaderFields &#x3D; wself.headersFilter(url,</span><br><span class="line">    								 [wself.HTTPHeaders copy]);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">            request.allHTTPHeaderFields &#x3D; wself.HTTPHeaders;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> &#x2F;&#x2F;设置一个过滤器来设置每一个下载图片的HTTP请求的请求头</span><br><span class="line"> &#x2F;&#x2F;这个代码块在每一个图片的下载请求中都会被调用，返回一个可以用作HTTP请求header的字典</span><br><span class="line">@property (nonatomic, copy) </span><br><span class="line">		SDWebImageDownloaderHeadersFilterBlock headersFilter;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 简单看下HTTPHeader的初始化部分（如果下载webp图片，需要的header不一样）：</span><br><span class="line">&#x2F;&#x2F; #ifdef SD_WEBP</span><br><span class="line">&#x2F;&#x2F; _HTTPHeaders &#x3D; [@&#123;@&quot;Accept&quot;: @&quot;image&#x2F;webp,image&#x2F;*;q&#x3D;0.8&quot;&#125; </span><br><span class="line">	mutableCopy];</span><br><span class="line">&#x2F;&#x2F; #else</span><br><span class="line">&#x2F;&#x2F; _HTTPHeaders &#x3D; [@&#123;@&quot;Accept&quot;: @&quot;image&#x2F;*;q&#x3D;0.8&quot;&#125; mutableCopy];</span><br><span class="line">&#x2F;&#x2F; #endif</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="图片下载完成后是否需要解码"><a href="#图片下载完成后是否需要解码" class="headerlink" title="图片下载完成后是否需要解码"></a>图片下载完成后是否需要解码</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shouldDecompressImages:图片下载完成是否需要解码</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>注意</code>：解压缩已经下载的图片或者在缓存中的图片，可以提高性能，但是会耗费很多空间，缺省情况下是要解压缩图片。</p>
<h5 id="身份验证"><a href="#身份验证" class="headerlink" title="身份验证"></a>身份验证</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">urlCredential:</span><br><span class="line"></span><br><span class="line">	web 服务可以在返回 http 响应时附带认证要求的challenge，作用是询问 http 请求的发起方是谁，这时发起方应提供正确的用户名和密码（即认证信息），然后 web 服务才会返回真正的 http 响应。</span><br><span class="line"></span><br><span class="line">	收到认证要求时，NSURLConnection 的委托对象会收到相应的消息并得到一个 NSURLAuthenticationChallenge 实例。该实例的发送方遵守 </span><br><span class="line">	</span><br><span class="line">	NSURLAuthenticationChallengeSender 协议。为了继续收到真实的数据，需要向该发送方向发回一个 NSURLCredential 实例</span><br><span class="line"></span><br><span class="line">if (wself.urlCredential) &#123;</span><br><span class="line">     operation.credential &#x3D; wself.urlCredential;</span><br><span class="line">&#125; else if (wself.username &amp;&amp; wself.password) &#123;</span><br><span class="line">     operation.credential &#x3D; [NSURLCredential </span><br><span class="line">     						credentialWithUser:wself.username</span><br><span class="line">      								   password:wself.password 			persistence:NSURLCredentialPersistenceForSession];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>NSURLCredentialPersistenceForSession表示在应用终止时，丢弃相应的 credential 。</p>
<p><a href="http://blog.csdn.net/majiakun1/article/details/17013379">urlCredential详情参考这里</a></p>
<h5 id="下载的优先级"><a href="#下载的优先级" class="headerlink" title="下载的优先级"></a>下载的优先级</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (options &amp; SDWebImageDownloaderHighPriority) &#123;</span><br><span class="line">    operation.queuePriority &#x3D; NSOperationQueuePriorityHigh;</span><br><span class="line">  &#125; else if (options &amp; SDWebImageDownloaderLowPriority) &#123;</span><br><span class="line">    operation.queuePriority &#x3D; NSOperationQueuePriorityLow;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个就不做过多的解释了，一看就能明白</p>
<h5 id="添加到下载队列"><a href="#添加到下载队列" class="headerlink" title="添加到下载队列"></a>添加到下载队列</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[wself.downloadQueue addOperation:operation];</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里的downloadQueue是一个NSOperationQueue</p>
<h5 id="设置操作队列的执行顺序"><a href="#设置操作队列的执行顺序" class="headerlink" title="设置操作队列的执行顺序"></a>设置操作队列的执行顺序</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (wself.executionOrder &#x3D;&#x3D; </span><br><span class="line">					SDWebImageDownloaderLIFOExecutionOrder) &#123;</span><br><span class="line">    &#x2F;&#x2F; Emulate LIFO execution order by systematically adding new </span><br><span class="line">    	operations as last operation&#39;s dependency</span><br><span class="line">    [wself.lastAddedOperation addDependency:operation];</span><br><span class="line">     wself.lastAddedOperation &#x3D; operation;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果是先进先出，队列的结构，后来新加入的队列自然后在后面执行，如果是后进先出，栈结构 需要设置操作的依赖</p>
<p>说到这里，下面就剩下正式的发送请求</p>
<h4 id="下载请求"><a href="#下载请求" class="headerlink" title="下载请求"></a>下载请求</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">这里的参数应该是都比较清楚了，不在赘述</span><br><span class="line">- (id)initWithRequest:(NSURLRequest *)request</span><br><span class="line">              options:(SDWebImageDownloaderOptions)options</span><br><span class="line">             progress:(SDWebImageDownloaderProgressBlock)progressBlock</span><br><span class="line">            completed:(SDWebImageDownloaderCompletedBlock)completedBlock</span><br><span class="line">            cancelled:(SDWebImageNoParamsBlock)cancelBlock</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个方法的返回值也是也operation用户可以定义，默认是SDWebImageDownloaderOperation</p>
<h4 id="图片下载progressBlock"><a href="#图片下载progressBlock" class="headerlink" title="图片下载progressBlock"></a>图片下载progressBlock</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">progress:^(NSInteger receivedSize, NSInteger expectedSize) &#123;</span><br><span class="line">                                                             	SDWebImageDownloader *sself &#x3D; wself;</span><br><span class="line">	if (!sself) return;</span><br><span class="line">                                                             	__block NSArray *callbacksForURL;</span><br><span class="line">                                                             	dispatch_sync(sself.barrierQueue, ^&#123;</span><br><span class="line">                                                                 		callbacksForURL &#x3D; [sself.URLCallbacks[url] copy];</span><br><span class="line">                                                            </span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">   for (NSDictionary *callbacks in callbacksForURL) &#123;</span><br><span class="line">                                                                 		dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                                                                     			SDWebImageDownloaderProgressBlock callback &#x3D; </span><br><span class="line">                                                                     							callbacks[kProgressCallbackKey];</span><br><span class="line">                                                         	if (callback) callback(receivedSize, expectedSize);</span><br><span class="line">                                                                 &#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>注意：</code><br>这里每一个URL对应的callbacksForURL是一个数组，数组中存放的是针对同一个URL的下载过程中的一些操作，这里对于同一个URL数组中的所有内容都做更新。</p>
<p>下载完成的回调(执行回调，删除回调的保存)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">                                                        completed:^(UIImage *image, NSData *data, NSError *error, BOOL finished) &#123;</span><br><span class="line">                                                            SDWebImageDownloader *sself &#x3D; wself;</span><br><span class="line">if (!sself) return;                                                     __block NSArray *callbacksForURL;                                                dispatch_barrier_sync(sself.barrierQueue, ^&#123;</span><br><span class="line">	callbacksForURL &#x3D; [sself.URLCallbacks[url] copy];</span><br><span class="line">	if (finished) &#123;</span><br><span class="line">		[sself.URLCallbacks removeObjectForKey:url];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br><span class="line">    for (NSDictionary *callbacks in callbacksForURL) &#123;</span><br><span class="line">		SDWebImageDownloaderCompletedBlock callback </span><br><span class="line">						&#x3D;callbacks[kCompletedCallbackKey];</span><br><span class="line">                                                                if (callback) callback(image, data, error, finished);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>下载操作被取消的回调：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">                                                                                                                cancelled:^&#123;</span><br><span class="line">                                                            SDWebImageDownloader *sself &#x3D; wself;</span><br><span class="line">if (!sself) return;                                             dispatch_barrier_async(sself.barrierQueue, ^&#123;</span><br><span class="line">	[sself.URLCallbacks removeObjectForKey:url];</span><br><span class="line">&#125;);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>到目前为止，除了具体的下载细节，图片下载就基本完成了！！！开始执行下载完成的回调</p>
<h5 id="图片下载完成（包含成功或者失败）："><a href="#图片下载完成（包含成功或者失败）：" class="headerlink" title="图片下载完成（包含成功或者失败）："></a>图片下载完成（包含成功或者失败）：</h5><p>这里要注意下，突然发现当前存在着好几个operation，先通过下面这张图片，理一下层次结构</p>
<p><img src="http://images2015.cnblogs.com/blog/715314/201512/715314-20151226140749593-1190538283.png" alt="icon"></p>
<p>现在回到了SDWebImageDownloader的downloadImageWithURL:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">__strong __typeof(weakOperation) strongOperation &#x3D;</span><br><span class="line">												 weakOperation;</span><br><span class="line">												 </span><br><span class="line">if (!strongOperation || strongOperation.isCancelled) &#123;</span><br><span class="line"> &#x2F;&#x2F; Do nothing if the operation was cancelled</span><br><span class="line"> &#x2F;&#x2F; See #699 for more details</span><br><span class="line"> &#x2F;&#x2F; if we would call the completedBlock, there could be a race</span><br><span class="line">  condition between this block and another completedBlock for</span><br><span class="line">   the same object, so if this one is called second, we will </span><br><span class="line">   overwrite the new data</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>问题</code>：</p>
<p>这里的解释是：如果操作被取消了，就不执行任何操作。如果我们调用了completedBlock，那么在同一个对象的另一个completedBlock之间就存在一个竞争关系，因此，如果这个方法被重复调用两次，我们会重写新的数据</p>
<h4 id="图片下载失败处理"><a href="#图片下载失败处理" class="headerlink" title="图片下载失败处理"></a>图片下载失败处理</h4><p>确定下载失败的原因，触发下载完成的回调（返回必要信息），同时加入黑名单</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dispatch_main_sync_safe(^&#123;</span><br><span class="line">  if (strongOperation &amp;&amp; !strongOperation.isCancelled) &#123;</span><br><span class="line">      completedBlock(nil, error, SDImageCacheTypeNone,</span><br><span class="line">       finished, url);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;);</span><br><span class="line"></span><br><span class="line"> if (error.code !&#x3D; NSURLErrorNotConnectedToInternet</span><br><span class="line">     &amp;&amp; error.code !&#x3D; NSURLErrorCancelled</span><br><span class="line">     &amp;&amp; error.code !&#x3D; NSURLErrorTimedOut</span><br><span class="line">     &amp;&amp; error.code !&#x3D; NSURLErrorInternationalRoamingOff</span><br><span class="line">     &amp;&amp; error.code !&#x3D; NSURLErrorDataNotAllowed</span><br><span class="line">     &amp;&amp; error.code !&#x3D; NSURLErrorCannotFindHost</span><br><span class="line">     &amp;&amp; error.code !&#x3D; NSURLErrorCannotConnectToHost) &#123;</span><br><span class="line">     @synchronized (self.failedURLs) &#123;</span><br><span class="line">          [self.failedURLs addObject:url];</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>注意：这里不管用户是否设置，都会将这个下载失败的URL加入到黑名单中</code></p>
<h4 id="图片下载成功"><a href="#图片下载成功" class="headerlink" title="图片下载成功"></a>图片下载成功</h4><p>判断是否为下载失败后的重试,如果是重试，那么就将这个图片从黑名单中移除</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if ((options &amp; SDWebImageRetryFailed)) &#123;</span><br><span class="line">   @synchronized (self.failedURLs) &#123;</span><br><span class="line">       [self.failedURLs removeObject:url];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>是否设置了SDWebImageRefreshCached（相同的URL 图片改变之后是否更新缓存）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (options &amp; SDWebImageRefreshCached &amp;&amp; </span><br><span class="line">							image &amp;&amp; !downloadedImage) &#123;</span><br><span class="line">   &#x2F;&#x2F; Image refresh hit the NSURLCache cache, do not call the</span><br><span class="line">    completion block</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>图片下载完成之后，是否需要对图片进行相应的处理（根据SDWebImageTransformAnimatedImage属性，用户可进行设置）：</p>
<p>先看一下图片下载成功之后判断条件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(downloadedImage &amp;&amp; (!downloadedImage.images || (options &amp; SDWebImageTransformAnimatedImage)) &amp;&amp; [self.delegate respondsToSelector:@selector(imageManager:transformDownloadedImage:withURL:)]) </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>downloadedImage:图片下载成功</p>
<p>图片不是gif且需要在图片下载完成之后，对图片进行其他操作<br>(!downloadedImage.images || (options &amp;<br>                SDWebImageTransformAnimatedImage))</p>
<p>是否实现了图片下载完成之后形变的代理方法</p>
<p>[self.delegate respondsToSelector:@selector(imageManager:transformDownloadedImage:withURL:)</p>
<p>如果满足了上面的三个条件，表明在图片下载完成之后需要对图片进行形变：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">如果要进行形变，这个代理方法需要开发者实现</span><br><span class="line">UIImage *transformedImage &#x3D; [self.delegate imageManager:self </span><br><span class="line">		transformDownloadedImage:downloadedImage withURL:url];</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  &#x2F;&#x2F;完成形变操作，且图片下载完成（图片没下载完成回到用这个方法吗）</span><br><span class="line"> if (transformedImage &amp;&amp; finished) &#123;</span><br><span class="line">     BOOL imageWasTransformed &#x3D;</span><br><span class="line">     			 ![transformedImage isEqual:downloadedImage];</span><br><span class="line">     &#x2F;&#x2F;图片保存</span><br><span class="line">     [self.imageCache storeImage:transformedImage </span><br><span class="line">     		 recalculateFromImage:imageWasTransformed</span><br><span class="line">      				imageData:(imageWasTransformed ? nil : data)</span><br><span class="line">      				forKey:key toDisk:cacheOnDisk];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>调用下载完成的回调</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dispatch_main_sync_safe(^&#123;</span><br><span class="line">	&#x2F;&#x2F;operation 没有被取消</span><br><span class="line">    if (strongOperation &amp;&amp; !strongOperation.isCancelled) &#123;</span><br><span class="line">		completedBlock(transformedImage, nil, 	</span><br><span class="line">						SDImageCacheTypeNone, finished, url);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>如果不需要再图片下载完成之后，对图片进行其他的处理,那么就做一下图片的缓存同时调用图片下载完成的回调即可</code></p>
<h5 id="图片下载完成最后移除"><a href="#图片下载完成最后移除" class="headerlink" title="图片下载完成最后移除"></a>图片下载完成最后移除</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (finished) &#123;</span><br><span class="line">   @synchronized (self.runningOperations) &#123;</span><br><span class="line">   if (strongOperation) &#123;</span><br><span class="line">     [self.runningOperations removeObject:strongOperation];</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h4 id="操作的取消"><a href="#操作的取消" class="headerlink" title="操作的取消"></a>操作的取消</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">operation.cancelBlock &#x3D; ^&#123;</span><br><span class="line">	&#x2F;&#x2F;首先取消SDWebImageDownloaderOperation</span><br><span class="line">   [subOperation cancel];</span><br><span class="line">                </span><br><span class="line">   @synchronized (self.runningOperations) &#123;</span><br><span class="line">    __strong __typeof(weakOperation) strongOperation &#x3D; </span><br><span class="line">    											weakOperation;</span><br><span class="line">    if (strongOperation) &#123;</span><br><span class="line">    	&#x2F;&#x2F;移除这一操作</span><br><span class="line">        [self.runningOperations removeObject:strongOperation];</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>注意</code>：这里取消的是operation而不是subOperation</p>
<p>operation:是一个NSOperation类型的<br>subOperation：是一个SDWebImageDownloaderOperation类型的</p>
<p>下面我们来仔细的看一下取消操作：</p>
<p> [subOperation cancel];</p>
<p>这是SDWebImageDownloaderOperation种重写的取消</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)cancel &#123;</span><br><span class="line">    @synchronized (self) &#123;</span><br><span class="line">        if (self.thread) &#123;</span><br><span class="line">            [self </span><br><span class="line">            performSelector:@selector(cancelInternalAndStop) </span><br><span class="line">            onThread:self.thread withObject:nil </span><br><span class="line">            					  waitUntilDone:NO];</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            [self cancelInternal];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>仔细观察一下这里的取消操作，会根据是否存在self.thread执行两个方法：</p>
<p>cancelInternalAndStop和cancelInternal</p>
<p>比较一下这两个方法可以看到cancelInternalAndStop只是比多了一句：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CFRunLoopStop(CFRunLoopGetCurrent());</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>用来停止当前线程的运行循环。</p>
<h4 id="没找到图片："><a href="#没找到图片：" class="headerlink" title="没找到图片："></a>没找到图片：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dispatch_main_sync_safe(^&#123;</span><br><span class="line">   __strong __typeof(weakOperation) strongOperation &#x3D; </span><br><span class="line">   												weakOperation;</span><br><span class="line">   if (strongOperation &amp;&amp; !weakOperation.isCancelled) &#123;</span><br><span class="line">       completedBlock(nil, nil, SDImageCacheTypeNone, YES, url);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;);</span><br><span class="line">@synchronized (self.runningOperations) &#123;</span><br><span class="line">    [self.runningOperations removeObject:operation];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="图片在查找到或者下载完成之后图片的显示"><a href="#图片在查找到或者下载完成之后图片的显示" class="headerlink" title="图片在查找到或者下载完成之后图片的显示"></a>图片在查找到或者下载完成之后图片的显示</h4><p>SDWebImageAvoidAutoSetImage 图片下载完成之后是否立即设置给ImageView<br>在这里如果想要对图片的显示添加一些动画，我们可以从这里着手</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;下载完成之后是否自动设置图片</span><br><span class="line">   SDWebImageAvoidAutoSetImage &#x3D; 1 &lt;&lt; 11</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>图片显示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dispatch_main_sync_safe(^&#123;</span><br><span class="line">  if (!wself) return;</span><br><span class="line">  &#x2F;&#x2F;用户是否设置了需要手动设置图片的显示</span><br><span class="line">  if (image </span><br><span class="line">  		&amp;&amp; (options &amp; SDWebImageAvoidAutoSetImage)</span><br><span class="line">   		&amp;&amp; completedBlock)</span><br><span class="line">  &#123;</span><br><span class="line">      completedBlock(image, error, cacheType, url);</span><br><span class="line">      return;</span><br><span class="line">  &#125;</span><br><span class="line">   else if (image) &#123;</span><br><span class="line">      wself.image &#x3D; image;</span><br><span class="line">      [wself setNeedsLayout];</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">   	  &#x2F;&#x2F;图片下载失败延时显示占位图片</span><br><span class="line">      if ((options &amp; SDWebImageDelayPlaceholder)) &#123;</span><br><span class="line">            wself.image &#x3D; placeholder;</span><br><span class="line">            [wself setNeedsLayout];</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F;图片下载成功之后的回调</span><br><span class="line">  if (completedBlock &amp;&amp; finished) &#123;</span><br><span class="line">       completedBlock(image, error, cacheType, url);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>源码分析</category>
      </categories>
      <tags>
        <tag>SDWebImage</tag>
        <tag>下载</tag>
      </tags>
  </entry>
  <entry>
    <title>祭最近的一次面试</title>
    <url>/2018/04/21/latest-interview/</url>
    <content><![CDATA[<p>最近工作事情不多,本着紧跟潮流的想法,在公司附近找了几家公司面试,涨涨经验顺便看看最近iOS都在招什么方向的的人！ 本人计算机专业毕业(不过基本已经把老师讲的还给老师了),因此在这次面试中 完全被虐。因此,打算写一篇文章来祭奠我的这次面试！</p>
<a id="more"></a>

<h2 id="面试题目"><a href="#面试题目" class="headerlink" title="面试题目"></a>面试题目</h2><h3 id="都学过哪些数据结构？"><a href="#都学过哪些数据结构？" class="headerlink" title="都学过哪些数据结构？"></a>都学过哪些数据结构？</h3><p>数据结构：是指相互之间存在着一种或多种关系的数据元素的集合和该集合中数据元素之间的关系组成<br>包括三个组成成分：数据的逻辑结构、物理结构（存储结构）、数据运算结构。</p>
<h4 id="数据的逻辑结构："><a href="#数据的逻辑结构：" class="headerlink" title="数据的逻辑结构："></a>数据的逻辑结构：</h4><ul>
<li>1、集合（数据之间无关系）</li>
<li>2、线性结构（一对一）</li>
<li>3、树形结构（一对多）</li>
<li>4、图形结构（多对多）</li>
</ul>
<h4 id="数据的物理结构：指数据在计算机存储空间的存放形式"><a href="#数据的物理结构：指数据在计算机存储空间的存放形式" class="headerlink" title="数据的物理结构：指数据在计算机存储空间的存放形式"></a>数据的物理结构：指数据在计算机存储空间的存放形式</h4><p>顺序存储、链表存储、索引存储、散列存储</p>
<h5 id="常用的数据结构："><a href="#常用的数据结构：" class="headerlink" title="常用的数据结构："></a>常用的数据结构：</h5><ul>
<li>1、数组</li>
<li>2、栈（先进后出、线性表）</li>
<li>3、队列（先进先出、后进后出、线性表）</li>
<li>4、链表（每个节点包括两个部分：一个存储数据元素的数据域、另一个存储下一个节点地址的指针域）</li>
<li>5、树</li>
<li>6、图</li>
<li>7、堆（是一种动态的树形结构）</li>
<li>8、散列表</li>
</ul>
<h3 id="数组和链表的区别"><a href="#数组和链表的区别" class="headerlink" title="数组和链表的区别"></a>数组和链表的区别</h3><h4 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h4><p>顺序表是在计算机内存中以数组的形式保存的线性表，是指用一组地址连续的存储单元依次存储数据元素的线性结构。只要确定了起始位置，表中任一元素的地址都通过下列公式得到：LOC（ai）=LOC（a1）+（i-1）*L 　1≤i≤n 其中，L是元素占用存储单元的长度。</p>
<h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><ul>
<li>长度固定，必须在分配内存之前确定数组的长度。</li>
<li>存储空间连续，即允许元素的随机访问。</li>
<li>存储密度大，内存中存储的全部是数据元素。</li>
<li>要访问特定元素，可以使用索引访问，时间复杂度为 。</li>
<li>要想在顺序表中插入或删除一个元素，都涉及到之后所有元素的移动，因此时间复杂度为 。</li>
</ul>
<p><img src="https://img-blog.csdn.net/20160323220752422" alt="顺序表"></p>
<h4 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h4><p>单链表是一种链式存取的数据结构，用一组地址任意的存储单元存放线性表中的数据元素。它的数据是以结点（类型一般为结构体）来表示的，每个结点的构成：数据（类型为要存储的数据的类型） + 指针（结构体指针），数据就是链表里具体要存储的东西，指针就是用来把每个节点都连接起来，使它们形成一个链状</p>
<p><img src="https://img-blog.csdn.net/20160323214456532" alt="链表"></p>
<h5 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h5><ul>
<li>长度不固定，可以任意增删。</li>
<li>存储空间不连续，数据元素之间使用指针相连，每个数据元素只能访问周围的一个元素（根据单链表还是双链表有所不同）。</li>
<li>存储密度小，因为每个数据元素，都需要额外存储一个指向下一元素的指针（双链表则需要两个指针）。</li>
<li>要访问特定元素，只能从链表头开始，遍历到该元素，时间复杂度为 。</li>
<li>在特定的数据元素之后插入或删除元素，不涉及到其他元素的移动，因此时间复杂度为 。双链表还允许在特定的数据元素之前插入或删除元素。</li>
</ul>
<h4 id="区别和优缺点"><a href="#区别和优缺点" class="headerlink" title="区别和优缺点"></a>区别和优缺点</h4><h5 id="空间的开辟"><a href="#空间的开辟" class="headerlink" title="空间的开辟"></a>空间的开辟</h5><p>顺序表的实现一般是实现连续开辟一段空间，然后在进行数据的增删查改（静态顺序表），所以顺序表一般是固定空间大小的；而单链表则是一次只开辟一个结点的空间，用来存储当前要保存的数据及指向下一个结点或NULL的指针，所以单链表的空间大小时动态变化的。（当然，顺序表也可以在初始化时利用malloc函数来开辟一块空间，每当空间不够用时，再用realloc来把当前空间扩容成2倍，从而也能实现空间的动态变化（动态顺序表））。</p>
<h5 id="空间的使用"><a href="#空间的使用" class="headerlink" title="空间的使用"></a>空间的使用</h5><p>当我们不知道要存储多少数据时，用顺序表来开辟的空间如果太大，就会造成一定程度上的浪费，而用单链表是实现时，因为是每需要存储一个数据时，才开辟一个空间，虽然有非数据项的指针占空间，但相比顺序表来说，浪费不是那么明显；反之，当我们知道存储的数据的数量时，用顺序表来开辟对应的空间大小，来存储数据，因为顺序表中每个元素的存储密度为 1，就完全不会有浪费的空间，而用单链表，因为每个结点都会有非数据项得指针，那么就会造成空间的浪费。再者 链表可能会产生内存碎片</p>
<h5 id="访问随机元素的时间复杂度"><a href="#访问随机元素的时间复杂度" class="headerlink" title="访问随机元素的时间复杂度"></a>访问随机元素的时间复杂度</h5><p>因为顺序表的结构就像是数组一样，可以用下标来访问它的元素，所以它的元素是支持随机访问的；相比之下，单链表的数据是链式存储的，它的元素是不支持随机访问的，想要知道某个元素，只能从头结点开始遍历整个链表，知道找到了该元素为止。因此顺序表访问随机元素的时间复杂度是O（1），而单链表访问随机元素的平均时间复杂度是O（n）。</p>
<h6 id="随机位置插入、删除元素的时间复杂度"><a href="#随机位置插入、删除元素的时间复杂度" class="headerlink" title="随机位置插入、删除元素的时间复杂度"></a>随机位置插入、删除元素的时间复杂度</h6><p>因为顺序表的元素是连续存储的，因此要在特定位置插入、删除元素需要把它之后的元素全部后移或前移一个元素的位置，时间开销很大；而单链表在插入或删除元素时，只需要改变它的前驱元素及插入或删除元素的指向即可。因此，顺序表在插入随机位置插入、删除元素的平均时间复杂度是O（n），单链表在插入随机位置插入、删除元素的时间复杂度是O（1）。</p>
<p>综上 <code>在查询操作使用的比较频繁时，使用顺序表会好一些；在插入、删除操作使用的比较频繁时，使用单链表会好一些。</code></p>
<h3 id="树学过哪些树-什么是完全二叉树-霍夫曼树-红黑树-图"><a href="#树学过哪些树-什么是完全二叉树-霍夫曼树-红黑树-图" class="headerlink" title="树学过哪些树 什么是完全二叉树 霍夫曼树 红黑树 图"></a>树学过哪些树 什么是完全二叉树 霍夫曼树 红黑树 图</h3><h4 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h4><p>二叉树是有限个结点的集合，这个集合或者是空集，或者是由一个根结点和两株互不相交的二叉树组成，其中一株叫根的做左子树，另一棵叫做根的右子树</p>
<p>二叉树的性质：</p>
<ul>
<li>性质1：在二叉树中第 i 层的结点数最多为2^(i-1)（i ≥ 1）</li>
<li>性质2：高度为k的二叉树其结点总数最多为2^k－1（ k ≥ 1）</li>
<li>性质3：对任意的非空二叉树 T ，如果叶结点的个数为 n0，而其度为 2 的结点数为 n2，则：n0 = n2 + 1</li>
</ul>
<h4 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h4><p>深度为k且有2^k －1个结点的二叉树称为满二叉树</p>
<ul>
<li>性质4：具有 n 个结点的完全二叉树的深度为 log2n + 1</li>
</ul>
<p><code>注意</code>:仅有前序和后序遍历，不能确定一个二叉树，必须有中序遍历的结果</p>
<h4 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h4><p>深度为 k 的，有n个结点的二叉树，当且仅当其每个结点都与深度为 k 的满二叉树中编号从 1 至 n 的结点一一对应，称之为完全二叉树。（除最后一层外，每一层上的节点数均达到最大值；在最后一层上只缺少右边的若干结点）</p>
<h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4><p>如果一棵完全二叉树的任意一个非终端结点的元素都不小于其左儿子结点和右儿子结点（如果有的话） 的元素，则称此完全二叉树为<code>最大堆</code>。</p>
<p>同样，如果一棵完全二叉树的任意一个非终端结点的元素都不大于其左儿子结点和右儿子结点（如果 有的话）的元素，则称此完全二叉树为<code>最小堆</code>。</p>
<p><code>最大堆的根结点中的元素在整个堆中是最大的</code>；</p>
<p><code>最小堆的根结点中的元素在整个堆中是最小的</code>。</p>
<h4 id="哈弗曼树"><a href="#哈弗曼树" class="headerlink" title="哈弗曼树"></a>哈弗曼树</h4><p>定义：给定n个权值作为n的叶子结点，构造一棵二叉树，若带权路径长度达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树(Huffman tree)。</p>
<h5 id="构造："><a href="#构造：" class="headerlink" title="构造："></a>构造：</h5><p>假设有n个权值，则构造出的哈夫曼树有n个叶子结点。 n个权值分别设为 w1、w2、…、wn，则哈夫曼树的构造规则为：</p>
<ul>
<li>将w1、w2、…，wn看成是有 n 棵树的森林(每棵树仅有一个结点)；</li>
<li>在森林中选出两个根结点的权值最小的树合并，作为一棵新树的左、右子树，且新树的根结点权值为其左、右子树根结点权值之和；</li>
<li>从森林中删除选取的两棵树，并将新树加入森林；</li>
<li>重复(2)、(3)步，直到森林中只剩一棵树为止，该树即为所求得的哈夫曼树。</li>
</ul>
<p><img src="https://gss3.bdstatic.com/-Po3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=408997773a12b31bd361c57be7715d1f/0df431adcbef7609783292af2ddda3cc7cd99ec0.jpg" alt="哈弗曼树"></p>
<h4 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a>二叉排序树</h4><p>二叉排序树（Binary Sort Tree）又称二叉查找树（Binary Search Tree），亦称二叉搜索树。</p>
<p>二叉排序树或者是一棵空树，或者是具有下列性质的二叉树：</p>
<ul>
<li>若左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li>
<li>若右子树不空，则右子树上所有结点的值均大于或等于它的根结点的值；</li>
<li>左、右子树也分别为二叉排序树；</li>
<li>没有键值相等的节点</li>
</ul>
<p>二分查找的时间复杂度是O(log(n))，最坏情况下的时间复杂度是O(n)（相当于顺序查找）</p>
<p><img src="https://gss2.bdstatic.com/9fo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=b3c80026d72a6059461de948495d5ffe/94cad1c8a786c9179df9bed6c93d70cf3ac75763.jpg" alt="二叉排序树"></p>
<h4 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h4><p>平衡二叉树（balanced binary tree）,又称 AVL 树。它或者是一棵空树,或者是具有如下性质的二叉树：</p>
<ul>
<li>它的左子树和右子树都是平衡二叉树，</li>
<li>左子树和右子树的深度之差的绝对值不超过1。</li>
</ul>
<p>平衡二叉树是对二叉搜索树(又称为二叉排序树)的一种改进。二叉搜索树有一个缺点就是，树的结构是无法预料的，随意性很大，它只与节点的值和插入的顺序有关系，往往得到的是一个不平衡的二叉树。在最坏的情况下，可能得到的是一个单支二叉树，其高度和节点数相同，相当于一个单链表，对其正常的时间复杂度有O(log(n))变成了O(n)，从而丧失了二叉排序树的一些应该有的优点</p>
<p><img src="https://gss2.bdstatic.com/9fo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=f997b13a8c01a18be4e61a1dff466c6d/3801213fb80e7bec26a434f7242eb9389b506bad.jpg" alt="平衡二叉树"></p>
<h4 id="B-树"><a href="#B-树" class="headerlink" title="B-树"></a>B-树</h4><p>B-树：B-树是一种非二叉的查找树， 除了要满足查找树的特性，还要满足以下结构特性：</p>
<p>一棵 m 阶的B-树：</p>
<ul>
<li>树的根或者是一片叶子(一个节点的树),或者其儿子数在 2 和 m 之间。</li>
<li>除根外，所有的非叶子结点的孩子数在 m/2 和 m 之间。</li>
<li>所有的叶子结点都在相同的深度。</li>
</ul>
<p>B-树的平均深度为logm/2(N)。执行查找的平均时间为O(logm)；</p>
<h4 id="Trie-树"><a href="#Trie-树" class="headerlink" title="Trie 树"></a>Trie 树</h4><p>Trie 树，又称前缀树，字典树， 是一种有序树，用于保存关联数组，其中的键通常是字符串。与二叉查找树不同，键不是直接保存在节点中，而是由节点在树中的位置决定。一个节点的所有子孙都有相同的前缀，也就是这个节点对应的字符串，而根节点对应空字符串。一般情况下，不是所有的节点都有对应的值，只有叶子节点和部分内部节点所对应的键才有相关的值。</p>
<p>Trie 树查询和插入时间复杂度都是 O(n)，是一种以空间换时间的方法。当节点树较多的时候，Trie 树占用的内存会很大。</p>
<p>Trie 树常用于搜索提示。如当输入一个网址，可以自动搜索出可能的选择。当没有完全匹配的搜索结果，可以返回前缀最相似的可能。</p>
<h3 id="哈希表-给一个数据如何存到哈希表中-如何得到这个key"><a href="#哈希表-给一个数据如何存到哈希表中-如何得到这个key" class="headerlink" title="哈希表 给一个数据如何存到哈希表中 如何得到这个key"></a>哈希表 给一个数据如何存到哈希表中 如何得到这个key</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>哈希表（Hash Table，也叫散列表），是根据关键码值 (Key-Value) 而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。哈希表的实现主要需要解决两个问题，哈希函数和冲突解决。</p>
<h4 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h4><p>根据key,计算出key对应记录的储存位置</p>
<p><code>position = f(key)</code></p>
<p>哈希函数也叫散列函数，它对不同的输出值得到一个固定长度的消息摘要。理想的哈希函数对于不同的输入应该产生不同的结构，同时散列结果应当具有同一性（输出值尽量均匀）和雪崩效应（微小的输入值变化使得输出值发生巨大的变化）</p>
<h4 id="冲突解决"><a href="#冲突解决" class="headerlink" title="冲突解决"></a>冲突解决</h4><p>现实中的哈希函数不是完美的，当两个不同的输入值对应一个输出值时，就会产生“碰撞”，这个时候便需要解决冲突。</p>
<p>常见的冲突解决方法有开放定址法，链地址法，建立公共溢出区等。实际的哈希表实现中，使用最多的是链地址法</p>
<h4 id="链地址法"><a href="#链地址法" class="headerlink" title="链地址法"></a>链地址法</h4><p>链地址法的基本思想是，为每个 Hash 值建立一个单链表，当发生冲突时，将记录插入到链表中。</p>
<p>例 2 设有 8 个元素 { a,b,c,d,e,f,g,h } ，采用某种哈希函数得到的地址分别为： {0 ， 2 ， 4 ， 1 ， 0 ， 8 ， 7 ， 2} ，当哈希表长度为 10 时，采用链地址法解决冲突的哈希表如下图所示：</p>
<p><img src="https://github.com/HIT-Alibaba/interview/blob/master/img/hash-table.jpg?raw=true" alt="链地址法"></p>
<h3 id="算法学过哪些"><a href="#算法学过哪些" class="headerlink" title="算法学过哪些"></a>算法学过哪些</h3><h4 id="常见排序算法"><a href="#常见排序算法" class="headerlink" title="常见排序算法"></a>常见排序算法</h4><h5 id="常见的稳定排序算法有："><a href="#常见的稳定排序算法有：" class="headerlink" title="常见的稳定排序算法有："></a>常见的稳定排序算法有：</h5><ul>
<li>冒泡排序（Bubble Sort） — O(n²)</li>
<li>插入排序（Insertion Sort）— O(n²)</li>
<li>桶排序（Bucket Sort）— O(n); 需要 O(k) 额外空间</li>
<li>计数排序 (Counting Sort) — O(n+k); 需要 O(n+k) 额外空间</li>
<li>合并排序（Merge Sort）— O(nlogn); 需要 O(n) 额外空间</li>
<li>二叉排序树排序 （Binary tree sort） — O(n log n) 期望时间; O(n²)最坏时间; 需要 O(n) 额外空间</li>
<li>基数排序（Radix sort）— O(n·k); 需要 O(n) 额外空间</li>
</ul>
<h5 id="常见的不稳定排序算法有："><a href="#常见的不稳定排序算法有：" class="headerlink" title="常见的不稳定排序算法有："></a>常见的不稳定排序算法有：</h5><ul>
<li>选择排序（Selection Sort）— O(n²)</li>
<li>希尔排序（Shell Sort）— O(nlogn)</li>
<li>堆排序（Heapsort）— O(nlogn)</li>
<li>快速排序（Quicksort）— O(nlogn) 期望时间, O(n²) 最坏情况; 对于大的、乱数串行一般相信是最快的已知排</li>
</ul>
<p><a href="https://blog.csdn.net/whuslei/article/details/6442755">常见排序算法小结</a></p>
<h4 id="常用查找算法"><a href="#常用查找算法" class="headerlink" title="常用查找算法"></a>常用查找算法</h4><ul>
<li>顺序查找 时间复杂度为O(n)</li>
<li>二分查找 O(log2n)</li>
<li>分块查找</li>
<li>树表查找</li>
<li>哈希表查找</li>
</ul>
<p><a href="http://codingxiaxw.cn/2017/01/14/66-leetcode-find/">常用查找算法</a></p>
<h3 id="内存的分区？"><a href="#内存的分区？" class="headerlink" title="内存的分区？"></a>内存的分区？</h3><p>一个程序的可执行文件在内存中的结果，从大的角度可以分为两个部分：只读部分和可读写部分。只读部分包括程序代码（.text）和程序中的常量（.rodata）。可读写部分（也就是变量）大致可以分成下面几个部分：</p>
<ul>
<li>.data： 初始化了的全局变量和静态变量</li>
<li>.bss： 即 Block Started by Symbol， 未初始化的全局变量和静态变量（这个我感觉上课真的没讲过啊我去。。。）</li>
<li>heap： 堆，使用 malloc, realloc, 和 free 函数控制的变量，堆在所有的线程，共享库，和动态加载的模块中被共享使用</li>
<li>stack： 栈，函数调用时使用栈来保存函数现场，自动变量（即生命周期限制在某个 scope 的变量）也存放在栈中。</li>
<li>文字常量区   —常量字符串就是放在这里的。程序结束后由系统释放  </li>
<li>程序代码区—存放函数体的二进制代码。</li>
</ul>
<h3 id="堆和栈的区别？-系统如何去管理栈的内存-是运行期间还是编译之后就确定了"><a href="#堆和栈的区别？-系统如何去管理栈的内存-是运行期间还是编译之后就确定了" class="headerlink" title="堆和栈的区别？ 系统如何去管理栈的内存 是运行期间还是编译之后就确定了?"></a>堆和栈的区别？ 系统如何去管理栈的内存 是运行期间还是编译之后就确定了?</h3><h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><p>栈是用于存放本地变量，内部临时变量以及有关上下文的内存区域。程序在调用函数时，<code>操作系统会自动通过压栈和弹栈完成保存函数现场等操作</code>，不需要程序员手动干预。</p>
<p>栈是一块连续的内存区域，栈顶的地址和栈的最大容量是系统预先规定好的。能从栈获得的空间较小。如果申请的空间超过栈的剩余空间时，例如<code>递归深度过深</code>，将提示<code>stackoverflow</code>。</p>
<p>栈是机器系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高</p>
<h4 id="堆-1"><a href="#堆-1" class="headerlink" title="堆"></a>堆</h4><p>堆是用于存放除了栈里的东西之外所有其他东西的内存区域，当使用malloc和free时就是在操作堆中的内存。对于堆来说，<code>释放工作由程序员控制</code>，<code>容易产生memory leak</code>。</p>
<p>堆是向高地址扩展的数据结构，<code>是不连续的内存区域</code>。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。</p>
<p>对于堆来讲，<code>频繁的new/delete势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低</code>。对于栈来讲，则不会存在这个问题，<code>因为栈是先进后出的队列，永远都不可能有一个内存块从栈中间弹出</code>。</p>
<p>堆都是动态分配的，没有静态分配的堆。栈有2种分配方式：静态分配和动态分配。静态分配是编译器完成的，比如局部变量的分配。动态分配由alloca函数进行分配，但是栈的动态分配和堆是不同的，他的动态分配是由编译器进行释放，无需我们手工实现。</p>
<p>计算机底层并没有对堆的支持，堆则是C/C++函数库提供的，同时由于上面提到的碎片问题，都会导致堆的效率比栈要低</p>
<h4 id="堆和栈的区别"><a href="#堆和栈的区别" class="headerlink" title="堆和栈的区别"></a>堆和栈的区别</h4><h5 id="申请方式"><a href="#申请方式" class="headerlink" title="申请方式"></a>申请方式</h5><ul>
<li>栈：由系统自动分配</li>
<li>堆：  需要程序员自己申请，并指明大小，在c中malloc函数    </li>
</ul>
<h5 id="申请后系统的响应"><a href="#申请后系统的响应" class="headerlink" title="申请后系统的响应"></a>申请后系统的响应</h5><ul>
<li><p>栈：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢<br>出。   </p>
</li>
<li><p>堆：首先应该知道操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，<br>会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表<br>中删除，并将该结点的空间分配给程序，另外，对于大多数系统，会在这块内存空间中的<br>首地址处记录本次分配的大小，这样，代码中的delete语句才能正确的释放本内存空间。<br>另外，由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部<br>分重新放入空闲链表中。    </p>
</li>
</ul>
<h5 id="申请大小的限制"><a href="#申请大小的限制" class="headerlink" title="申请大小的限制"></a>申请大小的限制</h5><ul>
<li><p>栈 ：栈顶的地址和栈的最大容量是系统预先规定好的 如果申请的空间超过栈的剩余空间时，将<br>提示overflow。因此，能从栈获得的空间较小</p>
</li>
<li><p>堆：是不连续的内存区域 堆的大小受限于计算机系统中有效的虚拟内存</p>
</li>
</ul>
<h5 id="申请效率"><a href="#申请效率" class="headerlink" title="申请效率"></a>申请效率</h5><ul>
<li>栈：栈由系统自动分配，速度较快。但程序员是无法控制的。    </li>
<li>堆：堆是由new分配的内存，一般速度比较慢，而且容易产生内存碎片,不过用起来最方便.    </li>
</ul>
<h5 id="存储内容"><a href="#存储内容" class="headerlink" title="存储内容"></a>存储内容</h5><ul>
<li><p>栈:在函数调用时，第一个进栈的是主函数中后的下一条指令（函数调用语句的下一条可<br>执行语句）的地址，然后是函数的各个参数，在大多数的C编译器中，参数是由右往左入栈<br>的，然后是函数中的局部变量。注意静态变量是不入栈的。 </p>
</li>
<li><p>堆:一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容由程序员安排。    </p>
</li>
</ul>
<h5 id="存取效率"><a href="#存取效率" class="headerlink" title="存取效率"></a>存取效率</h5><p>栈&gt;堆</p>
<h3 id="那种内存容易产生内存碎片-为什么会产生内存碎片"><a href="#那种内存容易产生内存碎片-为什么会产生内存碎片" class="headerlink" title="那种内存容易产生内存碎片? 为什么会产生内存碎片"></a>那种内存容易产生内存碎片? 为什么会产生内存碎片</h3><p>内存碎片容易发生在堆上,因为只有堆我们才会自己去管理内存的申请使用和释放,栈区是不会碎片化的,因为栈区一直遵守后进先出的逻辑。</p>
<h4 id="内存碎片"><a href="#内存碎片" class="headerlink" title="内存碎片"></a>内存碎片</h4><p>内存分配有静态分配和动态分配两种</p>
<p>静态分配在程序编译链接时分配的大小和使用寿命就已经确定，而应用上要求操作系统可以提供给进程运行时申请和释放任意大小内存的功能，这就是内存的动态分配</p>
<p><code>动态分配会导致内存的碎片化</code></p>
<h4 id="内存碎片类型"><a href="#内存碎片类型" class="headerlink" title="内存碎片类型"></a>内存碎片类型</h4><h5 id="内部碎片："><a href="#内部碎片：" class="headerlink" title="内部碎片："></a>内部碎片：</h5><p>因为所有的内存分配必须起始于可被 4、8 或 16 整除（视处理器体系结构而定）的地址或者因为MMU的分页机制的限制，决定内存分配算法<code>仅能把预定大小的内存块分配给客户</code>。假设当某个客户请求一个 43 字节的内存块时，因为没有适合大小的内存，所以它可能会获得 44字节、48字节等稍大一点的字节，因此由所需大小四舍五入而产生的多余空间就叫内部碎片。</p>
<h5 id="外部碎片"><a href="#外部碎片" class="headerlink" title="外部碎片"></a>外部碎片</h5><p>频繁的分配与回收物理页面会导致大量的、连续且小的页面块夹杂在已分配的页面中间，就会产生外部碎片。假设有一块一共有100个单位的连续空闲内存空间，范围是099。如果你从中申请一块内存，如10个单位，那么申请出来的内存块就为09区间。这时候你继续申请一块内存，比如说5个单位大，第二块得到的内存块就应该为1014区间。如果你把第一块内存块释放，然后再申请一块大于10个单位的内存块，比如说20个单位。因为刚被释放的内存块不能满足新的请求，所以只能从15开始分配出20个单位的内存块。现在整个内存空间的状态是09空闲，1014被占用，1524被占用，2599空闲。其中09就是一个内存碎片了。如果1014一直被占用，而以后申请的空间都大于10个单位，那么09就永远用不上了，变成外部碎片</p>
<h3 id="内存的对齐"><a href="#内存的对齐" class="headerlink" title="内存的对齐"></a>内存的对齐</h3><p>看的我一脸懵逼 直接放别人的文章吧,以后慢慢参悟！</p>
<p><a href="https://songlee24.github.io/2014/09/20/memory-alignment/">C/C++内存对齐</a></p>
<h3 id="线程调度算法-什么是优先级反转？"><a href="#线程调度算法-什么是优先级反转？" class="headerlink" title="线程调度算法 什么是优先级反转？"></a>线程调度算法 什么是优先级反转？</h3><h4 id="线程调度算法"><a href="#线程调度算法" class="headerlink" title="线程调度算法"></a>线程调度算法</h4><h5 id="先到先服务算法"><a href="#先到先服务算法" class="headerlink" title="先到先服务算法"></a>先到先服务算法</h5><p>用一个FIFO（先进先出）队列就可以满足要求。所有的线程构成一个队列，最先进入队列的线程获得处理器执行权，等到放弃处理器执行权时，又回到队列尾部，下一个线程继续执行。若有新的线程进来，则添加到队列尾部。此算法简单，易于实现，但是，如果每个线程执行的任务单元所需要的时间长短不一的话，则算法的实际效果可能非常不公平。</p>
<h5 id="时间片轮转调度算法"><a href="#时间片轮转调度算法" class="headerlink" title="时间片轮转调度算法"></a>时间片轮转调度算法</h5><p>处理器的时间被分成了最大长度不超过某个值的时间片段，称为时间片，然后，用轮转方法分配给每一个线程。当一个线程获得了处理器执行权以后，按照自身的逻辑执行下去，直到时间片用完，或者自己主动放弃执行权（比如要等待一个信号量）。系统在获得了处理器控制权以后，用轮转方法找到下一个正在等待运行的线程，让它继续执行。这种线程调度方法实现简单，所有满足运行条件的线程排成一个队列，然后按照时间片的间隔，轮流让每一个线程获得处理器执行权。由于时钟中断每次都要打断一个线程的运行，所以，这种做法存在固有的线程切换开销，而时间片长短的选择会影响到线程切换开销所占的比例。在现代操作系统中，时间片通常设置为几毫秒到几十、上百毫秒。由于现代计算机的指令周期越来越短，线程切换开销（通常几百条指令或几千条指令，取决于算法实现的复杂程度）也在减小。这种算法使用很广泛，它不仅简单，也确实能公平地分配处理器资源。</p>
<h5 id="优先级调度算法。"><a href="#优先级调度算法。" class="headerlink" title="优先级调度算法。"></a>优先级调度算法。</h5><p>在时间片轮转算法中，一个基本的假设是所有的线程都同等重要。这一假设在专用计算机上可能是非常合理的，但是，在现代多用途的计算机上，可能难以胜任多种不同类型的应用程序并发执行的实际情形。优先级调度算法是这种算法的一个改进，其基本思路是，每个线程都有一个优先级值，高优先级的线程总是优先被考虑在处理器上执行。操作系统在管理线程时，可以使用一个优先级队列，或者每一个优先级用一个队列来存放所有满足执行条件的线程，这样，当一个线程用完了它的时间片或者自动放弃处理器执行权时，系统选择优先级最高的线程作为下一个要运行的线程。每一个线程在队列中的位置是由它的优先级来决定的。同等优先级的线程使用轮转或先到先执行的策略。</p>
<p>简单优先级算法的<code>潜在问题</code>是，高优先级的线程可能会霸占处理器资源不放，从而导致低优先级的线程一点执行机会都没有。所以，一些变种的优先级算法考虑引入动态优先级，即每个线程有静态的优先级和动态的优先级。所谓动态的优先级是在静态优先级的基础上根据某些特定的条件提升或降低线程的优先级，系统调度器根据线程的动态优先级来安排它们的执行顺序。例如，连续执行了多个时间片的线程可能要降低优先级，而长时间没有得到时间片的低优先级线程可能会得到优先级提升。</p>
<h4 id="优先级反转"><a href="#优先级反转" class="headerlink" title="优先级反转"></a>优先级反转</h4><p><a href="http://www.cnblogs.com/kuliuheng/p/4080997.html">多线程编程之优先级翻转问题</a></p>
<h4 id="OC的对象存在哪里-存的是那些东西？"><a href="#OC的对象存在哪里-存的是那些东西？" class="headerlink" title="OC的对象存在哪里 存的是那些东西？"></a>OC的对象存在哪里 存的是那些东西？</h4><p>OC的对象肯定是存放子啊堆中的！</p>
<p>存放的具体内容 应该是这个对象所属的类所具有的 例如</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_class</span> &#123;</span></span><br><span class="line">    Class _Nonnull isa  OBJC_ISA_AVAILABILITY;  <span class="comment">//isa指针指向类的元类(metaClass)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !__OBJC2__</span></span><br><span class="line">    Class _Nullable super_class                              OBJC2_UNAVAILABLE; <span class="comment">//父类</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> * _Nonnull name                               OBJC2_UNAVAILABLE; <span class="comment">//类名</span></span><br><span class="line">    <span class="keyword">long</span> version                                             OBJC2_UNAVAILABLE; <span class="comment">//类版本</span></span><br><span class="line">    <span class="keyword">long</span> info                                                OBJC2_UNAVAILABLE; <span class="comment">//类的信息</span></span><br><span class="line">    <span class="keyword">long</span> instance_size                                       OBJC2_UNAVAILABLE; <span class="comment">//类实例对象的大小</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">objc_ivar_list</span> * _<span class="title">Nullable</span> <span class="title">ivars</span>                  <span class="title">OBJC2_UNAVAILABLE</span>;</span> <span class="comment">//实例变量的列表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">objc_method_list</span> * _<span class="title">Nullable</span> * _<span class="title">Nullable</span> <span class="title">methodLists</span>                    <span class="title">OBJC2_UNAVAILABLE</span>;</span><span class="comment">//方法列表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">objc_cache</span> * _<span class="title">Nonnull</span> <span class="title">cache</span>                       <span class="title">OBJC2_UNAVAILABLE</span>;</span> <span class="comment">//方法的缓存</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">objc_protocol_list</span> * _<span class="title">Nullable</span> <span class="title">protocols</span>          <span class="title">OBJC2_UNAVAILABLE</span>;</span> <span class="comment">//协议列表</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">&#125; OBJC2_UNAVAILABLE;</span><br></pre></td></tr></table></figure>

<h3 id="父类和子类的内存是分配在一起的吗？-爷爷类-父类-子类-！"><a href="#父类和子类的内存是分配在一起的吗？-爷爷类-父类-子类-！" class="headerlink" title="父类和子类的内存是分配在一起的吗？ 爷爷类 父类 子类 ！"></a>父类和子类的内存是分配在一起的吗？ 爷爷类 父类 子类 ！</h3><p>创建一个对象的时候，发生了两件事情，一是分配对象所需的内存，二是调用构造函数进行初始化。子类对象包含从父类对象继承过来的成员，实现上来说，一般也是子类的内存区域中有一部分就是父类的内存区域。调用父类构造函数的时候，这块父类对象的内存区域就被初始化了。为了避免未初始化的问题，语法强制子类调用父类构造函数。</p>
<p>属性（包括父类）都保存在对象本身的存储空间内；本类的实例方法保存在类对象中，本类的类方法保存在元类对象中；父类的实例方法保存在各级 super class 中，父类的类方法保存在各级 super meta class 中。</p>
<p><img src="https://img-blog.csdn.net/20160513101728296" alt="对象内存"><br><img src="https://img-blog.csdn.net/20160513104920809" alt="类对象"></p>
<p>子类的对象的大小实际是包含着父类一直到根类的大小的集合。跟方法没有关系。每个类的方法(实例方法和类方法都是固定的) 跟实际的对象没关系！只跟类有关系</p>
<h3 id="调用方法的流程-对象方法和类方法"><a href="#调用方法的流程-对象方法和类方法" class="headerlink" title="调用方法的流程 对象方法和类方法"></a>调用方法的流程 对象方法和类方法</h3><p><img src="http://static.oschina.net/uploads/img/201311/25085218_epWy.png" alt="方法调用流程"></p>
<p>如果当前类(元类)没有找到对应的实例方法(类方法),那么就去他的父类(父类的元类)查找,如果一直到根类仍然无法找到这个方法，那么会抛出unrecognized selector sent to instance异常</p>
<p>如果想要阻止这次异常 可以使用运行时的方法进行补救！</p>
<p><img src="https://raw.githubusercontent.com/WiInputMethod/interview/master/img/ios-runtime-method-resolve.png" alt="运行时补救"></p>
<h3 id="元类是个什么东西-元类只是存放类方法吗？"><a href="#元类是个什么东西-元类只是存放类方法吗？" class="headerlink" title="元类是个什么东西 元类只是存放类方法吗？"></a>元类是个什么东西 元类只是存放类方法吗？</h3><p>类对象(class object)中包含了类的实例变量，实例方法的定义，而元类对象(metaclass object)中包括了类的类方法(也就是C++中的静态方法)的定义。类对象和元类对象中水果公司当然还会包含一些其它的东西，以后也可能添加其它的内容，但对于我们了解其内存布局来说，只需要记住：类对象存的是关于实例对象的信息(变量，实例方法等)，而元类对象(metaclass object)中存储的是关于类的信息(类的版本，名字，类方法等)。要注意的是，类对象(class object)和元类对象(metaclass object)的定义都是objc_class结构，其不同仅仅是在用途上，比如其中的方法列表在类对象(instance object)中保存的是实例方法(instance method)，而在元类对象(metaclass object)中则保存的是类方法(class method)。</p>
<p>15、为什么类方法和实例方法分开存？</p>
<ul>
<li>类方法不需要创建一个类的实例就可以调用！对象方法必须创建这个类的实例才可以调用</li>
<li>如果放在一起 可能存在重名的情况</li>
</ul>
<h3 id="谈谈Runloop"><a href="#谈谈Runloop" class="headerlink" title="谈谈Runloop"></a>谈谈Runloop</h3><p><a href="https://blog.ibireme.com/2015/05/18/runloop/">深入理解RunLoop</a><br><a href="https://hit-alibaba.github.io/interview/iOS/ObjC-Basic/Runloop.html">RunLoop</a></p>
<h3 id="runloop和线程是什么关系？-runloop和autoreleasepool是什么关系"><a href="#runloop和线程是什么关系？-runloop和autoreleasepool是什么关系" class="headerlink" title="runloop和线程是什么关系？ runloop和autoreleasepool是什么关系"></a>runloop和线程是什么关系？ runloop和autoreleasepool是什么关系</h3><h4 id="Runloop和线程"><a href="#Runloop和线程" class="headerlink" title="Runloop和线程"></a>Runloop和线程</h4><p>线程和 RunLoop 之间是一一对应的，其关系是保存在一个全局的 Dictionary 里。线程刚创建时并没有 RunLoop，如果你不主动获取，那它一直都不会有。RunLoop 的创建是发生在第一次获取时，RunLoop 的销毁是发生在线程结束时。你只能在一个线程的内部获取其 RunLoop（主线程除外）。</p>
<p>首先我们要明确一个概念，线程一般都是一次执行完任务，就销毁了。<br>而添加了runloop，并运行起来，实际上是添加了一个do,while循环，这样这个线程的程序一直卡在这个do,while循环上，这样相当于线程的任务一直没有执行完，所以线程一直不会销毁。</p>
<p>所以，一旦我们添加了一个runloop，并run了，我们如果要销毁这个线程，必须停止runloop</p>
<h4 id="Runloop和-autoreleasepool"><a href="#Runloop和-autoreleasepool" class="headerlink" title="Runloop和 autoreleasepool"></a>Runloop和 autoreleasepool</h4><p>App启动后，苹果在主线程 RunLoop 里注册了两个 Observer，其回调都是 _wrapRunLoopWithAutoreleasePoolHandler()。</p>
<p>第一个 Observer 监视的事件是 Entry(即将进入Loop)，其回调内会调用 _objc_autoreleasePoolPush() 创建自动释放池。其 order 是-2147483647，优先级最高，保证创建释放池发生在其他所有回调之前。</p>
<p>第二个 Observer 监视了两个事件： BeforeWaiting(准备进入休眠) 时调用_objc_autoreleasePoolPop() 和 _objc_autoreleasePoolPush() 释放旧的池并创建新池；Exit(即将退出Loop) 时调用 _objc_autoreleasePoolPop() 来释放自动释放池。这个 Observer 的 order 是 2147483647，优先级最低，保证其释放池子发生在其他所有回调之后。</p>
<p>在主线程执行的代码，通常是写在诸如事件回调、Timer回调内的。这些回调会被 RunLoop 创建好的 AutoreleasePool 环绕着，所以不会出现内存泄漏，开发者也不必显示创建 Pool 了</p>
<h3 id="一个runloop中可以有多个autoreleasepool吗？"><a href="#一个runloop中可以有多个autoreleasepool吗？" class="headerlink" title="一个runloop中可以有多个autoreleasepool吗？"></a>一个runloop中可以有多个autoreleasepool吗？</h3><pre><code>可以,这个不多说!</code></pre>
<h3 id="如何拿到一个runloop的所有状态"><a href="#如何拿到一个runloop的所有状态" class="headerlink" title="如何拿到一个runloop的所有状态"></a>如何拿到一个runloop的所有状态</h3><p>CFRunLoopObserverRef是观察者，能够监听RunLoop的状态改变</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;创建一个runloop监听者</span><br><span class="line"></span><br><span class="line">    CFRunLoopObserverRef observer &#x3D; CFRunLoopObserverCreateWithHandler(CFAllocatorGetDefault(),kCFRunLoopAllActivities, YES, 0, ^(CFRunLoopObserverRef observer, CFRunLoopActivity activity) &#123;</span><br><span class="line"></span><br><span class="line">        NSLog(@&quot;监听runloop状态改变---%zd&quot;,activity);</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;为runloop添加一个监听者</span><br><span class="line"></span><br><span class="line">    CFRunLoopAddObserver(CFRunLoopGetCurrent(), observer, kCFRunLoopDefaultMode);</span><br><span class="line"></span><br><span class="line">    CFRelease(observer);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>监听的状态:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123;</span><br><span class="line"></span><br><span class="line">    kCFRunLoopEntry &#x3D; (1UL &lt;&lt; 0),   &#x2F;&#x2F;即将进入Runloop</span><br><span class="line"></span><br><span class="line">    kCFRunLoopBeforeTimers &#x3D; (1UL &lt;&lt; 1),    &#x2F;&#x2F;即将处理NSTimer</span><br><span class="line"></span><br><span class="line">    kCFRunLoopBeforeSources &#x3D; (1UL &lt;&lt; 2),   &#x2F;&#x2F;即将处理Sources</span><br><span class="line"></span><br><span class="line">    kCFRunLoopBeforeWaiting &#x3D; (1UL &lt;&lt; 5),   &#x2F;&#x2F;即将进入休眠</span><br><span class="line"></span><br><span class="line">    kCFRunLoopAfterWaiting &#x3D; (1UL &lt;&lt; 6),    &#x2F;&#x2F;刚从休眠中唤醒</span><br><span class="line"></span><br><span class="line">    kCFRunLoopExit &#x3D; (1UL &lt;&lt; 7),            &#x2F;&#x2F;即将退出runloop</span><br><span class="line"></span><br><span class="line">    kCFRunLoopAllActivities &#x3D; 0x0FFFFFFFU   &#x2F;&#x2F;所有状态改变</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="NSTimer是准确的timer吗？为什么？"><a href="#NSTimer是准确的timer吗？为什么？" class="headerlink" title="NSTimer是准确的timer吗？为什么？"></a>NSTimer是准确的timer吗？为什么？</h3><p>NSTimer不是准确的timer 其所在的 RunLoop 会定时检测是否可以触发 NSTimer 的事件，但由于 iOS 有多个 RunLoop 的运行模式，如果被切到另一个 run loop，NSTimer 就不会被触发。每个 RunLoop 的循环间隔也无法保证，当某个任务耗时比较久，RunLoop 的下一个消息处理就只能顺延，导致 NSTimer 的时间已经到达，但 Runloop 却无法及时触发 NSTimer，导致该时间点的回调被错过。</p>
<p>苹果官方文档：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A timer is not a real-time mechanism; it fires only when one of the run loop modes to which the timer has been added is running and able to check if the timer’s firing time has passed. If a timer’s firing time occurs during a long callout or while the run loop is in a mode that is not monitoring the timer, the timer does not fire until the next time the run loop checks the timer.</span><br></pre></td></tr></table></figure>

<h4 id="其他更准确的Timer"><a href="#其他更准确的Timer" class="headerlink" title="其他更准确的Timer"></a>其他更准确的Timer</h4><h5 id="CADisplayLink"><a href="#CADisplayLink" class="headerlink" title="CADisplayLink"></a>CADisplayLink</h5><p>CADisplayLink是一个频率能达到屏幕刷新率的定时器类。iPhone屏幕刷新频率为60帧/秒，也就是说最小间隔可以达到1/60s。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CADisplayLink * displayLink &#x3D; [CADisplayLink displayLinkWithTarget:self selector:@selector(logInfo)];</span><br><span class="line">[displayLink addToRunLoop:[NSRunLoop currentRunLoop] forMode:NSDefaultRunLoopMode];</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="GCD定时器"><a href="#GCD定时器" class="headerlink" title="GCD定时器"></a>GCD定时器</h5><p>我们知道，RunLoop是dispatch_source_t实现的timer，所以理论上来说，GCD定时器的精度比NSTimer只高不低。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSTimeInterval interval &#x3D; 1.0;</span><br><span class="line">_timer &#x3D; dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0));</span><br><span class="line">dispatch_source_set_timer(_timer, dispatch_walltime(NULL, 0), interval * NSEC_PER_SEC, 0);</span><br><span class="line">dispatch_source_set_event_handler(_timer, ^&#123;</span><br><span class="line">    NSLog(@&quot;GCD timer test&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_resume(_timer);</span><br></pre></td></tr></table></figure>

<h5 id="mach-absolute-time"><a href="#mach-absolute-time" class="headerlink" title="mach_absolute_time"></a>mach_absolute_time</h5><p>使用mach_absolute_time()来实现更高精度的定时器。<br>iPhone上有这么一个均匀变化的东西来提供给我们作为时间参考，就是CPU的时钟周期数（ticks）。<br>通过mach_absolute_time()获取CPU已运行的tick数量。将tick数经过转换变成秒或者纳秒，从而实现时间的计算。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;mach&#x2F;mach.h&gt;</span><br><span class="line">#include &lt;mach&#x2F;mach_time.h&gt;</span><br><span class="line"> </span><br><span class="line">static const uint64_t NANOS_PER_USEC &#x3D; 1000ULL;</span><br><span class="line">static const uint64_t NANOS_PER_MILLISEC &#x3D; 1000ULL * NANOS_PER_USEC;</span><br><span class="line">static const uint64_t NANOS_PER_SEC &#x3D; 1000ULL * NANOS_PER_MILLISEC;</span><br><span class="line"> </span><br><span class="line">static mach_timebase_info_data_t timebase_info;</span><br><span class="line"></span><br><span class="line">static uint64_t nanos_to_abs(uint64_t nanos) &#123;</span><br><span class="line">    return nanos * timebase_info.denom &#x2F; timebase_info.numer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void waitSeconds(int seconds) &#123;</span><br><span class="line">    mach_timebase_info(&amp;timebase_info);</span><br><span class="line">    uint64_t time_to_wait &#x3D; nanos_to_abs(seconds * NANOS_PER_SEC);</span><br><span class="line">    uint64_t now &#x3D; mach_absolute_time();</span><br><span class="line">    mach_wait_until(now + time_to_wait);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>理论上这是iPhone上最精准的定时器，可以达到纳秒级别的精度</code></p>
<p>21、performselector在一个子线程执行,是会自动执行的吗？</p>
<p>performSelector原理是：设置一个timer，添加到当前线程Runloop，默认是NSDefaultRunLoopMode；通过NSTimer的 scheduledTimerWithTimeIntervaly创建的定时器，也是自动被添加到当前RunLoop中，默认是NSDefaultRunLoopMode；</p>
<p>在子线程中，因为默认没有RunLoop，所以他们不执行；想要执行，需要创建并启动Runloop</p>
<p>手动开启：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)viewDidLoad</span><br><span class="line">&#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    [self threadInfo:@&quot;UI&quot;];</span><br><span class="line">    </span><br><span class="line">    _isNewThreadAborted &#x3D; NO;</span><br><span class="line">    _thread &#x3D; [[NSThread alloc] initWithTarget:self selector:@selector(newThread:) object:nil];</span><br><span class="line">    &#x2F;&#x2F;开始线程</span><br><span class="line">    [_thread start];</span><br><span class="line">    &#x2F;&#x2F;在另一个线程中的Run Loop中执行Selector</span><br><span class="line">    [self performSelector:@selector(test:) onThread:_thread withObject:nil waitUntilDone:NO];    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;在新线程中创建并开始一个NSRunLoop</span><br><span class="line">- (void)newThread:(id)obj</span><br><span class="line">&#123;</span><br><span class="line">    @autoreleasepool</span><br><span class="line">    &#123;</span><br><span class="line">        NSRunLoop *currentRunLoop &#x3D; [NSRunLoop currentRunLoop];</span><br><span class="line">        while (!_isNewThreadAborted)</span><br><span class="line">        &#123;</span><br><span class="line">            [currentRunLoop runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]];</span><br><span class="line">        &#125;</span><br><span class="line">        NSLog(@&quot;线程停止&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Selector执行</span><br><span class="line">- (void)test:(id)obj</span><br><span class="line">&#123;</span><br><span class="line">    [self threadInfo:@&quot;test&quot;];</span><br><span class="line">    _isNewThreadAborted &#x3D; YES;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)threadInfo:(NSString*)category</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;%@ - %@&quot;, category, [NSThread currentThread]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="GCD-队列和线程是什么关系？"><a href="#GCD-队列和线程是什么关系？" class="headerlink" title="GCD 队列和线程是什么关系？"></a>GCD 队列和线程是什么关系？</h3><h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><ul>
<li>主队列</li>
<li>串行队列</li>
<li>并发队列</li>
<li>全局队列</li>
</ul>
<h4 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h4><ul>
<li>同步执行</li>
<li>异步执行 </li>
</ul>
<h4 id="交叉出现的情况"><a href="#交叉出现的情况" class="headerlink" title="交叉出现的情况"></a>交叉出现的情况</h4><h5 id="串行队列，同步执行"><a href="#串行队列，同步执行" class="headerlink" title="串行队列，同步执行"></a>串行队列，同步执行</h5><p>不会开线程，顺序执行</p>
<h5 id="串行队列，异步执行"><a href="#串行队列，异步执行" class="headerlink" title="串行队列，异步执行"></a>串行队列，异步执行</h5><p>会开线程(1条)，顺序执行</p>
<h5 id="并发队列，异步执行"><a href="#并发队列，异步执行" class="headerlink" title="并发队列，异步执行"></a>并发队列，异步执行</h5><p>会开线程，不会顺序执行，具体开几条线程取决于队列</p>
<h5 id="并发队列，同步执行"><a href="#并发队列，同步执行" class="headerlink" title="并发队列，同步执行"></a>并发队列，同步执行</h5><p>和串行队列同步执行效果一样</p>
<h5 id="主队列，异步执行"><a href="#主队列，异步执行" class="headerlink" title="主队列，异步执行"></a>主队列，异步执行</h5><p>不开线程，异步任务必须等待主线程上的任务完成之后才会被调用</p>
<h5 id="主队列、同步执行"><a href="#主队列、同步执行" class="headerlink" title="主队列、同步执行"></a>主队列、同步执行</h5><p>会发生死锁，因为，同步任务要求必须顺序执行，但是同步任务必须等待主队列中没有任务可以被调用的时候才会被执行，因此这两方会造成死锁的情况</p>
<h5 id="同步任务的特点"><a href="#同步任务的特点" class="headerlink" title="同步任务的特点"></a>同步任务的特点</h5><p>可以再多个异步任务调度前，指定一个同步任务，让所有的异步任务，等待同步任务执行完成，这就是所谓的依赖关系</p>
<h5 id="全局队列"><a href="#全局队列" class="headerlink" title="全局队列"></a>全局队列</h5><p>系统提供给程序员，方便程序员使用的全局队列，有关服务质量的问题，使用下面的代码能够做到IOS7&amp;IOS8的适配，全局队列本质上就是一个异步队列</p>
<h3 id="一个队列可以管理多少线程？"><a href="#一个队列可以管理多少线程？" class="headerlink" title="一个队列可以管理多少线程？"></a>一个队列可以管理多少线程？</h3><p>并发队列可以分配多个线程，同时处理不同的任务；效率虽然提升了，但是多线程的并发是用时间片轮转方法实现的，线程创建、销毁、上下文切换等会消耗CPU 资源。</p>
<p>目前iPhone的处理器是多核（2个、4个），适当的并发可以提高效率，但是无节制地并发，如将大量任务不加思索就用并发队列来执行，这只会大量增加线程数，抢占CPU资源，甚至会挤占掉主线程的 CPU 资源（极端情况）。</p>
<p>可以使用 NSOperationQueue 设置maxConcurrentOperationCount 最大并发数</p>
<h4 id="串行队列中的所有任务都会在一条线程中执行吗"><a href="#串行队列中的所有任务都会在一条线程中执行吗" class="headerlink" title="串行队列中的所有任务都会在一条线程中执行吗"></a>串行队列中的所有任务都会在一条线程中执行吗</h4><pre><code>串行队列中的任务不会开多条线程,回一个一个执行,但是每一个任务所在的线程不一定是一个,但同时只会存在一条线程</code></pre>
<h3 id="白板画线-如何在点之间连线-用什么去重绘的"><a href="#白板画线-如何在点之间连线-用什么去重绘的" class="headerlink" title="白板画线(如何在点之间连线)  用什么去重绘的"></a>白板画线(如何在点之间连线)  用什么去重绘的</h3><p>利用贝塞尔曲线</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">-(<span class="built_in">UIBezierPath</span>*)drawSigleLine:(<span class="built_in">NSArray</span>*)line needStroke:(<span class="built_in">BOOL</span>)needStroke</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSUInteger</span> pointsCount = line.count;</span><br><span class="line">    </span><br><span class="line">    ArtWhiteBoardPoint *firstPoint = [line objectAtIndex:<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">UIBezierPath</span> *path = [[<span class="built_in">UIBezierPath</span> alloc] init];</span><br><span class="line">    path.lineWidth = [<span class="keyword">self</span> getDrawWidth:firstPoint.penStyle.lineWidth];</span><br><span class="line">    path.lineJoinStyle = kCGLineJoinRound;</span><br><span class="line">    path.lineCapStyle = kCGLineCapRound;</span><br><span class="line">    <span class="built_in">UIColor</span> *lineColor;</span><br><span class="line">    <span class="keyword">if</span> (firstPoint.penStyle.isEarser) &#123;</span><br><span class="line">        lineColor = [<span class="built_in">UIColor</span> clearColor];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        lineColor = [<span class="built_in">UIColor</span> colorWithHexString:firstPoint.penStyle.colorString alpha:<span class="number">1.0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (lineColor == [<span class="built_in">UIColor</span> clearColor]) &#123;</span><br><span class="line">        path.lineCapStyle = kCGLineCapSquare;</span><br><span class="line">        path.lineWidth = [<span class="keyword">self</span> getDrawWidth:[<span class="keyword">self</span>.dataSource earserWidth:firstPoint.penStyle.isLargeEarser]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> j = <span class="number">0</span> ; j &lt; pointsCount; j ++) &#123;</span><br><span class="line">        ArtWhiteBoardPoint *point = [line objectAtIndex:j];</span><br><span class="line">        <span class="built_in">CGPoint</span> p;</span><br><span class="line">        p = <span class="built_in">CGPointMake</span>(point.xScale * <span class="keyword">self</span>.frame.size.width ,  point.yScale * <span class="keyword">self</span>.frame.size.height);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">0</span>) &#123;</span><br><span class="line">            [path moveToPoint:p];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">self</span>.controlP1.x==p.x&amp;&amp;<span class="keyword">self</span>.controlP1.y==p.y) &#123;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                [path addQuadCurveToPoint:<span class="built_in">CGPointMake</span>((<span class="keyword">self</span>.controlP1.x+p.x)/<span class="number">2</span>, (<span class="keyword">self</span>.controlP1.y+p.y)/<span class="number">2</span>) controlPoint:<span class="keyword">self</span>.controlP1];</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">self</span>.controlP1 = p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (needStroke) &#123;</span><br><span class="line">        [lineColor setStroke];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (lineColor == [<span class="built_in">UIColor</span> clearColor]) &#123;</span><br><span class="line">            [path strokeWithBlendMode:kCGBlendModeCopy alpha:<span class="number">1.0</span>];</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            [path strokeWithBlendMode:kCGBlendModeNormal alpha:<span class="number">1.0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> path;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://cloud.tencent.com/developer/article/1018499">iOS开发之画图板(贝塞尔曲线)</a></p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://hit-alibaba.github.io/interview/basic/algo/Hash-Table.html">面试基础-哈希表</a></p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>数据结果 算法 计算机基础</tag>
      </tags>
  </entry>
  <entry>
    <title>滚动视图的ReloadData和VisibleCells</title>
    <url>/2019/10/20/reloadDataandvisibleCells/</url>
    <content><![CDATA[<p>作为<code>UIScrollView</code>的子类<code>UITableView</code>和<code>UICollectionView</code>是我们平时开发中最常使用的两个列表控件。同时在一些复杂的页面中也经常嵌套使用,同时由于对其有些方法理解的不够深入,很容易导致一些比较诡异的问题。</p>
<p>因此这里单独写一篇文章来介绍这两个常用控件中的几个常用的方法,希望可以加深大家对<code>UITableView</code>和<code>UICollectionView</code>的理解。</p>
<a id="more"></a>

<h3 id="数据刷新-reloadData"><a href="#数据刷新-reloadData" class="headerlink" title="数据刷新 reloadData"></a>数据刷新 reloadData</h3><p><code>为了更好的理解方法的调用链,我们会添加一个队runloop的监听</code></p>
<h4 id="UITableView"><a href="#UITableView" class="headerlink" title="UITableView"></a>UITableView</h4><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g83s1tlrh1j30ak0kjaag.jpg" alt="demo"></p>
<p>上图是我们demo的样子(只有一个cell)。</p>
<p>下面我们来看代码:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)reloadTableData &#123;</span><br><span class="line"> </span><br><span class="line">    [<span class="keyword">self</span>.tableView reloadData];</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;reloadData 执行完成&quot;</span>);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>点击Demo中左上角的reloadData会调用reloadTableData方法。</p>
<p>下面我们来看控制台打印结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2019-10-08 19:32:21.875441+0800 LayoutIfNeed[3662:223502] RunLoop被唤醒</span><br><span class="line"> </span><br><span class="line">2019-10-08 19:32:21.876164+0800 LayoutIfNeed[3662:223502] RunLoop即将处理Timer事件</span><br><span class="line"> </span><br><span class="line">2019-10-08 19:32:21.876295+0800 LayoutIfNeed[3662:223502] RunLoop即将处理Source事件</span><br><span class="line"> </span><br><span class="line">2019-10-08 19:32:21.877622+0800 LayoutIfNeed[3662:223502] -[ULTableView reloadData]</span><br><span class="line"> </span><br><span class="line">2019-10-08 19:32:21.880310+0800 LayoutIfNeed[3662:223502] -[ViewController numberOfSectionsInTableView:]</span><br><span class="line"> </span><br><span class="line">2019-10-08 19:32:21.880779+0800 LayoutIfNeed[3662:223502] -[ULTableView setNeedsLayout]</span><br><span class="line"> </span><br><span class="line">2019-10-08 19:32:21.881075+0800 LayoutIfNeed[3662:223502] -[ViewController tableView:numberOfRowsInSection:]</span><br><span class="line"> </span><br><span class="line">2019-10-08 19:32:21.881755+0800 LayoutIfNeed[3662:223502] -[ULTableView setNeedsLayout]</span><br><span class="line"> </span><br><span class="line">2019-10-08 19:32:21.881921+0800 LayoutIfNeed[3662:223502] -[ULTableView setNeedsLayout]</span><br><span class="line"> </span><br><span class="line">2019-10-08 19:32:21.882095+0800 LayoutIfNeed[3662:223502] -[ULTableView setNeedsLayout]</span><br><span class="line"> </span><br><span class="line">2019-10-08 19:32:21.882227+0800 LayoutIfNeed[3662:223502] reloadData 执行完成</span><br><span class="line"> </span><br><span class="line">2019-10-08 19:32:21.883112+0800 LayoutIfNeed[3662:223502] RunLoop即将处理Timer事件</span><br><span class="line"> </span><br><span class="line">2019-10-08 19:32:21.883582+0800 LayoutIfNeed[3662:223502] RunLoop即将处理Source事件</span><br><span class="line"> </span><br><span class="line">2019-10-08 19:32:21.906191+0800 LayoutIfNeed[3662:223502] RunLoop即将休眠</span><br><span class="line"> </span><br><span class="line">2019-10-08 19:32:21.907129+0800 LayoutIfNeed[3662:223502] -[ULTableView layoutSubviews]</span><br><span class="line"> </span><br><span class="line">2019-10-08 19:32:21.907349+0800 LayoutIfNeed[3662:223502] -[ULTableView dequeueReusableCellWithIdentifier:]</span><br><span class="line"> </span><br><span class="line">2019-10-08 19:32:21.908622+0800 LayoutIfNeed[3662:223502] -[ViewController tableView:cellForRowAtIndexPath:] 0 0</span><br><span class="line"> </span><br><span class="line">2019-10-08 19:32:21.909076+0800 LayoutIfNeed[3662:223502] -[ViewController tableView:heightForRowAtIndexPath:]</span><br><span class="line"> </span><br><span class="line">2019-10-08 19:32:21.909236+0800 LayoutIfNeed[3662:223502] -[ULTableView setNeedsLayout]</span><br><span class="line"> </span><br><span class="line">2019-10-08 19:32:21.909670+0800 LayoutIfNeed[3662:223502] -[ULTableView setNeedsLayout]</span><br><span class="line"> </span><br><span class="line">2019-10-08 19:32:21.909991+0800 LayoutIfNeed[3662:223502] -[ULTableView layoutSubviews]</span><br></pre></td></tr></table></figure>

<p>首先看到了我们比较熟悉的方法<code>numberOfSectionsInTableView</code>、<code>dequeueReusableCellWithIdentifier</code>、<code>tableView:heightForRowAtIndexPath:</code>、<code>tableView:cellForRowAtIndexPath:</code></p>
<p>这些方法都是我们比较熟悉的方法了,这里我就不再赘述。</p>
<p>其次根据log我们可以比较清晰的的出另外一个结论：<br><code>reloadData是一个异步方法,reloadData在当前的Runloop中只是做了setNeedsLayout(表示当前view在下一个runloop到来时需要被更新),显然当前Runloop结束后才根据之前设置setNeedsLayout的标记执行layoutSubviews方法进而触发页面的更新</code></p>
<h4 id="UICollectionView"><a href="#UICollectionView" class="headerlink" title="UICollectionView"></a>UICollectionView</h4><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g83un68eevj30l4152q4f.jpg" alt="demo"></p>
<p>上图是我们demo的样子(只展示了一个cell)。</p>
<p>下面我们在来看下代码：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)reloadCollectionViewData &#123;</span><br><span class="line">    [<span class="keyword">self</span>.collectionView reloadData];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;reloadData 执行完成&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>点击demo的左上角按钮即调用reloadData方法<br>下面看下打印结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2019-10-19 21:50:36.219755+0800 LayoutIfNeed[4002:2375227] RunLoop被唤醒</span><br><span class="line">2019-10-19 21:50:36.220045+0800 LayoutIfNeed[4002:2375227] RunLoop即将处理Timer事件</span><br><span class="line">2019-10-19 21:50:36.220326+0800 LayoutIfNeed[4002:2375227] RunLoop即将处理Source事件</span><br><span class="line">2019-10-19 21:50:36.221302+0800 LayoutIfNeed[4002:2375227] -[ULCollectionView reloadData]</span><br><span class="line">2019-10-19 21:50:36.221610+0800 LayoutIfNeed[4002:2375227] -[ULCollectionView setNeedsLayout]</span><br><span class="line">2019-10-19 21:50:36.221826+0800 LayoutIfNeed[4002:2375227] -[ULCollectionView setNeedsLayout]</span><br><span class="line">2019-10-19 21:50:36.221993+0800 LayoutIfNeed[4002:2375227] -[ULCollectionView setNeedsLayout]</span><br><span class="line">2019-10-19 21:50:36.222109+0800 LayoutIfNeed[4002:2375227] -[ULCollectionView setNeedsLayout]</span><br><span class="line">2019-10-19 21:50:36.222532+0800 LayoutIfNeed[4002:2375227] -[ULCollectionView setNeedsLayout]</span><br><span class="line">2019-10-19 21:50:36.222939+0800 LayoutIfNeed[4002:2375227] reloadData 执行完成</span><br><span class="line">2019-10-19 21:50:36.223924+0800 LayoutIfNeed[4002:2375227] RunLoop即将处理Timer事件</span><br><span class="line">2019-10-19 21:50:36.224480+0800 LayoutIfNeed[4002:2375227] RunLoop即将处理Source事件</span><br><span class="line">2019-10-19 21:50:36.225190+0800 LayoutIfNeed[4002:2375227] RunLoop即将休眠</span><br><span class="line">2019-10-19 21:50:36.226107+0800 LayoutIfNeed[4002:2375227] -[ULCollectionView layoutSubviews]</span><br><span class="line">2019-10-19 21:50:36.226609+0800 LayoutIfNeed[4002:2375227] -[ULCollectionViewController numberOfSectionsInCollectionView:]</span><br><span class="line">2019-10-19 21:50:36.226864+0800 LayoutIfNeed[4002:2375227] -[ULCollectionViewController collectionView:numberOfItemsInSection:]</span><br><span class="line">2019-10-19 21:50:36.323486+0800 LayoutIfNeed[4002:2375227] -[ULCollectionView dequeueReusableCellWithReuseIdentifier:forIndexPath:]</span><br><span class="line">2019-10-19 21:50:36.324053+0800 LayoutIfNeed[4002:2375227] -[ULCollectionViewController collectionView:cellForItemAtIndexPath:]</span><br></pre></td></tr></table></figure>
<p>从log中我们看出<code>UICollectionView</code>与<code>UITableView</code>的效果一致。因此其结论与<code>UITableView</code>也是一致。</p>
<h4 id="tableView中嵌套collectionView"><a href="#tableView中嵌套collectionView" class="headerlink" title="tableView中嵌套collectionView"></a>tableView中嵌套collectionView</h4><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g83yoeib27j30l4152gn7.jpg" alt="demo"></p>
<p>demo中tableView含两个cell 第一个cell上add一个collectionView,第二个cell为一个tableViewCell</p>
<p>点击右上角<code>reloadTableData</code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)reloadTableData &#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">    [self.tableView reloadData];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>log:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2019-10-20 08:45:10.415969+0800 LayoutIfNeed[5741:2466905] UIInnerCollectionView RunLoop即将处理Source事件</span><br><span class="line">2019-10-20 08:45:10.417080+0800 LayoutIfNeed[5741:2466905] -[TableCollectionViewController reloadTableData]</span><br><span class="line">2019-10-20 08:45:10.417207+0800 LayoutIfNeed[5741:2466905] -[ULTableView reloadData]</span><br><span class="line">2019-10-20 08:45:10.417477+0800 LayoutIfNeed[5741:2466905] -[TableCollectionViewController numberOfSectionsInTableView:]</span><br><span class="line">2019-10-20 08:45:10.417632+0800 LayoutIfNeed[5741:2466905] -[ULTableView setNeedsLayout]</span><br><span class="line">2019-10-20 08:45:10.418072+0800 LayoutIfNeed[5741:2466905] -[TableCollectionViewController tableView:numberOfRowsInSection:]</span><br><span class="line">2019-10-20 08:45:10.418353+0800 LayoutIfNeed[5741:2466905] -[ULTableView setNeedsLayout]</span><br><span class="line">2019-10-20 08:45:10.418493+0800 LayoutIfNeed[5741:2466905] -[ULTableView setNeedsLayout]</span><br><span class="line">2019-10-20 08:45:10.418716+0800 LayoutIfNeed[5741:2466905] -[ULTableView setNeedsLayout]</span><br><span class="line">2019-10-20 08:45:10.419573+0800 LayoutIfNeed[5741:2466905] TableCollectionViewController RunLoop即将处理Timer事件</span><br><span class="line">2019-10-20 08:45:10.419701+0800 LayoutIfNeed[5741:2466905] UIInnerCollectionView RunLoop即将处理Timer事件</span><br><span class="line">2019-10-20 08:45:10.419813+0800 LayoutIfNeed[5741:2466905] TableCollectionViewController RunLoop即将处理Source事件</span><br><span class="line">2019-10-20 08:45:10.420023+0800 LayoutIfNeed[5741:2466905] UIInnerCollectionView RunLoop即将处理Source事件</span><br><span class="line">2019-10-20 08:45:10.420644+0800 LayoutIfNeed[5741:2466905] TableCollectionViewController RunLoop即将休眠</span><br><span class="line">2019-10-20 08:45:10.420774+0800 LayoutIfNeed[5741:2466905] UIInnerCollectionView RunLoop即将休眠</span><br><span class="line">2019-10-20 08:45:10.421129+0800 LayoutIfNeed[5741:2466905] -[ULTableView layoutSubviews]</span><br><span class="line">2019-10-20 08:45:10.421393+0800 LayoutIfNeed[5741:2466905] -[ULTableView dequeueReusableCellWithIdentifier:]</span><br><span class="line">2019-10-20 08:45:10.421851+0800 LayoutIfNeed[5741:2466905] -[TableCollectionViewController tableView:cellForRowAtIndexPath:] 0 0</span><br><span class="line">2019-10-20 08:45:10.422269+0800 LayoutIfNeed[5741:2466905] -[ULCollectionView reloadData]</span><br><span class="line">2019-10-20 08:45:10.422648+0800 LayoutIfNeed[5741:2466905] -[ULCollectionView setNeedsLayout]</span><br><span class="line">2019-10-20 08:45:10.423020+0800 LayoutIfNeed[5741:2466905] -[ULCollectionView setNeedsLayout]</span><br><span class="line">2019-10-20 08:45:10.423360+0800 LayoutIfNeed[5741:2466905] -[ULCollectionView setNeedsLayout]</span><br><span class="line">2019-10-20 08:45:10.423758+0800 LayoutIfNeed[5741:2466905] -[ULCollectionView setNeedsLayout]</span><br><span class="line">2019-10-20 08:45:10.424125+0800 LayoutIfNeed[5741:2466905] -[ULCollectionView setNeedsLayout]</span><br><span class="line">2019-10-20 08:45:10.424765+0800 LayoutIfNeed[5741:2466905] -[TableCollectionViewController tableView:heightForRowAtIndexPath:]</span><br><span class="line">2019-10-20 08:45:10.424898+0800 LayoutIfNeed[5741:2466905] -[ULTableView setNeedsLayout]</span><br><span class="line">2019-10-20 08:45:10.425206+0800 LayoutIfNeed[5741:2466905] -[ULCollectionView layoutSubviews]</span><br><span class="line">2019-10-20 08:45:10.425470+0800 LayoutIfNeed[5741:2466905] -[UIInnerCollectionView numberOfSectionsInCollectionView:]</span><br><span class="line">2019-10-20 08:45:10.425776+0800 LayoutIfNeed[5741:2466905] -[UIInnerCollectionView collectionView:numberOfItemsInSection:]</span><br><span class="line">2019-10-20 08:45:10.427618+0800 LayoutIfNeed[5741:2466905] -[ULCollectionView dequeueReusableCellWithReuseIdentifier:forIndexPath:]</span><br><span class="line">2019-10-20 08:45:10.427884+0800 LayoutIfNeed[5741:2466905] -[UIInnerCollectionView collectionView:cellForItemAtIndexPath:]</span><br><span class="line">2019-10-20 08:45:10.428257+0800 LayoutIfNeed[5741:2466905] -[ULTableView dequeueReusableCellWithIdentifier:]</span><br><span class="line">2019-10-20 08:45:10.428505+0800 LayoutIfNeed[5741:2466905] -[TableCollectionViewController tableView:cellForRowAtIndexPath:] 0 1</span><br><span class="line">2019-10-20 08:45:10.429038+0800 LayoutIfNeed[5741:2466905] -[TableCollectionViewController tableView:heightForRowAtIndexPath:]</span><br><span class="line">2019-10-20 08:45:10.429178+0800 LayoutIfNeed[5741:2466905] -[ULTableView setNeedsLayout]</span><br><span class="line">2019-10-20 08:45:10.429590+0800 LayoutIfNeed[5741:2466905] -[ULTableView setNeedsLayout]</span><br><span class="line">2019-10-20 08:45:10.429988+0800 LayoutIfNeed[5741:2466905] -[ULTableView layoutSubviews]</span><br></pre></td></tr></table></figure>

<p>根据上面的log我们看到UITableView在执行reloadData之后仍让只是做了标记。在下一个runloop到来之后触发<code>UITableView</code>的<code>layoutSubviews</code>方法进而又触发该Cell中UICollectionView的reloadData操作</p>
<p>如果我们不主动的调用reloadData呢？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2019-10-20 09:05:20.372536+0800 LayoutIfNeed[5867:2475442] -[TableCollectionViewController reloadTableData]</span><br><span class="line">2019-10-20 09:05:40.060940+0800 LayoutIfNeed[5867:2475442] -[ULTableView reloadData]</span><br><span class="line">2019-10-20 09:05:40.061223+0800 LayoutIfNeed[5867:2475442] -[TableCollectionViewController numberOfSectionsInTableView:]</span><br><span class="line">2019-10-20 09:05:40.061361+0800 LayoutIfNeed[5867:2475442] -[ULTableView setNeedsLayout]</span><br><span class="line">2019-10-20 09:05:40.061539+0800 LayoutIfNeed[5867:2475442] -[TableCollectionViewController tableView:numberOfRowsInSection:]</span><br><span class="line">2019-10-20 09:05:40.061691+0800 LayoutIfNeed[5867:2475442] -[ULTableView setNeedsLayout]</span><br><span class="line">2019-10-20 09:05:40.061812+0800 LayoutIfNeed[5867:2475442] -[ULTableView setNeedsLayout]</span><br><span class="line">2019-10-20 09:05:40.061950+0800 LayoutIfNeed[5867:2475442] -[ULTableView setNeedsLayout]</span><br><span class="line">2019-10-20 09:05:40.062454+0800 LayoutIfNeed[5867:2475442] -[ULTableView layoutSubviews]</span><br><span class="line">2019-10-20 09:05:40.062653+0800 LayoutIfNeed[5867:2475442] -[ULTableView dequeueReusableCellWithIdentifier:]</span><br><span class="line">2019-10-20 09:05:40.062829+0800 LayoutIfNeed[5867:2475442] -[TableCollectionViewController tableView:cellForRowAtIndexPath:] 0 0</span><br><span class="line">2019-10-20 09:06:08.551189+0800 LayoutIfNeed[5867:2475442] -[TableCollectionViewController tableView:heightForRowAtIndexPath:]</span><br><span class="line">2019-10-20 09:06:08.551448+0800 LayoutIfNeed[5867:2475442] -[ULTableView setNeedsLayout]</span><br><span class="line">2019-10-20 09:06:08.551836+0800 LayoutIfNeed[5867:2475442] -[ULTableView dequeueReusableCellWithIdentifier:]</span><br><span class="line">2019-10-20 09:06:08.552087+0800 LayoutIfNeed[5867:2475442] -[TableCollectionViewController tableView:cellForRowAtIndexPath:] 0 1</span><br><span class="line">2019-10-20 09:06:08.552490+0800 LayoutIfNeed[5867:2475442] -[TableCollectionViewController tableView:heightForRowAtIndexPath:]</span><br><span class="line">2019-10-20 09:06:08.552625+0800 LayoutIfNeed[5867:2475442] -[ULTableView setNeedsLayout]</span><br><span class="line">2019-10-20 09:06:08.552972+0800 LayoutIfNeed[5867:2475442] -[ULTableView setNeedsLayout]</span><br><span class="line">2019-10-20 09:06:08.553263+0800 LayoutIfNeed[5867:2475442] -[ULTableView layoutSubviews]</span><br></pre></td></tr></table></figure>

<p>根据上面的日志我们看到,外部TableView的reloadData甚至是TableView的<code>layoutSubviews</code>操作均不会影响Cell中CollectionView。</p>
<h4 id="CollectionView中嵌套tableView"><a href="#CollectionView中嵌套tableView" class="headerlink" title="CollectionView中嵌套tableView"></a>CollectionView中嵌套tableView</h4><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g83z4a87hlj30l4152td5.jpg" alt="demo"></p>
<p>点击右上角reloadData 执行下面的代码</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)reloadCollectionViewData &#123;</span><br><span class="line">    [<span class="keyword">self</span>.collectionView reloadData];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;reloadData 执行完成&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面我们来看下log</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2019-10-20 08:48:14.430891+0800 LayoutIfNeed[5782:2468993] -[ULCollectionView reloadData]</span><br><span class="line">2019-10-20 08:48:14.431133+0800 LayoutIfNeed[5782:2468993] -[ULCollectionView setNeedsLayout]</span><br><span class="line">2019-10-20 08:48:14.431393+0800 LayoutIfNeed[5782:2468993] -[ULCollectionView setNeedsLayout]</span><br><span class="line">2019-10-20 08:48:14.431817+0800 LayoutIfNeed[5782:2468993] -[ULCollectionView setNeedsLayout]</span><br><span class="line">2019-10-20 08:48:14.432207+0800 LayoutIfNeed[5782:2468993] -[ULCollectionView setNeedsLayout]</span><br><span class="line">2019-10-20 08:48:14.432420+0800 LayoutIfNeed[5782:2468993] -[ULCollectionView setNeedsLayout]</span><br><span class="line">2019-10-20 08:48:14.432648+0800 LayoutIfNeed[5782:2468993] reloadData 执行完成</span><br><span class="line">2019-10-20 08:48:14.433422+0800 LayoutIfNeed[5782:2468993] CollectionTableViewController RunLoop即将处理Timer事件</span><br><span class="line">2019-10-20 08:48:14.433560+0800 LayoutIfNeed[5782:2468993] UIInnerTableView RunLoop即将处理Timer事件</span><br><span class="line">2019-10-20 08:48:14.433762+0800 LayoutIfNeed[5782:2468993] CollectionTableViewController RunLoop即将处理Source事件</span><br><span class="line">2019-10-20 08:48:14.434047+0800 LayoutIfNeed[5782:2468993] UIInnerTableView RunLoop即将处理Source事件</span><br><span class="line">2019-10-20 08:48:14.434736+0800 LayoutIfNeed[5782:2468993] CollectionTableViewController RunLoop即将休眠</span><br><span class="line">2019-10-20 08:48:14.434865+0800 LayoutIfNeed[5782:2468993] UIInnerTableView RunLoop即将休眠</span><br><span class="line">2019-10-20 08:48:14.435240+0800 LayoutIfNeed[5782:2468993] -[ULCollectionView layoutSubviews]</span><br><span class="line">2019-10-20 08:48:14.435422+0800 LayoutIfNeed[5782:2468993] -[CollectionTableViewController numberOfSectionsInCollectionView:]</span><br><span class="line">2019-10-20 08:48:14.435568+0800 LayoutIfNeed[5782:2468993] -[CollectionTableViewController collectionView:numberOfItemsInSection:]</span><br><span class="line">2019-10-20 08:48:14.437589+0800 LayoutIfNeed[5782:2468993] -[ULCollectionView dequeueReusableCellWithReuseIdentifier:forIndexPath:]</span><br><span class="line">2019-10-20 08:48:14.438094+0800 LayoutIfNeed[5782:2468993] -[CollectionTableViewController collectionView:cellForItemAtIndexPath:]</span><br><span class="line">2019-10-20 08:48:14.438444+0800 LayoutIfNeed[5782:2468993] -[ULTableView reloadData]</span><br><span class="line">2019-10-20 08:48:14.438847+0800 LayoutIfNeed[5782:2468993] -[UIInnerTableView numberOfSectionsInTableView:]</span><br><span class="line">2019-10-20 08:48:14.439129+0800 LayoutIfNeed[5782:2468993] -[ULTableView setNeedsLayout]</span><br><span class="line">2019-10-20 08:48:14.439520+0800 LayoutIfNeed[5782:2468993] -[UIInnerTableView tableView:numberOfRowsInSection:]</span><br><span class="line">2019-10-20 08:48:14.439828+0800 LayoutIfNeed[5782:2468993] -[ULTableView setNeedsLayout]</span><br><span class="line">2019-10-20 08:48:14.440130+0800 LayoutIfNeed[5782:2468993] -[ULTableView setNeedsLayout]</span><br><span class="line">2019-10-20 08:48:14.440494+0800 LayoutIfNeed[5782:2468993] -[ULTableView setNeedsLayout]</span><br><span class="line">2019-10-20 08:48:14.441025+0800 LayoutIfNeed[5782:2468993] -[ULTableView layoutSubviews]</span><br><span class="line">2019-10-20 08:48:14.441239+0800 LayoutIfNeed[5782:2468993] -[ULTableView dequeueReusableCellWithIdentifier:]</span><br><span class="line">2019-10-20 08:48:14.441523+0800 LayoutIfNeed[5782:2468993] -[UIInnerTableView tableView:cellForRowAtIndexPath:] 0 0</span><br><span class="line">2019-10-20 08:48:14.442092+0800 LayoutIfNeed[5782:2468993] -[UIInnerTableView tableView:heightForRowAtIndexPath:]</span><br><span class="line">2019-10-20 08:48:14.442281+0800 LayoutIfNeed[5782:2468993] -[ULTableView setNeedsLayout]</span><br><span class="line">2019-10-20 08:48:14.442722+0800 LayoutIfNeed[5782:2468993] -[ULTableView dequeueReusableCellWithIdentifier:]</span><br><span class="line">2019-10-20 08:48:14.443052+0800 LayoutIfNeed[5782:2468993] -[UIInnerTableView tableView:cellForRowAtIndexPath:] 0 1</span><br><span class="line">2019-10-20 08:48:14.443557+0800 LayoutIfNeed[5782:2468993] -[UIInnerTableView tableView:heightForRowAtIndexPath:]</span><br><span class="line">2019-10-20 08:48:14.443796+0800 LayoutIfNeed[5782:2468993] -[ULTableView setNeedsLayout]</span><br><span class="line">2019-10-20 08:48:14.444251+0800 LayoutIfNeed[5782:2468993] -[ULTableView dequeueReusableCellWithIdentifier:]</span><br><span class="line">2019-10-20 08:48:14.444577+0800 LayoutIfNeed[5782:2468993] -[UIInnerTableView tableView:cellForRowAtIndexPath:] 0 2</span><br><span class="line">2019-10-20 08:48:14.445056+0800 LayoutIfNeed[5782:2468993] -[UIInnerTableView tableView:heightForRowAtIndexPath:]</span><br><span class="line">2019-10-20 08:48:14.445428+0800 LayoutIfNeed[5782:2468993] -[ULTableView setNeedsLayout]</span><br><span class="line">2019-10-20 08:48:14.445989+0800 LayoutIfNeed[5782:2468993] -[ULTableView dequeueReusableCellWithIdentifier:]</span><br><span class="line">2019-10-20 08:48:14.446264+0800 LayoutIfNeed[5782:2468993] -[UIInnerTableView tableView:cellForRowAtIndexPath:] 0 3</span><br><span class="line">2019-10-20 08:48:14.446693+0800 LayoutIfNeed[5782:2468993] -[UIInnerTableView tableView:heightForRowAtIndexPath:]</span><br><span class="line">2019-10-20 08:48:14.447040+0800 LayoutIfNeed[5782:2468993] -[ULTableView setNeedsLayout]</span><br><span class="line">2019-10-20 08:48:14.447631+0800 LayoutIfNeed[5782:2468993] -[ULTableView dequeueReusableCellWithIdentifier:]</span><br><span class="line">2019-10-20 08:48:14.448047+0800 LayoutIfNeed[5782:2468993] -[UIInnerTableView tableView:cellForRowAtIndexPath:] 0 4</span><br><span class="line">2019-10-20 08:48:14.448584+0800 LayoutIfNeed[5782:2468993] -[UIInnerTableView tableView:heightForRowAtIndexPath:]</span><br><span class="line">2019-10-20 08:48:14.448971+0800 LayoutIfNeed[5782:2468993] -[ULTableView setNeedsLayout]</span><br><span class="line">2019-10-20 08:48:14.449616+0800 LayoutIfNeed[5782:2468993] -[ULTableView setNeedsLayout]</span><br><span class="line">2019-10-20 08:48:14.450075+0800 LayoutIfNeed[5782:2468993] -[ULTableView layoutSubviews]</span><br></pre></td></tr></table></figure>

<p>上述结果同TableView中嵌套CollectionView相似。被嵌套的控件的</p>
<p>那么我们同样看下如果我们在TableView的CellForRow方法中不主动调用reloadData时log的结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2019-10-20 08:58:07.783966+0800 LayoutIfNeed[5845:2473209] -[ULCollectionView reloadData]</span><br><span class="line">2019-10-20 08:58:07.784219+0800 LayoutIfNeed[5845:2473209] -[ULCollectionView setNeedsLayout]</span><br><span class="line">2019-10-20 08:58:07.784382+0800 LayoutIfNeed[5845:2473209] -[ULCollectionView setNeedsLayout]</span><br><span class="line">2019-10-20 08:58:07.784507+0800 LayoutIfNeed[5845:2473209] -[ULCollectionView setNeedsLayout]</span><br><span class="line">2019-10-20 08:58:07.784605+0800 LayoutIfNeed[5845:2473209] -[ULCollectionView setNeedsLayout]</span><br><span class="line">2019-10-20 08:58:07.784705+0800 LayoutIfNeed[5845:2473209] -[ULCollectionView setNeedsLayout]</span><br><span class="line">2019-10-20 08:58:07.784817+0800 LayoutIfNeed[5845:2473209] reloadData 执行完成</span><br><span class="line">2019-10-20 08:58:07.785197+0800 LayoutIfNeed[5845:2473209] CollectionTableViewController RunLoop即将处理Timer事件</span><br><span class="line">2019-10-20 08:58:07.785327+0800 LayoutIfNeed[5845:2473209] UIInnerTableView RunLoop即将处理Timer事件</span><br><span class="line">2019-10-20 08:58:07.785671+0800 LayoutIfNeed[5845:2473209] CollectionTableViewController RunLoop即将处理Source事件</span><br><span class="line">2019-10-20 08:58:07.786006+0800 LayoutIfNeed[5845:2473209] UIInnerTableView RunLoop即将处理Source事件</span><br><span class="line">2019-10-20 08:58:07.786776+0800 LayoutIfNeed[5845:2473209] CollectionTableViewController RunLoop即将休眠</span><br><span class="line">2019-10-20 08:58:07.786927+0800 LayoutIfNeed[5845:2473209] UIInnerTableView RunLoop即将休眠</span><br><span class="line">2019-10-20 08:58:07.787353+0800 LayoutIfNeed[5845:2473209] -[ULCollectionView layoutSubviews]</span><br><span class="line">2019-10-20 08:58:07.787514+0800 LayoutIfNeed[5845:2473209] -[CollectionTableViewController numberOfSectionsInCollectionView:]</span><br><span class="line">2019-10-20 08:58:07.787615+0800 LayoutIfNeed[5845:2473209] -[CollectionTableViewController collectionView:numberOfItemsInSection:]</span><br><span class="line">2019-10-20 08:58:07.789470+0800 LayoutIfNeed[5845:2473209] -[ULCollectionView dequeueReusableCellWithReuseIdentifier:forIndexPath:]</span><br><span class="line">2019-10-20 08:58:07.789994+0800 LayoutIfNeed[5845:2473209] -[CollectionTableViewController collectionView:cellForItemAtIndexPath:]</span><br></pre></td></tr></table></figure>
<p>根据上面的log我们可以得出一个结论 如果不主动触发,外部的CollectionView调用reloadData并不会影响cell中嵌套的TableView</p>
<h3 id="VisibleCell"><a href="#VisibleCell" class="headerlink" title="VisibleCell"></a>VisibleCell</h3><h4 id="UITableView-1"><a href="#UITableView-1" class="headerlink" title="UITableView"></a>UITableView</h4><p><code>demo同上</code></p>
<p>下面我们直接看代码：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)reloadTableData &#123;</span><br><span class="line"> </span><br><span class="line">    [<span class="keyword">self</span>.tableView reloadData];</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;reloadData 执行完成&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">NSArray</span> *array = [<span class="keyword">self</span>.tableView visibleCells];</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;visibleCells----:%@&quot;</span>,@(array.count));</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line"> </span><br><span class="line">        <span class="built_in">NSArray</span> *array = [<span class="keyword">self</span>.tableView visibleCells];</span><br><span class="line"> </span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;visibleCells==== :%@&quot;</span>,@(array.count));</span><br><span class="line">    &#125;);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于在reloadData中我们知道该方法是一个异步的,一次在获取visibleCell的时候我们使用两种方法</p>
<ul>
<li>1、直接调用<code>[self.tableView visibleCells]</code></li>
<li>2、使用GCD在下一个runloop到来时在去获取Runloop</li>
</ul>
<p>下面看下上面代码的执行结果:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2019-10-08 19:40:28.825840+0800 LayoutIfNeed[3696:229565] RunLoop被唤醒</span><br><span class="line"> </span><br><span class="line">2019-10-08 19:40:28.826209+0800 LayoutIfNeed[3696:229565] RunLoop即将处理Timer事件</span><br><span class="line"> </span><br><span class="line">2019-10-08 19:40:28.826463+0800 LayoutIfNeed[3696:229565] RunLoop即将处理Source事件</span><br><span class="line"> </span><br><span class="line">2019-10-08 19:40:28.827665+0800 LayoutIfNeed[3696:229565] -[ULTableView reloadData]</span><br><span class="line"> </span><br><span class="line">2019-10-08 19:40:28.828167+0800 LayoutIfNeed[3696:229565] -[ViewController numberOfSectionsInTableView:]</span><br><span class="line"> </span><br><span class="line">2019-10-08 19:40:28.830161+0800 LayoutIfNeed[3696:229565] -[ULTableView setNeedsLayout]</span><br><span class="line"> </span><br><span class="line">2019-10-08 19:40:28.830560+0800 LayoutIfNeed[3696:229565] -[ViewController tableView:numberOfRowsInSection:]</span><br><span class="line"> </span><br><span class="line">2019-10-08 19:40:28.830946+0800 LayoutIfNeed[3696:229565] -[ULTableView setNeedsLayout]</span><br><span class="line"> </span><br><span class="line">2019-10-08 19:40:28.831849+0800 LayoutIfNeed[3696:229565] -[ULTableView setNeedsLayout]</span><br><span class="line"> </span><br><span class="line">2019-10-08 19:40:28.832015+0800 LayoutIfNeed[3696:229565] -[ULTableView setNeedsLayout]</span><br><span class="line"> </span><br><span class="line">2019-10-08 19:40:28.832149+0800 LayoutIfNeed[3696:229565] reloadData 执行完成</span><br><span class="line"> </span><br><span class="line">2019-10-08 19:40:28.832346+0800 LayoutIfNeed[3696:229565] -[ULTableView dequeueReusableCellWithIdentifier:]</span><br><span class="line"> </span><br><span class="line">2019-10-08 19:40:28.832904+0800 LayoutIfNeed[3696:229565] -[ViewController tableView:cellForRowAtIndexPath:] 0 0</span><br><span class="line"> </span><br><span class="line">2019-10-08 19:40:28.833739+0800 LayoutIfNeed[3696:229565] -[ViewController tableView:heightForRowAtIndexPath:]</span><br><span class="line"> </span><br><span class="line">2019-10-08 19:40:28.833904+0800 LayoutIfNeed[3696:229565] -[ULTableView setNeedsLayout]</span><br><span class="line"> </span><br><span class="line">2019-10-08 19:40:28.834391+0800 LayoutIfNeed[3696:229565] -[ULTableView setNeedsLayout]</span><br><span class="line"> </span><br><span class="line">2019-10-08 19:40:28.834894+0800 LayoutIfNeed[3696:229565] visibleCells----:1</span><br><span class="line"> </span><br><span class="line">2019-10-08 19:40:28.835912+0800 LayoutIfNeed[3696:229565] visibleCells&#x3D;&#x3D;&#x3D;&#x3D; :1</span><br><span class="line"> </span><br><span class="line">2019-10-08 19:40:28.836664+0800 LayoutIfNeed[3696:229565] RunLoop即将处理Timer事件</span><br><span class="line"> </span><br><span class="line">2019-10-08 19:40:28.837310+0800 LayoutIfNeed[3696:229565] RunLoop即将处理Source事件</span><br><span class="line"> </span><br><span class="line">2019-10-08 19:40:28.838118+0800 LayoutIfNeed[3696:229565] RunLoop即将休眠</span><br><span class="line"> </span><br><span class="line">2019-10-08 19:40:28.839862+0800 LayoutIfNeed[3696:229565] -[ULTableView layoutSubviews]</span><br></pre></td></tr></table></figure>

<p>通过log我们可以看到</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">两次&#96;visibleCells&#96;方法都返回了正确的cells数据是一致的且均是正确的</span><br></pre></td></tr></table></figure>
<p>疑问一：</p>
<p><code>reloadData</code>是异步的,它是会调用<code>setNeedLayout</code>方法标记当前view在下一次Runloop到来时刷新页面,为什么获取<code>visibleCell</code>会是正确的？</p>
<p>疑问二：</p>
<p>为什么<code>cellforRow</code>的方法调用不是在reloadData的下一次Runloop到来时才被调用而是在当前的Runloop中就被调用？</p>
<p>下面我们通过在<code>cellForRow</code>方法中添加断点的方式确认下在<code>visibleCell</code>被调用的时候都做了什么。</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g83v94813xj314m08waik.jpg" alt="调用堆栈"></p>
<p>根据这个断点的截图我们发现在调用visibleCell(截图右侧)的时候会触发<code>createPreparedCell</code>的调用,这个方法又间接的调用了<code>cellForRow</code>的代理方法。因此我们在当前runloop中使用visibleCell就可以获取到正确的值。</p>
<h4 id="UICollectionView-1"><a href="#UICollectionView-1" class="headerlink" title="UICollectionView"></a>UICollectionView</h4><p><code>Demo同上</code></p>
<p>下面我们来直接看代码：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)reloadCollectionViewData &#123;</span><br><span class="line"> </span><br><span class="line">    [<span class="keyword">self</span>.collectionView reloadData];</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;reloadData 执行完成&quot;</span>);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="built_in">NSArray</span> *array = [<span class="keyword">self</span>.collectionView visibleCells];</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;visibleCells----:%@&quot;</span>,@(array.count));</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line"> </span><br><span class="line">        <span class="built_in">NSArray</span> *array = [<span class="keyword">self</span>.collectionView visibleCells];</span><br><span class="line"> </span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;visibleCells==== :%@&quot;</span>,@(array.count));</span><br><span class="line"> </span><br><span class="line">    &#125;);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>—————–我是分割线——————</p>
<p>大家可以思考下结果,然后在接着往下看…..</p>
<p>—————–我是分割线——————</p>
<p>下面我们直接看下log</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2019-10-09 15:09:32.564096+0800 LayoutIfNeed[5995:609901] RunLoop被唤醒</span><br><span class="line">2019-10-09 15:09:32.564291+0800 LayoutIfNeed[5995:609901] RunLoop即将处理Timer事件</span><br><span class="line">2019-10-09 15:09:32.564403+0800 LayoutIfNeed[5995:609901] RunLoop即将处理Source事件</span><br><span class="line">2019-10-09 15:09:32.565137+0800 LayoutIfNeed[5995:609901] -[ULCollectionView reloadData]</span><br><span class="line">2019-10-09 15:09:32.565606+0800 LayoutIfNeed[5995:609901] -[ULCollectionView setNeedsLayout]</span><br><span class="line">2019-10-09 15:09:32.565806+0800 LayoutIfNeed[5995:609901] -[ULCollectionView setNeedsLayout]</span><br><span class="line">2019-10-09 15:09:32.566099+0800 LayoutIfNeed[5995:609901] -[ULCollectionView setNeedsLayout]</span><br><span class="line">2019-10-09 15:09:32.566650+0800 LayoutIfNeed[5995:609901] -[ULCollectionView setNeedsLayout]</span><br><span class="line">2019-10-09 15:09:32.567124+0800 LayoutIfNeed[5995:609901] -[ULCollectionView setNeedsLayout]</span><br><span class="line">2019-10-09 15:09:32.567806+0800 LayoutIfNeed[5995:609901] reloadData 执行完成</span><br><span class="line">2019-10-09 15:09:32.568103+0800 LayoutIfNeed[5995:609901] visibleCells----:0</span><br><span class="line">2019-10-09 15:09:32.569715+0800 LayoutIfNeed[5995:609901] visibleCells&#x3D;&#x3D;&#x3D;&#x3D; :0</span><br><span class="line">2019-10-09 15:09:32.570232+0800 LayoutIfNeed[5995:609901] RunLoop即将处理Timer事件</span><br><span class="line">2019-10-09 15:09:32.570603+0800 LayoutIfNeed[5995:609901] RunLoop即将处理Source事件</span><br><span class="line">2019-10-09 15:09:32.571044+0800 LayoutIfNeed[5995:609901] RunLoop即将处理Timer事件</span><br><span class="line">2019-10-09 15:09:32.571513+0800 LayoutIfNeed[5995:609901] RunLoop即将处理Source事件</span><br><span class="line">2019-10-09 15:09:32.572296+0800 LayoutIfNeed[5995:609901] RunLoop即将休眠</span><br><span class="line">2019-10-09 15:09:32.572800+0800 LayoutIfNeed[5995:609901] -[ULCollectionView layoutSubviews]</span><br><span class="line">2019-10-09 15:09:32.572981+0800 LayoutIfNeed[5995:609901] -[ULCollectionViewController numberOfSectionsInCollectionView:]</span><br><span class="line">2019-10-09 15:09:32.573112+0800 LayoutIfNeed[5995:609901] -[ULCollectionViewController collectionView:numberOfItemsInSection:]</span><br><span class="line">2019-10-09 15:09:32.575343+0800 LayoutIfNeed[5995:609901] -[ULCollectionView dequeueReusableCellWithReuseIdentifier:forIndexPath:]</span><br><span class="line">2019-10-09 15:09:32.575858+0800 LayoutIfNeed[5995:609901] -[ULCollectionViewController collectionView:cellForItemAtIndexPath:]</span><br><span class="line">2019-10-09 15:09:32.576419+0800 LayoutIfNeed[5995:609901] -[ULCollectionView layoutSubviews] visibleCell 1</span><br></pre></td></tr></table></figure>

<p>额！！！！！！！！！！！！！！！！</p>
<p>通过log我们发现：</p>
<p>我们两次获取visibleCell的数据均不正确,但是我们发现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2019-10-09 15:09:32.576419+0800 LayoutIfNeed[5995:609901] -[ULCollectionView layoutSubviews] visibleCell 1</span><br></pre></td></tr></table></figure>
<p>在collectionView执行完<code>layoutSubviews</code>后获取的visibleCell是正确的。</p>
<p>同时我们注意到调用visibleCell时并没有像UITableView一样触发cellForRow被提前调用。</p>
<p>下面我们在观察下cellForRow被调用的时候的调用栈</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g83wam8lmbj30cu09ddmm.jpg" alt="调用栈"></p>
<p>我们看到对于UICollectionView在调用了layoutSubviews之后才会触发下面方法的调用<br><code>-[UICollectionView _createPreparedCellForItemAtIndexPath:withLayoutAttributes:applyAttributes:isFocused:notify:] </code></p>
<p>这个位置是跟UITableView是一致的！</p>
<h4 id="UITableView中嵌套UICollectionView"><a href="#UITableView中嵌套UICollectionView" class="headerlink" title="UITableView中嵌套UICollectionView"></a>UITableView中嵌套UICollectionView</h4><p>首先我们来确认下 如果在UITableView中调用了visibleCell是否会影响到内部的CollectionView</p>
<h5 id="页面加载完成后"><a href="#页面加载完成后" class="headerlink" title="页面加载完成后"></a>页面加载完成后</h5><p>下面我们直接看log</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2019-10-20 09:42:36.408243+0800 LayoutIfNeed[6044:2489041] -[TableCollectionViewController reloadTableData]</span><br><span class="line">2019-10-20 09:42:36.408414+0800 LayoutIfNeed[6044:2489041] visibleCells----:2</span><br></pre></td></tr></table></figure>

<p>log 显示页面加载完成后 我们在调用visibleCell时不会影响内部的CollectionView</p>
<h5 id="页面加载完成前"><a href="#页面加载完成前" class="headerlink" title="页面加载完成前"></a>页面加载完成前</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[self.view addSubview:self.tableView];</span><br><span class="line">NSArray *array &#x3D; [self.tableView visibleCells];</span><br><span class="line">  NSLog(@&quot;visibleCells----:%@&quot;,@(array.count));</span><br></pre></td></tr></table></figure>

<p>这里为了验证效果 我们暂时不主动调用reloadData </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2019-10-20 09:48:53.813778+0800 LayoutIfNeed[6081:2491415] -[ULTableView setNeedsLayout]</span><br><span class="line">2019-10-20 09:48:53.814644+0800 LayoutIfNeed[6081:2491415] visibleCells----:0</span><br><span class="line">2019-10-20 09:48:53.816761+0800 LayoutIfNeed[6081:2491415] -[TableCollectionViewController numberOfSectionsInTableView:]</span><br><span class="line">2019-10-20 09:48:53.816960+0800 LayoutIfNeed[6081:2491415] -[TableCollectionViewController tableView:numberOfRowsInSection:]</span><br><span class="line">2019-10-20 09:48:53.817162+0800 LayoutIfNeed[6081:2491415] -[ULTableView setNeedsLayout]</span><br><span class="line">2019-10-20 09:48:53.817733+0800 LayoutIfNeed[6081:2491415] -[ULTableView setNeedsLayout]</span><br><span class="line">2019-10-20 09:48:53.828370+0800 LayoutIfNeed[6081:2491415] -[ULTableView layoutSubviews]</span><br><span class="line">2019-10-20 09:48:53.828573+0800 LayoutIfNeed[6081:2491415] -[ULTableView reloadData]</span><br><span class="line">2019-10-20 09:48:53.828713+0800 LayoutIfNeed[6081:2491415] -[TableCollectionViewController numberOfSectionsInTableView:]</span><br><span class="line">2019-10-20 09:48:53.828853+0800 LayoutIfNeed[6081:2491415] -[TableCollectionViewController tableView:numberOfRowsInSection:]</span><br><span class="line">2019-10-20 09:48:53.828974+0800 LayoutIfNeed[6081:2491415] -[ULTableView setNeedsLayout]</span><br><span class="line">2019-10-20 09:48:53.829170+0800 LayoutIfNeed[6081:2491415] -[ULTableView dequeueReusableCellWithIdentifier:]</span><br><span class="line">2019-10-20 09:48:53.829604+0800 LayoutIfNeed[6081:2491415] -[TableCollectionViewController tableView:cellForRowAtIndexPath:] 0 0</span><br><span class="line">2019-10-20 09:48:53.830285+0800 LayoutIfNeed[6081:2491415] -[ULCollectionView setNeedsLayout]</span><br><span class="line">2019-10-20 09:48:53.830449+0800 LayoutIfNeed[6081:2491415] -[ULCollectionView setNeedsLayout]</span><br><span class="line">2019-10-20 09:48:53.830576+0800 LayoutIfNeed[6081:2491415] -[ULCollectionView setNeedsLayout]</span><br><span class="line">2019-10-20 09:48:53.830811+0800 LayoutIfNeed[6081:2491415] -[ULCollectionView reloadData]</span><br><span class="line">2019-10-20 09:48:53.830948+0800 LayoutIfNeed[6081:2491415] -[ULCollectionView setNeedsLayout]</span><br><span class="line">2019-10-20 09:48:53.831085+0800 LayoutIfNeed[6081:2491415] -[ULCollectionView setNeedsLayout]</span><br><span class="line">2019-10-20 09:48:53.831213+0800 LayoutIfNeed[6081:2491415] -[ULCollectionView setNeedsLayout]</span><br><span class="line">2019-10-20 09:48:53.831308+0800 LayoutIfNeed[6081:2491415] -[ULCollectionView setNeedsLayout]</span><br><span class="line">2019-10-20 09:48:53.831640+0800 LayoutIfNeed[6081:2491415] -[ULCollectionView setNeedsLayout]</span><br><span class="line">2019-10-20 09:48:53.832722+0800 LayoutIfNeed[6081:2491415] -[TableCollectionViewController tableView:heightForRowAtIndexPath:]</span><br><span class="line">2019-10-20 09:48:53.832866+0800 LayoutIfNeed[6081:2491415] -[ULTableView setNeedsLayout]</span><br><span class="line">2019-10-20 09:48:53.833304+0800 LayoutIfNeed[6081:2491415] -[ULCollectionView layoutSubviews]</span><br><span class="line">2019-10-20 09:48:53.833478+0800 LayoutIfNeed[6081:2491415] -[UIInnerCollectionView numberOfSectionsInCollectionView:]</span><br><span class="line">2019-10-20 09:48:53.833595+0800 LayoutIfNeed[6081:2491415] -[UIInnerCollectionView collectionView:numberOfItemsInSection:]</span><br><span class="line">2019-10-20 09:48:53.835002+0800 LayoutIfNeed[6081:2491415] -[ULCollectionView dequeueReusableCellWithReuseIdentifier:forIndexPath:]</span><br><span class="line">2019-10-20 09:48:53.835350+0800 LayoutIfNeed[6081:2491415] -[UIInnerCollectionView collectionView:cellForItemAtIndexPath:]</span><br><span class="line">2019-10-20 09:48:53.835618+0800 LayoutIfNeed[6081:2491415] -[ULCollectionView layoutSubviews] visibleCell 1</span><br><span class="line">2019-10-20 09:48:53.835801+0800 LayoutIfNeed[6081:2491415] -[ULTableView dequeueReusableCellWithIdentifier:]</span><br><span class="line">2019-10-20 09:48:53.836383+0800 LayoutIfNeed[6081:2491415] -[TableCollectionViewController tableView:cellForRowAtIndexPath:] 0 1</span><br><span class="line">2019-10-20 09:48:53.837371+0800 LayoutIfNeed[6081:2491415] -[TableCollectionViewController tableView:heightForRowAtIndexPath:]</span><br><span class="line">2019-10-20 09:48:53.837523+0800 LayoutIfNeed[6081:2491415] -[ULTableView setNeedsLayout]</span><br><span class="line">2019-10-20 09:48:53.838066+0800 LayoutIfNeed[6081:2491415] -[ULTableView setNeedsLayout]</span><br><span class="line">2019-10-20 09:48:53.838735+0800 LayoutIfNeed[6081:2491415] -[ULTableView layoutSubviews]</span><br></pre></td></tr></table></figure>
<p>根据上面的log 我们看到即使在页面加载的时候我们不主动调用reloadData页面也可以正常加载,是因为<code>addsubview/init</code>操作会触发<code>layoutSubviews</code>方法。这样即使没有reloadData页面也可以正常加载。</p>
<h5 id="确认VisibleCell调用获取的数值"><a href="#确认VisibleCell调用获取的数值" class="headerlink" title="确认VisibleCell调用获取的数值"></a>确认VisibleCell调用获取的数值</h5><p>先确认下代码</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)reloadVisibleCell &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>,__func__);</span><br><span class="line">    [<span class="keyword">self</span>.tableView reloadData];</span><br><span class="line">    <span class="built_in">NSArray</span> *tableViewVisibleCells = [<span class="keyword">self</span>.tableView visibleCells];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;UITableView visibleCount%@&quot;</span>,@(tableViewVisibleCells.count));</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">UITableViewCell</span> *cell <span class="keyword">in</span> tableViewVisibleCells) &#123;</span><br><span class="line">    <span class="comment">// cell 上加载内容的视图，对应可能是CollectionView</span></span><br><span class="line">        [cell.contentView.subviews enumerateObjectsUsingBlock:^(__kindof <span class="built_in">UIView</span> * _Nonnull obj, <span class="built_in">NSUInteger</span> idx, <span class="built_in">BOOL</span> * _Nonnull stop) &#123;</span><br><span class="line">            <span class="keyword">if</span> ([obj isKindOfClass:[<span class="built_in">UIInnerCollectionView</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">                <span class="built_in">UIInnerCollectionView</span> *collectionView = (<span class="built_in">UIInnerCollectionView</span> *)obj;</span><br><span class="line">                <span class="built_in">NSArray</span> *array = [collectionView visibleCell];</span><br><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@&quot;UIInnerCollectionView visibleCount%@&quot;</span>,@(array.count));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>log:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2019-10-20 10:57:19.462632+0800 LayoutIfNeed[6313:2513531] -[TableCollectionViewController reloadVisibleCell]</span><br><span class="line">2019-10-20 10:57:19.462805+0800 LayoutIfNeed[6313:2513531] -[ULTableView reloadData]</span><br><span class="line">2019-10-20 10:57:19.463147+0800 LayoutIfNeed[6313:2513531] -[TableCollectionViewController numberOfSectionsInTableView:]</span><br><span class="line">2019-10-20 10:57:19.463397+0800 LayoutIfNeed[6313:2513531] -[ULTableView setNeedsLayout]</span><br><span class="line">2019-10-20 10:57:19.463800+0800 LayoutIfNeed[6313:2513531] -[TableCollectionViewController tableView:numberOfRowsInSection:]</span><br><span class="line">2019-10-20 10:57:19.464301+0800 LayoutIfNeed[6313:2513531] -[ULTableView setNeedsLayout]</span><br><span class="line">2019-10-20 10:57:19.464657+0800 LayoutIfNeed[6313:2513531] -[ULTableView setNeedsLayout]</span><br><span class="line">2019-10-20 10:57:19.464797+0800 LayoutIfNeed[6313:2513531] -[ULTableView setNeedsLayout]</span><br><span class="line">2019-10-20 10:57:19.465240+0800 LayoutIfNeed[6313:2513531] -[ULTableView dequeueReusableCellWithIdentifier:]</span><br><span class="line">2019-10-20 10:57:19.465619+0800 LayoutIfNeed[6313:2513531] -[TableCollectionViewController tableView:cellForRowAtIndexPath:] 0 0</span><br><span class="line">2019-10-20 10:57:19.466193+0800 LayoutIfNeed[6313:2513531] -[TableCollectionViewController tableView:heightForRowAtIndexPath:]</span><br><span class="line">2019-10-20 10:57:19.466357+0800 LayoutIfNeed[6313:2513531] -[ULTableView setNeedsLayout]</span><br><span class="line">2019-10-20 10:57:19.466656+0800 LayoutIfNeed[6313:2513531] -[ULTableView dequeueReusableCellWithIdentifier:]</span><br><span class="line">2019-10-20 10:57:19.466921+0800 LayoutIfNeed[6313:2513531] -[TableCollectionViewController tableView:cellForRowAtIndexPath:] 0 1</span><br><span class="line">2019-10-20 10:57:19.467452+0800 LayoutIfNeed[6313:2513531] -[TableCollectionViewController tableView:heightForRowAtIndexPath:]</span><br><span class="line">2019-10-20 10:57:19.467690+0800 LayoutIfNeed[6313:2513531] -[ULTableView setNeedsLayout]</span><br><span class="line">2019-10-20 10:57:19.468489+0800 LayoutIfNeed[6313:2513531] -[ULTableView setNeedsLayout]</span><br><span class="line">2019-10-20 10:57:19.468747+0800 LayoutIfNeed[6313:2513531] UITableView visibleCount2</span><br><span class="line">2019-10-20 10:57:19.468898+0800 LayoutIfNeed[6313:2513531] UIInnerCollectionView visibleCount1</span><br></pre></td></tr></table></figure>

<p>从上面的log我们可以看到,我们在reloadData后获取到的visibleCell都是正确的！</p>
<h4 id="UICollectionView中嵌套UITableView"><a href="#UICollectionView中嵌套UITableView" class="headerlink" title="UICollectionView中嵌套UITableView"></a>UICollectionView中嵌套UITableView</h4><h5 id="页面加载时"><a href="#页面加载时" class="headerlink" title="页面加载时"></a>页面加载时</h5><p>代码：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">[<span class="keyword">self</span>.view addSubview:<span class="keyword">self</span>.collectionView];</span><br><span class="line"><span class="built_in">NSArray</span> *collectionViewVisibleCell = [<span class="keyword">self</span>.collectionView visibleCells];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;UICollectionView visibleCount%@&quot;</span>,@(collectionViewVisibleCell.count));</span><br></pre></td></tr></table></figure>

<p>log:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2019-10-20 11:12:00.989745+0800 LayoutIfNeed[6388:2521314] -[ULCollectionView setNeedsLayout]</span><br><span class="line">2019-10-20 11:12:00.989925+0800 LayoutIfNeed[6388:2521314] -[ULCollectionView setNeedsLayout]</span><br><span class="line">2019-10-20 11:12:00.990034+0800 LayoutIfNeed[6388:2521314] -[ULCollectionView setNeedsLayout]</span><br><span class="line">2019-10-20 11:12:00.990269+0800 LayoutIfNeed[6388:2521314] -[ULCollectionView reloadData]</span><br><span class="line">2019-10-20 11:12:00.990395+0800 LayoutIfNeed[6388:2521314] -[ULCollectionView setNeedsLayout]</span><br><span class="line">2019-10-20 11:12:00.990533+0800 LayoutIfNeed[6388:2521314] -[ULCollectionView setNeedsLayout]</span><br><span class="line">2019-10-20 11:12:00.990894+0800 LayoutIfNeed[6388:2521314] -[ULCollectionView setNeedsLayout]</span><br><span class="line">2019-10-20 11:12:00.991304+0800 LayoutIfNeed[6388:2521314] -[ULCollectionView setNeedsLayout]</span><br><span class="line">2019-10-20 11:12:00.991690+0800 LayoutIfNeed[6388:2521314] -[ULCollectionView setNeedsLayout]</span><br><span class="line">2019-10-20 11:12:00.992034+0800 LayoutIfNeed[6388:2521314] UICollectionView visibleCount0</span><br><span class="line">2019-10-20 11:12:00.994969+0800 LayoutIfNeed[6388:2521314] -[ULCollectionView setNeedsLayout]</span><br><span class="line">2019-10-20 11:12:00.995134+0800 LayoutIfNeed[6388:2521314] -[ULCollectionView setNeedsLayout]</span><br><span class="line">2019-10-20 11:12:00.995228+0800 LayoutIfNeed[6388:2521314] -[ULCollectionView setNeedsLayout]</span><br><span class="line">2019-10-20 11:12:00.995342+0800 LayoutIfNeed[6388:2521314] -[ULCollectionView setNeedsLayout]</span><br><span class="line">2019-10-20 11:12:00.995465+0800 LayoutIfNeed[6388:2521314] -[ULCollectionView setNeedsLayout]</span><br><span class="line">2019-10-20 11:12:00.995567+0800 LayoutIfNeed[6388:2521314] -[ULCollectionView setNeedsLayout]</span><br><span class="line">2019-10-20 11:12:00.995673+0800 LayoutIfNeed[6388:2521314] -[ULCollectionView setNeedsLayout]</span><br><span class="line">2019-10-20 11:12:00.995772+0800 LayoutIfNeed[6388:2521314] -[ULCollectionView setNeedsLayout]</span><br><span class="line">2019-10-20 11:12:00.995894+0800 LayoutIfNeed[6388:2521314] -[ULCollectionView setNeedsLayout]</span><br><span class="line">2019-10-20 11:12:01.009260+0800 LayoutIfNeed[6388:2521314] -[ULCollectionView layoutSubviews]</span><br><span class="line">2019-10-20 11:12:01.009536+0800 LayoutIfNeed[6388:2521314] -[CollectionTableViewController numberOfSectionsInCollectionView:]</span><br><span class="line">2019-10-20 11:12:01.009651+0800 LayoutIfNeed[6388:2521314] -[CollectionTableViewController collectionView:numberOfItemsInSection:]</span><br><span class="line">2019-10-20 11:12:01.010533+0800 LayoutIfNeed[6388:2521314] -[ULCollectionView dequeueReusableCellWithReuseIdentifier:forIndexPath:]</span><br><span class="line">2019-10-20 11:12:01.010844+0800 LayoutIfNeed[6388:2521314] -[CollectionTableViewController collectionView:cellForItemAtIndexPath:]</span><br><span class="line">2019-10-20 11:12:01.011126+0800 LayoutIfNeed[6388:2521314] -[ULTableView setNeedsLayout]</span><br><span class="line">2019-10-20 11:12:01.012000+0800 LayoutIfNeed[6388:2521314] -[ULTableView reloadData]</span><br><span class="line">2019-10-20 11:12:01.012172+0800 LayoutIfNeed[6388:2521314] -[UIInnerTableView numberOfSectionsInTableView:]</span><br><span class="line">2019-10-20 11:12:01.012511+0800 LayoutIfNeed[6388:2521314] -[UIInnerTableView tableView:numberOfRowsInSection:]</span><br><span class="line">2019-10-20 11:12:01.013372+0800 LayoutIfNeed[6388:2521314] -[ULTableView setNeedsLayout]</span><br><span class="line">2019-10-20 11:12:01.015872+0800 LayoutIfNeed[6388:2521314] -[UIInnerTableView numberOfSectionsInTableView:]</span><br><span class="line">2019-10-20 11:12:01.016756+0800 LayoutIfNeed[6388:2521314] -[UIInnerTableView tableView:numberOfRowsInSection:]</span><br><span class="line">2019-10-20 11:12:01.017156+0800 LayoutIfNeed[6388:2521314] -[UIInnerTableView numberOfSectionsInTableView:]</span><br><span class="line">2019-10-20 11:12:01.017900+0800 LayoutIfNeed[6388:2521314] -[UIInnerTableView tableView:numberOfRowsInSection:]</span><br><span class="line">2019-10-20 11:12:01.018193+0800 LayoutIfNeed[6388:2521314] -[ULTableView setNeedsLayout]</span><br><span class="line">2019-10-20 11:12:01.020487+0800 LayoutIfNeed[6388:2521314] -[ULCollectionView layoutSubviews] visibleCell 1</span><br><span class="line">2019-10-20 11:12:01.021245+0800 LayoutIfNeed[6388:2521314] -[ULTableView layoutSubviews]</span><br><span class="line">2019-10-20 11:12:01.021410+0800 LayoutIfNeed[6388:2521314] -[ULTableView dequeueReusableCellWithIdentifier:]</span><br><span class="line">2019-10-20 11:12:01.021747+0800 LayoutIfNeed[6388:2521314] -[UIInnerTableView tableView:cellForRowAtIndexPath:] 0 0</span><br><span class="line">2019-10-20 11:12:01.024221+0800 LayoutIfNeed[6388:2521314] -[UIInnerTableView tableView:heightForRowAtIndexPath:]</span><br><span class="line">2019-10-20 11:12:01.024501+0800 LayoutIfNeed[6388:2521314] -[ULTableView setNeedsLayout]</span><br><span class="line">2019-10-20 11:12:01.024982+0800 LayoutIfNeed[6388:2521314] -[ULTableView dequeueReusableCellWithIdentifier:]</span><br><span class="line">2019-10-20 11:12:01.025291+0800 LayoutIfNeed[6388:2521314] -[UIInnerTableView tableView:cellForRowAtIndexPath:] 0 1</span><br><span class="line">2019-10-20 11:12:01.025908+0800 LayoutIfNeed[6388:2521314] -[UIInnerTableView tableView:heightForRowAtIndexPath:]</span><br><span class="line">2019-10-20 11:12:01.026027+0800 LayoutIfNeed[6388:2521314] -[ULTableView setNeedsLayout]</span><br><span class="line">2019-10-20 11:12:01.026418+0800 LayoutIfNeed[6388:2521314] -[ULTableView dequeueReusableCellWithIdentifier:]</span><br><span class="line">2019-10-20 11:12:01.026711+0800 LayoutIfNeed[6388:2521314] -[UIInnerTableView tableView:cellForRowAtIndexPath:] 0 2</span><br><span class="line">2019-10-20 11:12:01.027502+0800 LayoutIfNeed[6388:2521314] -[UIInnerTableView tableView:heightForRowAtIndexPath:]</span><br><span class="line">2019-10-20 11:12:01.027624+0800 LayoutIfNeed[6388:2521314] -[ULTableView setNeedsLayout]</span><br><span class="line">2019-10-20 11:12:01.028011+0800 LayoutIfNeed[6388:2521314] -[ULTableView dequeueReusableCellWithIdentifier:]</span><br><span class="line">2019-10-20 11:12:01.028316+0800 LayoutIfNeed[6388:2521314] -[UIInnerTableView tableView:cellForRowAtIndexPath:] 0 3</span><br><span class="line">2019-10-20 11:12:01.029025+0800 LayoutIfNeed[6388:2521314] -[UIInnerTableView tableView:heightForRowAtIndexPath:]</span><br><span class="line">2019-10-20 11:12:01.029192+0800 LayoutIfNeed[6388:2521314] -[ULTableView setNeedsLayout]</span><br><span class="line">2019-10-20 11:12:01.029692+0800 LayoutIfNeed[6388:2521314] -[ULTableView dequeueReusableCellWithIdentifier:]</span><br><span class="line">2019-10-20 11:12:01.030077+0800 LayoutIfNeed[6388:2521314] -[UIInnerTableView tableView:cellForRowAtIndexPath:] 0 4</span><br><span class="line">2019-10-20 11:12:01.030814+0800 LayoutIfNeed[6388:2521314] -[UIInnerTableView tableView:heightForRowAtIndexPath:]</span><br><span class="line">2019-10-20 11:12:01.030965+0800 LayoutIfNeed[6388:2521314] -[ULTableView setNeedsLayout]</span><br><span class="line">2019-10-20 11:12:01.031518+0800 LayoutIfNeed[6388:2521314] -[ULTableView setNeedsLayout]</span><br><span class="line">2019-10-20 11:12:01.032057+0800 LayoutIfNeed[6388:2521314] -[ULTableView layoutSubviews]</span><br></pre></td></tr></table></figure>

<h5 id="页面加载完成后-1"><a href="#页面加载完成后-1" class="headerlink" title="页面加载完成后"></a>页面加载完成后</h5><p>代码：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)reloadVisibleCell &#123;</span><br><span class="line">    [<span class="keyword">self</span>.collectionView reloadData];</span><br><span class="line">     <span class="built_in">NSArray</span> *collectionViewVisibleCell = [<span class="keyword">self</span>.collectionView visibleCells];</span><br><span class="line">     <span class="built_in">NSLog</span>(<span class="string">@&quot;UICollectionView visibleCount%@&quot;</span>,@(collectionViewVisibleCell.count));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>log:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2019-10-20 11:15:40.370300+0800 LayoutIfNeed[6412:2522955] -[ULCollectionView reloadData]</span><br><span class="line">2019-10-20 11:15:40.370570+0800 LayoutIfNeed[6412:2522955] -[ULCollectionView setNeedsLayout]</span><br><span class="line">2019-10-20 11:15:40.370746+0800 LayoutIfNeed[6412:2522955] -[ULCollectionView setNeedsLayout]</span><br><span class="line">2019-10-20 11:15:40.370893+0800 LayoutIfNeed[6412:2522955] -[ULCollectionView setNeedsLayout]</span><br><span class="line">2019-10-20 11:15:40.371005+0800 LayoutIfNeed[6412:2522955] -[ULCollectionView setNeedsLayout]</span><br><span class="line">2019-10-20 11:15:40.371120+0800 LayoutIfNeed[6412:2522955] -[ULCollectionView setNeedsLayout]</span><br><span class="line">2019-10-20 11:15:40.371309+0800 LayoutIfNeed[6412:2522955] UICollectionView visibleCount0</span><br><span class="line">2019-10-20 11:15:44.145073+0800 LayoutIfNeed[6412:2522955] -[ULCollectionView layoutSubviews]</span><br><span class="line">2019-10-20 11:15:44.145280+0800 LayoutIfNeed[6412:2522955] -[CollectionTableViewController numberOfSectionsInCollectionView:]</span><br><span class="line">2019-10-20 11:15:44.145406+0800 LayoutIfNeed[6412:2522955] -[CollectionTableViewController collectionView:numberOfItemsInSection:]</span><br><span class="line">2019-10-20 11:15:44.146433+0800 LayoutIfNeed[6412:2522955] -[ULCollectionView dequeueReusableCellWithReuseIdentifier:forIndexPath:]</span><br><span class="line">2019-10-20 11:15:44.146820+0800 LayoutIfNeed[6412:2522955] -[CollectionTableViewController collectionView:cellForItemAtIndexPath:]</span><br></pre></td></tr></table></figure>

<h5 id="确认VisibleCell调用获取的数值-1"><a href="#确认VisibleCell调用获取的数值-1" class="headerlink" title="确认VisibleCell调用获取的数值"></a>确认VisibleCell调用获取的数值</h5><p>我们先看下代码：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)reloadVisibleCell &#123;</span><br><span class="line">    [<span class="keyword">self</span>.collectionView reloadData];</span><br><span class="line">     <span class="built_in">NSArray</span> *collectionViewVisibleCell = [<span class="keyword">self</span>.collectionView visibleCells];</span><br><span class="line">     <span class="built_in">NSLog</span>(<span class="string">@&quot;UICollectionView visibleCount%@&quot;</span>,@(collectionViewVisibleCell.count));</span><br><span class="line">     <span class="keyword">for</span> (<span class="built_in">UICollectionViewCell</span> *cell <span class="keyword">in</span> collectionViewVisibleCell) &#123;</span><br><span class="line">     <span class="comment">// cell 上加载内容的视图，对应可能是CollectionView</span></span><br><span class="line">         [cell.contentView.subviews enumerateObjectsUsingBlock:^(__kindof <span class="built_in">UIView</span> * _Nonnull obj, <span class="built_in">NSUInteger</span> idx, <span class="built_in">BOOL</span> * _Nonnull stop) &#123;</span><br><span class="line">             <span class="keyword">if</span> ([obj isKindOfClass:[<span class="built_in">UIInnerTableView</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">                 <span class="built_in">UIInnerTableView</span> *tableView = (<span class="built_in">UIInnerTableView</span> *)obj;</span><br><span class="line">                 <span class="built_in">NSArray</span> *array = [tableView visibleCell];</span><br><span class="line">                 <span class="built_in">NSLog</span>(<span class="string">@&quot;UIInnerTableView visibleCount%@&quot;</span>,@(array.count));</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;];</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们在看下log</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2019-10-20 11:08:33.397037+0800 LayoutIfNeed[6370:2519870] -[ULCollectionView reloadData]</span><br><span class="line">2019-10-20 11:08:33.397305+0800 LayoutIfNeed[6370:2519870] -[ULCollectionView setNeedsLayout]</span><br><span class="line">2019-10-20 11:08:33.397527+0800 LayoutIfNeed[6370:2519870] -[ULCollectionView setNeedsLayout]</span><br><span class="line">2019-10-20 11:08:33.397721+0800 LayoutIfNeed[6370:2519870] -[ULCollectionView setNeedsLayout]</span><br><span class="line">2019-10-20 11:08:33.397823+0800 LayoutIfNeed[6370:2519870] -[ULCollectionView setNeedsLayout]</span><br><span class="line">2019-10-20 11:08:33.397913+0800 LayoutIfNeed[6370:2519870] -[ULCollectionView setNeedsLayout]</span><br><span class="line">2019-10-20 11:08:33.398032+0800 LayoutIfNeed[6370:2519870] UICollectionView visibleCount0</span><br><span class="line">2019-10-20 11:08:38.437912+0800 LayoutIfNeed[6370:2519870] -[ULCollectionView layoutSubviews]</span><br><span class="line">2019-10-20 11:08:38.438140+0800 LayoutIfNeed[6370:2519870] -[CollectionTableViewController numberOfSectionsInCollectionView:]</span><br><span class="line">2019-10-20 11:08:38.438250+0800 LayoutIfNeed[6370:2519870] -[CollectionTableViewController collectionView:numberOfItemsInSection:]</span><br><span class="line">2019-10-20 11:08:38.489045+0800 LayoutIfNeed[6370:2519870] -[ULCollectionView dequeueReusableCellWithReuseIdentifier:forIndexPath:]</span><br><span class="line">2019-10-20 11:08:38.489259+0800 LayoutIfNeed[6370:2519870] -[CollectionTableViewController collectionView:cellForItemAtIndexPath:]</span><br></pre></td></tr></table></figure>
<p>从上面的log我们可以看出,reloadData之后 因为collectionView并没有调用<code>layoutIfNeed</code>所以在这之后无法获取到<code>visibleCell</code>,所以肯定不会影响到内部的TableView所以获取TableView的<code>visibleCell</code>肯定也是无效的。</p>
<p>未完待续…</p>
]]></content>
      <categories>
        <category>iOS基础</category>
      </categories>
      <tags>
        <tag>reloadData visibleCells</tag>
      </tags>
  </entry>
  <entry>
    <title>RunTime解析--Category(分类)实现</title>
    <url>/2020/08/22/runtimecategory/</url>
    <content><![CDATA[<p>  在日常的开发中，我们经常用到分类，用来给一个类添加扩展，包括对象方法、类方法、当然我们还可以通过关联对象的方式给分类添属性。但是这中间的过程是如何实现的呢？下面我们来做一个详细的解释。</p>
<a id="more"></a>

<h3 id="结构category-t"><a href="#结构category-t" class="headerlink" title="结构category_t"></a>结构category_t</h3><p>我们先看下分类的结构：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 分类</span></span><br><span class="line"><span class="keyword">struct</span> category_t &#123;</span><br><span class="line">    <span class="comment">// 分类名</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="comment">// 原始类</span></span><br><span class="line">    classref_t cls;</span><br><span class="line">    <span class="comment">// 对象方法列表</span></span><br><span class="line">    <span class="keyword">struct</span> method_list_t *instanceMethods;</span><br><span class="line">    <span class="comment">// 类方法列表</span></span><br><span class="line">    <span class="keyword">struct</span> method_list_t *classMethods;</span><br><span class="line">    <span class="comment">// 协议列表</span></span><br><span class="line">    <span class="keyword">struct</span> protocol_list_t *protocols;</span><br><span class="line">    <span class="comment">// 实例属性</span></span><br><span class="line">    <span class="keyword">struct</span> property_list_t *instanceProperties;</span><br><span class="line">    <span class="comment">// Fields below this point are not always present on disk.</span></span><br><span class="line">    <span class="comment">// 类属性(这个结构体以_开头命名？？？)</span></span><br><span class="line">    <span class="keyword">struct</span> property_list_t *_classProperties;</span><br><span class="line">    <span class="comment">// methodsForMeta 返回类方法列表或者对象方法列表</span></span><br><span class="line">    method_list_t *methodsForMeta(<span class="keyword">bool</span> isMeta) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isMeta) <span class="keyword">return</span> classMethods;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> instanceMethods;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 属性列表返回方法</span></span><br><span class="line">    property_list_t *propertiesForMeta(<span class="keyword">bool</span> isMeta, <span class="keyword">struct</span> header_info *hi);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>从上面我们看到，一个分类的结构体中，包含我们最关心的几个结构体：<code>instanceMethods</code>,<code>classMethods</code>,<code>protocols</code>,<code>instanceProperties</code>,而对于<code>_classProperties</code>目前好像大多数文章在讲解时都将他选择性的忽略了，我们在本篇文章结束后在继续看下这个属性到底是什么有什么作用！</p>
<p>从上面的结构我们看出：分类是独立于原始类存在的。因此对于分类来说也肯定是有一块单独的内存空间来存放分类，那么到底是怎么存放的呢？我们下面来看下</p>
<h3 id="分类的存储"><a href="#分类的存储" class="headerlink" title="分类的存储"></a>分类的存储</h3><p>我们先用CLang命令看下分类的结构和实现，我们新建一个类<code>PrimaryObject</code>以及他的分类<code>PrimaryObject (Demo)</code></p>
<p>.h</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">PrimaryObject</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">PrimaryObject</span> (<span class="title">Demo</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>.m</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">PrimaryObject</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)test &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;PrimaryObject---test&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">PrimaryObject</span> (<span class="title">Demo</span>)</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)test &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;PrimaryObject-Demo---test&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>然后我们对.m文件使用clang命令看下生成的cpp结果,具体命令如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">clang -rewrite-objc MyClass.m</span><br></pre></td></tr></table></figure>

<p>此时会在当前目录下生成一个<code>PrimaryObject.cpp</code>文件，我们来看下这个文件,我们可以通过我们的关键词定位到下面这段代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对象方法列表</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> /*_<span class="title">method_list_t</span>*/ &#123;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> entsize;  <span class="comment">// sizeof(struct _objc_method)</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> method_count;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> _<span class="title">objc_method</span> <span class="title">method_list</span>[1];</span></span><br><span class="line">&#125; _OBJC_$_CATEGORY_INSTANCE_METHODS_PrimaryObject_$_Demo __attribute__ ((used, section (<span class="string">&quot;__DATA,__objc_const&quot;</span>))) = &#123;</span><br><span class="line">  <span class="comment">// 对应结构体中的entsize</span></span><br><span class="line">	<span class="keyword">sizeof</span>(_objc_method),</span><br><span class="line">	<span class="comment">// 对应结构体中的method_count</span></span><br><span class="line">	<span class="number">1</span>,</span><br><span class="line">	<span class="comment">// 对应结构中的_objc_method  方法名 参数</span></span><br><span class="line">	&#123;&#123;(struct objc_selector *)<span class="string">&quot;test&quot;</span>, <span class="string">&quot;v16@0:8&quot;</span>, (<span class="keyword">void</span> *)_I_PrimaryObject_Demo_test&#125;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类方法列表</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> /*_<span class="title">method_list_t</span>*/ &#123;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> entsize;  <span class="comment">// sizeof(struct _objc_method)</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> method_count;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> _<span class="title">objc_method</span> <span class="title">method_list</span>[1];</span></span><br><span class="line">&#125; _OBJC_$_CATEGORY_CLASS_METHODS_PrimaryObject_$_Demo __attribute__ ((used, section (<span class="string">&quot;__DATA,__objc_const&quot;</span>))) = &#123;</span><br><span class="line">  <span class="comment">// 对应结构体中的entsize 与对象方法相同</span></span><br><span class="line">	<span class="keyword">sizeof</span>(_objc_method),</span><br><span class="line">	<span class="comment">// 对应结构体中的method_count</span></span><br><span class="line">	<span class="number">1</span>,</span><br><span class="line">  <span class="comment">// 对应结构中的_objc_method 方法名 参数</span></span><br><span class="line">	&#123;&#123;(struct objc_selector *)<span class="string">&quot;classMethod&quot;</span>, <span class="string">&quot;v16@0:8&quot;</span>, (<span class="keyword">void</span> *)_C_PrimaryObject_Demo_classMethod&#125;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 属性列表</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> /*_<span class="title">prop_list_t</span>*/ &#123;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> entsize;  <span class="comment">// sizeof(struct _prop_t)</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> count_of_properties;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> _<span class="title">prop_t</span> <span class="title">prop_list</span>[1];</span></span><br><span class="line">&#125; _OBJC_$_PROP_LIST_PrimaryObject_$_Demo __attribute__ ((used, section (<span class="string">&quot;__DATA,__objc_const&quot;</span>))) = &#123;</span><br><span class="line">   <span class="comment">// entsize</span></span><br><span class="line">	<span class="keyword">sizeof</span>(<span class="keyword">_prop_t</span>),</span><br><span class="line">	<span class="comment">// count_of_properties</span></span><br><span class="line">	<span class="number">1</span>,</span><br><span class="line">	<span class="comment">// _prop_t</span></span><br><span class="line">	&#123;&#123;<span class="string">&quot;demoCategoryArray&quot;</span>,<span class="string">&quot;T@\&quot;NSArray\&quot;,&amp;,N&quot;</span>&#125;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> __declspec(dllexport) <span class="class"><span class="keyword">struct</span> _<span class="title">class_t</span> <span class="title">OBJC_CLASS_</span>$_<span class="title">PrimaryObject</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个静态分类 结构体 名字为_OBJC_$_CATEGORY+分类名</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> _<span class="title">category_t</span> _<span class="title">OBJC_</span>$_<span class="title">CATEGORY_PrimaryObject_</span>$_<span class="title">Demo</span> __<span class="title">attribute__</span> ((<span class="title">used</span>, <span class="title">section</span> (&quot;__<span class="title">DATA</span>,__<span class="title">objc_const</span>&quot;))) = </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="comment">// 类名</span></span><br><span class="line">	<span class="string">&quot;PrimaryObject&quot;</span>,</span><br><span class="line">	<span class="number">0</span>, <span class="comment">// &amp;OBJC_CLASS_$_PrimaryObject,</span></span><br><span class="line">	<span class="comment">// 对象方法列表</span></span><br><span class="line">	(<span class="keyword">const</span> struct <span class="keyword">_method_list_t</span> *)&amp;_OBJC_$_CATEGORY_INSTANCE_METHODS_PrimaryObject_$_Demo,</span><br><span class="line">	<span class="comment">// 类方法列表</span></span><br><span class="line">	(<span class="keyword">const</span> struct <span class="keyword">_method_list_t</span> *)&amp;_OBJC_$_CATEGORY_CLASS_METHODS_PrimaryObject_$_Demo,</span><br><span class="line">	<span class="number">0</span>,</span><br><span class="line">	<span class="comment">// 属性列表</span></span><br><span class="line">	(<span class="keyword">const</span> struct <span class="keyword">_prop_list_t</span> *)&amp;_OBJC_$_PROP_LIST_PrimaryObject_$_Demo,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> OBJC_CATEGORY_SETUP_$_PrimaryObject_$_Demo(<span class="keyword">void</span> ) &#123;</span><br><span class="line">	_OBJC_$_CATEGORY_PrimaryObject_$_Demo.cls = &amp;OBJC_CLASS_$_PrimaryObject;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> section(<span class="meta-string">&quot;.objc_inithooks$B&quot;</span>, long, read, write)</span></span><br><span class="line"></span><br><span class="line">__declspec(allocate(<span class="string">&quot;.objc_inithooks$B&quot;</span>)) <span class="keyword">static</span> <span class="keyword">void</span> *OBJC_CATEGORY_SETUP[] = &#123;</span><br><span class="line">	(<span class="keyword">void</span> *)&amp;OBJC_CATEGORY_SETUP_$_PrimaryObject_$_Demo,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> _<span class="title">class_t</span> *<span class="title">L_OBJC_LABEL_CLASS_</span>$ [1] __<span class="title">attribute__</span>((<span class="title">used</span>, <span class="title">section</span> (&quot;__<span class="title">DATA</span>, __<span class="title">objc_classlist</span>,<span class="title">regular</span>,<span class="title">no_dead_strip</span>&quot;)))= &#123;</span></span><br><span class="line">	&amp;OBJC_CLASS_$_PrimaryObject,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> _<span class="title">category_t</span> *<span class="title">L_OBJC_LABEL_CATEGORY_</span>$ [1] __<span class="title">attribute__</span>((<span class="title">used</span>, <span class="title">section</span> (&quot;__<span class="title">DATA</span>, __<span class="title">objc_catlist</span>,<span class="title">regular</span>,<span class="title">no_dead_strip</span>&quot;)))= &#123;</span></span><br><span class="line">	&amp;_OBJC_$_CATEGORY_PrimaryObject_$_Demo,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">IMAGE_INFO</span> &#123;</span> <span class="keyword">unsigned</span> version; <span class="keyword">unsigned</span> flag; &#125; _OBJC_IMAGE_INFO = &#123; <span class="number">0</span>, <span class="number">2</span> &#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>首先编译器生成了实例方法列表<code>_OBJC_$_CATEGORY_INSTANCE_METHODS_PrimaryObject_$_Demo</code>和类方法列表<code>_OBJC_$_CATEGORY_CLASS_METHODS_PrimaryObject_$_Demo</code>以及属性列表<code>_OBJC_$_PROP_LIST_PrimaryObject_$_Demo</code>。三者的命名都遵循了公共前缀+类名+category名字的命名方式，而且实例方法列表和类方法列表里面填充的正是我们在Demo这个category里面写的方法<code>classMethod</code>、<code>classMethod</code>，而属性列表里面填充的也正是我们在Demo里添加的<code>demoCategoryArray</code>属性。还有一个需要注意到的事实就是category的名字用来给各种列表以及后面的category结构体本身命名，而且有static来修饰，所以在同一个编译单元里我们的category名不能重复，否则会出现编译错误。</p>
<p>其次，编译器生成了category本身<code>_OBJC_$_CATEGORY_PrimaryObject_$_Demo</code>，并用前面生成的列表来初始化category本身。</p>
<p>最后，编译器在DATA段下的<code>objc_catlist section</code>里保存了一个大小为1的<code>category_t</code>的数组L_OBJC_LABELCATEGORY$，在DATA段下的<code>__objc_classlist section</code>里保存了一个大小为1的<code>_category_t</code>数组<code>L_OBJC_LABEL_CLASS_</code>。</p>
<p>从上面Clang的代码中我们看到，分类的结构是独立于主类存在的，那么分类与主类是怎么关联的呢？分类又是如何加载的呢？</p>
<h3 id="分类的加载"><a href="#分类的加载" class="headerlink" title="分类的加载"></a>分类的加载</h3><p>我们首先看下rumtime的入口方法</p>
<h4 id="objc-init"><a href="#objc-init" class="headerlink" title="_objc_init"></a>_objc_init</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> _objc_init(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">bool</span> initialized = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (initialized) <span class="keyword">return</span>;</span><br><span class="line">    initialized = <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// fixme defer initialization until an objc-using image is found?</span></span><br><span class="line"><span class="comment">//	读取runtime的环境变量，如果需要则打印出来</span></span><br><span class="line">    environ_init();</span><br><span class="line">	</span><br><span class="line">    tls_init();</span><br><span class="line">	<span class="comment">//运行c++ 构造函数</span></span><br><span class="line">    static_init();</span><br><span class="line">	<span class="comment">//lock 初始化 暂时是空的函数</span></span><br><span class="line">    lock_init();</span><br><span class="line">	<span class="comment">//初始化系统异常操作</span></span><br><span class="line">    exception_init();</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 仅供objc运行时使用，注册在映射、取消映射和初始化objc映像调用的处理程序。dyld将使用包含objc-image-info回调给`mapped`.</span></span><br><span class="line"><span class="comment">	 这些dylibs将自动引用计数，因此objc将不再需要调用dlopen()防止未加载。</span></span><br><span class="line"><span class="comment">	 在调用_dyld_objc_notify_register()期间，dyld将调用 `mapped` 在已经加载好 images，稍后dlopen()。</span></span><br><span class="line"><span class="comment">	 在调动init的时候也会调用`mapped`,在dyld调用的时候，也会调用init函数</span></span><br><span class="line"><span class="comment">	 </span></span><br><span class="line"><span class="comment">	 在调用任何images +load方法时候</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    _dyld_objc_notify_register(&amp;map_images, load_images, unmap_image);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>出去上面的init方法我们看到，dyld的朱啊哟做操是调用了<code>_dyld_objc_notify_register</code>方法，我们接着看下这个方法做了什么参数有代表什么意思。</p>
<h4 id="dyld-objc-notify-register"><a href="#dyld-objc-notify-register" class="headerlink" title="_dyld_objc_notify_register"></a>_dyld_objc_notify_register</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 仅供objc运行时使用</span></span><br><span class="line"><span class="comment">// Note: only for use by objc runtime</span></span><br><span class="line"><span class="comment">// 当objc镜像在映射、取消映射、和初始化时注册的事件会被调</span></span><br><span class="line"><span class="comment">// Register handlers to be called when objc images are mapped, unmapped, and initialized.</span></span><br><span class="line"><span class="comment">// Dyld会回调给将mapped函数一组包含objc-image-info段</span></span><br><span class="line"><span class="comment">// Dyld will call back the &quot;mapped&quot; function with an array of images that contain an objc-image-info section.</span></span><br><span class="line"><span class="comment">// 这些dylibs 将自动引用计数，因此objc将不再需要调用dlopen()防止未加载</span></span><br><span class="line"><span class="comment">// Those images that are dylibs will have the ref-counts automatically bumped, so objc will no longer need to</span></span><br><span class="line"><span class="comment">// call dlopen() on them to keep them from being unloaded.  During the call to _dyld_objc_notify_register(),</span></span><br><span class="line"><span class="comment">// 在调用_dyld_objc_notify_register()期间 dyld将调用 `mapped` 在已经加载好 images，稍后dlopen()。</span></span><br><span class="line"><span class="comment">// dyld will call the &quot;mapped&quot; function with already loaded objc images.  During any later dlopen() call,</span></span><br><span class="line"><span class="comment">// 在调动init的时候也会调用`mapped`,在dyld调用的时候，也会调用init函数</span></span><br><span class="line"><span class="comment">// dyld will also call the &quot;mapped&quot; function.  Dyld will call the &quot;init&quot; function when dyld would be called</span></span><br><span class="line"><span class="comment">// 在调用任何images +load方法时候</span></span><br><span class="line"><span class="comment">// initializers in that image.  This is when objc calls any +load methods in that image.</span></span><br><span class="line"><span class="keyword">void</span> _dyld_objc_notify_register(_dyld_objc_notify_mapped    mapped,</span><br><span class="line">                                _dyld_objc_notify_init      init,</span><br><span class="line">                                _dyld_objc_notify_unmapped  unmapped);</span><br></pre></td></tr></table></figure>

<p>总的来说上面这个方法的作用是:<code>向dyld注册监听Mach-O中OC相关section被加载入\载出内存的事件</code>，而具体的事件为:</p>
<ul>
<li>_dyld_objc_notify_mapped  当dyld已将images加载入内存时回调。调用map_images方法</li>
<li>_dyld_objc_notify_init 当dyld初始化image后。OC调用类的+load方法，就是在这时进行的</li>
<li>_dyld_objc_notify_unmapped 当dyld将images移除内存时。调用unmap_image方法</li>
</ul>
<p>我们先来看下第一个方法，上面我们知道这个方法会在dyld将image加到内存中后调用map_images方法：</p>
<h3 id="map-images"><a href="#map-images" class="headerlink" title="map_images"></a>map_images</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// dyld将image加到内存中后调用</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">map_images(<span class="keyword">unsigned</span> count, <span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">const</span> paths[],</span><br><span class="line">           <span class="keyword">const</span> <span class="keyword">struct</span> mach_header * <span class="keyword">const</span> mhdrs[])</span><br><span class="line">&#123;</span><br><span class="line">    mutex_locker_t lock(runtimeLock);</span><br><span class="line">    <span class="keyword">return</span> map_images_nolock(count, paths, mhdrs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们重点看下<code>map_images_nolock</code>方法,因为这里我们主要关注的是分类的加载因此与分类加载无关的代码我们暂时先屏蔽不看</p>
<h4 id="map-images-nolock"><a href="#map-images-nolock" class="headerlink" title="map_images_nolock"></a>map_images_nolock</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> </span><br><span class="line">map_images_nolock(<span class="keyword">unsigned</span> mhCount, <span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">const</span> mhPaths[],</span><br><span class="line">                  <span class="keyword">const</span> <span class="keyword">struct</span> mach_header * <span class="keyword">const</span> mhdrs[])</span><br><span class="line">&#123;   </span><br><span class="line">    <span class="comment">// 当头文件个数大于0调用_read_images方法</span></span><br><span class="line">    <span class="keyword">if</span> (hCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        _read_images(hList, hCount, totalClasses, unoptimizedTotalClasses);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>map_images_nolock</code>方法中主要是调用了<code>_read_images</code>方法 我们来深入的看下这个方法</p>
<h4 id="read-images"><a href="#read-images" class="headerlink" title="_read_images"></a>_read_images</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="keyword">void</span> _read_images(header_info **hList, uint32_t hCount, <span class="keyword">int</span> totalClasses, <span class="keyword">int</span> unoptimizedTotalClasses)</span><br><span class="line">&#123;</span><br><span class="line">    header_info *hi;</span><br><span class="line">    uint32_t hIndex;</span><br><span class="line">    size_t count;</span><br><span class="line">    size_t i;</span><br><span class="line">    Class *resolvedFutureClasses = <span class="literal">nil</span>;</span><br><span class="line">    size_t resolvedFutureClassCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">bool</span> doneOnce;</span><br><span class="line">    TimeLogger ts(PrintImageTimes);</span><br><span class="line"></span><br><span class="line">    runtimeLock.assertLocked();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EACH_HEADER \</span></span><br><span class="line">    hIndex = <span class="number">0</span>;         \</span><br><span class="line">    hIndex &lt; hCount &amp;&amp; (hi = hList[hIndex]); \</span><br><span class="line">    hIndex++</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!doneOnce) &#123;</span><br><span class="line">        doneOnce = <span class="literal">YES</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (DisableTaggedPointers) &#123;</span><br><span class="line">            disableTaggedPointers();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        initializeTaggedPointerObfuscator();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (PrintConnecting) &#123;</span><br><span class="line">            _objc_inform(<span class="string">&quot;CLASS: found %d classes during launch&quot;</span>, totalClasses);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// namedClasses</span></span><br><span class="line">        <span class="comment">// Preoptimized classes don&#x27;t go in this table.</span></span><br><span class="line">        <span class="comment">// 4/3 is NXMapTable&#x27;s load factor</span></span><br><span class="line">        <span class="keyword">int</span> namedClassesSize = </span><br><span class="line">            (isPreoptimized() ? unoptimizedTotalClasses : totalClasses) * <span class="number">4</span> / <span class="number">3</span>;</span><br><span class="line">        gdb_objc_realized_classes =</span><br><span class="line">            NXCreateMapTable(NXStrValueMapPrototype, namedClassesSize);</span><br><span class="line">        </span><br><span class="line">        allocatedClasses = NXCreateHashTable(NXPtrPrototype, <span class="number">0</span>, <span class="literal">nil</span>);</span><br><span class="line">        </span><br><span class="line">        ts.log(<span class="string">&quot;IMAGE TIMES: first time tasks&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Discover classes. Fix up unresolved future classes. Mark bundle classes.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (EACH_HEADER) &#123;</span><br><span class="line">        classref_t *classlist = _getObjc2ClassList(hi, &amp;count);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (! mustReadClasses(hi)) &#123;</span><br><span class="line">            <span class="comment">// Image is sufficiently optimized that we need not call readClass()</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> headerIsBundle = hi-&gt;isBundle();</span><br><span class="line">        <span class="keyword">bool</span> headerIsPreoptimized = hi-&gt;isPreoptimized();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            Class cls = (Class)classlist[i];</span><br><span class="line">            Class newCls = readClass(cls, headerIsBundle, headerIsPreoptimized);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (newCls != cls  &amp;&amp;  newCls) &#123;</span><br><span class="line">                <span class="comment">// Class was moved but not deleted. Currently this occurs </span></span><br><span class="line">                <span class="comment">// only when the new class resolved a future class.</span></span><br><span class="line">                <span class="comment">// Non-lazily realize the class below.</span></span><br><span class="line">                resolvedFutureClasses = (Class *)</span><br><span class="line">                    realloc(resolvedFutureClasses, </span><br><span class="line">                            (resolvedFutureClassCount+<span class="number">1</span>) * <span class="keyword">sizeof</span>(Class));</span><br><span class="line">                resolvedFutureClasses[resolvedFutureClassCount++] = newCls;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ts.log(<span class="string">&quot;IMAGE TIMES: discover classes&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Fix up remapped classes</span></span><br><span class="line">    <span class="comment">// Class list and nonlazy class list remain unremapped.</span></span><br><span class="line">    <span class="comment">// Class refs and super refs are remapped for message dispatching.</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!noClassesRemapped()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (EACH_HEADER) &#123;</span><br><span class="line">            Class *classrefs = _getObjc2ClassRefs(hi, &amp;count);</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">                remapClassRef(&amp;classrefs[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// fixme why doesn&#x27;t test future1 catch the absence of this?</span></span><br><span class="line">            classrefs = _getObjc2SuperRefs(hi, &amp;count);</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">                remapClassRef(&amp;classrefs[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ts.log(<span class="string">&quot;IMAGE TIMES: remap classes&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Fix up @selector references</span></span><br><span class="line">    <span class="keyword">static</span> size_t UnfixedSelectors;</span><br><span class="line">    &#123;</span><br><span class="line">        mutex_locker_t lock(selLock);</span><br><span class="line">        <span class="keyword">for</span> (EACH_HEADER) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hi-&gt;isPreoptimized()) <span class="keyword">continue</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">bool</span> isBundle = hi-&gt;isBundle();</span><br><span class="line">            SEL *sels = _getObjc2SelectorRefs(hi, &amp;count);</span><br><span class="line">            UnfixedSelectors += count;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">                <span class="keyword">const</span> <span class="keyword">char</span> *name = sel_cname(sels[i]);</span><br><span class="line">                sels[i] = sel_registerNameNoLock(name, isBundle);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ts.log(<span class="string">&quot;IMAGE TIMES: fix up selector references&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SUPPORT_FIXUP</span></span><br><span class="line">    <span class="comment">// Fix up old objc_msgSend_fixup call sites</span></span><br><span class="line">    <span class="keyword">for</span> (EACH_HEADER) &#123;</span><br><span class="line">        message_ref_t *refs = _getObjc2MessageRefs(hi, &amp;count);</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (PrintVtables) &#123;</span><br><span class="line">            _objc_inform(<span class="string">&quot;VTABLES: repairing %zu unsupported vtable dispatch &quot;</span></span><br><span class="line">                         <span class="string">&quot;call sites in %s&quot;</span>, count, hi-&gt;fname());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            fixupMessageRef(refs+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ts.log(<span class="string">&quot;IMAGE TIMES: fix up objc_msgSend_fixup&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Discover protocols. Fix up protocol refs.</span></span><br><span class="line">    <span class="keyword">for</span> (EACH_HEADER) &#123;</span><br><span class="line">        <span class="keyword">extern</span> objc_class OBJC_CLASS_$_Protocol;</span><br><span class="line">        Class cls = (Class)&amp;OBJC_CLASS_$_Protocol;</span><br><span class="line">        assert(cls);</span><br><span class="line">        NXMapTable *protocol_map = protocols();</span><br><span class="line">        <span class="keyword">bool</span> isPreoptimized = hi-&gt;isPreoptimized();</span><br><span class="line">        <span class="keyword">bool</span> isBundle = hi-&gt;isBundle();</span><br><span class="line"></span><br><span class="line">        protocol_t **protolist = _getObjc2ProtocolList(hi, &amp;count);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            readProtocol(protolist[i], cls, protocol_map, </span><br><span class="line">                         isPreoptimized, isBundle);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ts.log(<span class="string">&quot;IMAGE TIMES: discover protocols&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Fix up @protocol references</span></span><br><span class="line">    <span class="comment">// Preoptimized images may have the right </span></span><br><span class="line">    <span class="comment">// answer already but we don&#x27;t know for sure.</span></span><br><span class="line">    <span class="keyword">for</span> (EACH_HEADER) &#123;</span><br><span class="line">        protocol_t **protolist = _getObjc2ProtocolRefs(hi, &amp;count);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            remapProtocolRef(&amp;protolist[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ts.log(<span class="string">&quot;IMAGE TIMES: fix up @protocol references&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Realize non-lazy classes (for +load methods and static instances)</span></span><br><span class="line">    <span class="keyword">for</span> (EACH_HEADER) &#123;</span><br><span class="line">        classref_t *classlist = </span><br><span class="line">            _getObjc2NonlazyClassList(hi, &amp;count);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            Class cls = remapClass(classlist[i]);</span><br><span class="line">            <span class="keyword">if</span> (!cls) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// hack for class __ARCLite__, which didn&#x27;t get this above</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> TARGET_OS_SIMULATOR</span></span><br><span class="line">            <span class="keyword">if</span> (cls-&gt;cache._buckets == (<span class="keyword">void</span>*)&amp;_objc_empty_cache  &amp;&amp;  </span><br><span class="line">                (cls-&gt;cache._mask  ||  cls-&gt;cache._occupied)) </span><br><span class="line">            &#123;</span><br><span class="line">                cls-&gt;cache._mask = <span class="number">0</span>;</span><br><span class="line">                cls-&gt;cache._occupied = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cls-&gt;ISA()-&gt;cache._buckets == (<span class="keyword">void</span>*)&amp;_objc_empty_cache  &amp;&amp;  </span><br><span class="line">                (cls-&gt;ISA()-&gt;cache._mask  ||  cls-&gt;ISA()-&gt;cache._occupied)) </span><br><span class="line">            &#123;</span><br><span class="line">                cls-&gt;ISA()-&gt;cache._mask = <span class="number">0</span>;</span><br><span class="line">                cls-&gt;ISA()-&gt;cache._occupied = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">            </span><br><span class="line">            addClassTableEntry(cls);</span><br><span class="line">            realizeClass(cls);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ts.log(<span class="string">&quot;IMAGE TIMES: realize non-lazy classes&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Realize newly-resolved future classes, in case CF manipulates them</span></span><br><span class="line">    <span class="keyword">if</span> (resolvedFutureClasses) &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; resolvedFutureClassCount; i++) &#123;</span><br><span class="line">            realizeClass(resolvedFutureClasses[i]);</span><br><span class="line">            resolvedFutureClasses[i]-&gt;setInstancesRequireRawIsa(<span class="literal">false</span><span class="comment">/*inherited*/</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        free(resolvedFutureClasses);</span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    ts.log(<span class="string">&quot;IMAGE TIMES: realize future classes&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Discover categories.</span></span><br><span class="line">    <span class="comment">// #define EACH_HEADER hIndex = 0; hIndex &lt; hCount &amp;&amp; (hi = hList[hIndex]); hIndex++</span></span><br><span class="line">    <span class="keyword">for</span> (EACH_HEADER) &#123;</span><br><span class="line">        <span class="comment">//GETSECT(_getObjc2CategoryList,        category_t *,    &quot;__objc_catlist&quot;);</span></span><br><span class="line">        <span class="comment">// 从__objc_catlist获取方法列表</span></span><br><span class="line">        category_t **catlist = </span><br><span class="line">            _getObjc2CategoryList(hi, &amp;count);</span><br><span class="line">        <span class="comment">// 是否有分类添加的属性</span></span><br><span class="line">        <span class="keyword">bool</span> hasClassProperties = hi-&gt;info()-&gt;hasCategoryClassProperties();</span><br><span class="line">        <span class="comment">// 遍历所有分类</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            <span class="comment">// 取出每一个分类</span></span><br><span class="line">            category_t *cat = catlist[i];</span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            Class cls = remapClass(cat-&gt;cls);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!cls) &#123;</span><br><span class="line">                <span class="comment">// Category&#x27;s target class is missing (probably weak-linked).</span></span><br><span class="line">                <span class="comment">// Disavow any knowledge of this category.</span></span><br><span class="line">                catlist[i] = <span class="literal">nil</span>;</span><br><span class="line">                <span class="keyword">if</span> (PrintConnecting) &#123;</span><br><span class="line">                    _objc_inform(<span class="string">&quot;CLASS: IGNORING category \?\?\?(%s) %p with &quot;</span></span><br><span class="line">                                 <span class="string">&quot;missing weak-linked target class&quot;</span>, </span><br><span class="line">                                 cat-&gt;name, cat);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Process this category. </span></span><br><span class="line">            <span class="comment">// First, register the category with its target class. </span></span><br><span class="line">            <span class="comment">// Then, rebuild the class&#x27;s method lists (etc) if </span></span><br><span class="line">            <span class="comment">// the class is realized.</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">bool</span> classExists = <span class="literal">NO</span>;</span><br><span class="line">            <span class="comment">// 如果这个类的instanceMethods、protocols、instanceProperties有值</span></span><br><span class="line">            <span class="keyword">if</span> (cat-&gt;instanceMethods ||  cat-&gt;protocols  </span><br><span class="line">                ||  cat-&gt;instanceProperties) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//</span></span><br><span class="line">                addUnattachedCategoryForClass(cat, cls, hi);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (cls-&gt;isRealized()) &#123;</span><br><span class="line">                    remethodizeClass(cls);</span><br><span class="line">                    classExists = <span class="literal">YES</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (PrintConnecting) &#123;</span><br><span class="line">                    _objc_inform(<span class="string">&quot;CLASS: found category -%s(%s) %s&quot;</span>, </span><br><span class="line">                                 cls-&gt;nameForLogging(), cat-&gt;name, </span><br><span class="line">                                 classExists ? <span class="string">&quot;on existing class&quot;</span> : <span class="string">&quot;&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (cat-&gt;classMethods  ||  cat-&gt;protocols  </span><br><span class="line">                ||  (hasClassProperties &amp;&amp; cat-&gt;_classProperties)) </span><br><span class="line">            &#123;</span><br><span class="line">                addUnattachedCategoryForClass(cat, cls-&gt;ISA(), hi);</span><br><span class="line">                <span class="keyword">if</span> (cls-&gt;ISA()-&gt;isRealized()) &#123;</span><br><span class="line">                    remethodizeClass(cls-&gt;ISA());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (PrintConnecting) &#123;</span><br><span class="line">                    _objc_inform(<span class="string">&quot;CLASS: found category +%s(%s)&quot;</span>, </span><br><span class="line">                                 cls-&gt;nameForLogging(), cat-&gt;name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ts.log(<span class="string">&quot;IMAGE TIMES: discover categories&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Category discovery MUST BE LAST to avoid potential races </span></span><br><span class="line">    <span class="comment">// when other threads call the new category code before </span></span><br><span class="line">    <span class="comment">// this thread finishes its fixups.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// +load handled by prepare_load_methods()</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (DebugNonFragileIvars) &#123;</span><br><span class="line">        realizeAllClasses();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> EACH_HEADER</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这段代码中出现频次比较高的是<code>EACH_HEADER</code>显然这是一个for循环中的条件，我们来看下每次循环都做了什么</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (EACH_HEADER) &#123;</span><br><span class="line">        classref_t *classlist = _getObjc2ClassList(hi, &amp;count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (EACH_HEADER) &#123;</span><br><span class="line">            Class *classrefs = _getObjc2ClassRefs(hi, &amp;count);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (EACH_HEADER) &#123;</span><br><span class="line">    SEL *sels = _getObjc2SelectorRefs(hi, &amp;count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (EACH_HEADER) &#123;</span><br><span class="line">        message_ref_t *refs = _getObjc2MessageRefs(hi, &amp;count);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (EACH_HEADER) &#123;</span><br><span class="line">        protocol_t **protolist = _getObjc2ProtocolList(hi, &amp;count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (EACH_HEADER) &#123;</span><br><span class="line">        protocol_t **protolist = _getObjc2ProtocolRefs(hi, &amp;count);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (EACH_HEADER) &#123;</span><br><span class="line">        classref_t *classlist = </span><br><span class="line">            _getObjc2NonlazyClassList(hi, &amp;count);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (EACH_HEADER) &#123;</span><br><span class="line">        category_t **catlist = </span><br><span class="line">            _getObjc2CategoryList(hi, &amp;count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>经过这样的简化后，我们在通过这些循环中调用的方法来判断这些循环中到底做了什么,在找这些方法的时候我们发现这些方法实际上在runtime中有单独的定义的地方</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//      function name                 content type     section name</span></span><br><span class="line">GETSECT(_getObjc2SelectorRefs,        SEL,             <span class="string">&quot;__objc_selrefs&quot;</span>); </span><br><span class="line">GETSECT(_getObjc2MessageRefs,         message_ref_t,   <span class="string">&quot;__objc_msgrefs&quot;</span>); </span><br><span class="line">GETSECT(_getObjc2ClassRefs,           Class,           <span class="string">&quot;__objc_classrefs&quot;</span>);</span><br><span class="line">GETSECT(_getObjc2SuperRefs,           Class,           <span class="string">&quot;__objc_superrefs&quot;</span>);</span><br><span class="line">GETSECT(_getObjc2ClassList,           classref_t,      <span class="string">&quot;__objc_classlist&quot;</span>);</span><br><span class="line">GETSECT(_getObjc2NonlazyClassList,    classref_t,      <span class="string">&quot;__objc_nlclslist&quot;</span>);</span><br><span class="line">GETSECT(_getObjc2CategoryList,        category_t *,    <span class="string">&quot;__objc_catlist&quot;</span>);</span><br><span class="line">GETSECT(_getObjc2NonlazyCategoryList, category_t *,    <span class="string">&quot;__objc_nlcatlist&quot;</span>);</span><br><span class="line">GETSECT(_getObjc2ProtocolList,        protocol_t *,    <span class="string">&quot;__objc_protolist&quot;</span>);</span><br><span class="line">GETSECT(_getObjc2ProtocolRefs,        protocol_t *,    <span class="string">&quot;__objc_protorefs&quot;</span>);</span><br><span class="line">GETSECT(getLibobjcInitializers,       UnsignedInitializer, <span class="string">&quot;__objc_init_func&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>这实际上是rumtime是根据Mach-O各个section的信息来初始化其自身，结合上面我们说过分类的结构体和分类中的对象方法被添加到<code>__DATA__</code>下的<code>__objc_catlist</code>中，类方法被添加到<code>__objc_classlist</code>中，而属性则是被添加到<code>__objc_const</code>中。</p>
<p>下面我们先来看下<code>__objc_catlist</code>,同时我们定位到对应的for循环</p>
<h4 id="objc-catlist"><a href="#objc-catlist" class="headerlink" title="__objc_catlist"></a>__objc_catlist</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">    <span class="comment">// 遍历所有分类</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="comment">// 取出每一个分类</span></span><br><span class="line">        category_t *cat = catlist[i];</span><br><span class="line">        <span class="comment">// 调用remapClass(cat-&gt;cls)，并返回一个objc_class *对象cls。这一步的目的在于找到到category对应的类对象cls</span></span><br><span class="line">        Class cls = remapClass(cat-&gt;cls);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!cls) &#123;</span><br><span class="line">            <span class="comment">// Category&#x27;s target class is missing (probably weak-linked).</span></span><br><span class="line">            <span class="comment">// Disavow any knowledge of this category.</span></span><br><span class="line">            catlist[i] = <span class="literal">nil</span>;</span><br><span class="line">            <span class="keyword">if</span> (PrintConnecting) &#123;</span><br><span class="line">                _objc_inform(<span class="string">&quot;CLASS: IGNORING category \?\?\?(%s) %p with &quot;</span></span><br><span class="line">                             <span class="string">&quot;missing weak-linked target class&quot;</span>, </span><br><span class="line">                             cat-&gt;name, cat);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> classExists = <span class="literal">NO</span>;</span><br><span class="line">        <span class="comment">// 如果这个类的instanceMethods、protocols、instanceProperties有值</span></span><br><span class="line">        <span class="comment">// 如果Category中有实例方法，协议，实例属性，会改写target class的结构</span></span><br><span class="line">        <span class="keyword">if</span> (cat-&gt;instanceMethods ||  cat-&gt;protocols  </span><br><span class="line">            ||  cat-&gt;instanceProperties) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            addUnattachedCategoryForClass(cat, cls, hi);</span><br><span class="line">            <span class="comment">//修改class的method list结构</span></span><br><span class="line">            <span class="keyword">if</span> (cls-&gt;isRealized()) &#123;</span><br><span class="line">                remethodizeClass(cls);</span><br><span class="line">                classExists = <span class="literal">YES</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (PrintConnecting) &#123;</span><br><span class="line">                _objc_inform(<span class="string">&quot;CLASS: found category -%s(%s) %s&quot;</span>, </span><br><span class="line">                             cls-&gt;nameForLogging(), cat-&gt;name, </span><br><span class="line">                             classExists ? <span class="string">&quot;on existing class&quot;</span> : <span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果category中有类方法，协议，或类属性(目前OC版本不支持类属性), 会改写target class的元类结构</span></span><br><span class="line">        <span class="keyword">if</span> (cat-&gt;classMethods  ||  cat-&gt;protocols  </span><br><span class="line">            ||  (hasClassProperties &amp;&amp; cat-&gt;_classProperties)) </span><br><span class="line">        &#123;</span><br><span class="line">            addUnattachedCategoryForClass(cat, cls-&gt;ISA(), hi);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 修改class的method list结构</span></span><br><span class="line">            <span class="keyword">if</span> (cls-&gt;ISA()-&gt;isRealized()) &#123;</span><br><span class="line">                remethodizeClass(cls-&gt;ISA());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (PrintConnecting) &#123;</span><br><span class="line">                _objc_inform(<span class="string">&quot;CLASS: found category +%s(%s)&quot;</span>, </span><br><span class="line">                             cls-&gt;nameForLogging(), cat-&gt;name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不管是在分类中添加的是对象方法还是类方法，我们发现实际上调用的都是<code>addUnattachedCategoryForClass</code>方法，那么我们看下这个方法是如何实现的呢？</p>
<h4 id="addUnattachedCategoryForClass"><a href="#addUnattachedCategoryForClass" class="headerlink" title="addUnattachedCategoryForClass"></a>addUnattachedCategoryForClass</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 把类和category做一个关联映射</span></span><br><span class="line"><span class="comment">//  category_t *cat 分类</span></span><br><span class="line"><span class="comment">//  Class cls 原始类</span></span><br><span class="line"><span class="comment">//  header_info *catHeader 分类头信息</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> addUnattachedCategoryForClass(category_t *cat, Class cls, </span><br><span class="line">                                          header_info *catHeader)</span><br><span class="line">&#123;</span><br><span class="line">    runtimeLock.assertLocked();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// DO NOT use cat-&gt;cls! cls may be cat-&gt;cls-&gt;isa instead</span></span><br><span class="line">    <span class="comment">// 初始化一个分类表(这里是一个table)</span></span><br><span class="line">    NXMapTable *cats = unattachedCategories();</span><br><span class="line">    <span class="comment">// 分类list</span></span><br><span class="line">    category_list *list;</span><br><span class="line">    <span class="comment">// 获取原始类cls元有的分类表</span></span><br><span class="line">    list = (category_list *)NXMapGet(cats, cls);</span><br><span class="line">    <span class="comment">// 如果之前没有 那么新建</span></span><br><span class="line">    <span class="keyword">if</span> (!list) &#123;</span><br><span class="line">        list = (category_list *)</span><br><span class="line">            calloc(<span class="keyword">sizeof</span>(*list) + <span class="keyword">sizeof</span>(list-&gt;list[<span class="number">0</span>]), <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果之前已经有了 那么扩容list-&gt;count + 1</span></span><br><span class="line">        list = (category_list *)</span><br><span class="line">            realloc(list, <span class="keyword">sizeof</span>(*list) + <span class="keyword">sizeof</span>(list-&gt;list[<span class="number">0</span>]) * (list-&gt;count + <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将这个分类的信息放到与原始类相关的表中</span></span><br><span class="line">    list-&gt;list[list-&gt;count++] = (locstamped_category_t)&#123;cat, catHeader&#125;;</span><br><span class="line"></span><br><span class="line">    NXMapInsert(cats, cls, list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将分类与原始类做了映射后，都调用<code>remethodizeClass</code>方法，我们看下这个方法做了什么</p>
<h4 id="remethodizeClass"><a href="#remethodizeClass" class="headerlink" title="remethodizeClass"></a>remethodizeClass</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> remethodizeClass(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    category_list *cats;</span><br><span class="line">    <span class="keyword">bool</span> isMeta;</span><br><span class="line"></span><br><span class="line">    runtimeLock.assertLocked();</span><br><span class="line"></span><br><span class="line">    isMeta = cls-&gt;isMetaClass();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取出还未被附加到class上的category list</span></span><br><span class="line">    <span class="keyword">if</span> ((cats = unattachedCategoriesForClass(cls, <span class="literal">false</span><span class="comment">/*not realizing*/</span>))) &#123;</span><br><span class="line">        <span class="keyword">if</span> (PrintConnecting) &#123;</span><br><span class="line">            _objc_inform(<span class="string">&quot;CLASS: attaching categories to class &#x27;%s&#x27; %s&quot;</span>, </span><br><span class="line">                         cls-&gt;nameForLogging(), isMeta ? <span class="string">&quot;(meta)&quot;</span> : <span class="string">&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将category附加到class上</span></span><br><span class="line">        attachCategories(cls, cats, <span class="literal">true</span> <span class="comment">/*flush caches*/</span>);        </span><br><span class="line">        free(cats);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这个方法，我们看到runtime会首先通过unattachedCategoriesForClass 取出还未被附加到class上的category list，然后调用attachCategories将这些category附加到class上。</p>
<p>所以主要的逻辑在<code>attachCategories</code>中，我们来看下这个方法</p>
<h4 id="attachCategories"><a href="#attachCategories" class="headerlink" title="attachCategories"></a>attachCategories</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 链接 分类中的 方法列表 属性和协议 到类中</span></span><br><span class="line"><span class="comment">// Class cls  原始类</span></span><br><span class="line"><span class="comment">// category_list *cats 分类列表</span></span><br><span class="line"><span class="comment">// bool flush_caches 是否需要刷新缓存</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> </span><br><span class="line">attachCategories(Class cls, category_list *cats, <span class="keyword">bool</span> flush_caches)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!cats) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (PrintReplacedMethods) printReplacements(cls, cats);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> isMeta = cls-&gt;isMetaClass();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// fixme rearrange to remove these intermediate allocations</span></span><br><span class="line">    <span class="comment">// 首先分配method_list_t *， property_list_t *， protocol_list_t *的数组空间，数组大小等于category的个数</span></span><br><span class="line">    <span class="comment">//方法数组 二维数组 每个分类的方法是数组中的一个元素 每个分类可能有多个方法</span></span><br><span class="line">    method_list_t **mlists = (method_list_t **)</span><br><span class="line">        malloc(cats-&gt;count * <span class="keyword">sizeof</span>(*mlists));</span><br><span class="line">	<span class="comment">//属性数组</span></span><br><span class="line">    property_list_t **proplists = (property_list_t **)</span><br><span class="line">        malloc(cats-&gt;count * <span class="keyword">sizeof</span>(*proplists));</span><br><span class="line">	<span class="comment">//协议数组</span></span><br><span class="line">    protocol_list_t **protolists = (protocol_list_t **)</span><br><span class="line">        malloc(cats-&gt;count * <span class="keyword">sizeof</span>(*protolists));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Count backwards through cats to get newest categories first</span></span><br><span class="line">    <span class="keyword">int</span> mcount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> propcount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> protocount = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// i表示分类的个数</span></span><br><span class="line">    <span class="keyword">int</span> i = cats-&gt;count;</span><br><span class="line">    <span class="keyword">bool</span> fromBundle = <span class="literal">NO</span>;</span><br><span class="line">    <span class="comment">//依次读取每一个category，将其methods，property，protocol添加到mlists，proplist，protolist中存储</span></span><br><span class="line">    <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">		<span class="comment">//取出某个分类</span></span><br><span class="line">        auto&amp; entry = cats-&gt;list[i];</span><br><span class="line">        <span class="comment">//取出分类 的 对象方法或者类方法</span></span><br><span class="line">        method_list_t *mlist = entry.cat-&gt;methodsForMeta(isMeta);</span><br><span class="line">        <span class="comment">// 将方法列表加入都mlists中(注意mlist本身也是个数组) 因此mlists是一个二维数组</span></span><br><span class="line">        <span class="keyword">if</span> (mlist) &#123;</span><br><span class="line">            mlists[mcount++] = mlist; <span class="comment">//mlists 接受所有分类方法</span></span><br><span class="line">            fromBundle |= entry.hi-&gt;isBundle();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//proplist 所有分类属性</span></span><br><span class="line">        property_list_t *proplist = </span><br><span class="line">            entry.cat-&gt;propertiesForMeta(isMeta, entry.hi);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (proplist) &#123;</span><br><span class="line">            proplists[propcount++] = proplist;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//proplist 所有协议方法</span></span><br><span class="line">        protocol_list_t *protolist = entry.cat-&gt;protocols;</span><br><span class="line">        <span class="keyword">if</span> (protolist) &#123;</span><br><span class="line">            protolists[protocount++] = protolist;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取出class的data()数据，其实是class_rw_t * 指针，其对应结构体实例存储了class的基本信息</span></span><br><span class="line">    auto rw = cls-&gt;data();</span><br><span class="line"></span><br><span class="line">    prepareMethodLists(cls, mlists, mcount, <span class="literal">NO</span>, fromBundle);</span><br><span class="line">	<span class="comment">//将category中的method 添加到class中</span></span><br><span class="line">    rw-&gt;methods.attachLists(mlists, mcount);</span><br><span class="line">	<span class="comment">//释放数组</span></span><br><span class="line">    free(mlists);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果需要，同时刷新class的method list cache</span></span><br><span class="line">    <span class="keyword">if</span> (flush_caches  &amp;&amp;  mcount &gt; <span class="number">0</span>) flushCaches(cls);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将category的property添加到class中</span></span><br><span class="line">    rw-&gt;properties.attachLists(proplists, propcount);</span><br><span class="line">    <span class="comment">//释放数组</span></span><br><span class="line">    free(proplists);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将category的protocol添加到class中</span></span><br><span class="line">    rw-&gt;protocols.attachLists(protolists, protocount);</span><br><span class="line">    <span class="comment">//释放数组</span></span><br><span class="line">    free(protolists);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>attachCategories</code>对类和元类都生效，即不论我们是向类对象中添加对象方法还是向元类中添加类方法都是调用<code>attachCategories</code>方法，在方法中我们明确的看到<code>方法</code>，<code>属性</code>，<code>协议</code>分别添加到原始类的列表中，当然我们还发现不管是方法属性还是协议我们调用的都是<code>attachLists</code>方法，下面我们来进一步看看这个方法。</p>
<p>在分析<code>attachLists</code>方法之前我们先看下<code>方法</code>，<code>属性</code>，<code>协议</code>对应的类型：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">struct</span> class_rw_t &#123;</span><br><span class="line">    method_array_t methods;<span class="comment">//方法列表</span></span><br><span class="line">    property_array_t properties;<span class="comment">//属性列表</span></span><br><span class="line">    protocol_array_t protocols;<span class="comment">//协议列表</span></span><br></pre></td></tr></table></figure>

<p>但实际上<code>method_array_t</code>,<code>property_array_t</code>,<code>protocol_array_t</code>都是对<code>list_array_tt</code>类型的包装。而<code>attachLists</code>刚好是<code>list_array_tt</code>中的方法。</p>
<h4 id="attachLists"><a href="#attachLists" class="headerlink" title="attachLists"></a>attachLists</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// 要添加的list 要添加的个数</span></span><br><span class="line">    <span class="keyword">void</span> attachLists(List* <span class="keyword">const</span> * addedLists, uint32_t addedCount) &#123;</span><br><span class="line">        <span class="keyword">if</span> (addedCount == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (hasArray()) &#123;</span><br><span class="line">            <span class="comment">// 就list的个数</span></span><br><span class="line">            uint32_t oldCount = array()-&gt;count;</span><br><span class="line">			<span class="comment">// 添加后list的个数</span></span><br><span class="line">            uint32_t newCount = oldCount + addedCount;</span><br><span class="line">			<span class="comment">//分配内存 内存不够用了，需要扩容</span></span><br><span class="line">            setArray((array_t *)realloc(array(), array_t::byteSize(newCount)));</span><br><span class="line">			<span class="comment">//赋值count</span></span><br><span class="line">            array()-&gt;count = newCount;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// array()-&gt;lists：原来的方法列表向后移动 oldCount * sizeof(array()-&gt;lists[0]个长度</span></span><br><span class="line">            memmove(array()-&gt;lists + addedCount<span class="comment">/*数组末尾*/</span>, array()-&gt;lists<span class="comment">/*数组*/</span>,</span><br><span class="line">                    oldCount * <span class="keyword">sizeof</span>(array()-&gt;lists[<span class="number">0</span>])<span class="comment">/*移动的大小*/</span>);</span><br><span class="line"></span><br><span class="line">			<span class="comment">//空出来的 内存使用addedLists拷贝过去 大小是:addedCount * sizeof(array()-&gt;lists[0])</span></span><br><span class="line">            memcpy(array()-&gt;lists, addedLists, </span><br><span class="line">                   addedCount * <span class="keyword">sizeof</span>(array()-&gt;lists[<span class="number">0</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果list为空 且要添加的个数为1 那么直接设置</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!list  &amp;&amp;  addedCount == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 0 lists -&gt; 1 list</span></span><br><span class="line">            list = addedLists[<span class="number">0</span>];</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果要添加的个数大于1个</span></span><br><span class="line">            List* oldList = list;</span><br><span class="line">            <span class="comment">// 就数据个数</span></span><br><span class="line">            uint32_t oldCount = oldList ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 更新后的数组元素个数</span></span><br><span class="line">            uint32_t newCount = oldCount + addedCount;</span><br><span class="line">            <span class="comment">// 分配内存空间 这时候空间所有数据为空</span></span><br><span class="line">            setArray((array_t *)malloc(array_t::byteSize(newCount)));</span><br><span class="line">            <span class="comment">// 更新数据个数</span></span><br><span class="line">            array()-&gt;count = newCount;</span><br><span class="line">            <span class="comment">// 如果有旧的</span></span><br><span class="line">            <span class="keyword">if</span> (oldList)</span><br><span class="line">                <span class="comment">// 将旧的数据放在了数组的addedCount的位置</span></span><br><span class="line">                <span class="comment">// 前面addedCount个位置是为了给addedLists保留</span></span><br><span class="line">                array()-&gt;lists[addedCount] = oldList;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将addedLists拷贝到数组的0-addedCount的位置</span></span><br><span class="line">            memcpy(array()-&gt;lists, addedLists, </span><br><span class="line">                   addedCount * <span class="keyword">sizeof</span>(array()-&gt;lists[<span class="number">0</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// memmove ：内存移动。</span></span><br><span class="line"><span class="comment">/*  __dst : 移动内存的目的地</span></span><br><span class="line"><span class="comment">*   __src : 被移动的内存首地址</span></span><br><span class="line"><span class="comment">*   __len : 被移动的内存长度</span></span><br><span class="line"><span class="comment">*   将__src的内存移动__len块内存到__dst中</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">void</span>    *memmove(<span class="keyword">void</span> *__dst, <span class="keyword">const</span> <span class="keyword">void</span> *__src, size_t __len);</span><br><span class="line"></span><br><span class="line"><span class="comment">// memcpy ：内存拷贝。</span></span><br><span class="line"><span class="comment">/*  __dst : 拷贝内存的拷贝目的地</span></span><br><span class="line"><span class="comment">*   __src : 被拷贝的内存首地址</span></span><br><span class="line"><span class="comment">*   __n : 被移动的内存长度</span></span><br><span class="line"><span class="comment">*   将__src的内存移动__n块内存到__dst中</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">void</span>    *memcpy(<span class="keyword">void</span> *__dst, <span class="keyword">const</span> <span class="keyword">void</span> *__src, size_t __n);</span><br></pre></td></tr></table></figure>

<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gi0viqko2dj30os09pgm9.jpg"></p>
<p>结合上图，我们发现将新的list插入到原有list的方式是：<code>头部插入</code>，结合方法调用的时候查找元类或者类对象的方法列表来调用，我们知道，分类的方法是会覆盖原始类的方法。这也从侧面证实了这一点。</p>
<p>上面的代码我们看到，无论是方法列表还是属性列表或者是协议列表我们都会添加到原始类对应的列表中，但是在实际使用中，我们都知道分类是无法添加属性的,这又是为什么呢？</p>
<p><code>注意</code>:上面的这句描述实际上是有问题的，准确的描述应该是分类可以添加属性但是系统不会为这个属性动态添加setter和getter方法(以及创建一个以_开头的实例变量)。</p>
<h3 id="AssociatedObject"><a href="#AssociatedObject" class="headerlink" title="AssociatedObject"></a>AssociatedObject</h3><p>不过runtime还是提供了关联属性的方法，让我们可以在分类中添加属性(实例变量+getter+setter),下面我们来看下关联属性的实现：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">id</span> objc_getAssociatedObject(<span class="keyword">id</span> object, <span class="keyword">const</span> <span class="keyword">void</span> *key) &#123;</span><br><span class="line">    <span class="keyword">return</span> _object_get_associative_reference(object, (<span class="keyword">void</span> *)key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> objc_setAssociatedObject(<span class="keyword">id</span> object, <span class="keyword">const</span> <span class="keyword">void</span> *key, <span class="keyword">id</span> value, objc_AssociationPolicy policy) &#123;</span><br><span class="line">    _object_set_associative_reference(object, (<span class="keyword">void</span> *)key, value, policy);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> objc_removeAssociatedObjects(<span class="keyword">id</span> object) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (object &amp;&amp; object-&gt;hasAssociatedObjects()) &#123;</span><br><span class="line">        _object_remove_assocations(object);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在看这几个方法的具体实现之前，我们先看下<code>policy</code>参数的值</p>
<h4 id="objc-AssociationPolicy"><a href="#objc-AssociationPolicy" class="headerlink" title="objc_AssociationPolicy"></a>objc_AssociationPolicy</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> OBJC_ENUM(uintptr_t, objc_AssociationPolicy) &#123;</span><br><span class="line">    <span class="comment">/**&lt; Specifies a weak reference to the associated object. */</span></span><br><span class="line">    OBJC_ASSOCIATION_ASSIGN = <span class="number">0</span>,           </span><br><span class="line">    <span class="comment">/**&lt; Specifies a strong reference to the associated object. </span></span><br><span class="line"><span class="comment">    *   The association is not made atomically. */</span></span><br><span class="line">    OBJC_ASSOCIATION_RETAIN_NONATOMIC = <span class="number">1</span>, </span><br><span class="line">    <span class="comment">/**&lt; Specifies that the associated object is copied. </span></span><br><span class="line"><span class="comment">    *   The association is not made atomically. */</span></span><br><span class="line">    OBJC_ASSOCIATION_COPY_NONATOMIC = <span class="number">3</span>,</span><br><span class="line">    <span class="comment">/**&lt; Specifies a strong reference to the associated object.</span></span><br><span class="line"><span class="comment">    *   The association is made atomically. */</span></span><br><span class="line">    OBJC_ASSOCIATION_RETAIN = <span class="number">01401</span>,    </span><br><span class="line">    <span class="comment">/**&lt; Specifies that the associated object is copied.</span></span><br><span class="line"><span class="comment">    *   The association is made atomically. */</span>   </span><br><span class="line">    OBJC_ASSOCIATION_COPY = <span class="number">01403</span>          </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>下面我们依次看下这三个方法，首先<code>_object_set_associative_reference</code>设置关联属性。</p>
<h4 id="object-set-associative-reference"><a href="#object-set-associative-reference" class="headerlink" title="_object_set_associative_reference"></a>_object_set_associative_reference</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置关联对象的值</span></span><br><span class="line"><span class="comment">// object 目标对象</span></span><br><span class="line"><span class="comment">// 关联对象的key</span></span><br><span class="line"><span class="comment">// 关联对象的值</span></span><br><span class="line"><span class="comment">// 关联策略</span></span><br><span class="line"><span class="keyword">void</span> _object_set_associative_reference(<span class="keyword">id</span> object, <span class="keyword">void</span> *key, <span class="keyword">id</span> value, uintptr_t policy) &#123;</span><br><span class="line">    <span class="comment">// retain the new value (if any) outside the lock.</span></span><br><span class="line">    ObjcAssociation old_association(<span class="number">0</span>, <span class="literal">nil</span>);</span><br><span class="line">	<span class="comment">//获取new_value的值</span></span><br><span class="line">    <span class="comment">// acquireValue根据policy== OBJC_ASSOCIATION_SETTER_COPY 或者OBJC_ASSOCIATION_SETTER_RETAIN</span></span><br><span class="line">    <span class="comment">// 判断是要进行retain操作还是copy操作</span></span><br><span class="line">    <span class="keyword">id</span> new_value = value ? acquireValue(value, policy) : <span class="literal">nil</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        AssociationsManager manager;</span><br><span class="line">		<span class="comment">//生成一个全局的 HashMap</span></span><br><span class="line">        AssociationsHashMap &amp;associations(manager.associations());</span><br><span class="line">        disguised_ptr_t disguised_object = DISGUISE(object);</span><br><span class="line">		<span class="comment">//newValue存在 需要更新</span></span><br><span class="line">        <span class="keyword">if</span> (new_value) &#123;</span><br><span class="line">            <span class="comment">// 遍历 hashMap是否有该obj</span></span><br><span class="line">            AssociationsHashMap::iterator i = associations.find(disguised_object);</span><br><span class="line">            <span class="comment">// 遍历</span></span><br><span class="line">            <span class="keyword">if</span> (i != associations.end()) &#123;</span><br><span class="line">				<span class="comment">//这个对象有关联对象 注意这里取出的并不是某个对象 而是一个哈希表</span></span><br><span class="line">                ObjectAssociationMap *refs = i-&gt;second;</span><br><span class="line">                <span class="comment">// 根据key找到对应的关联对象</span></span><br><span class="line">                ObjectAssociationMap::iterator j = refs-&gt;find(key);</span><br><span class="line">                <span class="comment">// 遍历根据key的查找结果</span></span><br><span class="line">                <span class="keyword">if</span> (j != refs-&gt;end()) &#123;</span><br><span class="line">                    <span class="comment">// 如果找到了 更新值</span></span><br><span class="line">                    old_association = j-&gt;second;</span><br><span class="line">                    j-&gt;second = ObjcAssociation(policy, new_value);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 如果找到最后仍然没有找到 那么新增插入</span></span><br><span class="line">                    (*refs)[key] = ObjcAssociation(policy, new_value);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">//如果这个对象之前就没有关联对象 那么新建</span></span><br><span class="line">                ObjectAssociationMap *refs = new ObjectAssociationMap;</span><br><span class="line">                associations[disguised_object] = refs;</span><br><span class="line">                (*refs)[key] = ObjcAssociation(policy, new_value);</span><br><span class="line">                object-&gt;setHasAssociatedObjects();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果传入的关联对象值为nil，则断开关联</span></span><br><span class="line">            AssociationsHashMap::iterator i = associations.find(disguised_object);</span><br><span class="line">            <span class="keyword">if</span> (i !=  associations.end()) &#123;</span><br><span class="line">                ObjectAssociationMap *refs = i-&gt;second;</span><br><span class="line">                ObjectAssociationMap::iterator j = refs-&gt;find(key);</span><br><span class="line">                <span class="keyword">if</span> (j != refs-&gt;end()) &#123;</span><br><span class="line">                    old_association = j-&gt;second;</span><br><span class="line">                    refs-&gt;erase(j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 释放旧值</span></span><br><span class="line">    <span class="keyword">if</span> (old_association.hasValue()) ReleaseValue()(old_association);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大概的流程是:</p>
<ul>
<li>根据关联的policy，调用id new_value = value ? acquireValue(value, policy) : nil; ，acquireValue 方法会根据poilcy是retain或copy，对value做引用+1操作或copy操作，并返回对应的new_value。（如果传入的value为nil，则返回nil，不做任何操作）</li>
<li>获取到new_value 后，根据是否有new_value的值。如果 new_value 存在，则对象与目标对象关联。实质是存入到全局单例 AssociationsManager manager 的对象关联表中。 如果new_value 不存在，则释放掉之前目标对象及关联 key所存储的关联对象。实质是在 AssociationsManager 中删除掉关联对象。</li>
<li>最后，释放掉之前以同样key存储的关联对象</li>
</ul>
<p>从上面的代码中我们看到所有对象的关联属性实际上都存放在一个全局的静态哈希表中<code> static AssociationsHashMap *_map;</code> 然后分别根据对象地址取出对象所有的关联属性，进而根据key去获取对应的关联对象。大致结构如下图：</p>
<p><img src="http://vanney9.com/lionheart/1706/association.png"></p>
<p>接着我们在来看下获取的方法即<code>_object_get_associative_reference</code>方法：</p>
<h4 id="object-get-associative-reference"><a href="#object-get-associative-reference" class="headerlink" title="_object_get_associative_reference"></a>_object_get_associative_reference</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取一个已关联的对象</span></span><br><span class="line"><span class="keyword">id</span> _object_get_associative_reference(<span class="keyword">id</span> object, <span class="keyword">void</span> *key) &#123;</span><br><span class="line">    <span class="keyword">id</span> value = <span class="literal">nil</span>;</span><br><span class="line">    uintptr_t policy = OBJC_ASSOCIATION_ASSIGN;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 可以把manager理解为一个单例 实际上是一个静态变量</span></span><br><span class="line">        AssociationsManager manager;</span><br><span class="line">		<span class="comment">//初始化 _map = AssociationsHashMap</span></span><br><span class="line">        AssociationsHashMap &amp;associations(manager.associations());</span><br><span class="line">        <span class="comment">// 取反object 地址 作为accociative key</span></span><br><span class="line">        disguised_ptr_t disguised_object = DISGUISE(object);</span><br><span class="line">        <span class="comment">// 在关联对象海西表中 找到与disguised_object关联的所有对象</span></span><br><span class="line">        AssociationsHashMap::iterator i = associations.find(disguised_object);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历这个哈希表</span></span><br><span class="line">        <span class="keyword">if</span> (i != associations.end()) &#123;</span><br><span class="line">            <span class="comment">// 取出当前的这个关联对象</span></span><br><span class="line">            ObjectAssociationMap *refs = i-&gt;second;</span><br><span class="line">            <span class="comment">// 根据key查找对应的关联对象 有可能存在多个</span></span><br><span class="line">            ObjectAssociationMap::iterator j = refs-&gt;find(key);</span><br><span class="line">            <span class="comment">// 遍历查找结果</span></span><br><span class="line">            <span class="keyword">if</span> (j != refs-&gt;end()) &#123;</span><br><span class="line">                <span class="comment">// 取出关联实体</span></span><br><span class="line">                ObjcAssociation &amp;entry = j-&gt;second;</span><br><span class="line">                value = entry.value();</span><br><span class="line">                policy = entry.policy();</span><br><span class="line">                <span class="keyword">if</span> (policy &amp; OBJC_ASSOCIATION_GETTER_RETAIN) &#123;</span><br><span class="line">                    objc_retain(value);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果policy = OBJC_ASSOCIATION_GETTER_AUTORELEASE</span></span><br><span class="line">    <span class="keyword">if</span> (value &amp;&amp; (policy &amp; OBJC_ASSOCIATION_GETTER_AUTORELEASE)) &#123;</span><br><span class="line">        objc_autorelease(value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结合上面图中的存储结构，get方法的流程为：</p>
<ul>
<li><p>根据对象地址获取该对象所有的关联属性<br>  AssociationsHashMap::iterator i = associations.find(disguised_object);</p>
</li>
<li><p>根据关联对象的key获取到具体的关联对象并返回 同时根据该关联对象的策略 判断是否需要retain</p>
</li>
</ul>
<p>紧接着我们再来看下释放的方法<code>objc_removeAssociatedObjects</code>,首先我们先搜索一下这个方法的调用时机，</p>
<h4 id="objc-destructInstance"><a href="#objc-destructInstance" class="headerlink" title="objc_destructInstance"></a>objc_destructInstance</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> *objc_destructInstance(<span class="keyword">id</span> obj) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj) &#123;</span><br><span class="line">        Class isa = obj-&gt;getIsa();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isa-&gt;hasCxxDtor()) &#123;</span><br><span class="line">            object_cxxDestruct(obj);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isa-&gt;instancesHaveAssociatedObjects()) &#123;</span><br><span class="line">            _object_remove_assocations(obj);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        objc_clear_deallocating(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>objc_destructInstance方法是对象在被释放时调用的，那么<code>objc_removeAssociatedObjects</code>的时机就是在对象被释放时，如果发现这个对象有关联对象那么就去释放这个对象的关联对象。</p>
<p>具体的释放方法如下:</p>
<h4 id="object-remove-assocations"><a href="#object-remove-assocations" class="headerlink" title="_object_remove_assocations"></a>_object_remove_assocations</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对象释放时移除所有的关联属性</span></span><br><span class="line"><span class="keyword">void</span> _object_remove_assocations(<span class="keyword">id</span> object) &#123;</span><br><span class="line">    vector&lt; ObjcAssociation,ObjcAllocator&lt;ObjcAssociation&gt; &gt; elements;</span><br><span class="line">    &#123;</span><br><span class="line">        AssociationsManager manager;</span><br><span class="line">        AssociationsHashMap &amp;associations(manager.associations());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (associations.size() == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        disguised_ptr_t disguised_object = DISGUISE(object);</span><br><span class="line">        <span class="comment">// 根据对象地址取出所有的关联对象</span></span><br><span class="line">        AssociationsHashMap::iterator i = associations.find(disguised_object);</span><br><span class="line">        <span class="keyword">if</span> (i != associations.end()) &#123;</span><br><span class="line">            <span class="comment">// 拷贝所有的关联关系</span></span><br><span class="line">            ObjectAssociationMap *refs = i-&gt;second;</span><br><span class="line">            <span class="keyword">for</span> (ObjectAssociationMap::iterator j = refs-&gt;begin(), end = refs-&gt;end(); j != end; ++j) &#123;</span><br><span class="line">                <span class="comment">// 记录所有的关联对象到elements</span></span><br><span class="line">                elements.push_back(j-&gt;second);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 删除refs 删除这个对象的所有关联对象</span></span><br><span class="line">            delete refs;</span><br><span class="line">            <span class="comment">// 清除关联关系</span></span><br><span class="line">            associations.erase(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// elements数组中的所有元素执行ReleaseValue操作</span></span><br><span class="line">    for_each(elements.begin(), elements.end(), ReleaseValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>删除关联对象的时候，我们实际上是将某个对象的所有关联对象放到一个数组中，先清除关联关系和，然后在对数组中的所有元素执行release操作。</p>
<p>通过上面的讲述，我们知道了分类方法是如何被添加到原始类的方法列表、属性列表、协议列表中的。而且添加的时机为<code>map_images</code>(参考前面讲述的_objc_init方法)。</p>
<p>那么我们接着看<code>map_images</code>方法执行后会继续执行<code>load_images</code>,<code>unmap_image</code>方法，</p>
<h3 id="load-images"><a href="#load-images" class="headerlink" title="load_images"></a>load_images</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">load_images(<span class="keyword">const</span> <span class="keyword">char</span> *path __unused, <span class="keyword">const</span> <span class="keyword">struct</span> mach_header *mh)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Return without taking locks if there are no +load methods here.</span></span><br><span class="line">    <span class="keyword">if</span> (!hasLoadMethods((<span class="keyword">const</span> headerType *)mh)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    recursive_mutex_locker_t lock(loadMethodLock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Discover load methods</span></span><br><span class="line">    &#123;</span><br><span class="line">        mutex_locker_t lock2(runtimeLock);</span><br><span class="line">        <span class="comment">//加载 class+load 和category+load方法</span></span><br><span class="line">        prepare_load_methods((<span class="keyword">const</span> headerType *)mh);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Call +load methods (without runtimeLock - re-entrant)</span></span><br><span class="line">    <span class="comment">//执行 class+load 和category+load方法</span></span><br><span class="line">    call_load_methods();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看到<code>load_images</code>方法中主要是执行了<code>call_load_methods</code>方法，这也侧面证明在+load方法中我们可以使用关联对象，因为对应的属性和方法列表已经被添加到类中。</p>
<p>而对于<code>call_load_methods</code>方法：</p>
<h4 id="call-load-methods"><a href="#call-load-methods" class="headerlink" title="call_load_methods"></a>call_load_methods</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 执行+load方法</span></span><br><span class="line"><span class="keyword">void</span> call_load_methods(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">//执行class+load直到完成</span></span><br><span class="line">        <span class="keyword">while</span> (loadable_classes_used &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            call_class_loads();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 执行Category +load 一次</span></span><br><span class="line">        more_categories = call_category_loads();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. Run more +loads if there are classes OR more untried categories</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (loadable_classes_used &gt; <span class="number">0</span>  ||  more_categories);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们也看到，+load方法是先调用了原始类中的+load方法，再调用分类中的load方法。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这篇文章我们主要介绍了分类的结构和分类是如何与主类关联的，同时分析了关联对象方法的具体实现。同时在介绍<code>load_images</code>方法时，我们又验证了+load方法的调用时机以及与分类方法链接到主类的执行顺序。</p>
]]></content>
  </entry>
  <entry>
    <title>SideTable结构</title>
    <url>/2020/08/16/sidetablestructure/</url>
    <content><![CDATA[<p>  iOS开发者都知道，当一个对象被释放时，所有对这个对象弱引用的指针都会释放并置为nil，那么系统是如何存储这些弱引用对象的呢？又是如何在一个对象释放时，将这些指向即将释放对象的弱引用的指针置为nil的呢？下面我们通过分析<code>SideTable</code>的结构来进一步了解内存管理的弱引用存储细节。</p>
<a id="more"></a>

<h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p>在runtime中，有四个数据结构非常重要，分别是<code>SideTables</code>，<code>SideTable</code>，<code>weak_table_t</code>和<code>weak_entry_t</code>。它们和对象的引用计数，以及weak引用相关。</p>
<h4 id="SideTables"><a href="#SideTables" class="headerlink" title="SideTables"></a>SideTables</h4><p>下面我们看下SideTables的结构：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> StripedMap&lt;SideTable&gt;&amp; SideTables() &#123;</span><br><span class="line">    <span class="keyword">return</span> *reinterpret_cast&lt;StripedMap&lt;SideTable&gt;*&gt;(SideTableBuf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>reinterpret_cast</code>，是C++里的强制类型转换符,我们看下<code>SideTableBuf</code>的定义。上面代码，我们看到StripedMap实际上返回的是一个SideTableBuf对象，那么我们来看下SideTableBuf对象：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//alignas 字节对齐</span></span><br><span class="line"><span class="comment">// SideTableBuf 静态全局变量</span></span><br><span class="line"><span class="comment">// sizeof(StripedMap&lt;SideTable&gt;) = 4096</span></span><br><span class="line"><span class="comment">//alignas (StripedMap&lt;SideTable&gt;) 是字节对齐的意思，表示让数组中每一个元素的起始位置对齐到4096的倍数</span></span><br><span class="line"><span class="comment">// 因此下面这句话可以翻译为 static uint8_t SideTableBuf[4096]</span></span><br><span class="line">alignas(StripedMap&lt;SideTable&gt;) <span class="keyword">static</span> uint8_t </span><br><span class="line">    SideTableBuf[<span class="keyword">sizeof</span>(StripedMap&lt;SideTable&gt;)];</span><br></pre></td></tr></table></figure>
<p><code>SideTableBuf</code>是一个外部不可见的静态内存区块，存储<code>StripedMap&lt;SideTable&gt;</code>对象。它是内存管理的基础。</p>
<p>我们接下来在看下<code>StripedMap</code>的结构</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> &#123; CacheLineSize = <span class="number">64</span> &#125;;</span><br><span class="line"><span class="comment">// StripedMap&lt;T&gt; 是一个模板类，根据传递的实际参数决定其中 array 成员存储的元素类型</span></span><br><span class="line"><span class="comment">// 能通过对象的地址，运算出 Hash 值，通过该 hash 值找到对应的 value</span></span><br><span class="line">template&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> StripedMap &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> TARGET_OS_IPHONE &amp;&amp; !TARGET_OS_SIMULATOR</span></span><br><span class="line">    <span class="keyword">enum</span> &#123; StripeCount = <span class="number">8</span> &#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="keyword">enum</span> &#123; StripeCount = <span class="number">64</span> &#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// PaddedT 为一个结构体</span></span><br><span class="line">    <span class="keyword">struct</span> PaddedT &#123;</span><br><span class="line">        T value alignas(CacheLineSize);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// array 中存放着8个sidetable</span></span><br><span class="line">    PaddedT array[StripeCount];</span><br><span class="line">    <span class="comment">//取得p的哈希值，p就是实例对象的地址</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> indexForPointer(<span class="keyword">const</span> <span class="keyword">void</span> *p) &#123;</span><br><span class="line">        uintptr_t addr = reinterpret_cast&lt;uintptr_t&gt;(p);</span><br><span class="line">        <span class="comment">// 这里根据对象的地址经过左移和异或操作 最终结果 模 8 得到一个0-7的值</span></span><br><span class="line">        <span class="comment">// 即对应该地址对应array中下标的sidetable中</span></span><br><span class="line">        <span class="keyword">return</span> ((addr &gt;&gt; <span class="number">4</span>) ^ (addr &gt;&gt; <span class="number">9</span>)) % StripeCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> public:</span><br><span class="line">    <span class="comment">// 重写了[]方法 即通过下标获取数组中对应下标的值</span></span><br><span class="line">    <span class="comment">// array[index] = array[indexForPointer(p)].value</span></span><br><span class="line">    T&amp; operator[] (<span class="keyword">const</span> <span class="keyword">void</span> *p) &#123; </span><br><span class="line">        <span class="keyword">return</span> array[indexForPointer(p)].value; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> T&amp; operator[] (<span class="keyword">const</span> <span class="keyword">void</span> *p) <span class="keyword">const</span> &#123; </span><br><span class="line">        <span class="keyword">return</span> const_cast&lt;StripedMap&lt;T&gt;&gt;(<span class="keyword">this</span>)[p]; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>StripedMap</code> 是一个以<code>void *</code>为hash key， T为vaule的hash 表。<code>StripedMap</code>的所有T类型数据都被封装到array中。</p>
<p>综上我们得出<code>SideTables</code>的机构实际是下图所示:<br><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghsmzzzthcj30tu05b0t8.jpg"></p>
<h4 id="SideTable"><a href="#SideTable" class="headerlink" title="SideTable"></a>SideTable</h4><p>下面来看下<code>sideTable</code>的结构</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> SideTable &#123;</span><br><span class="line">    <span class="comment">// 保证原子操作的自旋锁</span></span><br><span class="line">    spinlock_t slock;</span><br><span class="line">    <span class="comment">// 引用计数的 hash 表</span></span><br><span class="line">    RefcountMap refcnts;</span><br><span class="line">    <span class="comment">// weak 引用全局 hash 表</span></span><br><span class="line">    weak_table_t weak_table;</span><br><span class="line"></span><br><span class="line">    SideTable() &#123;</span><br><span class="line">        memset(&amp;weak_table, <span class="number">0</span>, <span class="keyword">sizeof</span>(weak_table));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    ~SideTable() &#123;</span><br><span class="line">        _objc_fatal(<span class="string">&quot;Do not delete SideTable.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghszonn7i6j308d08g74f.jpg"></p>
<p>上面是我们简化后的<code>SideTable</code>结构体，包含了:</p>
<ul>
<li>保证原子属性的自旋锁<code>spinlock_t</code></li>
<li>记录引用计数值的<code>RefcountMap</code></li>
<li>用于存储对象弱引用的哈希表 <code>weak_table_t</code></li>
</ul>
<p>自旋锁(slock)我们这里就不做过多介绍了,我们先来看下RefcountMap，看下<code>RefcountMap</code>结构</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// RefcountMap 是一个模板类</span></span><br><span class="line"><span class="comment">// key,DisguisedPtr&lt;objc_object&gt;类型</span></span><br><span class="line"><span class="comment">// value，size_t类型</span></span><br><span class="line"><span class="comment">// 是否清除为vlaue==0的数据，true</span></span><br><span class="line"><span class="keyword">typedef</span> objc::DenseMap&lt;DisguisedPtr&lt;objc_object&gt;,size_t,<span class="literal">true</span>&gt; RefcountMap;</span><br></pre></td></tr></table></figure>

<p>DenseMap是llvm库中的类，是一个简单的二次探测哈希表，擅长支持小的键和值。<code>RefcountMap</code>是一个hash map，其key是obj的<code>DisguisedPtr&lt;objc_object&gt;</code>，而value，则是obj对象的<code>引用计数</code>,同时，这个map还有个加强版功能，当引用计数为0时，会自动将对象数据清除。</p>
<p>上面我们知道了，refcnts是用来存放引用计数的，那么我们如何获取一个对象的引用计数呢？</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取一个对象的retainCount</span></span><br><span class="line"><span class="keyword">inline</span> uintptr_t </span><br><span class="line">objc_object::rootRetainCount()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//优化指针 直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (isTaggedPointer()) <span class="keyword">return</span> (uintptr_t)<span class="keyword">this</span>;</span><br><span class="line">    <span class="comment">//没优化则 到SideTable 读取</span></span><br><span class="line">    sidetable_lock();</span><br><span class="line">	<span class="comment">//isa指针</span></span><br><span class="line">    isa_t bits = LoadExclusive(&amp;isa.bits);</span><br><span class="line">    ClearExclusive(&amp;isa.bits);<span class="comment">//啥都没做</span></span><br><span class="line">    <span class="keyword">if</span> (bits.nonpointer) &#123;<span class="comment">//优化过 isa 指针</span></span><br><span class="line">        uintptr_t rc = <span class="number">1</span> + bits.extra_rc;<span class="comment">//计数数量</span></span><br><span class="line">        <span class="keyword">if</span> (bits.has_sidetable_rc) &#123;</span><br><span class="line">        <span class="comment">//bits.has_sidetable_rc标志位为1 表明有存放在sidetable中的引用计数</span></span><br><span class="line">			<span class="comment">//读取table的值 相加</span></span><br><span class="line">            rc += sidetable_getExtraRC_nolock();</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//解锁</span></span><br><span class="line">        sidetable_unlock();</span><br><span class="line">        <span class="keyword">return</span> rc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sidetable_unlock();</span><br><span class="line">	<span class="comment">//：如果没采用优化的isa指针，则直接返回sidetable中的值</span></span><br><span class="line">    <span class="keyword">return</span> sidetable_retainCount();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面的代码我们可以得出:<code>retainCount = isa.extra_rc + sidetable_getExtraRC_nolock</code>,即引用计数=isa指针中存储的引用计数+sidetable中存储的引用计数</p>
<p>那么<code>sidetable_getExtraRC_nolock</code>是如何从sideTable中获取<code>retainCount</code>的呢？<br>下面我们来看下这个方法的实现。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">size_t </span><br><span class="line">objc_object::sidetable_getExtraRC_nolock()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">    assert(isa.nonpointer);</span><br><span class="line">	<span class="comment">//key是 this，存储了每个对象的table</span></span><br><span class="line">    SideTable&amp; table = SideTables()[<span class="keyword">this</span>];</span><br><span class="line">	<span class="comment">//找到 it 否则返回0</span></span><br><span class="line">    RefcountMap::iterator it = table.refcnts.find(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">// 这里返回的it是RefcountMap类型 it == table.refcnts.end() </span></span><br><span class="line">    <span class="comment">// 表示在sidetable中没有找到this对应的引用计数则直接返回0</span></span><br><span class="line">    <span class="keyword">if</span> (it == table.refcnts.end()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// RefcountMap 结构的second值为引用计数值 </span></span><br><span class="line">    <span class="comment">// DenseMap&lt;DisguisedPtr&lt;objc_object&gt;,size_t,true&gt; RefcountMap;</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> it-&gt;second &gt;&gt; SIDE_TABLE_RC_SHIFT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>了解了SideTable的RefcountMap，下面我们接着看另外一个属性weak_table</p>
<h4 id="weak-table"><a href="#weak-table" class="headerlink" title="weak_table"></a>weak_table</h4><p>我们都知道weak_table是对象弱引用map，它记录了所有弱引用对象的集合。</p>
<p>我们先来看下<code>weak_table_t</code>的定义：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 全局的弱引用表</span></span><br><span class="line"><span class="keyword">struct</span> weak_table_t &#123;</span><br><span class="line">    <span class="comment">// hash数组，用来存储弱引用对象的相关信息weak_entry_t</span></span><br><span class="line">    weak_entry_t *weak_entries;</span><br><span class="line">    <span class="comment">// hash数组中的元素个数</span></span><br><span class="line">    size_t    num_entries;</span><br><span class="line">    <span class="comment">// hash数组长度-1，会参与hash计算。</span></span><br><span class="line">    <span class="comment">//（注意，这里是hash数组的长度，而不是元素个数。比如，数组长度可能是64，而元素个数仅存了2个）</span></span><br><span class="line">    uintptr_t mask;</span><br><span class="line">    <span class="comment">// 最大哈希偏移值</span></span><br><span class="line">    uintptr_t max_hash_displacement;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghszyu1ay9j30ae0af0tc.jpg"></p>
<p><code>weak_entries</code>实质上是一个hash数组，数组中存储<code>weak_entry_t</code>类型的元素。weak_entry_t的定义如下</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The internal structure stored in the weak references table. </span></span><br><span class="line"><span class="comment"> * It maintains and stores</span></span><br><span class="line"><span class="comment"> * a hash set of weak references pointing to an object.</span></span><br><span class="line"><span class="comment"> * If out_of_line_ness != REFERRERS_OUT_OF_LINE then the set</span></span><br><span class="line"><span class="comment"> * is instead a small inline array.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="comment">//inline_referrers数组中可以存放元素的最大个数 如果超过了这个个数就会使用referrers 存放</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WEAK_INLINE_COUNT 4</span></span><br><span class="line"><span class="comment">// out_of_line_ness field overlaps with the low two bits of inline_referrers[1].</span></span><br><span class="line"><span class="comment">// inline_referrers[1] is a DisguisedPtr of a pointer-aligned address.</span></span><br><span class="line"><span class="comment">// The low two bits of a pointer-aligned DisguisedPtr will always be 0b00</span></span><br><span class="line"><span class="comment">// (disguised nil or 0x80..00) or 0b11 (any other address).</span></span><br><span class="line"><span class="comment">// Therefore out_of_line_ness == 0b10 is used to mark the out-of-line state.</span></span><br><span class="line"><span class="comment">// DisguisedPtr方法返回的hash值得最低2个字节应该是0b00或0b11，因此可以用out_of_line_ness </span></span><br><span class="line"><span class="comment">// == 0b10来表明当前是否在使用数组或动态数组来保存引用该对象的列表。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REFERRERS_OUT_OF_LINE 2</span></span><br><span class="line"><span class="keyword">struct</span> weak_entry_t &#123;</span><br><span class="line">    <span class="comment">// 被弱引用的对象</span></span><br><span class="line">    DisguisedPtr&lt;objc_object&gt; referent;</span><br><span class="line">    <span class="comment">// 联合结构 两种结构共同占用一块内存空间 两种结构互斥</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="comment">// 弱引用 被弱引用对象的列表</span></span><br><span class="line">        <span class="keyword">struct</span> &#123;</span><br><span class="line">            <span class="comment">// 弱引用该对象的对象列表的动态数组</span></span><br><span class="line">            weak_referrer_t *referrers;</span><br><span class="line">            <span class="comment">// 是否使用动态数组标记位</span></span><br><span class="line">            uintptr_t        out_of_line_ness : <span class="number">2</span>;</span><br><span class="line">            <span class="comment">// 动态数组中元素的个数</span></span><br><span class="line">            uintptr_t        num_refs : PTR_MINUS_2;</span><br><span class="line">            <span class="comment">// 用于hash确定动态数组index，值实际上是动态数组空间长度-1（它和num_refs不一样，</span></span><br><span class="line">            <span class="comment">// 这里是记录的是数组中位置的个数，而不是数组中实际存储的元素个数）。</span></span><br><span class="line">            uintptr_t        mask;</span><br><span class="line">            <span class="comment">// 最大哈希偏移值</span></span><br><span class="line">            uintptr_t        max_hash_displacement;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">struct</span> &#123;</span><br><span class="line">            <span class="comment">// inline_referrers 数组 当不使用动态数组时使用 最大个数为4</span></span><br><span class="line">            weak_referrer_t  inline_referrers[WEAK_INLINE_COUNT];</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的介绍我们可以总结<code>SideTables</code>和<code>SideTable</code>以及<code>weak_table_t</code>在层级上的关系图如下：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ght18747k1j31bi0oqn0t.jpg"></p>
<p>上图是从数据结构的角度来看弱引用的保存,下面我们来看下从垂直方向来看</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ght1vuy3uqj30x909g3z3.jpg"></p>
<p>从上面的总结中我们可以看到，弱引用的存储实际上一个三级的哈希表，通过一层层的索引找到或者存储对应的弱引用。那当向<code>weak_table_t</code>中插入或查找某个元素时是如何操作的呢？算法是什么样的呢？</p>
<h4 id="weak-entry-for-referent"><a href="#weak-entry-for-referent" class="headerlink" title="weak_entry_for_referent"></a>weak_entry_for_referent</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">/ 在weak_table中查找所有弱引用referent的对象</span><br><span class="line"><span class="keyword">static</span> weak_entry_t *</span><br><span class="line">weak_entry_for_referent(weak_table_t *weak_table, objc_object *referent)</span><br><span class="line">&#123;</span><br><span class="line">    assert(referent);</span><br><span class="line">    <span class="comment">//获取这个weak_table_t中所有的弱引用对象</span></span><br><span class="line">    weak_entry_t *weak_entries = weak_table-&gt;weak_entries;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!weak_entries) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    <span class="comment">//hash_pointer 哈希函数 传入的是 objc_object *key</span></span><br><span class="line">    <span class="comment">// weak_table-&gt;mask = weaktable的容量-1</span></span><br><span class="line">    size_t begin = hash_pointer(referent) &amp; weak_table-&gt;mask;</span><br><span class="line">    size_t index = begin;</span><br><span class="line">    <span class="comment">// 哈希冲突次数</span></span><br><span class="line">    size_t hash_displacement = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 判断根据index获取到的弱引用对象数组中对应的weak_entry_t的弱引用对象是否为</span></span><br><span class="line">    <span class="comment">// 外部传入的对象</span></span><br><span class="line">    <span class="keyword">while</span> (weak_table-&gt;weak_entries[index].referent != referent) &#123;</span><br><span class="line">        <span class="comment">// 开放地址法解决哈希冲突</span></span><br><span class="line">        <span class="comment">// &amp; weak_table-&gt;mask 是为了在下一个地址仍然没有找到外部传入对象时回到第一个对比的位置</span></span><br><span class="line">        index = (index+<span class="number">1</span>) &amp; weak_table-&gt;mask;</span><br><span class="line">        <span class="keyword">if</span> (index == begin)</span><br><span class="line">            <span class="comment">// 对比了所有数据 仍没有找到 直接报错</span></span><br><span class="line">            bad_weak_table(weak_table-&gt;weak_entries);</span><br><span class="line">        <span class="comment">// 哈希冲突次数++</span></span><br><span class="line">        hash_displacement++;</span><br><span class="line">        <span class="comment">// 最大哈希偏移值 表示已经遍历了数组中所有的元素</span></span><br><span class="line">        <span class="comment">// 没有找到那么直接返回nil</span></span><br><span class="line">        <span class="keyword">if</span> (hash_displacement &gt; weak_table-&gt;max_hash_displacement) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 直接返回被弱引用的对象</span></span><br><span class="line">    <span class="keyword">return</span> &amp;weak_table-&gt;weak_entries[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面就是根据对象地址获取所有弱引用该对象的的数组，基本逻辑都比较清晰，我们在遍历<code>weak_table-&gt;weak_entries</code>中的时候发现判断是否遍历完一遍的时候使用的方法</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">index = (index+<span class="number">1</span>) &amp; weak_table-&gt;mask;</span><br></pre></td></tr></table></figure>

<p>假设当前数组长度8，下标分别是0-7，上面<code>weak_table-&gt;mask</code>= 7 = 0111。</p>
<table>
<thead>
<tr>
<th>下标</th>
<th>计算后结果</th>
</tr>
</thead>
<tbody><tr>
<td>index = 0</td>
<td>index &amp; mask = 0000 &amp; 0111 = 0000 = 0</td>
</tr>
<tr>
<td>index = 1</td>
<td>index &amp; mask = 0001 &amp; 0111 = 0001 = 1</td>
</tr>
<tr>
<td>index = 2</td>
<td>index &amp; mask = 0010 &amp; 0111 = 0010 = 2</td>
</tr>
<tr>
<td>index = 3</td>
<td>index &amp; mask = 0011 &amp; 0111 = 0011 = 3</td>
</tr>
<tr>
<td>index = 4</td>
<td>index &amp; mask = 0100 &amp; 0111 = 0100 = 4</td>
</tr>
<tr>
<td>index = 5</td>
<td>index &amp; mask = 0101 &amp; 0111 = 0101 = 5</td>
</tr>
<tr>
<td>index = 6</td>
<td>index &amp; mask = 0110 &amp; 0111 = 0110 = 6</td>
</tr>
<tr>
<td>index = 7</td>
<td>index &amp; mask = 0111 &amp; 0111 = 0111 = 7</td>
</tr>
<tr>
<td>index = 8</td>
<td>index &amp; mask = 1000 &amp; 0111 = 0000 = 0</td>
</tr>
</tbody></table>
<p>看完上面的计算相信大家都明白了这么做的真是意图了：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (index == begin)</span><br></pre></td></tr></table></figure>
<p>可以理解为：数组遍历完成，已经和数组中所有的元素做了对比。</p>
<p>随着某个对象被越来越多的对象弱引用，那么这个存放弱引用该对象的所有对象的数组也会越来越大。</p>
<h4 id="hash表自动扩容"><a href="#hash表自动扩容" class="headerlink" title="hash表自动扩容"></a>hash表自动扩容</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//weak_table_t扩容</span></span><br><span class="line"><span class="comment">// 参数 weak_table 要扩容的table new_size 目标大小</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> weak_resize(weak_table_t *weak_table, size_t new_size)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//weak_table的容量</span></span><br><span class="line">    size_t old_size = TABLE_SIZE(weak_table);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取出weak_table中存放的所有实体</span></span><br><span class="line">    weak_entry_t *old_entries = weak_table-&gt;weak_entries;</span><br><span class="line">    <span class="comment">// 新创建一个weak_entry_t类型的数组</span></span><br><span class="line">    <span class="comment">// 数组的大小是new_size * sizeof(weak_entry_t)</span></span><br><span class="line">    weak_entry_t *new_entries = (weak_entry_t *)</span><br><span class="line">        calloc(new_size, <span class="keyword">sizeof</span>(weak_entry_t));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重置weak_table的mask的值</span></span><br><span class="line">    weak_table-&gt;mask = new_size - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 将weak_table-&gt;weak_entries指向新创建的内存区域 注意 此时weak_table中没有任何数据</span></span><br><span class="line">    weak_table-&gt;weak_entries = new_entries;</span><br><span class="line">    <span class="comment">// 最大哈希偏移值重置为0</span></span><br><span class="line">    weak_table-&gt;max_hash_displacement = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//weak_table 中存储实体个数为0</span></span><br><span class="line">    weak_table-&gt;num_entries = <span class="number">0</span>;  <span class="comment">// restored by weak_entry_insert below</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 旧数据的搬迁</span></span><br><span class="line">    <span class="keyword">if</span> (old_entries) &#123;</span><br><span class="line">        weak_entry_t *entry;</span><br><span class="line">        <span class="comment">//old_entries看做数组中第一个元素的地址 由于数组是连续的存储空间 那么old_entries + old_size = 数组最后一个元素的地址</span></span><br><span class="line">        weak_entry_t *end = old_entries + old_size;</span><br><span class="line">        <span class="comment">// 遍历这些旧数据</span></span><br><span class="line">        <span class="keyword">for</span> (entry = old_entries; entry &lt; end; entry++) &#123;</span><br><span class="line">            <span class="comment">//weak_entry_t的referent(referent是指被弱引用的对象)</span></span><br><span class="line">            <span class="keyword">if</span> (entry-&gt;referent) &#123;</span><br><span class="line">                <span class="comment">// 将旧数据搬移到新的结构中</span></span><br><span class="line">                weak_entry_insert(weak_table, entry);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 释放所有的旧数据</span></span><br><span class="line">        free(old_entries);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的代码中我们可以看到，哈希表的扩容主要分为下面几个步骤:</p>
<ul>
<li>创建一个局部变量保存当前哈希表中保存的所有弱引用实体</li>
<li>新建一个容量是旧哈希表大小2倍的哈希表，同时重置<code>num_entries</code>、<code>max_hash_displacement</code>、<code>weak_entries</code>、<code>mask</code></li>
<li>遍历之前保存的旧的数据 将数据按照顺序依次重新插入的新建的哈希表中</li>
<li>释放旧数据</li>
</ul>
<p>我们看到将旧数据插入新数据的主要方法是<code>weak_entry_insert</code>，下面我们来仔细介绍下它：</p>
<h4 id="weak-entry-insert"><a href="#weak-entry-insert" class="headerlink" title="weak_entry_insert"></a>weak_entry_insert</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 向指定的weak_table_t中插入某个对象</span></span><br><span class="line"><span class="comment">// weak_table_t 目标 table</span></span><br><span class="line"><span class="comment">// new_entry 被弱引用的对象</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> weak_entry_insert(weak_table_t *weak_table, weak_entry_t *new_entry)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 取出weak_table中所有弱引用的对象</span></span><br><span class="line">    weak_entry_t *weak_entries = weak_table-&gt;weak_entries;</span><br><span class="line">    assert(weak_entries != <span class="literal">nil</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据new_entry中被弱引用对象地址通过哈希算法 算出 弱引用new_entry-&gt;referent的对象存放的index</span></span><br><span class="line">    size_t begin = hash_pointer(new_entry-&gt;referent) &amp; (weak_table-&gt;mask);</span><br><span class="line">    size_t index = begin;</span><br><span class="line">    size_t hash_displacement = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// weak_entries[index].referent 如果不为空 表示已经有</span></span><br><span class="line">    <span class="keyword">while</span> (weak_entries[index].referent != <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="comment">// 计算下一个要遍历的index</span></span><br><span class="line">        index = (index+<span class="number">1</span>) &amp; weak_table-&gt;mask;</span><br><span class="line">        <span class="comment">// 遍历了所有元素发现weak_entries[index].referent 都不为nil</span></span><br><span class="line">        <span class="keyword">if</span> (index == begin)</span><br><span class="line">            <span class="comment">// 直接报错</span></span><br><span class="line">            bad_weak_table(weak_entries);</span><br><span class="line">        <span class="comment">// 哈希冲突次数++</span></span><br><span class="line">        hash_displacement++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果走到这里 表明index位置的元素referent=nil</span></span><br><span class="line">    <span class="comment">// 直接插入</span></span><br><span class="line">    weak_entries[index] = *new_entry;</span><br><span class="line">    <span class="comment">// 实体个数++</span></span><br><span class="line">    weak_table-&gt;num_entries++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最大哈希偏移值大于之前的记录</span></span><br><span class="line">    <span class="keyword">if</span> (hash_displacement &gt; weak_table-&gt;max_hash_displacement) &#123;</span><br><span class="line">        <span class="comment">// 更新最大哈希偏移值</span></span><br><span class="line">        weak_table-&gt;max_hash_displacement = hash_displacement;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>插入操作也很简单，主要分为下面几个步骤:</p>
<ul>
<li>取出哈希表中所有弱引用对象的数据</li>
<li>遍历第一步取出的所有数据，找到第一个空位置</li>
<li>将要插入的实体插入到这个位置，同时更新当前<code>weak_table</code>中弱引用实体个数</li>
<li>重置<code>weak_table</code>中最大哈希冲突次数的值</li>
</ul>
<p>插入的主要逻辑实际上并不复杂，但是我们发现最后一步</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果本次哈希偏移值大于之前记录的最大偏移值 则更新 </span></span><br><span class="line"><span class="keyword">if</span> (hash_displacement &gt; weak_table-&gt;max_hash_displacement) &#123;</span><br><span class="line">    <span class="comment">// 修改最大哈希偏移值</span></span><br><span class="line">    weak_table-&gt;max_hash_displacement = hash_displacement;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过上面的代码我们发现，假设<code>weak_table</code>的<code>weak_entries</code>最大容量为8,当前存放了3个被弱引用的对象且分别存放在下标为[0,1,2]中，同时要插入的对象<code>new_entry</code>不再<code>weak_entries</code>中，那么经过while循环，<code>hash_displacement = 3</code>。实际上如果在没有哈希冲突的情况下我们通过<code>hash_pointer</code>得到的index就应该是用来存放<code>new_entry</code>的，但是因为存在哈希冲突，所以后移了3位后才找到合适的位置来存放<code>new_entry</code>，因此<code>hash_displacement</code>也被理解为，本应存放的位置距离实际存放位置的差值。</p>
<p>综上，我们分析了哈希表中获取所有弱引用某个对象的对象数组，哈希表扩容方法，以及如何在哈希表中插入一个弱引用对象。</p>
<p>下面我们来看下新增和释放弱引用对象的方法</p>
<h4 id="objc-initWeak"><a href="#objc-initWeak" class="headerlink" title="objc_initWeak"></a>objc_initWeak</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化一个weak 弱引用</span></span><br><span class="line"><span class="comment">// 参数location weak指针的地址  newObj weak指针指向的对象</span></span><br><span class="line"><span class="keyword">id</span></span><br><span class="line">objc_initWeak(<span class="keyword">id</span> *location, <span class="keyword">id</span> newObj)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 如果弱引用对象为空</span></span><br><span class="line">    <span class="keyword">if</span> (!newObj) &#123;</span><br><span class="line">        *location = <span class="literal">nil</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用storeWeak</span></span><br><span class="line">    <span class="keyword">return</span> storeWeak&lt;DontHaveOld, DoHaveNew, DoCrashIfDeallocating&gt;</span><br><span class="line">        (location, (objc_object*)newObj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>id *location ：__weak指针的地址，即weak指针取地址： &amp;weakObj 。它是一个指针的地址。之所以要存储指针的地址，是因为最后我们要讲__weak指针指向的内容置为nil，如果仅存储指针的话，是不能够完成这个功能的。</p>
</li>
<li><p>id newObj ：所引用的对象。即例子中的obj 。</p>
</li>
</ul>
<p>从上面我们看出<code>objc_initWeak</code>实际上是调用了<code>storeWeak</code>方法，且方法调用我们可以翻译为</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">storeWeak&lt;<span class="literal">false</span>, <span class="literal">true</span>, <span class="literal">true</span>&gt;</span><br><span class="line">        (location, (objc_object*)newObj)</span><br></pre></td></tr></table></figure>

<h4 id="storeWeak"><a href="#storeWeak" class="headerlink" title="storeWeak"></a>storeWeak</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> CrashIfDeallocating &#123;</span><br><span class="line">    DontCrashIfDeallocating = <span class="literal">false</span>, DoCrashIfDeallocating = <span class="literal">true</span></span><br><span class="line">&#125;;</span><br><span class="line">template &lt;HaveOld haveOld, HaveNew haveNew,</span><br><span class="line">          CrashIfDeallocating crashIfDeallocating&gt;</span><br><span class="line"><span class="comment">// HaveOld= true weak ptr之前是否已经指向了一个弱引用</span></span><br><span class="line"><span class="comment">// haveNew = true weak ptr是否需要指向一个新引用</span></span><br><span class="line"><span class="comment">// crashIfDeallocating = true 如果被弱引用的对象正在析构，此时再弱引用该对象，是否应该crash</span></span><br><span class="line"><span class="comment">// crashIfDeallocating = false 将存储的数据置为nil</span></span><br><span class="line"><span class="comment">// *location 代表weak 指针的地址</span></span><br><span class="line"><span class="comment">// newObj 被weak引用的对象。</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">id</span> </span><br><span class="line">storeWeak(<span class="keyword">id</span> *location, objc_object *newObj)</span><br><span class="line">&#123;</span><br><span class="line">    assert(haveOld  ||  haveNew);</span><br><span class="line">    <span class="comment">// 如果没有新值赋值 判断newObj 是否为空 否则断言</span></span><br><span class="line">    <span class="keyword">if</span> (!haveNew)</span><br><span class="line">        assert(newObj == <span class="literal">nil</span>);</span><br><span class="line"></span><br><span class="line">    Class previouslyInitializedClass = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">id</span> oldObj;</span><br><span class="line"></span><br><span class="line">    SideTable *oldTable;</span><br><span class="line">    SideTable *newTable;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> retry:</span><br><span class="line">    <span class="comment">// 如果weak ptr之前弱引用过一个obj，则将这个obj所对应的SideTable取出，赋值给oldTable</span></span><br><span class="line">    <span class="keyword">if</span> (haveOld) &#123;</span><br><span class="line">        <span class="comment">// 根据传入的地址获取到旧的值</span></span><br><span class="line">        oldObj = *location;</span><br><span class="line">        <span class="comment">// 根据旧值的地址获取到旧值所存在的SideTable</span></span><br><span class="line">        oldTable = &amp;SideTables()[oldObj];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果weak ptr之前没有弱引用过一个obj，则oldTable = nil</span></span><br><span class="line">        oldTable = <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 是否有新值 如果有</span></span><br><span class="line">    <span class="keyword">if</span> (haveNew) &#123;</span><br><span class="line">        <span class="comment">// 如果weak ptr要weak引用一个新的obj，则将该obj对应的SideTable取出，赋值给newTable</span></span><br><span class="line">        newTable = &amp;SideTables()[newObj];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果weak ptr不需要引用一个新obj，则newTable = nil</span></span><br><span class="line">        newTable = <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加锁管理一对 side tables，防止多线程中竞争冲突</span></span><br><span class="line">    SideTable::lockTwo&lt;haveOld, haveNew&gt;(oldTable, newTable);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// location 应该与 oldObj 保持一致，如果不同，说明当前的 location 已经处理过 oldObj 可是又被其他线程所修改</span></span><br><span class="line">    <span class="keyword">if</span> (haveOld  &amp;&amp;  *location != oldObj) &#123;</span><br><span class="line">        <span class="comment">// 解锁后重试</span></span><br><span class="line">        SideTable::unlockTwo&lt;haveOld, haveNew&gt;(oldTable, newTable);</span><br><span class="line">        <span class="keyword">goto</span> retry;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保证弱引用对象的 isa 都被初始化，防止弱引用和 +initialize 之间发生死锁，</span></span><br><span class="line">    <span class="comment">// 也就是避免 +initialize 中调用了 storeWeak 方法，而在 storeWeak 方法中 weak_register_no_lock</span></span><br><span class="line">    <span class="comment">// 方法中用到对象的 isa 还没有初始化完成的情况</span></span><br><span class="line">    <span class="keyword">if</span> (haveNew  &amp;&amp;  newObj) &#123;</span><br><span class="line">        Class cls = newObj-&gt;getIsa();</span><br><span class="line">        <span class="comment">// 如果cls还没有初始化，先初始化，再尝试设置weak</span></span><br><span class="line">        <span class="keyword">if</span> (cls != previouslyInitializedClass  &amp;&amp;  </span><br><span class="line">            !((objc_class *)cls)-&gt;isInitialized()) </span><br><span class="line">        &#123;</span><br><span class="line">            SideTable::unlockTwo&lt;haveOld, haveNew&gt;(oldTable, newTable);</span><br><span class="line">            <span class="comment">// 发送 +initialize 消息到未初始化的类</span></span><br><span class="line">            _class_initialize(_class_getNonMetaClass(cls, (<span class="keyword">id</span>)newObj));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果该类还没有初始化完成，例如在 +initialize 中调用了 storeWeak 方法，</span></span><br><span class="line">            <span class="comment">// 也就是会进入这里面，进而设置  previouslyInitializedClass  以在重试时识别它</span></span><br><span class="line">            <span class="comment">// 这里记录一下previouslyInitializedClass， 防止改if分支再次进入</span></span><br><span class="line">            previouslyInitializedClass = cls;</span><br><span class="line">            <span class="comment">// 重新获取一遍newObj，这时的newObj应该已经初始化过了</span></span><br><span class="line">            <span class="keyword">goto</span> retry;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果weak_ptr之前弱引用过别的对象oldObj，则调用weak_unregister_no_lock，在oldObj的weak_entry_t中移除该weak_ptr地址</span></span><br><span class="line">    <span class="keyword">if</span> (haveOld) &#123;</span><br><span class="line">        weak_unregister_no_lock(&amp;oldTable-&gt;weak_table, oldObj, location);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果weak_ptr需要弱引用新的对象newObj</span></span><br><span class="line">    <span class="keyword">if</span> (haveNew) &#123;</span><br><span class="line">        <span class="comment">// (1) 调用weak_register_no_lock方法，将weak ptr的地址记录到newObj对应的weak_entry_t中</span></span><br><span class="line">        newObj = (objc_object *)</span><br><span class="line">            weak_register_no_lock(&amp;newTable-&gt;weak_table, (<span class="keyword">id</span>)newObj, location, </span><br><span class="line">                                  crashIfDeallocating);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// (2) 更新newObj的isa的weakly_referenced bit标志位</span></span><br><span class="line">        <span class="keyword">if</span> (newObj  &amp;&amp;  !newObj-&gt;isTaggedPointer()) &#123;</span><br><span class="line">            newObj-&gt;setWeaklyReferenced_nolock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// （3）*location 赋值，也就是将weak ptr直接指向了newObj。可以看到，这里并没有将newObj的引用计数+1</span></span><br><span class="line">        <span class="comment">// 将weak ptr指向object</span></span><br><span class="line">        *location = (<span class="keyword">id</span>)newObj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// No new value. The storage is not changed.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 解锁，其他线程可以访问oldTable, newTable了</span></span><br><span class="line">    SideTable::unlockTwo&lt;haveOld, haveNew&gt;(oldTable, newTable);</span><br><span class="line">    <span class="comment">// 返回newObj，此时的newObj与刚传入时相比，weakly-referenced bit位置1</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">id</span>)newObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>storeWeak方法有点长，这也是weak引用的核心实现部分。其实核心也就实现了两个功能：</p>
<p>将weak指针的地址<code>location</code>存入到obj对应的weak_entry_t的数组（链表）中，用于在obj析构时，通过该数组（链表）找到所有其weak指针引用，并将指针指向的地址（<code>location</code>）置为nil。</p>
<p>如果启用了isa优化，则将obj的isa_t的<code>weakly_referenced</code>位置1。置位1的作用主要是为了标记obj被weak引用了，当dealloc时，runtime会根据<code>weakly_referenced</code>标志位来判断是否需要查找obj对应的weak_entry_t，并将引用置为nil。</p>
<p>上面的方法中，我们看到插入新值的方法为<code>weak_register_no_lock</code>,清除旧值的方法为<code>weak_unregister_no_lock</code>,下面我们来看下这两个方法：</p>
<h4 id="weak-register-no-lock"><a href="#weak-register-no-lock" class="headerlink" title="weak_register_no_lock"></a>weak_register_no_lock</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">/ 添加对某个对象的新的弱引用指针</span><br><span class="line"><span class="comment">// weak_table 目标被弱引用对象所存储的表</span></span><br><span class="line"><span class="comment">// referent_id 被所引用的对象</span></span><br><span class="line"><span class="comment">// referrer_id 要被添加的弱引用指针</span></span><br><span class="line"><span class="comment">// crashIfDeallocating 如果对象正在被释放时是否崩溃</span></span><br><span class="line"><span class="keyword">id</span> </span><br><span class="line">weak_register_no_lock(weak_table_t *weak_table, <span class="keyword">id</span> referent_id, </span><br><span class="line">                      <span class="keyword">id</span> *referrer_id, <span class="keyword">bool</span> crashIfDeallocating)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 被弱引用的对象</span></span><br><span class="line">    objc_object *referent = (objc_object *)referent_id;</span><br><span class="line">    <span class="comment">// 要添加的指向弱引用指针的对象</span></span><br><span class="line">    objc_object **referrer = (objc_object **)referrer_id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果referent为nil 或 referent 采用了TaggedPointer计数方式，直接返回，不做任何操作</span></span><br><span class="line">    <span class="keyword">if</span> (!referent  ||  referent-&gt;isTaggedPointer()) <span class="keyword">return</span> referent_id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 确保被引用的对象可用（没有在析构，同时应该支持weak引用）</span></span><br><span class="line">    <span class="keyword">bool</span> deallocating;</span><br><span class="line">    <span class="comment">// referent 是否有自定义的释放方法</span></span><br><span class="line">    <span class="keyword">if</span> (!referent-&gt;ISA()-&gt;hasCustomRR()) &#123;</span><br><span class="line">        deallocating = referent-&gt;rootIsDeallocating();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// referent是否支持weak引用</span></span><br><span class="line">        <span class="built_in">BOOL</span> (*allowsWeakReference)(objc_object *, SEL) = </span><br><span class="line">            (<span class="built_in">BOOL</span>(*)(objc_object *, SEL))</span><br><span class="line">            object_getMethodImplementation((<span class="keyword">id</span>)referent, </span><br><span class="line">                                           SEL_allowsWeakReference);</span><br><span class="line">        <span class="comment">// 如果referent不能够被weak引用，则直接返回nil</span></span><br><span class="line">        <span class="keyword">if</span> ((IMP)allowsWeakReference == _objc_msgForward) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 调用referent的SEL_allowsWeakReference方法来判断是否正在被释放</span></span><br><span class="line">        deallocating =</span><br><span class="line">            ! (*allowsWeakReference)(referent, SEL_allowsWeakReference);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 正在析构的对象，不能够被弱引用</span></span><br><span class="line">    <span class="keyword">if</span> (deallocating) &#123;</span><br><span class="line">        <span class="comment">// 判断是否需要崩溃 如果需要则崩溃</span></span><br><span class="line">        <span class="keyword">if</span> (crashIfDeallocating) &#123;</span><br><span class="line">            _objc_fatal(<span class="string">&quot;Cannot form weak reference to instance (%p) of &quot;</span></span><br><span class="line">                        <span class="string">&quot;class %s. It is possible that this object was &quot;</span></span><br><span class="line">                        <span class="string">&quot;over-released, or is in the process of deallocation.&quot;</span>,</span><br><span class="line">                        (<span class="keyword">void</span>*)referent, object_getClassName((<span class="keyword">id</span>)referent));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对象没有被正在释放</span></span><br><span class="line">    weak_entry_t *entry;</span><br><span class="line">    <span class="comment">// 在 weak_table中找到referent对应的weak_entry,并将referrer加入到weak_entry中</span></span><br><span class="line">    <span class="comment">// 如果能找到weak_entry,则讲referrer插入到weak_entry中</span></span><br><span class="line">    <span class="keyword">if</span> ((entry = weak_entry_for_referent(weak_table, referent))) &#123;</span><br><span class="line">        <span class="comment">// 将referrer插入到weak_entry_t的引用数组中</span></span><br><span class="line">        append_referrer(entry, referrer);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个新的weak_entry_t ，并将referrer插入到weak_entry_t的引用数组中</span></span><br><span class="line">        weak_entry_t new_entry(referent, referrer);</span><br><span class="line">        <span class="comment">// weak_table的weak_entry_t 数组是否需要动态增长，若需要，则会扩容一倍</span></span><br><span class="line">        weak_grow_maybe(weak_table);</span><br><span class="line">        <span class="comment">// 将weak_entry_t插入到weak_table中</span></span><br><span class="line">        weak_entry_insert(weak_table, &amp;new_entry);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Do not set *referrer. objc_storeWeak() requires that the </span></span><br><span class="line">    <span class="comment">// value not change.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> referent_id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面方法主要功能是：添加对某个对象的新的弱引用指针</p>
<ul>
<li>过滤掉<code>isTaggedPointer</code>和弱引用对象正在被释放这两种情况后(这里需要判断是否有自定义的释放方法)，然后根据<code>crashIfDeallocating</code>参数确定是崩溃还是返回nil</li>
<li>如果对象没有正在被释放，那么从<code>weak_table</code>中取出指向<code>referent</code>的弱引用指针实体，如果<code>weak_table</code>中存在指向<code>referent</code>的指针数组那么在这个数组中添加要新增的指针</li>
<li>如果<code>weak_table</code>没有找到指向<code>referent</code>的弱指针数组，那么新建一个<code>weak_entry_t</code>对象，将这个对象拆入到<code>weak_table</code>中(需要判断weak_table是否需要扩容)</li>
</ul>
<p>下面我们来看下具体的插入方法：</p>
<h4 id="append-referrer追加"><a href="#append-referrer追加" class="headerlink" title="append_referrer追加"></a>append_referrer追加</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在entry对象的弱引用数组中追加一个新的弱引用指针new_referrer</span></span><br><span class="line"><span class="comment">// entry 被弱引用的对象</span></span><br><span class="line"><span class="comment">// new_referrer 弱引用entry的指针</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> append_referrer(weak_entry_t *entry, objc_object **new_referrer)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 如果entry中弱引用指针没有超过了4个 表示弱引用指针存放在inline_referrers中</span></span><br><span class="line">    <span class="comment">// weak_entry 尚未使用动态数组</span></span><br><span class="line">    <span class="keyword">if</span> (! entry-&gt;out_of_line()) &#123;</span><br><span class="line">        <span class="comment">// 遍历inline_referrers数组找到第一个为空的位置 将目标指针插入 尾部追加</span></span><br><span class="line">        <span class="keyword">for</span> (size_t i = <span class="number">0</span>; i &lt; WEAK_INLINE_COUNT; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (entry-&gt;inline_referrers[i] == <span class="literal">nil</span>) &#123;</span><br><span class="line">                entry-&gt;inline_referrers[i] = new_referrer;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果entry中弱引用指针==4个</span></span><br><span class="line">        <span class="comment">// 新创建一个weak_referrer_t数组 大小为4(WEAK_INLINE_COUNT)</span></span><br><span class="line">        <span class="comment">// 如果inline_referrers的位置已经存满了，则要转型为referrers，做动态数组。</span></span><br><span class="line">        weak_referrer_t *new_referrers = (weak_referrer_t *)</span><br><span class="line">            calloc(WEAK_INLINE_COUNT, <span class="keyword">sizeof</span>(weak_referrer_t));</span><br><span class="line">        <span class="comment">// 遍历inline_referrers 将数据放在新创建的临时数组中</span></span><br><span class="line">        <span class="keyword">for</span> (size_t i = <span class="number">0</span>; i &lt; WEAK_INLINE_COUNT; i++) &#123;</span><br><span class="line">            new_referrers[i] = entry-&gt;inline_referrers[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 弱引用指针的存储改为存放到entry-&gt;referrers(entry-&gt;inline_referrers -&gt; entry-&gt;referrers)</span></span><br><span class="line">        entry-&gt;referrers = new_referrers;</span><br><span class="line">        <span class="comment">// 更新弱引用个数</span></span><br><span class="line">        entry-&gt;num_refs = WEAK_INLINE_COUNT;</span><br><span class="line">        <span class="comment">//更新是否使用动态数组标记位</span></span><br><span class="line">        entry-&gt;out_of_line_ness = REFERRERS_OUT_OF_LINE;</span><br><span class="line">        <span class="comment">// 更新mask和最大哈希偏移值</span></span><br><span class="line">        entry-&gt;mask = WEAK_INLINE_COUNT<span class="number">-1</span>;</span><br><span class="line">        entry-&gt;max_hash_displacement = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    assert(entry-&gt;out_of_line());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果只想entry的弱引用个数大于4</span></span><br><span class="line">    <span class="comment">// 弱引用个数是否已超过数组容量的3/4</span></span><br><span class="line">    <span class="keyword">if</span> (entry-&gt;num_refs &gt;= TABLE_SIZE(entry) * <span class="number">3</span>/<span class="number">4</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果已超过 那么先扩容在插入</span></span><br><span class="line">        <span class="keyword">return</span> grow_refs_and_insert(entry, new_referrer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果不需要扩容，直接插入到weak_entry中</span></span><br><span class="line">    <span class="comment">// 注意，weak_entry是一个哈希表，key：w_hash_pointer(new_referrer) value: new_referrer</span></span><br><span class="line">    size_t begin = w_hash_pointer(new_referrer) &amp; (entry-&gt;mask);</span><br><span class="line">    size_t index = begin;</span><br><span class="line">    size_t hash_displacement = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 由低到高遍历entry-&gt;referrers 找到第一个空位置</span></span><br><span class="line">    <span class="keyword">while</span> (entry-&gt;referrers[index] != <span class="literal">nil</span>) &#123;</span><br><span class="line">        hash_displacement++;</span><br><span class="line">        index = (index+<span class="number">1</span>) &amp; entry-&gt;mask;</span><br><span class="line">        <span class="comment">// 如果遍历了所有元素后都没有找到 那么报错</span></span><br><span class="line">        <span class="keyword">if</span> (index == begin)</span><br><span class="line">            bad_weak_table(entry);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新最大哈希偏移值</span></span><br><span class="line">    <span class="keyword">if</span> (hash_displacement &gt; entry-&gt;max_hash_displacement) &#123;</span><br><span class="line">        entry-&gt;max_hash_displacement = hash_displacement;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将new_referrer插入到数组的第index个位置</span></span><br><span class="line">    weak_referrer_t &amp;ref = entry-&gt;referrers[index];</span><br><span class="line">    ref = new_referrer;</span><br><span class="line">    <span class="comment">// 弱引用计个数+1</span></span><br><span class="line">    entry-&gt;num_refs++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>插入的过程主要分下面三种情况:</p>
<ul>
<li>如果<code>inline_referrers</code>没有存储满，直接存储到<code>inline_referrers</code>中</li>
<li>如果<code>inline_referrers</code>个数是4个了，在插入，就需要将<code>inline_referrers</code>拷贝到<code>referrers</code>，然后进入第三步。</li>
<li>如果<code>inline_referrers</code>存储满了，判断是否需要扩容，然后将数据存储到<code>referrers</code>中。</li>
</ul>
<p>下面我们来看下扩容的方法:</p>
<h4 id="grow-refs-and-insert"><a href="#grow-refs-and-insert" class="headerlink" title="grow_refs_and_insert"></a>grow_refs_and_insert</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// entry 中存放弱引用指针数组 扩容</span></span><br><span class="line"><span class="comment">// weak_entry_t 要扩容的对象</span></span><br><span class="line"><span class="comment">// new_referrer 要插入的指向entry-&gt;referent弱引用指针</span></span><br><span class="line">__attribute__((noinline, used))</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> grow_refs_and_insert(weak_entry_t *entry, </span><br><span class="line">                                 objc_object **new_referrer)</span><br><span class="line">&#123;</span><br><span class="line">    assert(entry-&gt;out_of_line());</span><br><span class="line">    <span class="comment">// 获取entry当前的大小</span></span><br><span class="line">    size_t old_size = TABLE_SIZE(entry);</span><br><span class="line">    <span class="comment">// 新的大小为旧的大小的2倍</span></span><br><span class="line">    size_t new_size = old_size ? old_size * <span class="number">2</span> : <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取weak_entry_t中存储的弱引用指针个数</span></span><br><span class="line">    size_t num_refs = entry-&gt;num_refs;</span><br><span class="line">    <span class="comment">//获取entry中旧的引用数组</span></span><br><span class="line">    weak_referrer_t *old_refs = entry-&gt;referrers;</span><br><span class="line">    <span class="comment">// 更新entry-&gt;mask 这里是为了后续申请内存空间使用</span></span><br><span class="line">    entry-&gt;mask = new_size - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个新的entry-&gt;referrers数组</span></span><br><span class="line">    <span class="comment">// #define TABLE_SIZE(entry) (entry-&gt;mask ? entry-&gt;mask + 1 : 0)</span></span><br><span class="line">    <span class="comment">// TABLE_SIZE 获取的数组大小是 mask+1 = new_size</span></span><br><span class="line">    entry-&gt;referrers = (weak_referrer_t *)</span><br><span class="line">        calloc(TABLE_SIZE(entry), <span class="keyword">sizeof</span>(weak_referrer_t));</span><br><span class="line">    <span class="comment">// 重置num_refs和max_hash_displacement</span></span><br><span class="line">    entry-&gt;num_refs = <span class="number">0</span>;</span><br><span class="line">    entry-&gt;max_hash_displacement = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将old_refs中的数据重新插入到新创建entry-&gt;referrers中</span></span><br><span class="line">    <span class="keyword">for</span> (size_t i = <span class="number">0</span>; i &lt; old_size &amp;&amp; num_refs &gt; <span class="number">0</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (old_refs[i] != <span class="literal">nil</span>) &#123;</span><br><span class="line">            append_referrer(entry, old_refs[i]);</span><br><span class="line">            num_refs--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将new_referrer插入到扩容后的entry中</span></span><br><span class="line">    append_referrer(entry, new_referrer);</span><br><span class="line">    <span class="keyword">if</span> (old_refs) free(old_refs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>看完了新增弱引用指针的操作，接下来我们看下如何删除弱引用指针即<code>weak_unregister_no_lock</code></p>
<h4 id="weak-unregister-no-lock"><a href="#weak-unregister-no-lock" class="headerlink" title="weak_unregister_no_lock"></a>weak_unregister_no_lock</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将 weak ptr地址 从obj的weak_entry_t中移除</span></span><br><span class="line"><span class="comment">// 参数weak_table 全局弱引用表</span></span><br><span class="line"><span class="comment">// referent_id 弱引用所指向的对象</span></span><br><span class="line"><span class="comment">// referrer_id 弱引用指针地址</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">weak_unregister_no_lock(weak_table_t *weak_table, <span class="keyword">id</span> referent_id, </span><br><span class="line">                        <span class="keyword">id</span> *referrer_id)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 被弱引用的对象</span></span><br><span class="line">    objc_object *referent = (objc_object *)referent_id;</span><br><span class="line">    <span class="comment">// 指向被弱引用对象的指针的地址</span></span><br><span class="line">    objc_object **referrer = (objc_object **)referrer_id;</span><br><span class="line"></span><br><span class="line">    weak_entry_t *entry;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!referent) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到weak_table中指向被弱引用对象的所有指针 类型为 weak_entry_t</span></span><br><span class="line">    <span class="keyword">if</span> ((entry = weak_entry_for_referent(weak_table, referent))) &#123;</span><br><span class="line">        <span class="comment">// 从数组中删除当前这个弱引用指针</span></span><br><span class="line">        remove_referrer(entry, referrer);</span><br><span class="line">        <span class="keyword">bool</span> empty = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 弱引用referent对象的弱引用指针是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (entry-&gt;out_of_line()  &amp;&amp;  entry-&gt;num_refs != <span class="number">0</span>) &#123;</span><br><span class="line">            empty = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果referrer数组中为空 那么判断inline_referrers中是否为空 如果为空empty=true</span></span><br><span class="line">            <span class="keyword">for</span> (size_t i = <span class="number">0</span>; i &lt; WEAK_INLINE_COUNT; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (entry-&gt;inline_referrers[i]) &#123;</span><br><span class="line">                    empty = <span class="literal">false</span>; </span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果为空 则证明没有其他指针指向这个被所引用的对象</span></span><br><span class="line">        <span class="keyword">if</span> (empty) &#123;</span><br><span class="line">            <span class="comment">// 将这个实体从weak_table中移除</span></span><br><span class="line">            weak_entry_remove(weak_table, entry);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Do not set *referrer = nil. objc_storeWeak() requires that the </span></span><br><span class="line">    <span class="comment">// value not change.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>weak_unregister_no_lock</code>的实现逻辑比较简单,其实主要的操作为:</p>
<ul>
<li>首先，它会在<code>weak_table</code>中找出<code>referent</code>对应的<code>weak_entry_t</code></li>
<li>在<code>weak_entry_t</code>中移除<code>referrer</code></li>
<li>移除元素后，判断此时<code>weak_entry_t</code>中是否还有元素 <code>（empty==true？）</code></li>
<li>如果此时<code>weak_entry_t</code>已经没有元素了，则需要将<code>weak_entry_t从weak_table</code>中移除</li>
</ul>
<p>而对于<code>remove_referrer</code>方法，我们来简单的看下他的实现:</p>
<h4 id="remove-referrer"><a href="#remove-referrer" class="headerlink" title="remove_referrer"></a>remove_referrer</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 删除old_referrer集合中的referrers</span></span><br><span class="line"><span class="comment">// 参数 entry 被弱引用对象</span></span><br><span class="line"><span class="comment">// 参数 old_referrer 要删除的弱引用指针</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> remove_referrer(weak_entry_t *entry, objc_object **old_referrer)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 指向entry的弱引用指针不超过4个</span></span><br><span class="line">    <span class="keyword">if</span> (! entry-&gt;out_of_line()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (size_t i = <span class="number">0</span>; i &lt; WEAK_INLINE_COUNT; i++) &#123;</span><br><span class="line">            <span class="comment">// 遍历inline_referrers数组如果找到直接置空</span></span><br><span class="line">            <span class="keyword">if</span> (entry-&gt;inline_referrers[i] == old_referrer) &#123;</span><br><span class="line">                entry-&gt;inline_referrers[i] = <span class="literal">nil</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果没有找到 则报错 弱引用指针小于4个且在inline_referrers中没有找到</span></span><br><span class="line">        _objc_inform(<span class="string">&quot;Attempted to unregister unknown __weak variable &quot;</span></span><br><span class="line">                     <span class="string">&quot;at %p. This is probably incorrect use of &quot;</span></span><br><span class="line">                     <span class="string">&quot;objc_storeWeak() and objc_loadWeak(). &quot;</span></span><br><span class="line">                     <span class="string">&quot;Break on objc_weak_error to debug.\n&quot;</span>, </span><br><span class="line">                     old_referrer);</span><br><span class="line">        objc_weak_error();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 哈希函数 判断这个旧的弱引用指针存放的位置</span></span><br><span class="line">    size_t begin = w_hash_pointer(old_referrer) &amp; (entry-&gt;mask);</span><br><span class="line">    size_t index = begin;</span><br><span class="line">    size_t hash_displacement = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 遍历entry-&gt;referrers数组查找old_referrer</span></span><br><span class="line">    <span class="keyword">while</span> (entry-&gt;referrers[index] != old_referrer) &#123;</span><br><span class="line">        <span class="comment">// 如果没有在指定index找到 那么取下一个位置的值比较</span></span><br><span class="line">        index = (index+<span class="number">1</span>) &amp; entry-&gt;mask;</span><br><span class="line">        <span class="comment">// 如果找了一圈仍然没有找到 那么报错</span></span><br><span class="line">        <span class="keyword">if</span> (index == begin)</span><br><span class="line">            bad_weak_table(entry);</span><br><span class="line">        <span class="comment">// 更新最大哈希偏移值</span></span><br><span class="line">        hash_displacement++;</span><br><span class="line">        <span class="comment">// 如果最大哈希偏移值 超过了预定的限制 那么报错</span></span><br><span class="line">        <span class="keyword">if</span> (hash_displacement &gt; entry-&gt;max_hash_displacement) &#123;</span><br><span class="line">            _objc_inform(<span class="string">&quot;Attempted to unregister unknown __weak variable &quot;</span></span><br><span class="line">                         <span class="string">&quot;at %p. This is probably incorrect use of &quot;</span></span><br><span class="line">                         <span class="string">&quot;objc_storeWeak() and objc_loadWeak(). &quot;</span></span><br><span class="line">                         <span class="string">&quot;Break on objc_weak_error to debug.\n&quot;</span>, </span><br><span class="line">                         old_referrer);</span><br><span class="line">            objc_weak_error();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 走到这一步说明在entry-&gt;referrers中的index位置找到了值为old_referrer的引用</span></span><br><span class="line">    <span class="comment">// 将数组的这个位置置空</span></span><br><span class="line">    entry-&gt;referrers[index] = <span class="literal">nil</span>;</span><br><span class="line">    <span class="comment">// 弱引用个数-1</span></span><br><span class="line">    entry-&gt;num_refs--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的描述也很简单，大概的流程为：</p>
<ul>
<li>在<code>entry-&gt;inline_referrers</code>中一次查找值为<code>old_referrer</code>的指针 如果找到就清空如果没找到报错</li>
<li>在<code>entry-&gt;referrers</code>中查找值为<code>old_referrer</code>的指针，如果找到则置空同时<code>entry-&gt;num_refs</code>做-1操作(使用<code>inline_referrers</code>存储时不会更新<code>num_refs</code>值因此移除也不用-1)</li>
</ul>
<p>我们在删除指向某个对象的某个弱引用指针之后，还会对存储指向该对象的弱引用指针数组做判空操作，如果发现数组为空，那表示目前没有弱引用指针指向这个对象，那我们需要将这个对象从<code>weak_table</code>中移除。下面我们来看下移除方法<code>weak_entry_remove</code>。</p>
<h4 id="weak-entry-remove"><a href="#weak-entry-remove" class="headerlink" title="weak_entry_remove"></a>weak_entry_remove</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//从weak_table中移除entry (指向entry的弱引用指针数为0)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> weak_entry_remove(weak_table_t *weak_table, weak_entry_t *entry)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 如果弱引用指针超过4个(弱引用指针存放在entry-&gt;referrers中)</span></span><br><span class="line">    <span class="keyword">if</span> (entry-&gt;out_of_line())</span><br><span class="line">        <span class="comment">// 释放entry-&gt;referrers中所有数据</span></span><br><span class="line">        free(entry-&gt;referrers);</span><br><span class="line">    bzero(entry, <span class="keyword">sizeof</span>(*entry));</span><br><span class="line">    <span class="comment">//num_entries-1</span></span><br><span class="line">    weak_table-&gt;num_entries--;</span><br><span class="line">    <span class="comment">//weak_table是否需要锁绒</span></span><br><span class="line">    weak_compact_maybe(weak_table);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面方法的主要操作为:</p>
<ul>
<li>将没有弱引用的对象从全局的<code>weak_table</code>中移除</li>
<li>减少<code>weak_table</code>中存储的弱引用对象个数</li>
<li>判断<code>weak_table</code>是否需要缩小容量</li>
</ul>
<p>上面的所有就是当我们将一个obj作weak引用时，所发生的事情。那么，当obj释放时，所有weak引用它的指针又是如何自动设置为nil的呢？接下来我们来看一下obj释放时，所发生的事情。</p>
<h3 id="Dealloc"><a href="#Dealloc" class="headerlink" title="Dealloc"></a>Dealloc</h3><p>当对象引用计数为0时，runtime会调用_objc_rootDealloc方法来析构对象，实现如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)dealloc &#123;</span><br><span class="line">    _objc_rootDealloc(<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">_objc_rootDealloc(<span class="keyword">id</span> obj)</span><br><span class="line">&#123;</span><br><span class="line">    assert(obj);</span><br><span class="line"></span><br><span class="line">    obj-&gt;rootDealloc();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>_objc_rootDealloc</code>又会调用objc_object的<code>rootDealloc</code>方法</p>
<h4 id="rootDealloc"><a href="#rootDealloc" class="headerlink" title="rootDealloc"></a>rootDealloc</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">objc_object::rootDealloc()</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//    判断object是否采用了Tagged Pointer计数，如果是，则不进行任何析构操作。</span></span><br><span class="line">    <span class="keyword">if</span> (isTaggedPointer()) <span class="keyword">return</span>;  <span class="comment">// fixme necessary?</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//接下来判断对象是否采用了优化的isa计数方式（isa.nonpointer）</span></span><br><span class="line">    <span class="comment">// 对象没有被weak引用!isa.weakly_referenced</span></span><br><span class="line">    <span class="comment">// 没有关联对象!isa.has_assoc</span></span><br><span class="line">    <span class="comment">// 没有自定义的C++析构方法!isa.has_cxx_dtor</span></span><br><span class="line">    <span class="comment">// 没有用到sideTable来做引用计数 !isa.has_sidetable_rc</span></span><br><span class="line">    <span class="comment">// 如果满足条件 则可以快速释放</span></span><br><span class="line">    <span class="keyword">if</span> (fastpath(isa.nonpointer  &amp;&amp;  </span><br><span class="line">                 !isa.weakly_referenced  &amp;&amp;  </span><br><span class="line">                 !isa.has_assoc  &amp;&amp;  </span><br><span class="line">                 !isa.has_cxx_dtor  &amp;&amp;  </span><br><span class="line">                 !isa.has_sidetable_rc))</span><br><span class="line">    &#123;</span><br><span class="line">        assert(!sidetable_present());</span><br><span class="line">        free(<span class="keyword">this</span>);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 慢速释放</span></span><br><span class="line">        object_dispose((<span class="keyword">id</span>)<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此根据上面代码判断，如果obj被weak引用了，应该进入<code>object_dispose((id)this)</code>分支，下面我们来看下<code>object_dispose</code>方法：</p>
<h4 id="object-dispose"><a href="#object-dispose" class="headerlink" title="object_dispose"></a>object_dispose</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">id</span> </span><br><span class="line">object_dispose(<span class="keyword">id</span> obj)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!obj) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    <span class="comment">// 析构obj</span></span><br><span class="line">    objc_destructInstance(obj);</span><br><span class="line">    <span class="comment">// 释放内存</span></span><br><span class="line">    free(obj);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>析构obj主要是看<code>objc_destructInstance</code>方法，下面我们来看下这个方法的实现</p>
<h4 id="objc-destructInstance"><a href="#objc-destructInstance" class="headerlink" title="objc_destructInstance"></a>objc_destructInstance</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> *objc_destructInstance(<span class="keyword">id</span> obj) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj) &#123;</span><br><span class="line">        <span class="comment">// Read all of the flags at once for performance.</span></span><br><span class="line">		<span class="comment">//c++析构函数</span></span><br><span class="line">        <span class="keyword">bool</span> cxx = obj-&gt;hasCxxDtor();</span><br><span class="line">		<span class="comment">//关联函数</span></span><br><span class="line">        <span class="keyword">bool</span> assoc = obj-&gt;hasAssociatedObjects();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果有c++析构函数 则调用c++析构函数.</span></span><br><span class="line">        <span class="keyword">if</span> (cxx)</span><br><span class="line">            object_cxxDestruct(obj);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果有关联对象则移除关联对象</span></span><br><span class="line">        <span class="keyword">if</span> (assoc)</span><br><span class="line">            _object_remove_assocations(obj);</span><br><span class="line">        <span class="comment">// 清理相关的引用</span></span><br><span class="line">        obj-&gt;clearDeallocating();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>清理相关引用方法主要是在<code>clearDeallocating</code>中实现的，下面我们再来看下这个方法：</p>
<h4 id="clearDeallocating"><a href="#clearDeallocating" class="headerlink" title="clearDeallocating"></a>clearDeallocating</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//正在清除side table 和weakly referenced</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> </span><br><span class="line">objc_object::clearDeallocating()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// obj是否采用了优化isa引用计数</span></span><br><span class="line">    <span class="keyword">if</span> (slowpath(!isa.nonpointer)) &#123;</span><br><span class="line">		<span class="comment">//没有采用优化isa引用计数 清理obj存储在sideTable中的引用计数等信息</span></span><br><span class="line">        sidetable_clearDeallocating();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 启用了isa优化，则判断是否使用了sideTable</span></span><br><span class="line">    <span class="comment">// 使用的原因是因为做了weak引用（isa.weakly_referenced ） 或 使用了sideTable的辅助引用计数（isa.has_sidetable_rc）</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (slowpath(isa.weakly_referenced  ||  isa.has_sidetable_rc)) &#123;</span><br><span class="line">        <span class="comment">// Slow path for non-pointer isa with weak refs and/or side table data.</span></span><br><span class="line">		<span class="comment">//释放weak 和引用计数</span></span><br><span class="line">        clearDeallocating_slow();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    assert(!sidetable_present());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的清理方法有两个分别为<code>sidetable_clearDeallocating</code>和<code>clearDeallocating_slow</code>,</p>
<p>我们先来看下<code>clearDeallocating_slow</code>：</p>
<h4 id="clearDeallocating-slow"><a href="#clearDeallocating-slow" class="headerlink" title="clearDeallocating_slow"></a>clearDeallocating_slow</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">NEVER_INLINE <span class="keyword">void</span></span><br><span class="line">objc_object::clearDeallocating_slow()</span><br><span class="line">&#123;</span><br><span class="line">    assert(isa.nonpointer  &amp;&amp;  (isa.weakly_referenced || isa.has_sidetable_rc));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在全局的SideTables中，以this指针为key，找到对应的SideTable</span></span><br><span class="line">    SideTable&amp; table = SideTables()[<span class="keyword">this</span>];</span><br><span class="line">    table.lock();</span><br><span class="line">    	<span class="comment">//// 如果obj被弱引用</span></span><br><span class="line">    <span class="keyword">if</span> (isa.weakly_referenced) &#123;</span><br><span class="line">		<span class="comment">//// 在SideTable的weak_table中对this进行清理工作</span></span><br><span class="line">        weak_clear_no_lock(&amp;table.weak_table, (<span class="keyword">id</span>)<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 如果采用了SideTable做引用计数</span></span><br><span class="line">    <span class="keyword">if</span> (isa.has_sidetable_rc) &#123;</span><br><span class="line">		<span class="comment">//在SideTable的引用计数中移除this</span></span><br><span class="line">        table.refcnts.erase(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    table.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里调用了<code>weak_clear_no_lock</code>来做<code>weak_table</code>的清理工作，同时将所有weak引用该对象的ptr置为nil。</p>
<h4 id="weak-clear-no-lock"><a href="#weak-clear-no-lock" class="headerlink" title="weak_clear_no_lock"></a>weak_clear_no_lock</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//清理weak_table，同时将所有weak引用该对象的ptr置为nil</span></span><br><span class="line"><span class="keyword">void</span> </span><br><span class="line">weak_clear_no_lock(weak_table_t *weak_table, <span class="keyword">id</span> referent_id) </span><br><span class="line">&#123;</span><br><span class="line">    objc_object *referent = (objc_object *)referent_id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到referent在weak_table中对应的weak_entry_t</span></span><br><span class="line">    weak_entry_t *entry = weak_entry_for_referent(weak_table, referent);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (entry == <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="comment">/// XXX shouldn&#x27;t happen, but does with mismatched CF/objc</span></span><br><span class="line">        <span class="comment">//printf(&quot;XXX no entry for clear deallocating %p\n&quot;, referent);</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找出weak引用referent的weak 指针地址数组以及数组长度</span></span><br><span class="line">    weak_referrer_t *referrers;</span><br><span class="line">    size_t count;</span><br><span class="line">    <span class="comment">// 是否使用动态数组</span></span><br><span class="line">    <span class="keyword">if</span> (entry-&gt;out_of_line()) &#123;</span><br><span class="line">        referrers = entry-&gt;referrers;</span><br><span class="line">        count = TABLE_SIZE(entry);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        referrers = entry-&gt;inline_referrers;</span><br><span class="line">        count = WEAK_INLINE_COUNT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历所有的所引用weak指针</span></span><br><span class="line">    <span class="keyword">for</span> (size_t i = <span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line">        <span class="comment">// 取出每个weak ptr的地址</span></span><br><span class="line">        objc_object **referrer = referrers[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (referrer) &#123;</span><br><span class="line">            <span class="comment">// 如果weak ptr确实weak引用了referent，则将weak ptr设置为nil，这也就是为什么weak 指针会自动设置为nil的原因</span></span><br><span class="line">            <span class="keyword">if</span> (*referrer == referent) &#123;</span><br><span class="line">                *referrer = <span class="literal">nil</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (*referrer) &#123;</span><br><span class="line">                <span class="comment">// 如果所存储的weak ptr没有weak 引用referent，这可能是由于runtime代码的逻辑错误引起的，报错</span></span><br><span class="line">                _objc_inform(<span class="string">&quot;__weak variable at %p holds %p instead of %p. &quot;</span></span><br><span class="line">                             <span class="string">&quot;This is probably incorrect use of &quot;</span></span><br><span class="line">                             <span class="string">&quot;objc_storeWeak() and objc_loadWeak(). &quot;</span></span><br><span class="line">                             <span class="string">&quot;Break on objc_weak_error to debug.\n&quot;</span>, </span><br><span class="line">                             referrer, (<span class="keyword">void</span>*)*referrer, (<span class="keyword">void</span>*)referent);</span><br><span class="line">                objc_weak_error();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 由于referent要被释放了，因此referent的weak_entry_t也要移除出weak_table</span></span><br><span class="line">    weak_entry_remove(weak_table, entry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面就是为什么当对象析构时，所有弱引用该对象的指针都会被设置为nil的原因。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>综上我们讲述了SideTable的结构，以及如何使用SideTable存储和清除对象和指向这些对象的指针地址。从而在侧面验证了弱引用的存储方式以及在对象释放时如何将弱引用的指针置空。读完这篇文章相信你对于SideTable结构和弱引用已经有了一个比较全面的认识。</p>
]]></content>
      <categories>
        <category>iOS进阶</category>
      </categories>
      <tags>
        <tag>SideTable</tag>
      </tags>
  </entry>
  <entry>
    <title>RunTime的那些事儿</title>
    <url>/2018/03/02/runtime-common-method/</url>
    <content><![CDATA[<p>Runtime 又叫运行时，是一套底层的 C 语言 API，其为 iOS 内部的核心之一，我们平时编写的 OC 代码，底层都是基于它来实现的!</p>
<a id="more"></a>

<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[receiver message];</span><br><span class="line">&#x2F;&#x2F; 底层运行时会被编译器转化为：</span><br><span class="line">objc_msgSend(receiver, selector)</span><br><span class="line">&#x2F;&#x2F; 如果其还有参数比如：</span><br><span class="line">[receiver message:(id)arg...];</span><br><span class="line">&#x2F;&#x2F; 底层运行时会被编译器转化为：</span><br><span class="line">objc_msgSend(receiver, selector, arg1, arg2, ...)</span><br></pre></td></tr></table></figure>

<p>Objective-C 是一门动态语言，它会将一些工作放在代码运行时才处理而并非编译时。也就是说，有很多类和成员变量在我们编译的时是不知道的，而在运行时，我们所编写的代码会转换成完整的确定的代码运行。</p>
<p>因此，编译器是不够的，我们还需要一个运行时系统(Runtime system)来处理编译后的代码。</p>
<p>Runtime 基本是用 C 和汇编写的。</p>
<h2 id="了解Runtime的方式"><a href="#了解Runtime的方式" class="headerlink" title="了解Runtime的方式"></a>了解Runtime的方式</h2><p>Objc 在三种层面上与 Runtime 系统进行交互：</p>
<blockquote>
<p>通过 Objective-C 源代码<br>通过 Foundation 框架的 NSObject 类定义的方法<br>通过对 Runtime 库函数的直接调用</p>
</blockquote>
<h3 id="通过-Objective-C-源代码"><a href="#通过-Objective-C-源代码" class="headerlink" title="通过 Objective-C 源代码"></a>通过 Objective-C 源代码</h3><p>多数情况我们只需要编写 OC 代码即可，Runtime 系统自动在幕后搞定一切，还记得简介中如果我们调用方法，编译器会将 OC 代码转换成运行时代码，在运行时确定数据结构和函数。</p>
<h3 id="通过-Foundation-框架的-NSObject-类定义的方法"><a href="#通过-Foundation-框架的-NSObject-类定义的方法" class="headerlink" title="通过 Foundation 框架的 NSObject 类定义的方法"></a>通过 Foundation 框架的 NSObject 类定义的方法</h3><p>Cocoa 程序中绝大部分类都是 NSObject 类的子类，所以都继承了 NSObject 的行为。(<code>NSProxy</code> 类时个例外，它是个抽象超类)</p>
<p>一些情况下，NSObject 类仅仅定义了完成某件事情的模板，并没有提供所需要的代码。例如 <code>-description</code> 方法，该方法返回类内容的字符串表示，该方法主要用来调试程序。NSObject 类并不知道子类的内容，所以它只是返回类的名字和对象的地址，NSObject 的子类可以重新实现。</p>
<blockquote>
<p><code>-class</code>方法返回对象的类；<br><code>-isKindOfClass:</code> 和 <code>-isMemberOfClass:</code> 方法检查对象是否存在于指定的类的继承体系中(是否是其子类或者父类或者当前类的成员变量)；</p>
</blockquote>
<blockquote>
<p><code>-respondsToSelector:</code> 检查对象能否响应指定的消息；<br><code>-conformsToProtocol:</code>检查对象是否实现了指定协议类的方法；<br><code>-methodForSelector:</code> 返回指定方法实现的地址</p>
</blockquote>
<h3 id="通过对-Runtime-库函数的直接调用"><a href="#通过对-Runtime-库函数的直接调用" class="headerlink" title="通过对 Runtime 库函数的直接调用"></a>通过对 Runtime 库函数的直接调用</h3><p>Runtime 系统是具有公共接口的动态共享库。头文件存放于<code>/usr/include/objc</code>目录下，这意味着我们使用时只需要引入<code>objc/Runtime.h</code>头文件即可。</p>
<p>许多函数可以让你使用纯 C 代码来实现 Objc 中同样的功能。除非是写一些 Objc 与其他语言的桥接或是底层的 debug 工作，你在写 Objc 代码时一般不会用到这些 C 语言函数。对于公共接口都有哪些，后面会讲到。我将会参考苹果官方的 API 文档。</p>
<h2 id="Runtime-详解"><a href="#Runtime-详解" class="headerlink" title="Runtime 详解"></a>Runtime 详解</h2><p>要想全面了解 Runtime 机制，我们必须先了解 Runtime 的一些术语，他们都对应着数据结构。</p>
<h3 id="SEL"><a href="#SEL" class="headerlink" title="SEL"></a>SEL</h3><p>它是<code>selector</code>在 Objc 中的表示(Swift 中是 Selector 类)</p>
<p><code>Selector</code> 是方法选择器，其实作用就和名字一样，日常生活中，我们通过人名辨别谁是谁，注意 Objc 在相同的类中不会有命名相同的两个方法</p>
<p><code>selector</code> 对方法名进行包装，以便找到对应的方法实现</p>
<p>数据结构：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef struct objc_selector *SEL;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们可以看出它是个映射到方法的 C 字符串，你可以通过 Objc 编译器器命令<code>@selector() </code>或者 Runtime 系统的 <code>sel_registerName</code> 函数来获取一个 SEL 类型的方法选择器。</p>
<p><code>注意</code>：</p>
<p>不同类中相同名字的方法所对应的 selector 是相同的，由于变量的类型不同，所以不会导致它们调用方法实现混乱。</p>
<h3 id="id"><a href="#id" class="headerlink" title="id"></a>id</h3><p>id 是一个参数类型，它是指向某个类的实例的指针。定义如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef struct objc_object *id;</span><br><span class="line">struct objc_object &#123; Class isa; &#125;;</span><br></pre></td></tr></table></figure>

<p>以上定义，看到 <code>objc_object</code> 结构体包含一个 <code>isa</code> 指针，根据 <code>isa</code> 指针就可以找到对象所属的类。</p>
<p><code>注意</code>：<br><code>isa</code> 指针在代码运行时并不总指向实例对象所属的类型，所以不能依靠它来确定类型，要想确定类型还是需要用对象的 <code>-class</code> 方法。</p>
<p>PS:KVO 的实现机理就是将被观察对象的 isa 指针指向一个中间类而不是真实类型，</p>
<h3 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h3><p>Class 其实是指向 <code>objc_class</code> 结构体的指针</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_class *Class;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>objc_class 的数据结构如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_class</span> &#123;</span></span><br><span class="line">    Class isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !__OBJC2__</span></span><br><span class="line">    Class super_class                                        OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name                                         OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">long</span> version                                             OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">long</span> info                                                OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">long</span> instance_size                                       OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">objc_ivar_list</span> *<span class="title">ivars</span>                             <span class="title">OBJC2_UNAVAILABLE</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">objc_method_list</span> **<span class="title">methodLists</span>                    <span class="title">OBJC2_UNAVAILABLE</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">objc_cache</span> *<span class="title">cache</span>                                 <span class="title">OBJC2_UNAVAILABLE</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">objc_protocol_list</span> *<span class="title">protocols</span>                     <span class="title">OBJC2_UNAVAILABLE</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">&#125; OBJC2_UNAVAILABLE;</span><br></pre></td></tr></table></figure>

<p>从 <code>objc_class</code> 可以看到，一个运行时类中关联了它的父类指针、类名、成员变量、方法、缓存以及附属的协议。</p>
<p>其中 <code>objc_ivar_list</code> 和 <code>objc_method_list</code> 分别是成员变量列表和方法列表：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 成员变量列表</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_ivar_list</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> ivar_count                                           OBJC2_UNAVAILABLE;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __LP64__</span></span><br><span class="line">    <span class="keyword">int</span> space                                                OBJC2_UNAVAILABLE;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">/* variable length structure */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">objc_ivar</span> <span class="title">ivar_list</span>[1]                            <span class="title">OBJC2_UNAVAILABLE</span>;</span></span><br><span class="line">&#125;                                                            OBJC2_UNAVAILABLE;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法列表</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_method_list</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">objc_method_list</span> *<span class="title">obsolete</span>                        <span class="title">OBJC2_UNAVAILABLE</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> method_count                                         OBJC2_UNAVAILABLE;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __LP64__</span></span><br><span class="line">    <span class="keyword">int</span> space                                                OBJC2_UNAVAILABLE;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">/* variable length structure */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">objc_method</span> <span class="title">method_list</span>[1]                        <span class="title">OBJC2_UNAVAILABLE</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由此可见，我们可以动态修改 <code>*methodList</code> 的值来添加成员方法，这也是 Category 实现的原理，同样解释了 Category 不能添加属性的原因。这里可以参考下美团技术团队的文章：<a href="https://tech.meituan.com/DiveIntoCategory.html">深入理解 Objective-C: Category</a>。</p>
<p><code>objc_ivar_list</code> 结构体用来存储成员变量的列表，而 <code>objc_ivar</code> 则是存储了单个成员变量的信息；<br>‘同理，<code>objc_method_list</code> 结构体存储着方法数组的列表，而单个方法的信息则由 <code>objc_method</code> 结构体存储</p>
<p>值得注意的时，<code>objc_class</code> 中也有一个 isa 指针，这说明 Objc 类本身也是一个对象。为了处理类和对象的关系，Runtime 库创建了一种叫做 <code>Meta Class(元类)</code> 的东西，类对象所属的类就叫做元类。<code>Meta Class</code> 表述了类对象本身所具备的元数据。</p>
<p>我们所熟悉的类方法，就源自于 <code>Meta Class</code>。我们可以理解为类方法就是类对象的实例方法。每个类仅有一个类对象，而每个类对象仅有一个与之相关的元类。</p>
<p>当你发出一个类似 <code>[NSObject alloc](类方法) </code>的消息时，实际上，这个消息被发送给了一个类对象<code>(Class Object)</code>，这个类对象必须是一个元类的实例，而这个元类同时也是一个根元类<code>(Root Meta Class)</code>的实例。所有元类的 isa 指针最终都指向根元类。</p>
<p>所以当 <code>[NSObject alloc]</code> 这条消息发送给类对象的时候，运行时代码 <code>objc_msgSend()</code> 会去它元类中查找能够响应消息的方法实现，如果找到了，就会对这个类对象执行方法调用</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1330553-81f64a11ad20c764.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="执行方法调用"></p>
<p>上图实现是 <code>super_class</code> 指针，虚线时 isa 指针。而根元类的父类是 <code>NSObject</code>，isa指向了自己。而 NSObject 没有父类。</p>
<p>最后 <code>objc_class</code> 中还有一个 <code>objc_cache</code> ，缓存，它的作用很重要，后面会提到。</p>
<h3 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h3><p>Method 代表类中某个方法的类型</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">objc_method</span> *<span class="title">Method</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_method</span> &#123;</span></span><br><span class="line">    SEL method_name                                          OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">char</span> *method_types                                       OBJC2_UNAVAILABLE;</span><br><span class="line">    IMP method_imp                                           OBJC2_UNAVAILABLE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>objc_method</code> 存储了方法名，方法类型和方法实现：</p>
<blockquote>
<p>方法名类型为 SEL<br>方法类型 <code>method_types</code> 是个 char 指针，存储方法的参数类 型和返回值类型<br><code>method_imp</code> 指向了方法的实现，本质是一个函数指针</p>
</blockquote>
<h3 id="Ivar"><a href="#Ivar" class="headerlink" title="Ivar"></a>Ivar</h3><p>Ivar 是表示成员变量的类型。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">objc_ivar</span> *<span class="title">Ivar</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_ivar</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> *ivar_name                                          OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">char</span> *ivar_type                                          OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">int</span> ivar_offset                                          OBJC2_UNAVAILABLE;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __LP64__</span></span><br><span class="line">    <span class="keyword">int</span> space                                                OBJC2_UNAVAILABLE;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 <code>ivar_offset</code> 是基地址偏移字节</p>
<h3 id="IMP"><a href="#IMP" class="headerlink" title="IMP"></a>IMP</h3><p>IMP在objc.h中的定义是：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">id</span> <span class="params">(*IMP)</span><span class="params">(id, SEL, ...)</span></span>;</span><br></pre></td></tr></table></figure>

<p>IMP在objc.h中的定义是：</p>
<p><code>typedef id (*IMP)(id, SEL, ...);</code></p>
<p>它就是一个函数指针，这是由编译器生成的。当你发起一个 ObjC 消息之后，最终它会执行的那段代码，就是由这个函数指针指定的。而 <code>IMP</code> 这个函数指针就指向了这个方法的实现。</p>
<p>如果得到了执行某个实例某个方法的入口，我们就可以绕开消息传递阶段，直接执行方法，这在后面 Cache 中会提到。</p>
<p>你会发现 IMP 指向的方法与 <code>objc_msgSend</code> 函数类型相同，参数都包含 <code>id</code> 和 <code>SEL</code> 类型。每个方法名都对应一个 <code>SEL</code> 类型的方法选择器，而每个实例对象中的 <code>SEL</code> 对应的方法实现肯定是唯一的，通过一组 <code>id</code>和 <code>SEL</code> 参数就能确定唯一的方法实现地址。</p>
<p>而一个确定的方法也只有唯一的一组 <code>id</code> 和 <code>SEL </code>参数</p>
<h3 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h3><p>Cache 定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">objc_cache</span> *<span class="title">Cache</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">objc_cache</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> mask <span class="comment">/* total = mask + 1 */</span>                 OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> occupied                                    OBJC2_UNAVAILABLE;</span><br><span class="line">    Method buckets[<span class="number">1</span>]                                        OBJC2_UNAVAILABLE;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Cache 为方法调用的性能进行优化，每当实例对象接收到一个消息时，它不会直接在 <code>isa</code> 指针指向的类的方法列表中遍历查找能够响应的方法，因为每次都要查找效率太低了，而是优先在 Cache 中查找。</p>
<p>Runtime 系统会把被调用的方法存到 Cache 中，如果一个方法被调用，那么它有可能今后还会被调用，下次查找的时候就会效率更高。就像计算机组成原理中 CPU 绕过主存先访问 Cache 一样。</p>
<h3 id="Property"><a href="#Property" class="headerlink" title="Property"></a>Property</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">objc_property</span> *<span class="title">Property</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">objc_property</span> *<span class="title">objc_property_t</span>;</span><span class="comment">//这个更常用</span></span><br></pre></td></tr></table></figure>

<p>可以通过class_copyPropertyList 和 protocol_copyPropertyList 方法获取类和协议中的属性：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">objc_property_t</span> *<span class="title">class_copyPropertyList</span><span class="params">(Class cls, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount)</span></span></span><br><span class="line"><span class="function"><span class="keyword">objc_property_t</span> *<span class="title">protocol_copyPropertyList</span><span class="params">(Protocol *proto, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount)</span></span></span><br></pre></td></tr></table></figure>

<p><code>返回的是属性列表，列表中每个元素都是一个 objc_property_t 指针</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">@interface Person : NSObject</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 姓名 */</span></span><br><span class="line">@property (strong, nonatomic) NSString *name;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** age */</span></span><br><span class="line">@property (assign, nonatomic) <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** weight */</span></span><br><span class="line">@property (assign, nonatomic) <span class="keyword">double</span> weight;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>以上是一个 Person 类，有3个属性。让我们用上述方法获取类的运行时属性。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> outCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">objc_property_t</span> *properties = class_copyPropertyList([Person class], &amp;outCount);</span><br><span class="line"></span><br><span class="line">    NSLog(@<span class="string">&quot;%d&quot;</span>, outCount);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (NSInteger i = <span class="number">0</span>; i &lt; outCount; i++) &#123;</span><br><span class="line">        NSString *name = @(property_getName(properties[i]));</span><br><span class="line">        NSString *attributes = @(property_getAttributes(properties[i]));</span><br><span class="line">        NSLog(@<span class="string">&quot;%@--------%@&quot;</span>, name, attributes);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>打印结果：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">2014</span><span class="number">-11</span><span class="number">-10</span> <span class="number">11</span>:<span class="number">27</span>:<span class="number">28.473</span> test[<span class="number">2321</span>:<span class="number">451525</span>] <span class="number">3</span></span><br><span class="line"><span class="number">2014</span><span class="number">-11</span><span class="number">-10</span> <span class="number">11</span>:<span class="number">27</span>:<span class="number">28.473</span> test[<span class="number">2321</span>:<span class="number">451525</span>] name--------T@<span class="string">&quot;NSString&quot;</span>,&amp;,N,V_name</span><br><span class="line"><span class="number">2014</span><span class="number">-11</span><span class="number">-10</span> <span class="number">11</span>:<span class="number">27</span>:<span class="number">28.473</span> test[<span class="number">2321</span>:<span class="number">451525</span>] age--------Ti,N,V_age</span><br><span class="line"><span class="number">2014</span><span class="number">-11</span><span class="number">-10</span> <span class="number">11</span>:<span class="number">27</span>:<span class="number">28.474</span> test[<span class="number">2321</span>:<span class="number">451525</span>] weight--------Td,N,V_weight</span><br></pre></td></tr></table></figure>

<p><code>property_getName</code> 用来查找属性的名称，返回 c 字符串。<code>property_getAttributes</code> 函数挖掘属性的真实名称和 @encode 类型，返回 c 字符串。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">objc_property_t</span> <span class="title">class_getProperty</span><span class="params">(Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span></span><br><span class="line"><span class="function"><span class="keyword">objc_property_t</span> <span class="title">protocol_getProperty</span><span class="params">(Protocol *proto, <span class="keyword">const</span> <span class="keyword">char</span> *name, BOOL isRequiredProperty, BOOL isInstanceProperty)</span></span></span><br></pre></td></tr></table></figure>
<p><code>·class_getProperty</code> 和 <code>protocol_getProperty</code> 通过给出属性名在类和协议中获得属性的引用。</p>
<h2 id="消息"><a href="#消息" class="headerlink" title="消息"></a>消息</h2><p>消息发送步骤：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1330553-87d03a7c0971c730.gif?imageMogr2/auto-orient/strip" alt="消息转发步骤"></p>
<p>详解：</p>
<blockquote>
<p>首先检测这个 selector 是不是要忽略。比如 Mac OS X 开发，有了垃圾回收就不理会 retain，release 这些函数。<br>检测这个 selector 的 target 是不是 nil，Objc 允许我们对一个 nil 对象执行任何方法不会 Crash，因为运行时会被忽略掉。<br>如果上面两步都通过了，那么就开始查找这个类的实现 IMP，先从 cache 里查找，如果找到了就运行对应的函数去执行相应的代码。<br>如果 cache 找不到就找类的方法列表中是否有对应的方法。<br>如果类的方法列表中找不到就到父类的方法列表中查找，一直找到 NSObject 类为止。<br>如果还找不到，就要开始进入动态方法解析了，后面会提到</p>
</blockquote>
<p>在消息的传递中，编译器会根据情况在 <code>objc_msgSend</code> ， <code>objc_msgSend_stret</code> ， <code>objc_msgSendSuper</code> ， <code>objc_msgSendSuper_stret</code> 这四个方法中选择一个调用。</p>
<ul>
<li>如果消息是传递给父类，那么会调用名字带有 Super 的函数，</li>
<li>如果消息返回值是数据结构而不是简单值时，会调用名字带有 stret 的函数。</li>
</ul>
<h3 id="方法中的隐藏参数"><a href="#方法中的隐藏参数" class="headerlink" title="方法中的隐藏参数"></a>方法中的隐藏参数</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">疑问：</span><br><span class="line">我们经常用到关键字 self ，但是 self 是如何获取当前方法的对象呢？</span><br></pre></td></tr></table></figure>

<p>其实，这也是 Runtime 系统的作用，self 实在方法运行时被动态传入的。</p>
<p>当 <code>objc_msgSend</code> 找到方法对应实现时，它将直接调用该方法实现，并将消息中所有参数都传递给方法实现，同时，它还将传递两个隐藏参数：</p>
<blockquote>
<p>接受消息的对象(self 所指向的内容，当前方法的对象指针)<br>方法选择器(_cmd 指向的内容，当前方法的 SEL 指针)</p>
</blockquote>
<p>因为在源代码方法的定义中，我们并没有发现这两个参数的声明。它们时在代码被编译时被插入方法实现中的。尽管这些参数没有被明确声明，在源代码中我们仍然可以引用它们。</p>
<p>这两个参数中， self更实用。它是在方法实现中访问消息接收者对象的实例变量的途径。</p>
<p>这时我们可能会想到另一个关键字 super ，实际上 super 关键字接收到消息时，编译器会创建一个 <code>objc_super</code> 结构体：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_super</span> &#123;</span> id receiver; Class <span class="class"><span class="keyword">class</span>;</span> &#125;;</span><br></pre></td></tr></table></figure>

<p>这个结构体指明了消息应该被传递给特定的父类。 receiver 仍然是 self 本身，当我们想通过 <code>[super class]</code> 获取父类时，编译器其实是将指向 self 的 id 指针和 class 的 SEL 传递给了 <code>objc_msgSendSuper</code> 函数。</p>
<p>只有在 NSObject 类中才能找到 class 方法，然后 class 方法底层被转换为 <code>object_getClass()</code>， 接着底层编译器将代码转换为 <code>objc_msgSend(objc_super-&gt;receiver, @selector(class))</code>，<br>传入的第一个参数是指向 self 的 id 指针，与调用 <code>[self class]</code> 相同，所以我们得到的永远都是 self 的类型。因此你会发现：<br>// 这句话并不能获取父类的类型，只能获取当前类的类型名</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, <span class="built_in">NSStringFromClass</span>([<span class="keyword">super</span> <span class="keyword">class</span>]));</span><br></pre></td></tr></table></figure>

<h3 id="获取方法地址"><a href="#获取方法地址" class="headerlink" title="获取方法地址"></a>获取方法地址</h3><p>NSObject 类中有一个实例方法：<code>methodForSelector</code>，你可以用它来获取某个方法选择器对应的 IMP ，举个例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void (*setter)(id, SEL, BOOL);</span><br><span class="line">int i;</span><br><span class="line"></span><br><span class="line">setter &#x3D; (void (*)(id, SEL, BOOL))[target</span><br><span class="line">    methodForSelector:@selector(setFilled:)];</span><br><span class="line">for ( i &#x3D; 0 ; i &lt; 1000 ; i++ )</span><br><span class="line">    setter(targetList[i], @selector(setFilled:), YES);</span><br></pre></td></tr></table></figure>

<p>当方法被当做函数调用时，两个隐藏参数也必须明确给出，上面的例子调用了1000次函数，你也可以尝试给 target 发送1000次 setFilled: 消息会花多久。</p>
<p>虽然可以更高效的调用方法，但是这种做法很少用，除非时需要持续大量重复调用某个方法的情况，才会选择使用以免消息发送泛滥。</p>
<p><code>注意：methodForSelector:方法是由 Runtime 系统提供的，而不是 Objc 自身的特性</code></p>
<h3 id="动态方法解析"><a href="#动态方法解析" class="headerlink" title="动态方法解析"></a>动态方法解析</h3><p>你可以动态提供一个方法实现。如果我们使用关键字 @dynamic 在类的实现文件中修饰一个属性，表明我们会为这个属性动态提供存取方法，编译器不会再默认为我们生成这个属性的 setter 和 getter 方法了，需要我们自己提供。</p>
<p><code>@dynamic propertyName;</code></p>
<p>这时，我们可以通过分别重载 <code>resolveInstanceMethod:</code> 和 <code>resolveClassMethod:</code> 方法添加实例方法实现和类方法实现。</p>
<p>当 Runtime 系统在 Cache 和类的方法列表(包括父类)中找不到要执行的方法时，Runtime 会调用 <code>resolveInstanceMethod: </code>或 <code>resolveClassMethod:</code> 来给我们一次动态添加方法实现的机会。我们需要用 <code>class_addMethod</code> 函数完成向特定类添加特定方法实现的操作：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void dynamicMethodIMP(id self, SEL _cmd) &#123;</span><br><span class="line">    &#x2F;&#x2F; implementation ....</span><br><span class="line">&#125;</span><br><span class="line">@implementation MyClass</span><br><span class="line">+ (BOOL)resolveInstanceMethod:(SEL)aSEL</span><br><span class="line">&#123;</span><br><span class="line">    if (aSEL &#x3D;&#x3D; @selector(resolveThisMethodDynamically)) &#123;</span><br><span class="line">          class_addMethod([self class], aSEL, (IMP) dynamicMethodIMP, &quot;v@:&quot;);</span><br><span class="line">          return YES;</span><br><span class="line">    &#125;</span><br><span class="line">    return [super resolveInstanceMethod:aSEL];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面的例子为 <code>resolveThisMethodDynamically</code> 方法添加了实现内容，就是 <code>dynamicMethodIMP</code> 方法中的代码。其中 “v@:” 表示返回值和参数，这个符号表示的含义见：<a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html">Type Encoding</a></p>
<p>注意：<br>动态方法解析会在消息转发机制侵入前执行，动态方法解析器将会首先给予提供该方法选择器对应的 IMP 的机会。如果你想让该方法选择器被传送到转发机制，就让 <code>resolveInstanceMethod: </code>方法返回 NO。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1330553-400bc5bde4db1725.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="消息转发"></p>
<h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h3><p>消息转发机制执行前，Runtime 系统允许我们替换消息的接收者为其他对象。通过 <code>- (id)forwardingTargetForSelector:(SEL)aSelector</code> 方法。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)forwardingTargetForSelector:(SEL)aSelector</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(aSelector == <span class="keyword">@selector</span>(mysteriousMethod:))&#123;</span><br><span class="line">        <span class="keyword">return</span> alternateObject;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> forwardingTargetForSelector:aSelector];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果此方法返回 nil 或者 self，则会计入消息转发机制(<code>forwardInvocation:</code>)，否则将向返回的对象重新发送消息。</p>
<h3 id="转发"><a href="#转发" class="headerlink" title="转发"></a>转发</h3><p>当动态方法解析不做处理返回 NO 时，则会触发消息转发机制。这时 <code>forwardInvocation:</code> 方法会被执行，我们可以重写这个方法来自定义我们的转发逻辑：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)anInvocation</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ([someOtherObject respondsToSelector:</span><br><span class="line">            [anInvocation selector]])</span><br><span class="line">        [anInvocation invokeWithTarget:someOtherObject];</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        [<span class="keyword">super</span> forwardInvocation:anInvocation];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>唯一参数是个 <code>NSInvocation</code> 类型的对象，该对象封装了原始的消息和消息的参数。我们可以实现 <code>forwardInvocation:</code> 方法来对不能处理的消息做一些处理。也可以将消息转发给其他对象处理，而不抛出错误。</p>
<p><code>注意：</code></p>
<p>参数 anInvocation 是从哪来的？</p>
<pre><code>在 forwardInvocation: 消息发送前，Runtime 系统会向对象发送methodSignatureForSelector: 消息，并取到返回的方法签名用于生成 NSInvocation 对象。所以重写 
forwardInvocation: 的同时也要重写 methodSignatureForSelector: 方法，否则会抛异常。</code></pre>
<h3 id="消息转发"><a href="#消息转发" class="headerlink" title="消息转发"></a>消息转发</h3><p>当一个对象由于没有相应的方法实现而无法相应某消息时，运行时系统将通过 <code>forwardInvocation:</code> 消息通知该对象。每个对象都继承了 <code>forwardInvocation:</code> 方法。但是， NSObject 中的方法实现只是简单的调用了 <code>doesNotRecognizeSelector:</code>。通过实现自己的 <code>forwardInvocation:</code> 方法，我们可以将消息转发给其他对象。</p>
<p><code>forwardInvocation: </code>方法就是一个不能识别消息的分发中心，将这些不能识别的消息转发给不同的接收对象，或者转发给同一<br>个对象，再或者将消息翻译成另外的消息，亦或者简单的“吃掉”某些消息，因此没有响应也不会报错。这一切都取决于方法的具体实现。</p>
<h3 id="转发和多继承"><a href="#转发和多继承" class="headerlink" title="转发和多继承"></a>转发和多继承</h3><p>转发和继承相似，可用于为 Objc 编程添加一些多继承的效果。就像下图那样，一个对象把消息转发出去，就好像它把另一个对象中的方法接过来或者“继承”过来一样。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1330553-c7ef6392ecc9ee9d.gif?imageMogr2/auto-orient/strip" alt="转发"></p>
<p>这使得在不同继承体系分支下的两个类可以实现“继承”对方的方法，在上图中 <code>Warrior</code> 和 <code>Diplomat</code> 没有继承关系，但是 <code>Warrior</code> 将 <code>negotiate</code> 消息转发给了 <code>Diplomat</code> 后，就好似 <code>Diploma</code>t 是 <code>Warrior</code> 的超类一样。</p>
<p>消息转发弥补了 Objc 不支持多继承的性质，也避免了因为多继承导致单个类变得臃肿复杂</p>
<h3 id="转发与继承"><a href="#转发与继承" class="headerlink" title="转发与继承"></a>转发与继承</h3><p>虽然转发可以实现继承的功能，但是 NSObject 还是必须表面上很严谨，像 <code>respondsToSelector:</code> 和 <code>isKindOfClass:</code> 这类方法只会考虑继承体系，不会考虑转发链。</p>
<p>如果上图中的 Warrior 对象被问到是否能响应 negotiate消息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if ( [aWarrior respondsToSelector:@selector(negotiate)] )</span><br></pre></td></tr></table></figure>

<p>回答当然是 NO， 尽管它能接受 negotiate 消息而不报错，因为它靠转发消息给 Diplomat 类响应消息。</p>
<p>如果你就是想要让别人以为 Warrior 继承到了 Diplomat 的 negotiate 方法，你得重新实现 <code>respondsToSelector:</code> 和 <code>isKindOfClass:</code> 来加入你的转发算法：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)respondsToSelector:(SEL)aSelector</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ( [<span class="keyword">super</span> respondsToSelector:aSelector] )</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* Here, test whether the aSelector message can     *</span></span><br><span class="line"><span class="comment">         * be forwarded to another object and whether that  *</span></span><br><span class="line"><span class="comment">         * object can respond to it. Return YES if it can.  */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>除了 <code>respondsToSelector:</code> 和 <code>isKindOfClass:</code> 之外，<code>instancesRespondToSelector:</code> 中也应该写一份转发算法。如果使用了协议，<code>conformsToProtocol:</code> 同样也要加入到这一行列中。</p>
<p>如果一个对象想要转发它接受的任何远程消息，它得给出一个方法标签来返回准确的方法描述 <code>methodSignatureForSelector:</code>，这个方法会最终响应被转发的消息。从而生成一个确定的 <code>NSInvocation</code> 对象描述消息和消息参数。这个方法最终响应被转发的消息。它需要像下面这样实现：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">NSMethodSignature</span>*)methodSignatureForSelector:(SEL)selector</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSMethodSignature</span>* signature = [<span class="keyword">super</span> methodSignatureForSelector:selector];</span><br><span class="line">    <span class="keyword">if</span> (!signature) &#123;</span><br><span class="line">       signature = [surrogate methodSignatureForSelector:selector];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> signature;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="健壮的实例变量-Non-Fragile-ivars"><a href="#健壮的实例变量-Non-Fragile-ivars" class="headerlink" title="健壮的实例变量(Non Fragile ivars)"></a>健壮的实例变量(Non Fragile ivars)</h3><p>在 Runtime 的现行版本中，最大的特点就是健壮的实例变量了。当一个类被编译时，实例变量的内存布局就形成了，它表明访问类的实例变量的位置。实例变量一次根据自己所占空间而产生位移</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1330553-bcbc243a281ef8d9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>上图左是 NSObject 类的实例变量布局。右边是我们写的类的布局。这样子有一个很大的缺陷，就是缺乏拓展性。哪天苹果更新了 NSObject 类的话，就会出现问题：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1330553-33263710847f6d86.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>我们自定义的类的区域和父类的区域重叠了。只有苹果将父类改为以前的布局才能拯救我们，但这样导致它们不能再拓展它们的框架了，因为成员变量布局被固定住了。在脆弱的实例变量(Fragile ivar)环境下，需要我们重新编译继承自 Apple 的类来恢复兼容。</p>
<p>在健壮的实例变量下，编译器生成的实例变量布局跟以前一样，但是当 Runtime 系统检测到与父类有部分重叠时它会调整你新添加的实例变量的位移，那样你再子类中新添加的成员变量就被保护起来了。</p>
<p>注意：<br>在健壮的实例变量下，不要使用 <code>siof(SomeClass)</code>，而是用 <code>class_getInstanceSize([SomeClass class])</code> 代替；也不要使用 <code>offsetof(SomeClass, SomeIvar)</code>，而要使用 <code>ivar_getOffset(class_getInstanceVariable([SomeClass class], &quot;SomeIvar&quot;))</code> 来代替。</p>
<h2 id="Runtime-在iOS中的应用"><a href="#Runtime-在iOS中的应用" class="headerlink" title="Runtime 在iOS中的应用"></a>Runtime 在iOS中的应用</h2><h3 id="KVO"><a href="#KVO" class="headerlink" title="KVO"></a>KVO</h3><p>KVO，即：<code>Key-Value Observing</code>，它提供一种机制，当指定的对象的属性被修改后，则其观察者就会接受到通知。简单的说就是每次指定的被观察的对象的属性被修改后，KVO就会自动通知相应的观察者了。</p>
<h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">&quot;ViewController.h&quot;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&quot;Person.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span><br><span class="line"><span class="comment">/** p1 */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) Person *p1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    <span class="comment">// 1.什么是通知</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3个对象</span></span><br><span class="line">    <span class="keyword">self</span>.p1 = [[Person alloc] init];</span><br><span class="line">    <span class="keyword">self</span>.p1.name = <span class="string">@&quot;p1&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// KVO是监听对象的属性值的改变的</span></span><br><span class="line">    [<span class="keyword">self</span>.p1 addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@&quot;name&quot;</span> options:<span class="built_in">NSKeyValueObservingOptionNew</span> | <span class="built_in">NSKeyValueObservingOptionOld</span> context:<span class="literal">nil</span>];</span><br><span class="line">    <span class="keyword">self</span>.p1.name = <span class="string">@&quot;123&quot;</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个方法时属于 NSObject 类的，任何对象都可以作为观察者</span></span><br><span class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath ofObject:(<span class="keyword">id</span>)object change:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *,<span class="keyword">id</span>&gt; *)change context:(<span class="keyword">void</span> *)context</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;监听到了%@的%@属性发生了改变&quot;</span>, object, keyPath);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, change);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>打印结果：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">打印结果：</span><br><span class="line"><span class="number">2014</span><span class="number">-05</span><span class="number">-11</span> <span class="number">19</span>:<span class="number">55</span>:<span class="number">34.319</span> KVO和KVC和通知代理[<span class="number">559</span>:<span class="number">109378</span>] 监听到了&lt;Person: <span class="number">0x15ee2baa0</span>&gt;的name属性发生了改变</span><br><span class="line"><span class="number">2014</span><span class="number">-05</span><span class="number">-11</span> <span class="number">19</span>:<span class="number">55</span>:<span class="number">34.320</span> KVO和KVC和通知代理[<span class="number">559</span>:<span class="number">109378</span>] <span class="number">123</span></span><br></pre></td></tr></table></figure>
<h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><p>当 p1.name 的值改变时，p1对象的 isa 指针会指向 NSKVONotifying_Person，意味着，在程序运行时，会动态生成一个 NSKVONotifying_Person 类，该类继承于 Person，而且该类中也有个 -setName: 方法，方法中在设置 name 的同时实现了：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setName:(<span class="built_in">NSString</span> *)name</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">super</span> setName:name];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这两个方法底层会调用observer的- (void)observeValueForKeyPath: ofObject: change: context:这个方法</span></span><br><span class="line">    [<span class="keyword">self</span> willChangeValueForKey:<span class="string">@&quot;age&quot;</span>];</span><br><span class="line">    [<span class="keyword">self</span> didChangeValueForKey:<span class="string">@&quot;age&quot;</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><h3 id="实现原理-1"><a href="#实现原理-1" class="headerlink" title="实现原理"></a>实现原理</h3><p>无论我们有没有主动引入 Category 的头文件，Category 中的方法都会被添加进主类中。我们可以通过<code>·- performSelector: </code>等<br>方式对<code>Category</code>中的相应方法进行调用，之所以需要在调用的地方引入 Category 的头文件，只是为了“照顾”编译器同学的感受</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static void attachCategories(Class cls, category_list *cats, bool flush_caches) &#123;  </span><br><span class="line">    if (!cats) return;</span><br><span class="line">    bool isMeta &#x3D; cls-&gt;isMetaClass();</span><br><span class="line"></span><br><span class="line">    method_list_t **mlists &#x3D; (method_list_t **)malloc(cats-&gt;count * sizeof(*mlists));</span><br><span class="line">    &#x2F;&#x2F; Count backwards through cats to get newest categories first</span><br><span class="line">    int mcount &#x3D; 0;</span><br><span class="line">    int i &#x3D; cats-&gt;count;</span><br><span class="line">    while (i--) &#123;</span><br><span class="line">        auto&amp; entry &#x3D; cats-&gt;list[i];</span><br><span class="line"></span><br><span class="line">        method_list_t *mlist &#x3D; entry.cat-&gt;methodsForMeta(isMeta);</span><br><span class="line">        if (mlist) &#123;</span><br><span class="line">            mlists[mcount++] &#x3D; mlist;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    auto rw &#x3D; cls-&gt;data();</span><br><span class="line"></span><br><span class="line">    prepareMethodLists(cls, mlists, mcount, NO, fromBundle);</span><br><span class="line">    rw-&gt;methods.attachLists(mlists, mcount);</span><br><span class="line">    free(mlists);</span><br><span class="line">    if (flush_caches  &amp;&amp;  mcount &gt; 0) flushCaches(cls);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过 while 循环，我们遍历所有的 category，也就是参数 <code>cats</code> 中的 <code>list</code> 属性。对于每一个 category，得到它的方法列表 <code>mlist</code> 并存入 <code>mlists</code> 中。</p>
<p>换句话说，我们将所有 <code>category</code> 中的方法拼接到了一个大的二维数组中，数组的每一个元素都是装有一个 <code>category</code> 所有方法的容器</p>
<p>在 while 循环外，我们得到了拼接成的方法，此时需要与类原来的方法合并</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void attachLists(List* const * addedLists, uint32_t addedCount) &#123;  </span><br><span class="line">    if (addedCount &#x3D;&#x3D; 0) return;</span><br><span class="line">    uint32_t oldCount &#x3D; array()-&gt;count;</span><br><span class="line">    uint32_t newCount &#x3D; oldCount + addedCount;</span><br><span class="line">    setArray((array_t *)realloc(array(), array_t::byteSize(newCount)));</span><br><span class="line">    array()-&gt;count &#x3D; newCount;</span><br><span class="line">    memmove(array()-&gt;lists + addedCount, array()-&gt;lists, oldCount * sizeof(array()-&gt;lists[0]));</span><br><span class="line">    memcpy(array()-&gt;lists, addedLists, addedCount * sizeof(array()-&gt;lists[0]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码很简单，其实就是先调用 realloc() 函数将原来的空间拓展，然后把原来的数组复制到后面，最后再把新数组复制到前面。</p>
<p>因此 category 中定义的同名方法不会替换类中原有的方法，但是对原方法的调用实际上会调用 category 中的方法。</p>
<h3 id="Objective-C-load-vs-initialize"><a href="#Objective-C-load-vs-initialize" class="headerlink" title="Objective-C +load vs +initialize"></a>Objective-C +load vs +initialize</h3><h4 id="load"><a href="#load" class="headerlink" title="+load"></a>+load</h4><p>这样的调用方式就使得 <code>+load</code> 方法拥有了一个非常有趣的特性，那就是子类、父类和分类中的 <code>+load</code> 方法的实现是被区别对待的。也就是说如果子类没有实现 <code>+load</code> 方法，那么当它被加载时 runtime 是不会去调用父类的 <code>+load</code> 方法的。同理，当一个类和它的分类都实现了 <code>+load</code> 方法时，两个方法都会被调用。因此，我们常常可以利用这个特性做一些“邪恶”的事情，比如说方法混淆<a href="http://nshipster.com/method-swizzling/">Method Swizzling</a>。</p>
<h4 id="initialize"><a href="#initialize" class="headerlink" title="+initialize"></a>+initialize</h4><p><code>+initialize</code> 方法是在类或它的子类收到第一条消息之前被调用的，这里所指的消息包括实例方法和类方法的调用。也就是说 <code>+initialize</code> 方法是以懒加载的方式被调用的，如果程序一直没有给某个类或它的子类发送消息，那么这个类的 <code>+initialize</code> 方法是永远不会被调用的。那这样设计有什么好处呢？好处是显而易见的，那就是节省系统资源，避免浪费。</p>
<p>因此，如果一个子类没有实现 +initialize 方法，那么父类的实现是会被执行多次的。有时候，这可能是你想要的；但如果我们想确保自己的 +initialize 方法只执行一次，避免多次执行可能带来的副作用时，我们可以使用下面的代码来实现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+ (void)initialize &#123;</span><br><span class="line">  if (self &#x3D;&#x3D; [ClassName self]) &#123;</span><br><span class="line">    &#x2F;&#x2F; ... do the initialization ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h4><table>
<thead>
<tr>
<th></th>
<th align="center">+load</th>
<th align="right">+initialize</th>
</tr>
</thead>
<tbody><tr>
<td>调用时机</td>
<td align="center">被添加到runtime时</td>
<td align="right">收到第一条消息前，可能永远不调用</td>
</tr>
<tr>
<td>调用顺序</td>
<td align="center">父类-&gt;子类-&gt;分类</td>
<td align="right">父类-&gt;子类</td>
</tr>
<tr>
<td>调用次数</td>
<td align="center">1次</td>
<td align="right">多次</td>
</tr>
<tr>
<td>是否需要显式调用父类实现</td>
<td align="center">否</td>
<td align="right">否</td>
</tr>
<tr>
<td>是否沿用父类的实现</td>
<td align="center">否</td>
<td align="right">是</td>
</tr>
<tr>
<td>分类中的实现</td>
<td align="center">类和分类都执行</td>
<td align="right">覆盖类中的方法，只执行分类的实现</td>
</tr>
</tbody></table>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="http://www.cnblogs.com/ioshe/p/5489086.html">iOS开发-Runtime详解（简书）</a><br><a href="https://opensource.apple.com/source/objc4/">Runtime源码</a><br><a href="http://lizhaoloveit.com/2014/05/11/KVO/">KVO</a><br><a href="https://tech.meituan.com/DiveIntoCategory.html">深入理解Objective-C：Category</a><br><a href="https://www.jianshu.com/p/55f781f8c915">iOS成员属性和成员变量的区别</a></p>
]]></content>
      <categories>
        <category>iOS基础</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
        <tag>Runtime</tag>
      </tags>
  </entry>
  <entry>
    <title>ios网络基础与多线程</title>
    <url>/2018/03/26/ios%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<p>本文分为两个部分 第一部分将着重讲述跟网络有关的基础知识，包含但不止于网络模型、Socket、HTTP以及HTTPS基础知识。第二部分着重于iOS相关的多线程的基础内容GCD,NSOperation等</p>
<a id="more"></a>

<h2 id="常见名词"><a href="#常见名词" class="headerlink" title="常见名词"></a>常见名词</h2><ul>
<li><p>TCP/IP：网络上使用的网络协议簇，TCP是应用程序之间的通信，IP是计算机之间的通信</p>
</li>
<li><p>逻辑地址：协议软件配置的网络地址</p>
</li>
<li><p>物理地址：网络硬件相关的地址</p>
</li>
<li><p>IP地址：定位计算机设备的逻辑地址</p>
</li>
<li><p>端口：内部通道或地址，它在TCP/IP传输层和应用程序之间提供了一个接口</p>
</li>
<li><p>域名：与IP地址相关联的名字</p>
</li>
<li><p>路由器：通过逻辑地址转发数据的网络设备</p>
</li>
<li><p>局域网：LAN，小型网络</p>
</li>
<li><p>网关：连接LAN到大型网络的路由器</p>
</li>
<li><p>TCP：传输层中可靠的、面向连接的协议</p>
</li>
<li><p>UDP：传输层中不可靠、非面向连接协议</p>
</li>
<li><p>Socket：套接字</p>
</li>
<li><p>IPv4：TCP/IP协议簇中网络层协议IP的版本4（IP version 4），32位</p>
</li>
<li><p>IPv6：IPv4的下一个版本，号称可以为全世界的每一粒沙子编上一个网址，解决IPv4的网络资源地址有限问题，128位</p>
</li>
<li><p>IPv6-Only网络：运营商逐渐部署IPv6 DNS64/NAT64网络之后，设备被分配的地址变成IPv6的地址，依然可以通过此网络获取IPv4地址提供的内容。</p>
</li>
</ul>
<h2 id="网络模型"><a href="#网络模型" class="headerlink" title="网络模型"></a>网络模型</h2><h3 id="七层-OSI模型"><a href="#七层-OSI模型" class="headerlink" title="七层 OSI模型"></a>七层 OSI模型</h3><p><img src="https://www.processon.com/chart_image/5874486ce4b09f680a444685.png" alt="OSI"></p>
<h3 id="TCP-IP模型"><a href="#TCP-IP模型" class="headerlink" title="TCP/IP模型"></a>TCP/IP模型</h3><p><img src="https://www.processon.com/chart_image/58744d35e4b09f680a44d98b.png" alt="TCP/IP"></p>
<h3 id="TCP-IP模型层次结构"><a href="#TCP-IP模型层次结构" class="headerlink" title="TCP/IP模型层次结构"></a>TCP/IP模型层次结构</h3><p><img src="https://www.processon.com/chart_image/587450f3e4b09f680a45538f.png" alt="层次结构"></p>
<h3 id="工作流"><a href="#工作流" class="headerlink" title="工作流"></a>工作流</h3><p><img src="https://www.processon.com/chart_image/58744865e4b09f680a4445b9.png" alt="工作流"></p>
<h3 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h3><p>每个TCP、UDP数据段中都包含源端口和目标端口，有时我们把一个IP地址和一个端口号合称为一个套接字，一个套接字可唯一确定网络中每个TCP连接的双方(客户IP地址、客户端口号、服务器IP地址、服务器端口号)</p>
<p><img src="https://www.processon.com/chart_image/58745474e4b09f680a45ce9b.png" alt="socket"></p>
<blockquote>
<p>不同的应用层协议可能基于不同传输层协议，比如TCP<br>有的应用层协议可能占用了两个端口号，比如FTP<br>有的应用层协议使用了不同的传输层协议提供服务，比如DNS</p>
</blockquote>
<h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p>TCP会话通过三次握手初始化，目标是使数据段的发送和接收同步。</p>
<p><img src="https://www.processon.com/chart_image/5874600be4b087b19d58e611.png" alt="三次握手"></p>
<ul>
<li><p>第一次握手：主机A发送位码为syn＝1,随机产生seq number=1234567的数据包到服务器，主机B由SYN=1知道，A要求建立联机；</p>
</li>
<li><p>第二次握手：主机B收到请求后要确认联机信息，向A发送ack number=(主机A的seq+1),syn=1,ack=1,随机产生seq=7654321的包</p>
</li>
<li><p>第三次握手：主机A收到后检查ack number是否正确，即第一次发送的seq number+1,以及位码ack是否为1，若正确，主机A会再发送ack number=(主机B的seq+1),ack=1，主机B收到后确认seq值与ack=1则连接建立成功。</p>
</li>
</ul>
<h3 id="IPV6-Only"><a href="#IPV6-Only" class="headerlink" title="IPV6-Only"></a>IPV6-Only</h3><p><img src="https://www.processon.com/chart_image/5875f622e4b07c7a98ad1030.png" alt="IPV6-Only"></p>
<p><code>如果DNS判断IPV6地址不存在，那么会在去查询IPV4对应的地址是否存在</code></p>
<h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><p><img src="https://www.processon.com/chart_image/587470f4e4b09f680a47af4c.png" alt="HTTP"></p>
<h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><p><img src="https://camo.githubusercontent.com/746827a43b810029d15952adc33e62811e91bc58/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f323730323634362d633666313538623564346164343630322e6a70673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f363438" alt="HTTPS"></p>
<ul>
<li>1、就是用户发起请求，服务器响应后返回一个证书，证书中包含一些基本信息和公钥。</li>
<li>2、用户拿到证书后，去验证这个证书是否合法，不合法，则请求终止。</li>
<li>3、合法则生成一个随机数，作为对称加密的密钥，用服务器返回的公钥对这个随机数加密。然后返回给服务器。</li>
<li>4、服务器拿到加密后的随机数，利用私钥解密，然后再用解密后的随机数（对称密钥），把需要返回的数据加密，加密完成后数据传输给用户。</li>
<li>5、最后用户拿到加密的数据，用一开始的那个随机数（对称密钥），进行数据解密。整个过程完成。</li>
</ul>
<h2 id="HTTP-VS-HTTPS"><a href="#HTTP-VS-HTTPS" class="headerlink" title="HTTP VS HTTPS"></a>HTTP VS HTTPS</h2><p>HTTPS需要到CA申请证书，需要交费<br>HTTP信息是明文传输，HTTPS有SSL加密传输协议<br>HTTP端口是80，HTTPS端口是443<br>HTTPS协议握手阶段比较费时，页面加载时间增加50%，好点增加10-20%</p>
<h2 id="Socket-1"><a href="#Socket-1" class="headerlink" title="Socket"></a>Socket</h2><p>Socket是在应用层和传输层之间的一个抽象层，它把TCP/IP层复杂的操作抽象为几个简单的接口供应用层调用实现进程在网络中通信。</p>
<p><img src="https://www.processon.com/chart_image/5874775fe4b087b19d5a3de9.png" alt="Socket"></p>
<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><h3 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h3><p>进程（process），指的是一个正在运行中的可执行文件。每一个进程都拥有独立的虚拟内存空间和系统资源，包括端口权限等，且至少包含一个主线程和任意数量的辅助线程。另外，当一个进程的主线程退出时，这个进程就结束了；<br>线程（thread），指的是一个独立的代码执行路径，也就是说线程是代码执行路径的最小分支。在 iOS 中，线程的底层实现是基于 POSIX threads API 的，也就是我们常说的 pthreads ；<br>任务（task），指的是我们需要执行的工作，是一个抽象的概念，用通俗的话说，就是一段代码。</p>
<h2 id="Pthreads"><a href="#Pthreads" class="headerlink" title="Pthreads"></a>Pthreads</h2><p>基于C语言，移植性强</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="keyword">pthread_t</span> thread;</span><br><span class="line">pthread_create(&amp;thread, <span class="literal">NULL</span>, start, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>

<h2 id="NSThread"><a href="#NSThread" class="headerlink" title="NSThread"></a>NSThread</h2><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSThread</span> *thread = [[<span class="built_in">NSThread</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(run:) object:<span class="literal">nil</span>];</span><br><span class="line">[thread start];</span><br></pre></td></tr></table></figure>

<h2 id="GCD"><a href="#GCD" class="headerlink" title="GCD"></a>GCD</h2><p>异步和同步最大的区别在于异步不会阻塞当前线程，是否等待block完成后返回</p>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><h4 id="1、系统标准两个队列"><a href="#1、系统标准两个队列" class="headerlink" title="1、系统标准两个队列"></a>1、系统标准两个队列</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//全局队列，一个并行的队列</span></span><br><span class="line">dispatch_get_global_queue</span><br><span class="line"><span class="comment">//主队列，主线程中的唯一队列，一个串行队列</span></span><br><span class="line">dispatch_get_main_queue</span><br></pre></td></tr></table></figure>

<h4 id="2、自定义队列"><a href="#2、自定义队列" class="headerlink" title="2、自定义队列"></a>2、自定义队列</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//串行队列</span></span><br><span class="line">dispatch_queue_create(<span class="string">&quot;com.starming.serialqueue&quot;</span>, DISPATCH_QUEUE_SERIAL)</span><br><span class="line"><span class="comment">//并行队列</span></span><br><span class="line">dispatch_queue_create(<span class="string">&quot;com.starming.concurrentqueue&quot;</span>, DISPATCH_QUEUE_CONCURRENT)</span><br></pre></td></tr></table></figure>

<h4 id="3、同步异步线程创建"><a href="#3、同步异步线程创建" class="headerlink" title="3、同步异步线程创建"></a>3、同步异步线程创建</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//同步线程</span></span><br><span class="line"><span class="built_in">dispatch_sync</span>(..., ^(block))</span><br><span class="line"><span class="comment">//异步线程</span></span><br><span class="line"><span class="built_in">dispatch_async</span>(..., ^(block))</span><br></pre></td></tr></table></figure>

<h3 id="队列（dispatch-queue）"><a href="#队列（dispatch-queue）" class="headerlink" title="队列（dispatch queue）"></a>队列（dispatch queue）</h3><p>Serial(串行队列)：又叫private dispatch queues，同时只执行一个任务。Serial queue常用于同步访问特定的资源或数据。当你创建多个Serial queue时，虽然各自是同步，但serial queue之间是并发执行。<br>Main dispatch queue(主队列)：全局可用的serial queue，在应用程序主线程上执行任务。<br>Concurrent(全局队列)：又叫global dispatch queue，可以并发的执行多个任务，但执行完成顺序是随机的。系统提供四个全局并发队列，这四个队列有这对应的优先级，用户是不能够创建全局队列的，只能获取。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">dipatch_queue_t queue;</span><br><span class="line">queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH,<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>User create queue：创建自己定义的队列，可以用dispatch_queue_create函数，函数有两个参数，第一个自定义的队列名，第二个参数是队列类型，默认NULL或者DISPATCH_QUEUE_SERIAL的是串行，参数为DISPATCH_QUEUE_CONCURRENT为并行队列。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> queue</span><br><span class="line">queue = dispatch_queue_create(<span class="string">&quot;com.starming.gcddemo.concurrentqueue&quot;</span>, DISPATCH_QUEUE_CONCURRENT);</span><br></pre></td></tr></table></figure>

<h4 id="自定义队列优先级"><a href="#自定义队列优先级" class="headerlink" title="自定义队列优先级"></a>自定义队列优先级</h4><p><code>dispatch_set_target_queue(dispatch_object_t object, dispatch_queue_t queue);</code></p>
<p><code>dispatch_set_target_queue</code> 函数有两个作用：</p>
<ul>
<li>第一，变更队列的执行优先级；</li>
<li>第二，目标队列可以成为原队列的执行阶层。<pre><code>  第一个参数是要执行变更的队列（不能指定主队列和全局队列）
  第二个参数是目标队列（指定全局队列）</code></pre>
</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//优先级变更的串行队列，初始是默认优先级 NULL 默认是串行队列</span></span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> serialQueue = dispatch_queue_create(<span class="string">&quot;com.gcd.setTargetQueue.serialQueue&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//优先级不变的串行队列（参照），初始是默认优先级</span></span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> serialDefaultQueue = dispatch_queue_create(<span class="string">&quot;com.gcd.setTargetQueue.serialDefaultQueue&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//变更前</span></span><br><span class="line">    <span class="built_in">dispatch_async</span>(serialQueue, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;1&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">dispatch_async</span>(serialDefaultQueue, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;2&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取优先级为后台优先级的全局队列</span></span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> globalDefaultQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//变更优先级</span></span><br><span class="line">    dispatch_set_target_queue(serialQueue, globalDefaultQueue);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//变更后 serialQueue 最低的优先级</span></span><br><span class="line">    <span class="built_in">dispatch_async</span>(serialQueue, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;1&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">dispatch_async</span>(serialDefaultQueue, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;2&quot;</span>);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>

<p>执行结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2018-03-27 14:53:33.911110+0800 GCDTest[63921:39078159] 2</span><br><span class="line">2018-03-27 14:53:33.911110+0800 GCDTest[63921:39078155] 1</span><br><span class="line">2018-03-27 14:53:33.911240+0800 GCDTest[63921:39078159] 2</span><br><span class="line">2018-03-27 14:53:33.911266+0800 GCDTest[63921:39078158] 1</span><br></pre></td></tr></table></figure>

<h3 id="队列类型"><a href="#队列类型" class="headerlink" title="队列类型"></a>队列类型</h3><p>5种队列，主队列（main queue）,四种通用调度队列，自己定制的队列。四种通用调度队列为</p>
<ul>
<li>QOS_CLASS_USER_INTERACTIVE：user interactive等级表示任务需要被立即执行提供好的体验，用来更新UI，响应事件等。这个等级最好保持小规模。</li>
<li>QOS_CLASS_USER_INITIATED：user initiated等级表示任务由UI发起异步执行。适用场景是需要及时结果同时又可以继续交互的时候。</li>
<li>QOS_CLASS_UTILITY：utility等级表示需要长时间运行的任务，伴有用户可见进度指示器。经常会用来做计算，I/O，网络，持续的数据填充等任务。这个任务节能。</li>
<li>QOS_CLASS_BACKGROUND：background等级表示用户不会察觉的任务，使用它来处理预加载，或者不需要用户交互和对时间不敏感的任务。</li>
</ul>
<h3 id="dispatch-once用法"><a href="#dispatch-once用法" class="headerlink" title="dispatch_once用法"></a>dispatch_once用法</h3><p>dispatch_once_t要是全局或static变量，保证dispatch_once_t只有一份实例</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">+ (<span class="keyword">instancetype</span>)shared</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> WMPayService *shared;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        shared = [[<span class="keyword">self</span> alloc] init];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> shared;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>最好可以做到手写单例</code></p>
<h3 id="dispatch-async"><a href="#dispatch-async" class="headerlink" title="dispatch_async"></a>dispatch_async</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//代码框架</span></span><br><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">     <span class="comment">// 耗时的操作</span></span><br><span class="line">     <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">          <span class="comment">// 更新界面</span></span><br><span class="line">     &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="dispatch-after延后执行"><a href="#dispatch-after延后执行" class="headerlink" title="dispatch_after延后执行"></a>dispatch_after延后执行</h3><p><code>dispatch_after只是延时提交block，不是延时立刻执行。</code></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)foo</span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">double</span> delayInSeconds = <span class="number">2.0</span>;</span><br><span class="line">     dispatch_time_t popTime = dispatch_time(DISPATCH_TIME_NOW, (int64_t) (delayInSeconds * <span class="built_in">NSEC_PER_SEC</span>));</span><br><span class="line">     dispatch_after(popTime, dispatch_get_main_queue(), ^(<span class="keyword">void</span>)&#123;</span><br><span class="line">          [<span class="keyword">self</span> bar];</span><br><span class="line">     &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="dispatch-apply进行快速迭代"><a href="#dispatch-apply进行快速迭代" class="headerlink" title="dispatch_apply进行快速迭代"></a>dispatch_apply进行快速迭代</h3><p>类似for循环，但是在并发队列的情况下dispatch_apply会并发执行block任务。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)applyTest</span><br><span class="line">&#123;</span><br><span class="line">    for (size_t y &#x3D; 0; y &lt; 10; ++y) &#123;</span><br><span class="line">        for (size_t x &#x3D; 0; x &lt; 10; ++x) &#123;</span><br><span class="line">            &#x2F;&#x2F; Do something with x and y here</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;因为可以并行执行，所以使用dispatch_apply可以运行的更快</span><br><span class="line">    dispatch_queue_t concurrentQueue &#x3D; dispatch_queue_create(&quot;com.starming.gcddemo.concurrentqueue&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    dispatch_apply(10, concurrentQueue, ^(size_t i) &#123;</span><br><span class="line">        NSLog(@&quot;%zu&quot;,i);</span><br><span class="line">    &#125;);</span><br><span class="line">    NSLog(@&quot;The end&quot;); &#x2F;&#x2F;这里有个需要注意的是，dispatch_apply这个是会阻塞主线程的。这个log打印会在dispatch_apply都结束后才开始执行</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2018-03-27 15:38:35.550890+0800 GCDTest[71235:39254293] 2</span><br><span class="line">2018-03-27 15:38:35.550895+0800 GCDTest[71235:39254387] 6</span><br><span class="line">2018-03-27 15:38:35.550892+0800 GCDTest[71235:39254375] 1</span><br><span class="line">2018-03-27 15:38:35.550893+0800 GCDTest[71235:39254377] 5</span><br><span class="line">2018-03-27 15:38:35.550892+0800 GCDTest[71235:39254376] 0</span><br><span class="line">2018-03-27 15:38:35.550892+0800 GCDTest[71235:39254378] 3</span><br><span class="line">2018-03-27 15:38:35.550893+0800 GCDTest[71235:39254379] 4</span><br><span class="line">2018-03-27 15:38:35.550950+0800 GCDTest[71235:39254388] 7</span><br><span class="line">2018-03-27 15:38:35.551024+0800 GCDTest[71235:39254293] 8</span><br><span class="line">2018-03-27 15:38:35.551029+0800 GCDTest[71235:39254387] 9</span><br><span class="line">2018-03-27 15:38:35.551520+0800 GCDTest[71235:39254293] The end</span><br></pre></td></tr></table></figure>


<h3 id="dispatch-group-t"><a href="#dispatch-group-t" class="headerlink" title="dispatch_group_t"></a>dispatch_group_t</h3><p>dispatch groups是专门用来监视多个异步任务。dispatch_group_t实例用来追踪不同队列中的不同任务</p>
<p>当group里所有事件都完成GCD API有两种方式发送通知，第一种是dispatch_group_wait，会阻塞当前进程，等所有任务都完成或等待超时。第二种方法是使用dispatch_group_notify，异步执行闭包，不会阻塞。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)dispatchGroupWaitDemo &#123;</span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> concurrentQueue = dispatch_queue_create(<span class="string">&quot;com.starming.gcddemo.concurrentqueue&quot;</span>,DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    dispatch_group_t group = dispatch_group_create();</span><br><span class="line">    <span class="comment">//在group中添加队列的block</span></span><br><span class="line">    dispatch_group_async(group, concurrentQueue, ^&#123;</span><br><span class="line">        [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2.</span>f];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;1&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_group_async(group, concurrentQueue, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;2&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_time_t time = dispatch_time(DISPATCH_TIME_NOW, <span class="number">2</span>*USEC_PER_SEC);</span><br><span class="line">    dispatch_group_wait(group, time);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;go on&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2018-03-27 16:14:44.160150+0800 GCDTest[72371:39397292] 2</span><br><span class="line">2018-03-27 16:14:44.162394+0800 GCDTest[72371:39396970] go on</span><br><span class="line">2018-03-27 16:14:46.163427+0800 GCDTest[72371:39397294] 1</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;dispatch_group_notify</span><br><span class="line">- (void)dispatchGroupNotifyDemo &#123;</span><br><span class="line">    dispatch_queue_t concurrentQueue &#x3D; dispatch_queue_create(&quot;com.starming.gcddemo.concurrentqueue&quot;,DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    dispatch_group_t group &#x3D; dispatch_group_create();</span><br><span class="line">    dispatch_group_async(group, concurrentQueue, ^&#123;</span><br><span class="line">        sleep(2);</span><br><span class="line">        NSLog(@&quot;1&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_group_async(group, concurrentQueue, ^&#123;</span><br><span class="line">        NSLog(@&quot;2&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        NSLog(@&quot;end&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">    NSLog(@&quot;can continue&quot;);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2018-03-27 16:13:58.912264+0800 GCDTest[72343:39394024] can continue</span><br><span class="line">2018-03-27 16:13:58.912264+0800 GCDTest[72343:39394093] 2</span><br><span class="line">2018-03-27 16:14:00.913552+0800 GCDTest[72343:39394099] 1</span><br><span class="line">2018-03-27 16:14:00.913930+0800 GCDTest[72343:39394024] end</span><br></pre></td></tr></table></figure>

<h3 id="dispatch-block-cancel"><a href="#dispatch-block-cancel" class="headerlink" title="dispatch_block_cancel"></a>dispatch_block_cancel</h3><p>iOS8后GCD支持对dispatch block的取消</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)dispatchBlockCancel &#123;</span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> serialQueue = dispatch_queue_create(<span class="string">&quot;com.starming.gcddemo.serialqueue&quot;</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    dispatch_block_t firstBlock = dispatch_block_create(<span class="number">0</span>, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;first block start&quot;</span>);</span><br><span class="line">        [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2.</span>f];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;first block end&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_block_t secondBlock = dispatch_block_create(<span class="number">0</span>, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;second block run&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">dispatch_async</span>(serialQueue, firstBlock);</span><br><span class="line">    <span class="built_in">dispatch_async</span>(serialQueue, secondBlock);</span><br><span class="line">    <span class="comment">//取消secondBlock</span></span><br><span class="line">    dispatch_block_cancel(secondBlock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2018-03-27 16:13:24.401008+0800 GCDTest[72320:39391634] first block start</span><br><span class="line">2018-03-27 16:13:26.403986+0800 GCDTest[72320:39391634] first block end</span><br></pre></td></tr></table></figure>

<h3 id="信号量-Dispatch-Semaphore"><a href="#信号量-Dispatch-Semaphore" class="headerlink" title="信号量(Dispatch Semaphore)"></a>信号量(Dispatch Semaphore)</h3><p>dispatch_semaphore_create：创建一个信号量（semaphore）<br>dispatch_semaphore_signal：信号通知，即让信号量+1<br>dispatch_semaphore_wait：等待，直到信号量大于0时，即可操作，同时将信号量-1</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)semaphorTest &#123;</span><br><span class="line">    <span class="comment">//crate的value表示，最多几个资源可访问</span></span><br><span class="line">    dispatch_semaphore_t semaphore = dispatch_semaphore_create(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> quene = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//任务1</span></span><br><span class="line">    <span class="built_in">dispatch_async</span>(quene, ^&#123;</span><br><span class="line">        dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;run task 1&quot;</span>);</span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;complete task 1&quot;</span>);</span><br><span class="line">        dispatch_semaphore_signal(semaphore);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//任务2</span></span><br><span class="line">    <span class="built_in">dispatch_async</span>(quene, ^&#123;</span><br><span class="line">        dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;run task 2&quot;</span>);</span><br><span class="line">        sleep(<span class="number">3</span>);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;complete task 2&quot;</span>);</span><br><span class="line">        dispatch_semaphore_signal(semaphore);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//任务3</span></span><br><span class="line">    <span class="built_in">dispatch_async</span>(quene, ^&#123;</span><br><span class="line">        dispatch_semaphore_wait(semaphore, <span class="number">2</span>);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;run task 3&quot;</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;complete task 3&quot;</span>);</span><br><span class="line">        dispatch_semaphore_signal(semaphore);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;end&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2018-03-27 16:12:41.938609+0800 GCDTest[72293:39388442] run task 2</span><br><span class="line">2018-03-27 16:12:41.938612+0800 GCDTest[72293:39388438] run task 3</span><br><span class="line">2018-03-27 16:12:41.938609+0800 GCDTest[72293:39388391] end</span><br><span class="line">2018-03-27 16:12:41.938610+0800 GCDTest[72293:39388439] run task 1</span><br><span class="line">2018-03-27 16:12:42.942686+0800 GCDTest[72293:39388438] complete task 3</span><br><span class="line">2018-03-27 16:12:43.943696+0800 GCDTest[72293:39388439] complete task 1</span><br><span class="line">2018-03-27 16:12:44.942998+0800 GCDTest[72293:39388442] complete task 2</span><br></pre></td></tr></table></figure>

<h3 id="dispatch-time-t"><a href="#dispatch-time-t" class="headerlink" title="dispatch_time_t"></a>dispatch_time_t</h3><p>用dispatch_after的时候就会用到dispatch_time_t变量，但是如何创建合适的时间呢？答案就是用dispatch_time函数，其原型如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">dispatch_time_t dispatch_time ( dispatch_time_t when, int64_t delta );</span><br></pre></td></tr></table></figure>
<blockquote>
<p>第一个参数一般是DISPATCH_TIME_NOW，表示从现在开始。<br>那么第二个参数就是真正的延时的具体时间</p>
</blockquote>
<p>这里要特别注意的是，delta参数是“纳秒！”，就是说，延时1秒的话，delta应该是“1000000000”=。=，太长了，所以理所当然系统提供了常量，如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NSEC_PER_SEC 1000000000ull 纳秒</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> USEC_PER_SEC 1000000ull 微妙</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NSEC_PER_USEC 1000ull 秒</span></span><br></pre></td></tr></table></figure>

<p>所以要延时一秒可以写成:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">dispatch_time(DISPATCH_TIME_NOW, <span class="number">1</span> * <span class="built_in">NSEC_PER_SEC</span>);</span><br><span class="line">dispatch_time(DISPATCH_TIME_NOW, <span class="number">1000</span> * USEC_PER_SEC);</span><br><span class="line">dispatch_time(DISPATCH_TIME_NOW, USEC_PER_SEC * <span class="built_in">NSEC_PER_USEC</span>);</span><br></pre></td></tr></table></figure>

<h3 id="dispatch-suspend-dispatch-resume"><a href="#dispatch-suspend-dispatch-resume" class="headerlink" title="dispatch_suspend dispatch_resume"></a>dispatch_suspend dispatch_resume</h3><p><code>dispatch_suspend != 立即停止队列的运行</code><br><code>dispatch_suspend</code>，<code>dispatch_resume</code>提供了“挂起、恢复”队列的功能，简单来说，就是可以暂停、恢复队列上的任务。但是这里的“挂起”，并不能保证可以立即停止队列上正在运行的block，看如下例子</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)dispatch_suspendTest</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">&quot;me.tutuge.test.gcd&quot;</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    <span class="comment">//提交第一个block，延时5秒打印。</span></span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">5</span>];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;After 5 seconds...&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//提交第二个block，也是延时5秒打印</span></span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">5</span>];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;After 5 seconds again...&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//延时一秒</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;sleep 1 second...&quot;</span>);</span><br><span class="line">    [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">1</span>];</span><br><span class="line">    <span class="comment">//挂起队列</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;suspend...&quot;</span>);</span><br><span class="line">    dispatch_suspend(queue);</span><br><span class="line">    <span class="comment">//延时10秒</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;sleep 10 second...&quot;</span>);</span><br><span class="line">    [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">10</span>];</span><br><span class="line">    <span class="comment">//恢复队列</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;resume...&quot;</span>);</span><br><span class="line">    dispatch_resume(queue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2018-03-27 16:38:38.979600+0800 GCDTest[73048:39489499] sleep 1 second...</span><br><span class="line">2018-03-27 16:38:39.980863+0800 GCDTest[73048:39489499] suspend...</span><br><span class="line">2018-03-27 16:38:39.981146+0800 GCDTest[73048:39489499] sleep 10 second...</span><br><span class="line">2018-03-27 16:38:43.984071+0800 GCDTest[73048:39489555] After 5 seconds...</span><br><span class="line">2018-03-27 16:38:49.981099+0800 GCDTest[73048:39489499] resume...</span><br><span class="line">2018-03-27 16:38:54.985417+0800 GCDTest[73048:39489554] After 5 seconds again...</span><br></pre></td></tr></table></figure>
<p><code>dispatch_suspend</code>并不会立即暂停正在运行的block，而是在当前block执行完成后，暂停后续的block执行</p>
<h3 id="GCD死锁"><a href="#GCD死锁" class="headerlink" title="GCD死锁"></a>GCD死锁</h3><p>当前串行队列里面同步执行当前串行队列就会死锁，解决的方法就是将同步的串行队列放到另外一个线程就能够解决。</p>
<h4 id="主队列的同步线程"><a href="#主队列的同步线程" class="headerlink" title="主队列的同步线程"></a>主队列的同步线程</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)deadLockCase1 &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;1&quot;</span>);</span><br><span class="line">    <span class="comment">//主队列的同步线程，按照FIFO的原则（先入先出），2排在3后面会等3执行完，但因为同步线程，3又要等2执行完，相互等待成为死锁。</span></span><br><span class="line">    <span class="built_in">dispatch_sync</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;2&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;3&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://og0h689k8.bkt.clouddn.com/18-3-27/81353906.jpg" alt="结果"></p>
<p>解决：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)deadLockCase2 &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;1&quot;</span>);</span><br><span class="line">    <span class="comment">//3会等2，因为2在全局并行队列里，不需要等待3，这样2执行完回到主队列，3就开始执行</span></span><br><span class="line">    <span class="built_in">dispatch_sync</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, <span class="number">0</span>), ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;2&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;3&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2018-03-27 16:28:50.688138+0800 GCDTest[72824:39450961] 1</span><br><span class="line">2018-03-27 16:28:50.688254+0800 GCDTest[72824:39450961] 2</span><br><span class="line">2018-03-27 16:28:50.688336+0800 GCDTest[72824:39450961] 3</span><br></pre></td></tr></table></figure>

<h4 id="串行队列中同步执行"><a href="#串行队列中同步执行" class="headerlink" title="串行队列中同步执行"></a>串行队列中同步执行</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)deadLockCase3 &#123;</span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> serialQueue = dispatch_queue_create(<span class="string">&quot;com.starming.gcddemo.serialqueue&quot;</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;1&quot;</span>);</span><br><span class="line">    <span class="built_in">dispatch_async</span>(serialQueue, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;2&quot;</span>);</span><br><span class="line">        <span class="comment">//串行队列里面同步一个串行队列就会死锁</span></span><br><span class="line">        <span class="built_in">dispatch_sync</span>(serialQueue, ^&#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;3&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;4&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;5&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果也是死锁 解决方法如下</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)deadLockCase4 &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;1&quot;</span>);</span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;2&quot;</span>);</span><br><span class="line">        <span class="comment">//将同步的串行队列放到另外一个线程就能够解决</span></span><br><span class="line">        <span class="built_in">dispatch_sync</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;3&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;4&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;5&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="主线程被占用"><a href="#主线程被占用" class="headerlink" title="主线程被占用"></a>主线程被占用</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)deadLockCase5 &#123;</span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;1&quot;</span>);</span><br><span class="line">        <span class="comment">//回到主线程发现死循环后面就没法执行了</span></span><br><span class="line">        <span class="built_in">dispatch_sync</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;2&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;3&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;4&quot;</span>);</span><br><span class="line">    <span class="comment">//死循环</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="dispatch-barrier-async"><a href="#dispatch-barrier-async" class="headerlink" title="dispatch_barrier_async"></a>dispatch_barrier_async</h3><p>dispatch_barrier_async函数的作用与barrier的意思相同,在进程管理中起到一个栅栏的作用,它等待所有位于barrier函数之前的操作执行完毕后执行,并且在barrier函数执行之后,barrier函数之后的操作才会得到执行,该函数需要同dispatch_queue_create函数生成的concurrent Dispatch Queue队列一起使用</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)barrier</span><br><span class="line">&#123;</span><br><span class="line">　　<span class="comment">//同dispatch_queue_create函数生成的concurrent Dispatch Queue队列一起使用</span></span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">&quot;12312312&quot;</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;----1-----%@&quot;</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;----2-----%@&quot;</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_barrier_async(queue, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;----barrier-----%@&quot;</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;----3-----%@&quot;</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;----4-----%@&quot;</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印结果:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">2018</span><span class="number">-05</span><span class="number">-24</span> <span class="number">18</span>:<span class="number">19</span>:<span class="number">13.234432</span>+<span class="number">0800</span> Test[<span class="number">8324</span>:<span class="number">8295580</span>] ---<span class="number">-1</span>-----&lt;NSThread: <span class="number">0x600000279d00</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2018</span><span class="number">-05</span><span class="number">-24</span> <span class="number">18</span>:<span class="number">19</span>:<span class="number">13.234434</span>+<span class="number">0800</span> Test[<span class="number">8324</span>:<span class="number">8295577</span>] ---<span class="number">-2</span>-----&lt;NSThread: <span class="number">0x60800027ba00</span>&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2018</span><span class="number">-05</span><span class="number">-24</span> <span class="number">18</span>:<span class="number">19</span>:<span class="number">13.234607</span>+<span class="number">0800</span> Test[<span class="number">8324</span>:<span class="number">8295580</span>] ----barrier-----&lt;NSThread: <span class="number">0x600000279d00</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2018</span><span class="number">-05</span><span class="number">-24</span> <span class="number">18</span>:<span class="number">19</span>:<span class="number">13.234733</span>+<span class="number">0800</span> Test[<span class="number">8324</span>:<span class="number">8295577</span>] ---<span class="number">-4</span>-----&lt;NSThread: <span class="number">0x60800027ba00</span>&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2018</span><span class="number">-05</span><span class="number">-24</span> <span class="number">18</span>:<span class="number">19</span>:<span class="number">13.234739</span>+<span class="number">0800</span> Test[<span class="number">8324</span>:<span class="number">8295580</span>] ---<span class="number">-3</span>-----&lt;NSThread: <span class="number">0x600000279d00</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br></pre></td></tr></table></figure>

<h3 id="dispatch-queue-set-specific-dispatch-get-specific"><a href="#dispatch-queue-set-specific-dispatch-get-specific" class="headerlink" title="dispatch_queue_set_specific dispatch_get_specific"></a>dispatch_queue_set_specific dispatch_get_specific</h3><p>FMDB如何使用dispatch_queue_set_specific和dispatch_get_specific来防止死锁</p>
<p>作用类似objc_setAssociatedObject跟objc_getAssociatedObject</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">void</span> * <span class="keyword">const</span> kDispatchQueueSpecificKey = &amp;kDispatchQueueSpecificKey;</span><br><span class="line"><span class="comment">//创建串行队列，所有数据库的操作都在这个队列里</span></span><br><span class="line">_queue = dispatch_queue_create([[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;fmdb.%@&quot;</span>, <span class="keyword">self</span>] UTF8String], <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">//标记队列</span></span><br><span class="line">dispatch_queue_set_specific(_queue, kDispatchQueueSpecificKey, (__bridge <span class="keyword">void</span> *)<span class="keyword">self</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//检查是否是同一个队列来避免死锁的方法</span></span><br><span class="line">- (<span class="keyword">void</span>)inDatabase:(<span class="keyword">void</span> (^)(FMDatabase *db))block &#123;</span><br><span class="line">    FMDatabaseQueue *currentSyncQueue = (__bridge <span class="keyword">id</span>)dispatch_get_specific(kDispatchQueueSpecificKey);</span><br><span class="line">    assert(currentSyncQueue != <span class="keyword">self</span> &amp;&amp; <span class="string">&quot;inDatabase: was called reentrantly on the same queue, which would lead to a deadlock&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="NSOperation"><a href="#NSOperation" class="headerlink" title="NSOperation"></a>NSOperation</h1><h3 id="Operation-Queues-vs-Grand-Central-Dispatch-GCD"><a href="#Operation-Queues-vs-Grand-Central-Dispatch-GCD" class="headerlink" title="Operation Queues vs. Grand Central Dispatch (GCD)"></a>Operation Queues vs. Grand Central Dispatch (GCD)</h3><p>简单来说，<code>GCD</code> 是苹果基于 C 语言开发的，一个用于多核编程的解决方案，主要用于优化应用程序以支持多核处理器以及其他对称多处理系统。而<code>Operation Queues</code> 则是一个建立在 <code>GCD</code> 的基础之上的，面向对象的解决方案。它使用起来比 <code>GCD</code> 更加灵活，功能也更加强大。下面简单地介绍了 <code>Operation Queues</code> 和 <code>GCD</code> 各自的使用场景：</p>
<p><code>Operation Queues</code> ：相对 GCD 来说，使用 Operation Queues 会增加一点点额外的开销，但是我们却换来了非常强大的灵活性和功能，我们可以给 operation 之间添加依赖关系、取消一个正在执行的 operation 、暂停和恢复 operation queue 等；</p>
<p><code>GCD</code> ：则是一种更轻量级的，以 <code>FIFO</code> 的顺序执行并发任务的方式，使用 GCD 时我们并不关心任务的调度情况，而让系统帮我们自动处理。但是 GCD 的短板也是非常明显的，比如我们想要给任务之间添加依赖关系、取消或者暂停一个正在执行的任务时就会变得非常棘手。</p>
<h3 id="Operation对象"><a href="#Operation对象" class="headerlink" title="Operation对象"></a>Operation对象</h3><p>NSOperation 本身是一个抽象类，不能直接实例化，因此，如果我们想要使用它来执行具体任务的话，就必须创建自己的子类或者使用系统预定义的两个子类，NSInvocationOperation 和 NSBlockOperation 。</p>
<ul>
<li><code>NSInvocationOperation</code> ：我们可以通过一个 <code>object</code> 和 <code>selector</code> 非常方便地创建一个 <code>NSInvocationOperation</code> ，这是一种非常动态和灵活的方式。假设我们已经有了一个现成的方法，这个方法中的代码正好就是我们需要执行的任务，那么我们就可以在不修改任何现有代码的情况下，通过方法所在的对象和这个现有方法直接创建一个 <code>NSInvocationOperation</code> 。</li>
<li><code>NSBlockOperation</code> ：我们可以使用 <code>NSBlockOperation</code> 来并发执行一个或多个 block ，只有当一个 <code>NSBlockOperation</code> 所关联的所有 block 都执行完毕时，这个 NSBlockOperation 才算执行完成，有点类似于 <code>dispatch_group</code> 的概念。</li>
</ul>
<h4 id="Operation对象还支持下面的特性"><a href="#Operation对象还支持下面的特性" class="headerlink" title="Operation对象还支持下面的特性"></a>Operation对象还支持下面的特性</h4><ul>
<li>支持在 operation 之间建立依赖关系，只有当一个 operation 所依赖的所有 operation 都执行完成时，这个 operation 才能开始执行；</li>
<li>支持一个可选的 <code>completion block</code> ，这个 block 将会在 operation 的主任务执行完成时被调用；</li>
<li>支持通过 <code>KVO</code> 来观察 operation 执行状态的变化；</li>
<li>支持设置执行的优先级，从而影响 operation 之间的相对执行顺序；</li>
<li>支持<code>取消操作</code>，可以允许我们停止正在执行的 operation 。</li>
</ul>
<h3 id="并发-vs-非并发-Operation"><a href="#并发-vs-非并发-Operation" class="headerlink" title="并发 vs. 非并发 Operation"></a>并发 vs. 非并发 Operation</h3><p>通常来说，我们都是通过将 operation 添加到一个 operation queue 的方式来执行 operation 的，然而这并不是必须的。</p>
<p>我们也可以直接通过调用 start 方法来执行一个 operation ，但是这种方式并不能保证 operation 是异步执行的。NSOperation 类的 <code>isConcurrent</code> 方法的返回值标识了一个 operation 相对于调用它的 <code>start</code> 方法的线程来说是否是异步执行的。在默认情况下，<code>isConcurrent</code> 方法的返回值是 <code>NO</code> ，也就是说会阻塞调用它的 start 方法的线程。</p>
<p>如果我们想要自定义一个并发执行的 operation ，那么我们就必须要编写一些额外的代码来让这个 operation 异步执行。比如，为这个 operation 创建新的线程、调用系统的异步方法或者其他任何方式来确保 start 方法在开始执行任务后立即返回。</p>
<h3 id="创建-NSInvocationOperation-对象"><a href="#创建-NSInvocationOperation-对象" class="headerlink" title="创建 NSInvocationOperation 对象"></a>创建 NSInvocationOperation 对象</h3><p>NSInvocationOperation 是 NSOperation 类的一个子类，当一个 NSInvocationOperation 开始执行时，它会调用我们指定的 object 的 selector 方法</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">NSInvocationOperation</span> *)invocationOperationWithData:(<span class="keyword">id</span>)data &#123;</span><br><span class="line">    <span class="keyword">return</span> [[<span class="built_in">NSInvocationOperation</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(myTaskMethod1:) object:data];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2018-03-28 11:16:41.061212+0800 NSOperationDemo[2314:40962438] Start executing myTaskMethod1: with data: 111, mainThread: &lt;NSThread: 0x60800007b280&gt;&#123;number &#x3D; 1, name &#x3D; main&#125;, currentThread: &lt;NSThread: 0x60800007b280&gt;&#123;number &#x3D; 1, name &#x3D; main&#125;</span><br><span class="line">2018-03-28 11:16:44.062435+0800 NSOperationDemo[2314:40962438] Finish executing myTaskMethod1:</span><br></pre></td></tr></table></figure>

<h3 id="创建-NSBlockOperation-对象"><a href="#创建-NSBlockOperation-对象" class="headerlink" title="创建 NSBlockOperation 对象"></a>创建 NSBlockOperation 对象</h3><p>NSBlockOperation 是 NSOperation 类的另外一个系统预定义的子类，我们可以用它来封装一个或多个 block </p>
<p>什么情况下会优先使用NSBlockOperation：</p>
<blockquote>
<p>当我们在应用中已经使用了 Operation Queues 且不想创建 Dispatch Queues 时，<br>    NSBlockOperation 类可以为我们的应用提供一个面向对象的封装；<br>我们需要用到 Dispatch Queues 不具备的功能时，比如需要设置 operation 之间的依赖关系、使<br>    用 KVO 观察 operation 的状态变化等。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (NSBlockOperation *)blockOperation &#123;</span><br><span class="line">    NSBlockOperation *blockOperation &#x3D; [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">        NSLog(@&quot;Start executing block1, mainThread: %@, currentThread: %@&quot;, [NSThread mainThread], [NSThread currentThread]);</span><br><span class="line">        sleep(3);</span><br><span class="line">        NSLog(@&quot;Finish executing block1&quot;);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    [blockOperation addExecutionBlock:^&#123;</span><br><span class="line">        NSLog(@&quot;Start executing block2, mainThread: %@, currentThread: %@&quot;, [NSThread mainThread], [NSThread currentThread]);</span><br><span class="line">        sleep(3);</span><br><span class="line">        NSLog(@&quot;Finish executing block2&quot;);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    [blockOperation addExecutionBlock:^&#123;</span><br><span class="line">        NSLog(@&quot;Start executing block3, mainThread: %@, currentThread: %@&quot;, [NSThread mainThread], [NSThread currentThread]);</span><br><span class="line">        sleep(3);</span><br><span class="line">        NSLog(@&quot;Finish executing block3&quot;);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    return blockOperation;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2018-03-28 11:16:44.063438+0800 NSOperationDemo[2314:40962438] Start executing block1, mainThread: &lt;NSThread: 0x60800007b280&gt;&#123;number &#x3D; 1, name &#x3D; main&#125;, currentThread: &lt;NSThread: 0x60800007b280&gt;&#123;number &#x3D; 1, name &#x3D; main&#125;</span><br><span class="line">2018-03-28 11:16:44.063491+0800 NSOperationDemo[2314:40962523] Start executing block3, mainThread: &lt;NSThread: 0x60800007b280&gt;&#123;number &#x3D; 1, name &#x3D; (null)&#125;, currentThread: &lt;NSThread: 0x60000027b940&gt;&#123;number &#x3D; 4, name &#x3D; (null)&#125;</span><br><span class="line">2018-03-28 11:16:44.063500+0800 NSOperationDemo[2314:40962525] Start executing block2, mainThread: &lt;NSThread: 0x60800007b280&gt;&#123;number &#x3D; 1, name &#x3D; (null)&#125;, currentThread: &lt;NSThread: 0x604000273140&gt;&#123;number &#x3D; 3, name &#x3D; (null)&#125;</span><br><span class="line">2018-03-28 11:16:47.063715+0800 NSOperationDemo[2314:40962438] Finish executing block1</span><br><span class="line">2018-03-28 11:16:47.063714+0800 NSOperationDemo[2314:40962525] Finish executing block2</span><br><span class="line">2018-03-28 11:16:47.063714+0800 NSOperationDemo[2314:40962523] Finish executing block3</span><br></pre></td></tr></table></figure>


<h3 id="自定义-Operation-对象"><a href="#自定义-Operation-对象" class="headerlink" title="自定义 Operation 对象"></a>自定义 Operation 对象</h3><p>当系统预定义的两个子类 NSInvocationOperation 和 NSBlockOperation 不能很好的满足我们的需求时，我们可以自定义自己的 NSOperation 子类，添加我们想要的功能。目前，我们可以自定义非并发和并发两种不同类型的 NSOperation 子类</p>
<h4 id="非并发的NSOperation"><a href="#非并发的NSOperation" class="headerlink" title="非并发的NSOperation"></a>非并发的NSOperation</h4><p>对于一个非并发的 operation ，我们需要做的就只是执行 main 方法中的任务以及能够正常响应取消事件就可以了，其它的复杂工作比如依赖配置、KVO 通知等 NSOperation 类都已经帮我们处理好了。</p>
<h5 id="执行主任务"><a href="#执行主任务" class="headerlink" title="执行主任务"></a>执行主任务</h5><p>从最低限度上来说，每一个 operation 都应该至少实现以下两个方法：</p>
<blockquote>
<p>一个自定义的初始化方法；<br>main 方法。</p>
</blockquote>
<h5 id="响应取消事件"><a href="#响应取消事件" class="headerlink" title="响应取消事件"></a>响应取消事件</h5><p>当一个 operation 开始执行后，它会一直执行它的任务直到完成或被取消为止。我们可以在任意时间点取消一个 operation ，甚至是在它还未开始执行之前。为了让我们自定义的 operation 能够支持取消事件，我们需要在代码中定期地检查 <code>isCancelled</code> 方法的返回值，一旦检查到这个方法返回 YES ，我们就需要立即停止执行接下来的任务。根据苹果官方的说法，<code>isCancelled</code> 方法本身是足够轻量的，所以就算是频繁地调用它也不会给系统带来太大的负担。</p>
<blockquote>
<p>The isCancelled method itself is very lightweight and can be called<br>  frequently without any significant performance penalty.</p>
</blockquote>
<p>通常来说，当我们自定义一个 operation 类时，我们需要考虑在以下几个关键点检查 isCancelled 方法的返回值：</p>
<ul>
<li>在真正开始执行任务之前；</li>
<li>至少在每次循环中检查一次，而如果一次循环的时间本身就比较长的话，则需要检查得更加频繁；</li>
<li>在任何相对来说比较容易中止 operation 的地方。</li>
</ul>
<p>看到这里，我想你应该可以意识到一点，那就是尽管 <code>operation</code> 是支持取消操作的，但却并不是立即取消的，而是在你调用了 <code>operation</code> 的 <code>cancel</code> 方法之后的下一个 <code>isCancelled</code> 的检查点取消的</p>
<p>示例 一个支持取消操作Operation</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NonConcurrentOperation</span> ()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="keyword">id</span> data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NonConcurrentOperation</span></span></span><br><span class="line">- (<span class="keyword">id</span>)initWithData:(<span class="keyword">id</span>)data &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 支持取消操作</span></span><br><span class="line">- (<span class="keyword">void</span>)main &#123;</span><br><span class="line">    <span class="keyword">@try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.isCancelled) <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;Start executing %@ with data: %@, mainThread: %@, currentThread: %@&quot;</span>, <span class="built_in">NSStringFromSelector</span>(_cmd), <span class="keyword">self</span>.data, [<span class="built_in">NSThread</span> mainThread], [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">self</span>.isCancelled) <span class="keyword">return</span>;</span><br><span class="line">            </span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;Loop %@&quot;</span>, @(i + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;Finish executing %@&quot;</span>, <span class="built_in">NSStringFromSelector</span>(_cmd));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">@catch</span>(<span class="built_in">NSException</span> *exception) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;Exception: %@&quot;</span>, exception);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>注意</code>:operation的取消操作需要自己在block或者selector中加isCancelled的判断</p>
<h4 id="配置并发执行的-Operation"><a href="#配置并发执行的-Operation" class="headerlink" title="配置并发执行的 Operation"></a>配置并发执行的 Operation</h4><p>在默认情况下，<code>operation</code> 是同步执行的，也就是说在调用它的 <code>start</code> 方法的线程中执行它们的任务。而在 <code>operation</code> 和 <code>operation queue</code> 结合使用时，<code>operation queue</code> 可以为非并发的 <code>operation</code> 提供线程，因此，大部分的 operation 仍然可以异步执行</p>
<p>如果你想要手动地执行一个 operation ，又想这个 operation 能够异步执行的话，你需要做一些额外的配置来让你的 operation 支持并发执行。</p>
<p>需要重写的方法：</p>
<p><code>start</code> ：<code>必须的</code>，所有并发执行的 operation 都必须要重写这个方法，替换掉 NSOperation 类中的默认实现。start 方法是一个 operation 的起点，我们可以在这里配置任务执行的线程或者一些其它的执行环境。另外，需要特别注意的是，在我们重写的 start 方法中<code>一定不要调用父类的实现</code>；</p>
<p><code>main</code> ：<code>可选的</code>，通常这个方法就是专门用来实现与该 operation 相关联的任务的。尽管我们可以直接在 start 方法中执行我们的任务，但是用 main 方法来实现我们的任务可以使设置代码和任务代码得到分离，从而使 operation 的结构更清晰；</p>
<p><code>isExecuting</code> 和 <code>isFinished</code> ：<code>必须的</code>，并发执行的 operation 需要负责配置它们的执行环境，并且向外界客户报告执行环境的状态。因此，一个并发执行的 operation 必须要维护一些状态信息，用来记录它的任务是否正在执行，是否已经完成执行等。此外，当这两个方法所代表的值发生变化时，我们需要生成相应的 KVO 通知，以便外界能够观察到这些状态的变化；</p>
<p><code>isConcurrent</code> ：<code>必须的</code>，这个方法的返回值用来标识一个 operation 是否是并发的 operation ，我们需要重写这个方法并返回 YES 。</p>
<p>示例：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ConcurrentOperation</span></span></span><br><span class="line"><span class="comment">//用 @synthesize 关键字手动合成了两个实例变量 _executing 和 _finished ，</span></span><br><span class="line"><span class="comment">//然后分别在重写的 isExecuting 和 isFinished 方法中返回了这两个实例变量</span></span><br><span class="line"><span class="comment">//通过查看 NSOperation 类的头文件可以发现，executing 和 finished 属性都被声明成了只读的 readonly 。</span></span><br><span class="line"><span class="comment">//所以我们在 NSOperation 子类中就没有办法直接通过 setter 方法来自动触发 KVO 通知，</span></span><br><span class="line"><span class="comment">//这也是为什么我们需要在接下来的代码中手动触发 KVO 通知的原因。</span></span><br><span class="line"><span class="keyword">@synthesize</span> executing = _executing;</span><br><span class="line"><span class="keyword">@synthesize</span> finished  = _finished;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)init &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        _executing = <span class="literal">NO</span>;</span><br><span class="line">        _finished  = <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//是否为并发</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)isConcurrent &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//是否正在执行</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)isExecuting &#123;</span><br><span class="line">    <span class="keyword">return</span> _executing;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否完成</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)isFinished &#123;</span><br><span class="line">    <span class="keyword">return</span> _finished;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)start &#123;</span><br><span class="line"><span class="comment">//    在真正开始执行任务前，我们通过检查 isCancelled 方法的返回值来判断 operation 是否已经被 cancel ，如果是就直接返回了</span></span><br><span class="line"><span class="comment">//    即使一个 operation 是被 cancel 掉了，我们仍然需要手动触发 isFinished 的 KVO 通知。</span></span><br><span class="line"><span class="comment">//    因为当一个 operation 依赖其他 operation 时，它会观察所有其他 operation 的 isFinished 的值的变化，</span></span><br><span class="line"><span class="comment">//    只有当它依赖的所有 operation 的 isFinished 的值为 YES 时，这个 operation 才能够开始执行。</span></span><br><span class="line"><span class="comment">//    因此，如果一个我们自定义的 operation 被取消了但却没有手动触发 isFinished 的 KVO 通知的话，</span></span><br><span class="line"><span class="comment">//    那么所有依赖它的 operation 都不会执行</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.isCancelled) &#123;</span><br><span class="line">        [<span class="keyword">self</span> willChangeValueForKey:<span class="string">@&quot;isFinished&quot;</span>];</span><br><span class="line">        _finished = <span class="literal">YES</span>;</span><br><span class="line">        [<span class="keyword">self</span> didChangeValueForKey:<span class="string">@&quot;isFinished&quot;</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span> willChangeValueForKey:<span class="string">@&quot;isExecuting&quot;</span>];</span><br><span class="line"><span class="comment">//    为 main 方法分离了一个新的线程 这是 operation 能够并发执行的关键所在</span></span><br><span class="line">    [<span class="built_in">NSThread</span> detachNewThreadSelector:<span class="keyword">@selector</span>(main) toTarget:<span class="keyword">self</span> withObject:<span class="literal">nil</span>];</span><br><span class="line">    _executing = <span class="literal">YES</span>;</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span> didChangeValueForKey:<span class="string">@&quot;isExecuting&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在任务执行完毕后，我们需要手动触动 isExecuting 和 isFinished 的 KVO 通知。</span></span><br><span class="line">- (<span class="keyword">void</span>)main &#123;</span><br><span class="line">    <span class="keyword">@try</span> &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;Start executing %@, mainThread: %@, currentThread: %@&quot;</span>, <span class="built_in">NSStringFromSelector</span>(_cmd), [<span class="built_in">NSThread</span> mainThread], [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">        </span><br><span class="line">        sleep(<span class="number">3</span>);</span><br><span class="line">        </span><br><span class="line">        [<span class="keyword">self</span> willChangeValueForKey:<span class="string">@&quot;isExecuting&quot;</span>];</span><br><span class="line">        _executing = <span class="literal">NO</span>;</span><br><span class="line">        [<span class="keyword">self</span> didChangeValueForKey:<span class="string">@&quot;isExecuting&quot;</span>];</span><br><span class="line">        </span><br><span class="line">        [<span class="keyword">self</span> willChangeValueForKey:<span class="string">@&quot;isFinished&quot;</span>];</span><br><span class="line">        _finished  = <span class="literal">YES</span>;</span><br><span class="line">        [<span class="keyword">self</span> didChangeValueForKey:<span class="string">@&quot;isFinished&quot;</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;Finish executing %@&quot;</span>, <span class="built_in">NSStringFromSelector</span>(_cmd));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">@catch</span> (<span class="built_in">NSException</span> *exception) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;Exception: %@&quot;</span>, exception);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="维护-KVO-通知"><a href="#维护-KVO-通知" class="headerlink" title="维护 KVO 通知"></a>维护 KVO 通知</h3><p>NSOperation 类的以下 <code>key paths</code> 支持 KVO 通知，我们可以通过观察这些 <code>key paths</code> 非常方便地监听到一个 operation 内部状态的变化：</p>
<ul>
<li>isCancelled</li>
<li>isConcurrent</li>
<li>isExecuting</li>
<li>isFinished</li>
<li>isReady</li>
<li>dependencies</li>
<li>queuePriority</li>
<li>completionBlock</li>
</ul>
<p>与重写 main 方法不同的是，如果我们重写了 start 方法或者对 NSOperation 类做了大量定制的话，我们需要保证自定义的 operation 在这些 key paths 上仍然支持 KVO 通知。比如，当我们重写了 start 方法时，我们需要特别关注的是 <code>isExecuting</code> 和 <code>isFinished</code> 这两个 key paths ，因为这两个 key paths 最可能受重写 start 方法的影响。</p>
<h2 id="Operation-对象的执行行为"><a href="#Operation-对象的执行行为" class="headerlink" title="Operation 对象的执行行为"></a>Operation 对象的执行行为</h2><h3 id="配置依赖关系"><a href="#配置依赖关系" class="headerlink" title="配置依赖关系"></a>配置依赖关系</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)addDependency:(<span class="built_in">NSOperation</span> *)op;</span><br><span class="line">- (<span class="keyword">void</span>)removeDependency:(<span class="built_in">NSOperation</span> *)op;</span><br></pre></td></tr></table></figure>

<p><code>注意</code>：</p>
<ul>
<li><p><code>addDependency: </code>方法添加的依赖关系是单向的，比如 <code>[A addDependency:B];</code> ，表示 A 依赖 B，B 并不依赖 A 。</p>
</li>
<li><p>这里的依赖关系并不局限于相同 operation queue 中的 operation 之间。</p>
</li>
<li><p>不要在 operation 之间添加循环依赖，因为这样会导致这些 operation 都不会被执行</p>
</li>
</ul>
<p>示例</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)operationDependencyTest</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSOperationQueue</span> *queue = [[<span class="built_in">NSOperationQueue</span> alloc] init];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSBlockOperation</span> *op1 = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;op1 test&quot;</span>);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSBlockOperation</span> *op2 = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;op2 test&quot;</span>);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSBlockOperation</span> *op3 = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;op3 test&quot;</span>);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//op1依赖于op2</span></span><br><span class="line">    [op1 addDependency:op2];</span><br><span class="line">    </span><br><span class="line">    [queue addOperation:op1];</span><br><span class="line">    [queue addOperation:op2];</span><br><span class="line">    [queue addOperation:op3];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2018-03-28 14:38:26.281018+0800 NSOperationDemo[5771:41445417] op2 test</span><br><span class="line">2018-03-28 14:38:26.281019+0800 NSOperationDemo[5771:41445416] op3 test</span><br><span class="line">2018-03-28 14:38:26.281244+0800 NSOperationDemo[5771:41445419] op1 test</span><br></pre></td></tr></table></figure>

<h3 id="修改-Operation-在队列中的优先级"><a href="#修改-Operation-在队列中的优先级" class="headerlink" title="修改 Operation 在队列中的优先级"></a>修改 Operation 在队列中的优先级</h3><p><code>setQueuePriority:</code></p>
<p>适用范围：只适用于同一个operation queue中的operation<br>但是高德优先级并不意味着可以首先被执行,因为 决定operation被执行顺序的第一要素是它们的 isReady 状态，其次是它们在队列中的优先级</p>
<p>示例：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)QueuePriorityTest</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSOperationQueue</span> *queue = [[<span class="built_in">NSOperationQueue</span> alloc] init];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSBlockOperation</span> *op1 = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;op1 test&quot;</span>);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSBlockOperation</span> *op2 = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;op2 test&quot;</span>);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSBlockOperation</span> *op3 = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;op3 test&quot;</span>);</span><br><span class="line">    &#125;];</span><br><span class="line"><span class="comment">//    NSOperationQueuePriorityVeryLow = -8L,</span></span><br><span class="line"><span class="comment">//    NSOperationQueuePriorityLow = -4L,</span></span><br><span class="line"><span class="comment">//    NSOperationQueuePriorityNormal = 0,</span></span><br><span class="line"><span class="comment">//    NSOperationQueuePriorityHigh = 4,</span></span><br><span class="line"><span class="comment">//    NSOperationQueuePriorityVeryHigh = 8</span></span><br><span class="line">    [op1 setQueuePriority:<span class="built_in">NSOperationQueuePriorityHigh</span>];</span><br><span class="line">    [op3 setQueuePriority:<span class="built_in">NSOperationQueuePriorityLow</span>];</span><br><span class="line">    </span><br><span class="line">    [queue addOperation:op1];</span><br><span class="line">    [queue addOperation:op2];</span><br><span class="line">    [queue addOperation:op3];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2018-03-28 14:41:18.941460+0800 NSOperationDemo[5852:41457022] op1 test</span><br><span class="line">2018-03-28 14:41:18.941460+0800 NSOperationDemo[5852:41457021] op3 test</span><br><span class="line">2018-03-28 14:41:18.941460+0800 NSOperationDemo[5852:41457020] op2 test</span><br></pre></td></tr></table></figure>

<h3 id="设置-Completion-Block"><a href="#设置-Completion-Block" class="headerlink" title="设置 Completion Block"></a>设置 Completion Block</h3><p><code>setCompletionBlock:</code><br>一个 operation 可以在它的主任务执行完成时回调一个 completion block </p>
<ul>
<li>当一个 operation 被取消时，它的 <code>completion block</code> 仍然会执行，所以我们需要在真正执行代码前检查一下 <code>isCancelled</code> 方法的返回值</li>
<li>我们也没有办法保证 <code>completion block</code> 被回调时一定是在主线程，理论上它应该是与触发 <code>isFinished</code> 的 KVO 通知所在的线程一致的，所以如果有必要的话我们可以在 <code>completion block</code> 中使用 GCD 来保证从主线程更新 UI</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置completionBlock</span></span><br><span class="line">- (<span class="keyword">void</span>)completionBlockTest</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSOperationQueue</span> *queue = [[<span class="built_in">NSOperationQueue</span> alloc] init];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSBlockOperation</span> *op1 = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;op1 test&quot;</span>);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSBlockOperation</span>* op2 = [[<span class="built_in">NSBlockOperation</span> alloc] init];</span><br><span class="line">    __<span class="keyword">weak</span> <span class="built_in">NSBlockOperation</span>* myWeakOp = op2;</span><br><span class="line">    myWeakOp = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">        sleep(<span class="number">5</span>);</span><br><span class="line">        <span class="comment">// 如果要可以取消需要自己加判断</span></span><br><span class="line">        <span class="keyword">if</span> ([myWeakOp isCancelled]) &#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;op2 test&quot;</span>);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    [op2 setCompletionBlock:^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">        <span class="comment">//回调的线程跟触发KVO isFinished的在一个线程不一定是主线程 如果不是主线程 而且在这个回调里</span></span><br><span class="line">        <span class="comment">// 做了更新UI的操作需要在主线程更新</span></span><br><span class="line">        <span class="keyword">if</span> (![<span class="built_in">NSThread</span> isMainThread]) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;not main thread update ui in main thread&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//即使任务呗取消了 也会走CompletionBlock 只不过可以通过cancelled属性判断</span></span><br><span class="line">        <span class="keyword">if</span> (myWeakOp.cancelled) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;op2 cancelled&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;op2 complete&quot;</span>);</span><br><span class="line">    &#125;];</span><br><span class="line">  </span><br><span class="line">    __<span class="keyword">weak</span> <span class="keyword">typeof</span>(op1) weakOp1 = op1;</span><br><span class="line">    [op1 setCompletionBlock:^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;op1 complete&quot;</span>);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    [queue addOperation:op1];</span><br><span class="line">    [queue addOperation:op2];</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    [queue cancelAllOperations];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;op2 cancel&quot;</span>);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="执行-Operation-对象"><a href="#执行-Operation-对象" class="headerlink" title="执行 Operation 对象"></a>执行 Operation 对象</h3><ul>
<li>直接调用start</li>
<li>将 operation 添加到一个 operation queue 中，让 operation queue 来帮我们自动执行</li>
</ul>
<h4 id="添加-Operation-到-Operation-Queue-中"><a href="#添加-Operation-到-Operation-Queue-中" class="headerlink" title="添加 Operation 到 Operation Queue 中"></a>添加 Operation 到 Operation Queue 中</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSOperationQueue</span> *operationQueue = [[<span class="built_in">NSOperationQueue</span> alloc] init];</span><br></pre></td></tr></table></figure>

<p>将operation添加到queue中的方法：</p>
<ul>
<li>addOperation: ，添加一个 operation 到 operation queue 中；</li>
<li>addOperations:waitUntilFinished: ，添加一组 operation 到 operation queue 中；</li>
<li>addOperationWithBlock: ，直接添加一个 block 到 operation queue 中，而不用创建一个 NSBlockOperation 对象。</li>
</ul>
<p>示例：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)executeOperationUsingOperationQueue &#123;</span><br><span class="line">    <span class="built_in">NSOperationQueue</span> *operationQueue = [[<span class="built_in">NSOperationQueue</span> alloc] init];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSInvocationOperation</span> *invocationOperation = [[<span class="built_in">NSInvocationOperation</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(taskMethod) object:<span class="literal">nil</span>];</span><br><span class="line">    [operationQueue addOperation:invocationOperation];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSBlockOperation</span> *blockOperation1 = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">        sleep(<span class="number">3</span>);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;Finish executing blockOperation1&quot;</span>);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSBlockOperation</span> *blockOperation2 = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">        sleep(<span class="number">3</span>);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;Finish executing blockOperation2&quot;</span>);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    [operationQueue addOperations:@[ blockOperation1, blockOperation2 ] waitUntilFinished:<span class="literal">YES</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;blockOperation1 blockOperation2 taskMethod all finished&quot;</span>);</span><br><span class="line">    [operationQueue addOperationWithBlock:^&#123;</span><br><span class="line">        sleep(<span class="number">3</span>);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;Finish executing block&quot;</span>);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    [operationQueue waitUntilAllOperationsAreFinished];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;test end&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)taskMethod &#123;</span><br><span class="line">    sleep(<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;Finish executing %@&quot;</span>, <span class="built_in">NSStringFromSelector</span>(_cmd));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2018-03-28 15:36:57.950936+0800 NSOperationDemo[7299:41666224] Finish executing blockOperation1</span><br><span class="line">2018-03-28 15:36:57.950941+0800 NSOperationDemo[7299:41666225] Finish executing blockOperation2</span><br><span class="line">2018-03-28 15:36:57.950964+0800 NSOperationDemo[7299:41666227] Finish executing taskMethod</span><br><span class="line">2018-03-28 15:36:57.951320+0800 NSOperationDemo[7299:41666189] blockOperation1 blockOperation2 taskMethod all finished</span><br><span class="line">2018-03-28 15:37:00.956712+0800 NSOperationDemo[7299:41666227] Finish executing block</span><br><span class="line">2018-03-28 15:37:00.957116+0800 NSOperationDemo[7299:41666189] test end</span><br></pre></td></tr></table></figure>

<p><code>在将一个 operation 添加到 operation queue 后就不要再修改这个 operation 了。因为 operation 被添加到 operation queue 后随时可能会执行，这个是由系统决定的，所以再修改它的依赖关系或者所包含的数据就很有可能会造成未知的影响。</code></p>
<h4 id="手动执行-Operation"><a href="#手动执行-Operation" class="headerlink" title="手动执行 Operation"></a>手动执行 Operation</h4><p>如果要手动执行Operation 可以直接调用start方法，但是从严格意义上来说，在调用 start 方法真正开始执行一个 operation 前，我们应该要做一些防范性的判断：</p>
<ul>
<li>检查 operation 的 isReady 状态是否为 YES ，这个取决于它所依赖的 operation 是否已经执行完成</li>
<li>检查 operation 的 isCancelled 状态是否为 YES ，如果是，那么我们就根本不需要再花费不必要的开销去启动它</li>
<li>检查一下它的 isConcurrent 状态。如果它的 isConcurrent 状态为 NO ，那么我们就需要考虑一下是否可以在当前线程同步执行这个 operation ，或者是先为这个 operation 创建一个单独的线程，以供它异步执行。</li>
</ul>
<p>在默认的 start 方法中会生成一些必要的 KVO 通知，比如 isExcuting 和 isFinished ，而这些 KVO 通知正是 operation 能够正确处理好依赖关系的关键所在。</p>
<h3 id="取消-Operation"><a href="#取消-Operation" class="headerlink" title="取消 Operation"></a>取消 Operation</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">[operation cancel];</span><br><span class="line"></span><br><span class="line">[queue cancelAllOperations];</span><br></pre></td></tr></table></figure>
<p><code>注意</code>：当一个 operation 被取消后，这个 operation 的 isFinished 状态也会变成 YES ，这样处理的好处就是所有依赖它的 operation 能够接收到这个 KVO 通知，从而能够清除这个依赖关系正常执行。</p>
<h3 id="等待-Operation-执行完成"><a href="#等待-Operation-执行完成" class="headerlink" title="等待 Operation 执行完成"></a>等待 Operation 执行完成</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">[operation waitUntilFinished];</span><br><span class="line">[queue waitUntilAlloperationsAreFinished];</span><br></pre></td></tr></table></figure>

<p><code>注意</code>:当我们在等待一个 operation queue 中的所有 operation 执行完成时，其他的线程仍然可以向这个 operation queue 中添加 operation ，从而延长我们的等待时间</p>
<h3 id="暂停和恢复-Operation-Queue"><a href="#暂停和恢复-Operation-Queue" class="headerlink" title="暂停和恢复 Operation Queue"></a>暂停和恢复 Operation Queue</h3><p><code>[queue setSuspended]</code></p>
<p><code>注意</code>：暂停执行 operation queue 并不能使正在执行的 operation 暂停执行，而只是简单地暂停调度新的 operation 。另外，我们并不能单独地暂停执行一个 operation ，除非直接 cancel 掉。</p>
<h4 id="setMaxConcurrentoperationCount"><a href="#setMaxConcurrentoperationCount" class="headerlink" title="setMaxConcurrentoperationCount"></a>setMaxConcurrentoperationCount</h4><p>设置一个 operation queue 最大可并发的 operation 数.<br>可以通过将这个值设置成 1 实现让 operation queue 一次只执行一个 operation 的目的<br><font color='red' size='8'>注意</font>:</p>
<ul>
<li>1、operation 的执行顺序还是一样会受其他因素影响的，比如 operation 的 isReady 状态、operation 的队列优先级等</li>
<li>一个串行的 operation queue 与一个串行的 dispatch queue 还是有本质区别的，因为 dispatch queue 的执行顺序一直是 FIFO 的。如果 operation 的执行顺序对我们来说非常重要，那么我们就应该在将 operation 添加到 operation queue 之前就建立好它的依赖关系。</li>
</ul>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://github.com/ming1016/study/wiki/%E7%BB%86%E8%AF%B4GCD%EF%BC%88Grand-Central-Dispatch%EF%BC%89%E5%A6%82%E4%BD%95%E7%94%A8">细说GCD</a><br><a href="http://tutuge.me/2015/04/03/something-about-gcd/index.html">GCD使用经验与技巧浅谈</a><br><a href="http://yolynn.com/2015/08/10/ios_thread/">多线程基础到进阶</a><br><a href="http://blog.leichunfeng.com/blog/2015/07/29/ios-concurrency-programming-operation-queues/">iOS并发编程</a></p>
]]></content>
      <categories>
        <category>iOS基础</category>
      </categories>
      <tags>
        <tag>网络 多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>runloop 的那些事儿(转)</title>
    <url>/2018/02/28/runloop-detail/</url>
    <content><![CDATA[<p>最近在看iOS的一些基础原理,看到<a href="https://www.jianshu.com/u/14431e509ae8">涂耀辉</a>的这篇关于Runloop的,感觉原理+代码的这种讲解方式非常好,特地转过来，由于简书后半部分排版有点乱,这里特地按照我的思路重新整理一下！</p>
<a id="more"></a>

<h2 id="先看AFN的一段经典代码："><a href="#先看AFN的一段经典代码：" class="headerlink" title="先看AFN的一段经典代码："></a>先看AFN的一段经典代码：</h2><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">+ (<span class="built_in">NSThread</span> *)networkRequestThread &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">NSThread</span> *_networkRequestThread = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> oncePredicate;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;oncePredicate, ^&#123;</span><br><span class="line">        _networkRequestThread = [[<span class="built_in">NSThread</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(networkRequestThreadEntryPoint:) object:<span class="literal">nil</span>];</span><br><span class="line">        [_networkRequestThread start];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> _networkRequestThread;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)networkRequestThreadEntryPoint:(<span class="keyword">id</span>)__unused object &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        [[<span class="built_in">NSThread</span> currentThread] setName:<span class="string">@&quot;AFNetworking&quot;</span>];</span><br><span class="line">        <span class="built_in">NSRunLoop</span> *runLoop = [<span class="built_in">NSRunLoop</span> currentRunLoop];</span><br><span class="line">        [runLoop addPort:[<span class="built_in">NSMachPort</span> port] forMode:<span class="built_in">NSDefaultRunLoopMode</span>];</span><br><span class="line">        [runLoop run];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>1、首先我们要明确一个概念，线程一般都是一次执行完任务，就销毁了。</li>
<li>2、而添加了runloop，并运行起来，实际上是添加了一个do,while循环，这样这个线程的程序一直卡在这个do,while循环上，这样相当于线程的任务一直没有执行完，所以线程一直不会销毁。</li>
<li>3、所以，一旦我们添加了一个runloop，并run了，我们如果要销毁这个线程，必须停止runloop，至于停止的方式，我们接下去往下看。</li>
</ul>
<p><code>注</code>:这里创建的名为<code>AFNetworking</code>的线程,由于其被添加到Runloop上 所以除非Runloop被销毁,否则线程也不会被销毁</p>
<p>1、添加监听事件的端口</p>
<p><code>[runLoop addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode]; </code></p>
<p>2、Runloop跑起来</p>
<p><code>[runLoop run];</code></p>
<p>不过以这种方式启动Runloop后只有一种方式可以终止该Runloop：<br>移除之前添加的端口 这样Runloop中没有事件了，所以可以直接退出。<br><code>[NSRunLoop currentRunLoop]removePort:&lt;#(nonnull NSPort *)#&gt; forMode:&lt;#(nonnull NSRunLoopMode)#&gt;</code></p>
<p>因此 我们可以得出<code>AFN中并没有记录该port,所以压根就不会退出Runloop,所以这是一个常驻线程</code></p>
<h2 id="再看看AFN3-X"><a href="#再看看AFN3-X" class="headerlink" title="再看看AFN3.X"></a>再看看AFN3.X</h2><p>开启RunLoop:</p>
<p><code>CFRunLoopRun();</code></p>
<p>终止RunLoop:</p>
<p><code>CFRunLoopStop(CFRunLoopGetCurrent());</code></p>
<h2 id="RAC中的RunLoop"><a href="#RAC中的RunLoop" class="headerlink" title="RAC中的RunLoop"></a>RAC中的RunLoop</h2><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//自己用一个Bool值done去控制runloop的运行，每次只运行这</span></span><br><span class="line"><span class="comment">//个模式的runloop，0.1秒。0.1秒后开启runloop的下一次运行</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    [<span class="built_in">NSRunLoop</span>.mainRunLoop runMode:<span class="built_in">NSDefaultRunLoopMode</span> beforeDate:[<span class="built_in">NSDate</span> dateWithTimeIntervalSinceNow:<span class="number">0.1</span>]];</span><br><span class="line">&#125; <span class="keyword">while</span> (!done);</span><br></pre></td></tr></table></figure>

<h2 id="RunLoop概念"><a href="#RunLoop概念" class="headerlink" title="RunLoop概念"></a>RunLoop概念</h2><p><img src="https://upload-images.jianshu.io/upload_images/2702646-08d6e834e337387d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt="RunLoop官方图"></p>
<p>Runloop，顾名思义就是跑圈，他的本质就是一个do,while循环，当有事做时做事，没事做时睡眠。至于怎么做事，怎么睡眠，这个是由系统内核来调度的，我们后面会讲到</p>
<p>每个线程都有一个Run Loop，主线程的Run Loop会在App运行时自动运行，子线程中需要手动获取运行，第一次获取时，才会去创建。</p>
<p>每个Run Loop都会以一个模式mode来运行，可以使用NSRunLoop的</p>
<p><code>-(BOOL)runMode:(NSString *)mode beforeDate:(NSDate *)limitDate  </code><br>方法来设置运行在那个特定的mode</p>
<ul>
<li><p>1 Run Loop的处理两大类事件源：<code>Timer Source</code>和<code>Input Source</code>(包括<code>performSelector***</code>方法簇,<code>Port</code>或者自定义<code>Input Source</code>)，每个事件源都会绑定在Run Loop的某个特定模式mode上，<code>而且只有RunLoop在这个模式运行的时候才会触发该Timer和Input Source</code>。</p>
</li>
<li><p>2、如果没有任何事件源添加到RunLoop上，RunLoop就会立刻exit，这也是一开始的AF例子，为什么需要绑定一个Port的原因。</p>
</li>
</ul>
<h3 id="OS下Run-Loop的主要运行模式mode有："><a href="#OS下Run-Loop的主要运行模式mode有：" class="headerlink" title="OS下Run Loop的主要运行模式mode有："></a>OS下Run Loop的主要运行模式mode有：</h3><blockquote>
<p>1、NSDefaultRunLoopMode: 默认的运行模式，除了NSConnection对象的事件。<br>2、NSRunLoopCommonModes: 是一组常用的模式集合，将一个input source关联到这个模式集合上，等于将input source关联到这个模式集合中的所有模式上。在iOS系统中NSRunLoopCommonMode包含NSDefaultRunLoopMode、NSTaskDeathCheckMode、UITrackingRunLoopMode。</p>
</blockquote>
<p>假如我有个timer要关联到这些模式上，一个个注册很麻烦，我可以用</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">[[<span class="built_in">NSRunLoop</span> currentRunLoop] addTimer:timer forMode:<span class="built_in">NSRunLoopCommonModes</span>];</span><br></pre></td></tr></table></figure>
<p>将UITrackingRunLoopMode或者其他模式添加到这个NSRunLoopCommonModes模式中，然后只需要将Timer关联到NSRunLoopCommonModes，即可以实现Run Loop运行在这个模式集合中任何一个模式时，这个Timer都可以被触发</p>
<p>当然，默认情况下NSRunLoopCommonModes包含了NSDefaultRunLoopMode和UITrackingRunLoopMode。我指的是如果有其他自定义Mode。</p>
<blockquote>
<p>3、UITrackingRunLoopMode: 用于跟踪触摸事件触发的模式（例如UIScrollView上下滚动），主线程当触摸事件触发时会设置为这个模式，可以用来在控件事件触发过程中设置Timer。<br>4、GSEventReceiveRunLoopMode: 用于接受系统事件，属于内部的Run Loop模式。<br>5、自定义Mode：可以设置自定义的运行模式Mode，你也可以用CFRunLoopAddCommonMode添加到NSRunLoopCommonModes中</p>
</blockquote>
<h3 id="总结一下："><a href="#总结一下：" class="headerlink" title="总结一下："></a>总结一下：</h3><p>Run Loop运行时只能以一种固定的模式运行，如果我们需要它切换模式，只有停掉它，再重新开启它。</p>
<p>运行时它只会监控这个模式下添加的Timer Source和Input Source，如果这个模式下没有相应的事件源，Run Loop的运行也会立刻返回的。</p>
<p>注意Run Loop不能在运行在NSRunLoopCommonModes模式，因为NSRunLoopCommonModes其实是个模式集合，而不是一个具体的模式，我可以在添加事件源的时候使用NSRunLoopCommonModes，只要Run Loop运行在NSRunLoopCommonModes中任何一个模式，这个事件源都可以被触发</p>
<h2 id="Run-Loop运行接口"><a href="#Run-Loop运行接口" class="headerlink" title="Run Loop运行接口"></a>Run Loop运行接口</h2><p>Foundation层和CoreFoundation层都有对应的接口可以操作RunLoop：</p>
<p>Foundation层对应的是NSRunLoop，Core Foundation层对应的是CFRunLoopRef；</p>
<p>两组接口差不多，不过功能上还是有许多区别的：<br>例如CF层可以添加自定义Input Source事件源、(CFRunLoopSourceRef)Run Loop观察者Observer(CFRunLoopObserverRef)，很多类似功能的接口特性也是不一样的。</p>
<h3 id="NSRunLoop的运行接口："><a href="#NSRunLoop的运行接口：" class="headerlink" title="NSRunLoop的运行接口："></a>NSRunLoop的运行接口：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;运行 NSRunLoop，运行模式为默认的NSDefaultRunLoopMode模式，没有超时限制</span><br><span class="line">- (void)run;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;运行 NSRunLoop: 参数为运时间期限，运行模式为默认的NSDefaultRunLoopMode模式 </span><br><span class="line">- (void)runUntilDate:(NSDate *)limitDate;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;运行 NSRunLoop: 参数为运行模式、时间期限，返回值为YES表示是处理事件后返回的，NO表示是超时或者停止运行导致返回的</span><br><span class="line">- (BOOL)runMode:(NSString *)mode beforeDate:(NSDate *)limitDate;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>CFRunLoopRef的运行接口：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;运行 CFRunLoopRef</span><br><span class="line">void CFRunLoopRun();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;运行 CFRunLoopRef: 参数为运行模式、时间和是否在处理Input Source后退出标志，返回值是exit原因</span><br><span class="line">SInt32 CFRunLoopRunInMode (mode, seconds, returnAfterSourceHandled);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;停止运行 CFRunLoopRef</span><br><span class="line">void CFRunLoopStop( CFRunLoopRef rl );</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;唤醒CFRunLoopRef</span><br><span class="line">void CFRunLoopWakeUp ( CFRunLoopRef rl );</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="下面分类进行详解"><a href="#下面分类进行详解" class="headerlink" title="下面分类进行详解"></a>下面分类进行详解</h3><p><code>- (void)run; 无条件运行</code></p>
<ul>
<li>AFN2.X使用的方式</li>
<li>不建议使用，因为这个接口会导致Run Loop永久性的运行在NSDefaultRunLoopMode模式。</li>
<li>即使用CFRunLoopStop(runloopRef);也无法停止Run Loop的运行，除非能移除这个runloop上的所有事件源，包括定时器和source事件，不然这个子线程就无法停止，只能永久运行下去。</li>
</ul>
<p><code>- (void)runUntilDate:(NSDate *)limitDate;  有一个超时时间限制 </code><br>比上面的接口好点，有个超时时间，可以控制每次Run Loop的运行时间，也是运行在NSDefaultRunLoopMode模式。<br>这个方法运行Run Loop一段时间会退出给你检查运行条件的机会，如果需要可以再次运行Run Loop。<br>注意CFRunLoopStop(runloopRef),也无法停止Run Loop的运行</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (!Done)</span><br><span class="line">&#123;</span><br><span class="line">    [[<span class="built_in">NSRunLoop</span> currentRunLoop] runUntilDate:[<span class="built_in">NSDate</span> dateWithTimeIntervalSinceNow:<span class="number">10</span>]];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;exiting runloop.........:&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意这个Done是我们自定义的一个Bool值，用来控制是否还需要开启下一次的runloop。</p>
<p>这个例子大概做了如下的事：这个Runloop会每10秒退出一次，然后输出exiting runloop………，然后下一次根据我们的Done值来判断是否再去运行runloop</p>
<p>`//有一个超时时间限制，而且设置运行模式</p>
<ul>
<li>(BOOL)runMode:(NSString *)mode beforeDate:(NSDate *)limitDate;`</li>
</ul>
<ul>
<li><p>这种运行方式是可以被CFRunLoopStop(runloopRef)所停止的(大家可以自己写个例子试试)。</p>
</li>
<li><p>这个方法和第二个方法还有一个很大的区别就是这样去运行runloop会多一种退出方式。这里我指的退出方式是除了timer触发以外的事件，都会导致runloop退出</p>
</li>
</ul>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)testDemo1</span><br><span class="line">&#123;</span><br><span class="line">    dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;</span><br><span class="line">        NSLog(@&quot;线程开始&quot;);</span><br><span class="line">        &#x2F;&#x2F;获取到当前线程</span><br><span class="line">        self.thread &#x3D; [NSThread currentThread];</span><br><span class="line">        </span><br><span class="line">        NSRunLoop *runloop &#x3D; [NSRunLoop currentRunLoop];</span><br><span class="line">        &#x2F;&#x2F;添加一个Port，同理为了防止runloop没事干直接退出</span><br><span class="line">        [runloop addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode];</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;运行一个runloop，[NSDate distantFuture]：很久很久以后才让它失效</span><br><span class="line">        [runloop runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]];</span><br><span class="line">        </span><br><span class="line">        NSLog(@&quot;线程结束&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        &#x2F;&#x2F;在我们开启的异步线程调用方法</span><br><span class="line">        [self performSelector:@selector(recieveMsg) onThread:self.thread withObject:nil waitUntilDone:NO];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)recieveMsg</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;收到消息了，在这个线程：%@&quot;,[NSThread currentThread]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2016-11-22 14:04:15.250 TestRunloop3[70591:1742754] 线程开始</span><br><span class="line">2016-11-22 14:04:17.250 TestRunloop3[70591:1742754] 收到消息了，在这个线程：&lt;NSThread: 0x600000263c80&gt;&#123;number &#x3D; 3, name &#x3D; (null)&#125;</span><br><span class="line">2016-11-22 14:04:17.250 TestRunloop3[70591:1742754] 线程结束</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在这里我们用了<code>performSelector: onThread...</code>这个方法去进行线程间通信，这只是其中一种最简单的方式。但是缺点也很明显，就是在去调用这个线程的时候，<code>如果线程已经不存在了</code>，程序就会<code>crash</code>。后面我们会仔细讲各种线程间的通信。</p>
<h3 id="线程为什么会结束呢？"><a href="#线程为什么会结束呢？" class="headerlink" title="线程为什么会结束呢？"></a>线程为什么会结束呢？</h3><p>我们先看一下RunLoop的源码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; RunLoop的实现</span><br><span class="line">int CFRunLoopRunSpecific(runloop, modeName, seconds, stopAfterHandle) &#123;</span><br><span class="line">     </span><br><span class="line">    &#x2F;&#x2F;&#x2F; 首先根据modeName找到对应mode</span><br><span class="line">    CFRunLoopModeRef currentMode &#x3D; __CFRunLoopFindMode(runloop, modeName, false);</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 如果mode里没有source&#x2F;timer&#x2F;observer, 直接返回。</span><br><span class="line">    if (__CFRunLoopModeIsEmpty(currentMode)) return;</span><br><span class="line">     </span><br><span class="line">    &#x2F;&#x2F;&#x2F; 1. 通知 Observers: RunLoop 即将进入 loop。</span><br><span class="line">    __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopEntry);</span><br><span class="line">     </span><br><span class="line">    &#x2F;&#x2F;&#x2F; 内部函数，进入loop</span><br><span class="line">    __CFRunLoopRun(runloop, currentMode, seconds, returnAfterSourceHandled) &#123;</span><br><span class="line">         </span><br><span class="line">        Boolean sourceHandledThisLoop &#x3D; NO;</span><br><span class="line">        int retVal &#x3D; 0;</span><br><span class="line">        do &#123;</span><br><span class="line">  </span><br><span class="line">            &#x2F;&#x2F;&#x2F; 2. 通知 Observers: RunLoop 即将触发 Timer 回调。</span><br><span class="line">            __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeTimers);</span><br><span class="line">            &#x2F;&#x2F;&#x2F; 3. 通知 Observers: RunLoop 即将触发 Source0 (非port) 回调。</span><br><span class="line">            __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeSources);</span><br><span class="line">            &#x2F;&#x2F;&#x2F; 执行被加入的block</span><br><span class="line">            __CFRunLoopDoBlocks(runloop, currentMode);</span><br><span class="line">             </span><br><span class="line">            &#x2F;&#x2F;&#x2F; 4. RunLoop 触发 Source0 (非port) 回调。</span><br><span class="line">            sourceHandledThisLoop &#x3D; __CFRunLoopDoSources0(runloop, currentMode, stopAfterHandle);</span><br><span class="line">            &#x2F;&#x2F;&#x2F; 执行被加入的block</span><br><span class="line">            __CFRunLoopDoBlocks(runloop, currentMode);</span><br><span class="line">  </span><br><span class="line">            &#x2F;&#x2F;&#x2F; 5. 如果有 Source1 (基于port) 处于 ready 状态，直接处理这个 Source1 然后跳转去处理消息。</span><br><span class="line">            if (__Source0DidDispatchPortLastTime) &#123;</span><br><span class="line">                Boolean hasMsg &#x3D; __CFRunLoopServiceMachPort(dispatchPort, &amp;msg)</span><br><span class="line">                if (hasMsg) goto handle_msg;</span><br><span class="line">            &#125;</span><br><span class="line">             </span><br><span class="line">            &#x2F;&#x2F;&#x2F; 6.通知 Observers: RunLoop 的线程即将进入休眠(sleep)。</span><br><span class="line">            if (!sourceHandledThisLoop) &#123;</span><br><span class="line">                __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeWaiting);</span><br><span class="line">            &#125;</span><br><span class="line">             </span><br><span class="line">            &#x2F;&#x2F;&#x2F; 7. 调用 mach_msg 等待接受 mach_port 的消息。线程将进入休眠, 直到被下面某一个事件唤醒。</span><br><span class="line">            &#x2F;&#x2F;&#x2F; ? 一个基于 port 的Source 的事件。</span><br><span class="line">            &#x2F;&#x2F;&#x2F; ? 一个 Timer 到时间了</span><br><span class="line">            &#x2F;&#x2F;&#x2F; ? RunLoop 自身的超时时间到了</span><br><span class="line">            &#x2F;&#x2F;&#x2F; ? 被其他什么调用者手动唤醒</span><br><span class="line">            __CFRunLoopServiceMachPort(waitSet, &amp;msg, sizeof(msg_buffer), &amp;livePort) &#123;</span><br><span class="line">                mach_msg(msg, MACH_RCV_MSG, port); &#x2F;&#x2F; thread wait for receive msg</span><br><span class="line">            &#125;</span><br><span class="line">  </span><br><span class="line">            &#x2F;&#x2F;&#x2F; 8. 通知 Observers: RunLoop 的线程刚刚被唤醒了。</span><br><span class="line">            __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopAfterWaiting);</span><br><span class="line">             </span><br><span class="line">            &#x2F;&#x2F;&#x2F; 9.收到消息，处理消息。</span><br><span class="line">            handle_msg:</span><br><span class="line">  </span><br><span class="line">            &#x2F;&#x2F;&#x2F; 10.1 如果一个 Timer 到时间了，触发这个Timer的回调。</span><br><span class="line">            if (msg_is_timer) &#123;</span><br><span class="line">                __CFRunLoopDoTimers(runloop, currentMode, mach_absolute_time())</span><br><span class="line">            &#125; </span><br><span class="line">  </span><br><span class="line">            &#x2F;&#x2F;&#x2F; 10.2 如果有dispatch到main_queue的block，执行block。</span><br><span class="line">            else if (msg_is_dispatch) &#123;</span><br><span class="line">                __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg);</span><br><span class="line">            &#125; </span><br><span class="line">  </span><br><span class="line">            &#x2F;&#x2F;&#x2F; 10.3 如果一个 Source1 (基于port) 发出事件了，处理这个事件</span><br><span class="line">            else &#123;</span><br><span class="line">                CFRunLoopSourceRef source1 &#x3D; __CFRunLoopModeFindSourceForMachPort(runloop, currentMode, livePort);</span><br><span class="line">                sourceHandledThisLoop &#x3D; __CFRunLoopDoSource1(runloop, currentMode, source1, msg);</span><br><span class="line">                if (sourceHandledThisLoop) &#123;</span><br><span class="line">                    mach_msg(reply, MACH_SEND_MSG, reply);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">             </span><br><span class="line">            &#x2F;&#x2F;&#x2F; 执行加入到Loop的block</span><br><span class="line">            __CFRunLoopDoBlocks(runloop, currentMode);</span><br><span class="line">             </span><br><span class="line">  </span><br><span class="line">            if (sourceHandledThisLoop &amp;&amp; stopAfterHandle) &#123;</span><br><span class="line">                &#x2F;&#x2F;&#x2F; 进入loop时参数说处理完事件就返回。</span><br><span class="line">                retVal &#x3D; kCFRunLoopRunHandledSource;</span><br><span class="line">            &#125; else if (timeout) &#123;</span><br><span class="line">                &#x2F;&#x2F;&#x2F; 超出传入参数标记的超时时间了</span><br><span class="line">                retVal &#x3D; kCFRunLoopRunTimedOut;</span><br><span class="line">            &#125; else if (__CFRunLoopIsStopped(runloop)) &#123;</span><br><span class="line">                &#x2F;&#x2F;&#x2F; 被外部调用者强制停止了</span><br><span class="line">                retVal &#x3D; kCFRunLoopRunStopped;</span><br><span class="line">            &#125; else if (__CFRunLoopModeIsEmpty(runloop, currentMode)) &#123;</span><br><span class="line">                &#x2F;&#x2F;&#x2F; source&#x2F;timer&#x2F;observer一个都没有了</span><br><span class="line">                retVal &#x3D; kCFRunLoopRunFinished;</span><br><span class="line">            &#125;</span><br><span class="line">             </span><br><span class="line">            &#x2F;&#x2F;&#x2F; 如果没超时，mode里没空，loop也没被停止，那继续loop。</span><br><span class="line">        &#125; while (retVal &#x3D;&#x3D; 0);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    &#x2F;&#x2F;&#x2F; 11. 通知 Observers: RunLoop 即将退出。</span><br><span class="line">    __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>大概流程是这样的：</p>
<blockquote>
<p>1、函数的主体是一个do,while循环，用一个变量retVal，来控制循环的执行。默认为0，无限循环。<br>2、刚进入循环1，2，3，4，5在做一件事，就是检查是否有事件需要处理，如果有的话，就直接跳到9去处理事件。<br>3、处理完事件之后，到第10，会去判断4种是否应该跳出循环的情况，给变量retVal赋一个不为0的值，来跳出循环。<br>4、如果走到6，则判断没有事做，那么runloop就睡眠了，停在第7行，这一行</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">__CFRunLoopServiceMachPort(waitSet, &amp;msg, <span class="keyword">sizeof</span>(msg_buffer), &amp;livePort)</span><br><span class="line"> &#123; </span><br><span class="line">      <span class="comment">// thread wait for receive msg </span></span><br><span class="line">      mach_msg(msg, MACH_RCV_MSG, port); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">这一行类似sync这样的一个同步机制（其实不是，举个例子。。）</span><br><span class="line">，把程序阻塞在这一行，直到有消息返回值，才继续往下进行。</span><br><span class="line">这一阻塞操作是系统内核来挂起的，阻塞了当前的线程，</span><br><span class="line">当有消息返回时，因为当前线程是被阻塞的，</span><br><span class="line">系统内核会再开辟一个新的线程去返回这个消息。</span><br><span class="line">然后程序继续往下进行。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>5、走到第8、9，通知Observers，然后处理事件。<br>6、到10，去判断是否退出循环的条件，如果满足条件退出循环，runloop结束。反之，又从新开始循环，从2开始。</p>
</blockquote>
<p>那为什么执行完之后RunLoop会退出呢？</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (sourceHandledThisLoop &amp;&amp; stopAfterHandle)</span><br><span class="line">&#123; </span><br><span class="line">    <span class="comment">/// 进入loop时参数说处理完事件就返回。 </span></span><br><span class="line">    retVal = kCFRunLoopRunHandledSource; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种形式开启的runloop, stopAfterHandle这个参数为YES，<br>而sourceHandledThisLoop这个参数在如下代码中被赋值为YES：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 10.3 如果一个 Source1 (基于port) 发出事件了，处理这个事件</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">CFRunLoopSourceRef</span> source1 = __CFRunLoopModeFindSourceForMachPort(runloop, currentMode, livePort);</span><br><span class="line">    sourceHandledThisLoop = __CFRunLoopDoSource1(runloop, currentMode, source1, msg);</span><br><span class="line">    <span class="keyword">if</span> (sourceHandledThisLoop) &#123;</span><br><span class="line">        mach_msg(reply, MACH_SEND_MSG, reply);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>所以在这里我们触发了事件之后，runloop被退出了，这时候我们也明白了为什么timer并不会导致runloop的退出。</p>
<h3 id="Core-Foundation中运行runloop的接口"><a href="#Core-Foundation中运行runloop的接口" class="headerlink" title="Core Foundation中运行runloop的接口"></a>Core Foundation中运行runloop的接口</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;运行 CFRunLoopRef</span><br><span class="line">void CFRunLoopRun();</span><br><span class="line">&#x2F;&#x2F;运行 CFRunLoopRef: 参数为运行模式、时间和是否在处理Input Source后退出标志，返回值是exit原因</span><br><span class="line">SInt32 CFRunLoopRunInMode (mode, seconds, returnAfterSourceHandled);</span><br><span class="line">&#x2F;&#x2F;停止运行 CFRunLoopRef</span><br><span class="line">void CFRunLoopStop( CFRunLoopRef rl );</span><br><span class="line">&#x2F;&#x2F;唤醒 CFRunLoopRef</span><br><span class="line">void CFRunLoopWakeUp ( CFRunLoopRef rl );</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="下面详细介绍一下："><a href="#下面详细介绍一下：" class="headerlink" title="下面详细介绍一下："></a>下面详细介绍一下：</h4><p><code>void CFRunLoopRun();</code></p>
<ul>
<li>运行在默认的kCFRunLoopDefaultMode模式下，直到使用CFRunLoopStop接口停止这个Run Loop，或者Run Loop的所有事件源都被删除。</li>
<li>NSRunloop是基于CFRunloop来封装的，NSRunloop是线程不安全的，而CFRunloop则是线程安全的。</li>
</ul>
<p><code>注意</code>:在这里我们可以看到和上面<code>NSRunloop</code>有一个直观的区别就是，<code>CFRunLoopStop</code>能直接停止掉所有用<code>CFRunloop</code>运行起<code>runloop</code></p>
<p>现在回忆一下上面<br><code>- (BOOL)runMode:(NSString *)mode beforeDate:(NSDate *)limitDate;</code><br>这个方法也是可以用<code>CFRunLoopStop</code>来停止 其实这是因为上面的方法是依据：<br><code>SInt32 CFRunLoopRunInMode (mode, seconds, returnAfterSourceHandled); </code><br>这个方法实现的,可以明显的看出参数是一模一样的,前者默认returnAfterSourceHandled参数为YES，当触发一个非timer事件后，runloop就终止了</p>
<p><code>SInt32 CFRunLoopRunInMode (mode, seconds, returnAfterSourceHandled); </code><br>其中</p>
<ul>
<li>第一个参数是指RunLoop运行的模式（例如kCFRunLoopDefaultMode或者kCFRunLoopCommonModes），</li>
<li>第二个参数是运行时间，第三个参数是是否在处理事件后让Run Loop退出返回，NSRunloop的第三种开启runloop的方法，综上述，我们知道，实际上就是设置stopAfterHandle这个参数为YES</li>
<li>我们知道调用runloop运行，代码是停在这一行不返回的，当返回的时候runloop就结束了，所以这个返回值就是runloop结束原因的返回，为一个枚举值，具体原因如下</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">    kCFRunLoopRunFinished = <span class="number">1</span>, <span class="comment">//Run Loop结束，没有Timer或者其他Input Source</span></span><br><span class="line">    kCFRunLoopRunStopped = <span class="number">2</span>, <span class="comment">//Run Loop被停止，使用CFRunLoopStop停止Run Loop</span></span><br><span class="line">    kCFRunLoopRunTimedOut = <span class="number">3</span>, <span class="comment">//Run Loop超时</span></span><br><span class="line">    kCFRunLoopRunHandledSource = <span class="number">4</span> <span class="comment">////Run Loop处理完事件，注意Timer事件的触发是不会让Run Loop退出返回的，即使CFRunLoopRunInMode的第三个参数是YES也不行</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>看到这，我们发现我们忽略了NSRunloop第三种开启方式的返回值。<br><code>- (BOOL)runMode:(NSString *)mode beforeDate:(NSDate *)limitDate;</code></p>
<p>它其实就是基于<code>CFRunLoopRunInMode</code>封装的，它的返回值为一个Bool值，如果是<code>PerfromSelector***</code>事件或者其他<code>Input Source</code>事件触发处理后，<code>RunLoop</code>会退出返回YES，其他返回NO。</p>
<p>下面举个例子来验证这个问题：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)testDemo2</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;starting thread.......&quot;</span>);</span><br><span class="line">        <span class="built_in">NSTimer</span> *timer = [<span class="built_in">NSTimer</span> timerWithTimeInterval:<span class="number">1</span> target:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(doTimerTask1:) userInfo:remotePort repeats:<span class="literal">YES</span>];</span><br><span class="line">        [[<span class="built_in">NSRunLoop</span> currentRunLoop] addTimer:timer forMode:<span class="built_in">NSDefaultRunLoopMode</span>];</span><br><span class="line">            </span><br><span class="line">        <span class="comment">//最后一个参数，是否处理完事件返回,结束runLoop</span></span><br><span class="line">        SInt32 result = <span class="built_in">CFRunLoopRunInMode</span>(kCFRunLoopDefaultMode, <span class="number">100</span>, <span class="literal">YES</span>);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         kCFRunLoopRunFinished = 1, //Run Loop结束，没有Timer或者其他Input Source</span></span><br><span class="line"><span class="comment">         kCFRunLoopRunStopped = 2, //Run Loop被停止，使用CFRunLoopStop停止Run Loop</span></span><br><span class="line"><span class="comment">         kCFRunLoopRunTimedOut = 3, //Run Loop超时</span></span><br><span class="line"><span class="comment">         kCFRunLoopRunHandledSource = 4 ////Run Loop处理完事件，注意Timer事件的触发是不会让Run Loop退出返回的，即使CFRunLoopRunInMode的第三个参数是YES也不行</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">switch</span> (result) &#123;</span><br><span class="line">            <span class="keyword">case</span> kCFRunLoopRunFinished:</span><br><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@&quot;kCFRunLoopRunFinished&quot;</span>);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> kCFRunLoopRunStopped:</span><br><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@&quot;kCFRunLoopRunStopped&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> kCFRunLoopRunTimedOut:</span><br><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@&quot;kCFRunLoopRunTimedOut&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> kCFRunLoopRunHandledSource:</span><br><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@&quot;kCFRunLoopRunHandledSource&quot;</span>);</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;end thread.......&quot;</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)doTimerTask1:(<span class="built_in">NSTimer</span> *)timer</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    count++;</span><br><span class="line">    <span class="keyword">if</span> (count == <span class="number">2</span>) &#123;</span><br><span class="line">        [timer invalidate];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;do timer task count:%d&quot;</span>,count);</span><br></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2016-11-23 09:19:28.342 TestRunloop3[88598:1971412] starting thread.......</span><br><span class="line">2016-11-23 09:19:29.347 TestRunloop3[88598:1971412] do timer task count:1</span><br><span class="line">2016-11-23 09:19:30.345 TestRunloop3[88598:1971412] do timer task count:2</span><br><span class="line">2016-11-23 09:19:30.348 TestRunloop3[88598:1971412] kCFRunLoopRunFinished</span><br><span class="line">2016-11-23 09:19:30.348 TestRunloop3[88598:1971412] end thread.......</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>很清楚的可以看到，当timer被置无效的时候，runloop里面没有了任何的事件源，所以退出了，退出原因为：kCFRunLoopRunFinished，线程也就结束了。</code></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="RunLoop停止和取消的方法"><a href="#RunLoop停止和取消的方法" class="headerlink" title="RunLoop停止和取消的方法"></a>RunLoop停止和取消的方法</h3><blockquote>
<p>1、移除掉runloop中的所有事件源（timer和source）<br>2、设置一个超时时间。<br>3、只要CFRunloop运行起来就可以用：<br>    <code>void CFRunLoopStop( CFRunLoopRef rl );</code>去停止。<br>4、除此之外用NSRunLoop下面这个方法运行也能使用<br>     <code>void CFRunLoopStop( CFRunLoopRef rl );</code>停止：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[NSRunLoop currentRunLoop]runMode:&lt;#(nonnull</span><br><span class="line"> NSRunLoopMode)#&gt; beforeDate:&lt;#(nonnull NSDate *)#&gt;</span><br></pre></td></tr></table></figure>

<p>实际过程中，可以根据需求，我们可以设置一个自己的Bool值，<br>  来控制runloop的开始与停止,类似下面这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  while (!cancel) &#123;</span><br><span class="line">CFRunLoopRunInMode(kCFRunLoopDefaultMode, 1, YES);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>每次runloop只运行1秒就停止，然后开始下一次的runloop。</li>
<li>这里最后一个参数设置为YES，当有非timer事件进来，也会立即开始下一次runloop。</li>
<li>当然每次进来我们都可以去修改Mode的值，这样我们可以让runloop每次都运行在不同的模式下。</li>
<li>当我们不需要runloop的时候，直接将cancel置为YES即可</li>
</ul>
<h2 id="基于runloop的线程通信"><a href="#基于runloop的线程通信" class="headerlink" title="基于runloop的线程通信"></a>基于runloop的线程通信</h2><p>首先明确一个概念，线程间的通信（不仅限于通信，几乎所有iOS事件都是如此），实际上是各种输入源，触发runloop去处理对应的事件，所以我们先来讲讲输入源：</p>
<p>输入源异步的发送消息给你的线程。事件来源取决于输入源的种类：</p>
<ul>
<li>基于端口的输入源和自定义输入源。基于端口的输入源监听程序相应的端口。自定义输入源则监听自定义的事件源。</li>
</ul>
<p>至于run loop，它不关心输入源的是基于端口的输入源还是自定义的输入源。系统会实现两种输入源供你使用。两类输入源的区别在于：</p>
<ul>
<li>基于端口的输入源由内核自动发送，而自定义的则需要人工从其他线程发送。</li>
</ul>
<p>当你创建输入源，你需要将其分配给<code>RunLoop</code>中的一个或多个模式。模式只会在特定事件影响监听的源。大多数情况下，<code>RunLoop</code>运行在默认模式下，但是你也可以使其运行在自定义模式。若某一源在当前模式下不被监听，那么任何其生成的消息只在<code>RunLoop</code>运行在其关联的模式下才会被传递。</p>
<h3 id="基于端口的输入源"><a href="#基于端口的输入源" class="headerlink" title="基于端口的输入源:"></a>基于端口的输入源:</h3><p>在<code>RunLoop</code>中，被定义名为<code>souce1</code>。Cocoa和Core Foundation内置支持使用端口相关的对象和函数来创建的基于端口的源。例如，在Cocoa里面你从来不需要直接创建输入源。你只要简单的创建端口对象，并使用<code>NSPort</code>的方法把该端口添加到<code>Run Loop</code>。端口对象会自己处理创建和配置输入源。</p>
<p>在Core Foundation，你必须人工创建端口和它的<code>RunLoop</code>源.在两种情况下，你都可以使用端口相关的函数（CFMachPortRef，CFMessagePortRef，CFSocketRef）来创建合适的对象。</p>
<p>这里用Cocoa里的举个例子，Cocoa里用来线程间传值的是NSMachPort，它的父类是NSPort。<br>首先我们看下面：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSPort *port1 &#x3D; [[NSPort alloc]init];</span><br><span class="line">NSPort *port2 &#x3D; [[NSMachPort alloc]init];</span><br><span class="line">NSPort *port3 &#x3D; [NSPort port];</span><br><span class="line">NSPort *port4 &#x3D; [NSMachPort port];</span><br></pre></td></tr></table></figure>
<p>我们打断点可以看到如下：<br><img src="http://upload-images.jianshu.io/upload_images/2702646-6364a8544aa941b3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="port图.png"></p>
<ul>
<li>发现我们怎么创建，都返回给我们的是NSMachPort的实例，这应该是NSPort内部做了一个消息的转发，这就有点像是一个抽象类了，它本身只是定义一些公有的属性和方法，然后利用集成它的子类去实现（只是我个人猜测。。）</li>
</ul>
<p>继续看我们写的一个利用NSMachPort来线程通信的实例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(void)testDemo3</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;&#x2F;声明两个端口 随便怎么写创建方法，返回的总是一个NSMachPort实例</span><br><span class="line">NSMachPort *mainPort &#x3D; [[NSMachPort alloc]init];</span><br><span class="line">NSPort *threadPort &#x3D; [NSMachPort port];</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;设置线程的端口的代理回调为自己</span><br><span class="line">threadPort.delegate &#x3D; self;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;给主线程runloop加一个端口</span><br><span class="line">[[NSRunLoop currentRunLoop]addPort:mainPort forMode:NSDefaultRunLoopMode];</span><br><span class="line"></span><br><span class="line">dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;添加一个Port</span><br><span class="line">  [[NSRunLoop currentRunLoop]addPort:threadPort forMode:NSDefaultRunLoopMode];</span><br><span class="line">  [[NSRunLoop currentRunLoop]runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]];</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">NSString *s1 &#x3D; @&quot;hello&quot;;</span><br><span class="line"></span><br><span class="line">NSData *data &#x3D; [s1 dataUsingEncoding:NSUTF8StringEncoding];</span><br><span class="line"></span><br><span class="line">dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">NSMutableArray *array &#x3D; [NSMutableArray arrayWithArray:@[mainPort,data]];</span><br><span class="line">&#x2F;&#x2F;过2秒向threadPort发送一条消息，第一个参数：发送时间。msgid 消息标识。</span><br><span class="line">&#x2F;&#x2F;components，发送消息附带参数。reserved：为头部预留的字节数（从官方文档上看到的，猜测可能是类似请求头的东西...）</span><br><span class="line">[threadPort sendBeforeDate:[NSDate date] msgid:1000 components:array from:mainPort reserved:0];</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个NSMachPort收到消息的回调，注意这个参数，可以先给一个id。如果用文档里的NSPortMessage会发现无法取值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(void)handlePortMessage:(id)message</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;收到消息了，线程为：%@&quot;,[NSThread currentThread]);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;只能用KVC的方式取值</span><br><span class="line">NSArray *array &#x3D; [message valueForKeyPath:@&quot;components&quot;];</span><br><span class="line"></span><br><span class="line">NSData *data &#x3D; array[1];</span><br><span class="line">NSString *s1 &#x3D; [[NSString alloc]initWithData:data encoding:NSUTF8StringEncoding];</span><br><span class="line">NSLog(@&quot;%@&quot;,s1);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; NSMachPort *localPort &#x3D; [message valueForKeyPath:@&quot;localPort&quot;];</span><br><span class="line">&#x2F;&#x2F; NSMachPort *remotePort &#x3D; [message valueForKeyPath:@&quot;remotePort&quot;];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>结果打印如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2016-11-23 16:50:20.604 TestRunloop3[1322:120162] 收到消息了，线程为：&lt;NSThread: 0x60800026d700&gt;&#123;number &#x3D; 3, name &#x3D; (null)&#125;</span><br><span class="line">2016-11-23 16:50:26.551 TestRunloop3[1322:120162] hello</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p>1、我们跨越线程，确实从主线程往另一个线程发送了消息。</p>
</li>
<li><p>2、这里要注意几个点：</p>
<blockquote>
<p>1、<code>- (void)handlePortMessage:(id)message</code>这里这个代理的参数，从.h里去复制过来的为NSPortMessage类型的一个对象，但是我们发现苹果只是在.h中@class进来，我们无法调用它的任何方法。所以我们用id声明，然后通过KVC去取它的属性。</p>
</blockquote>
<blockquote>
<p>2、关于下面这个传值类型的问题：</p>
</blockquote>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSMutableArray *array &#x3D; [NSMutableArray  </span><br><span class="line">arrayWithArray:@[mainPort,data]];</span><br></pre></td></tr></table></figure>


</li>
</ul>
<p>作者在这困惑了好一会。。之前我是往数组里添加的是String或者其他类型的对象，但是发现参数传过去之后，变成nil了。于是去百度查了半天，然后没有结果。。于是去翻官方文档，终于在方法描述里看到（其实很醒目。。然而作者英文水平实在有限。。）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">The components array consists of a series of instances of some subclass of NSData, </span><br><span class="line">and instances of some subclass of NSPort; </span><br><span class="line">since one subclass of NSPort does not necessarily know  how to transport an instance of another subclass of NSPort (or could do it even if it</span><br><span class="line"></span><br><span class="line">knew about the other subclass), all of the instancesof NSPort in the components array and the</span><br><span class="line"> &#39;receivePort&#39;argument MUST be of the same subclass of NSPort that receives this message.  If </span><br><span class="line"> multiple DO transports are being used in the same program, this requires some care.</span><br></pre></td></tr></table></figure>

<p>  从这段描述中我们可以看出，<strong>这个传参数组里面只能装两种类型的数据，一种是NSPort的子类，一种是NSData的子类。</strong>所以我们如果要用这种方式传值必须得先把数据转成NSData类型的才行。</p>
<h3 id="Cocoa-执行-Selector-的源"><a href="#Cocoa-执行-Selector-的源" class="headerlink" title="Cocoa 执行 Selector 的源:"></a>Cocoa 执行 Selector 的源:</h3><p>  除了基于端口的源，Cocoa定义了自定义输入源，允许你在任何线程执行selector。它被称为source0,和基于端口的源一样，执行selector请求会在目标线程上序列化，减缓许多在线程上允许多个方法容易引起的同步问题。不像基于端口的源，一个selector执行完后会自动从run loop里面移除。</p>
<p>有方法如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[self performSelectorOnMainThread:&lt;#(nonnull SEL)#&gt; withObject:&lt;#(nullable id)#&gt; waitUntilDone:&lt;#(BOOL)#&gt;]</span><br><span class="line"></span><br><span class="line">[self performSelectorOnMainThread:&lt;#(nonnull SEL)#&gt; withObject:&lt;#(nullable id)#&gt; waitUntilDone:&lt;#(BOOL)#&gt; modes:&lt;#(nullable NSArray&lt;NSString *&gt; *)#&gt;]</span><br><span class="line"></span><br><span class="line">[self performSelector:&lt;#(nonnull SEL)#&gt; onThread:&lt;#(nonnull NSThread *)#&gt; withObject:&lt;#(nullable id)#&gt; waitUntilDone:&lt;#(BOOL)#&gt;]</span><br><span class="line"></span><br><span class="line">[self performSelector:&lt;#(nonnull SEL)#&gt; onThread:&lt;#(nonnull NSThread *)#&gt; withObject:&lt;#(nullable id)#&gt; waitUntilDone:&lt;#(BOOL)#&gt; modes:&lt;#(nullable NSArray&lt;NSString *&gt; *)#&gt;]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>这四个方法很类似，一个是在主线程去掉，一个可以指定一个线程。然后一个带Mode，一个不带。</li>
<li>大概讲一下 waitUntilDone 这个参数，顾名思义，就是是否等到结束。<br>1）如果这个值设为YES，那么就需要等到这个方法执行完，线程才能继续往下去执行。它会阻塞提交的线程。<br>2）如果为NO的话，这个调用的方法会异步的实行，不会阻塞提交线程。</li>
</ul>
<h3 id="自定义输入源"><a href="#自定义输入源" class="headerlink" title="自定义输入源:"></a>自定义输入源:</h3><p> 为了自定义输入源，必须使用 Core Foundation里面的 CGRunLoopSourceRef类型相关的函数来创建。你可以使用回调函数来配置自定义输入源。Corefondation 会在配置源的不同地方调用回调函数，处理输入时间，在源从 runloop 移除的时候清理它。<br>除了定义在事件到达时自定义输入源的行为，你也必须定义消息传递机制。源的这部分运行在单独的线程里面，并负责在数据等待处理的时候传递数据给源并源并通知它处理数据。消息传递机制的定义取决于你，但是最好不要过于复杂。<br>创建自定义的输入源包括定义以下内容：<br>1.输入源要处理的信息。<br>2.使感兴趣的客户端知道如何和输入源交互的调度例程。<br>3.处理其他任何客户端发送请求的例程。<br>4.使输入源失效的取消例程。</p>
<p>由于创建输入源来处理自定义消息，实际配置选是灵活配置的。调度<br>例程，处理例程和取消例程都是创建自定义输入源是最关键的例程。<br>二输入源其他的大部分行为都发生在这些例程的外部。比如，由于你决定数据传输到输入源的机制，还有输入源和其他线程的通信机制也<br>是由你决定。</p>
<p>下图中，程序的主线程维护了一个输入源的引用，输入源所需的自定义命令缓冲区和输入源所在的 runloop。当主线程有任务需要分发<br>给工作线程时候，**<em>主线程会给命令缓冲区发送命令和必须的信息来通知工作线程开始执行任务。（因为主线程和输入源所在工作线程<br>都可以访问命令缓冲区，因此这些访问必须是同步的）**</em>一旦命令<br>传送出去，主线程会通知输入源并且唤醒工作线程的 runloop。而一收到唤醒命令，runloop 会调用输入源的处理程序，由它来执行<br>命令缓冲区中响应的命令。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CFRunLoopRef _runLoopRef;</span><br><span class="line">CFRunLoopSourceRef _source;</span><br><span class="line">CFRunLoopSourceContext _source_context;</span><br></pre></td></tr></table></figure>

<p><img src="http://upload-images.jianshu.io/upload_images/2702646-532788b8b08ec601.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="自定义输入源.png"></p>
<p>还是一样，我们来写一个实例来讲讲自定义的输入源（注：自定义输入源，只有用CF来实现）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CFRunLoopRef _runLoopRef;</span><br><span class="line">CFRunLoopSourceRef _source;</span><br><span class="line">CFRunLoopSourceContext _source_context;</span><br></pre></td></tr></table></figure>
<p>首先我们声明3个成员变量，这是我们自定义输入源所需要的3个参数。具体我们举完例子之后再说。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(void)testDemo4</span><br><span class="line">&#123;</span><br><span class="line">dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;</span><br><span class="line"></span><br><span class="line">  NSLog(@&quot;starting thread.......&quot;);</span><br><span class="line">  </span><br><span class="line">  _runLoopRef &#x3D; CFRunLoopGetCurrent();</span><br><span class="line">  &#x2F;&#x2F;初始化_source_context。</span><br><span class="line">  bzero(&amp;_source_context, sizeof(_source_context));</span><br><span class="line">  &#x2F;&#x2F;这里创建了一个基于事件的源，绑定了一个函数</span><br><span class="line">  _source_context.perform &#x3D; fire;</span><br><span class="line">  &#x2F;&#x2F;参数</span><br><span class="line">  _source_context.info &#x3D; &quot;hello&quot;;</span><br><span class="line">  &#x2F;&#x2F;创建一个source</span><br><span class="line">  _source &#x3D; CFRunLoopSourceCreate(NULL, 0, &amp;_source_context);</span><br><span class="line">  &#x2F;&#x2F;将source添加到当前RunLoop中去</span><br><span class="line">  CFRunLoopAddSource(_runLoopRef, _source, kCFRunLoopDefaultMode);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;开启runloop 第三个参数设置为YES，执行完一次事件后返回</span><br><span class="line">  CFRunLoopRunInMode(kCFRunLoopDefaultMode, 9999999, YES);</span><br><span class="line">  </span><br><span class="line">  NSLog(@&quot;end thread.......&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">    </span><br><span class="line">    if (CFRunLoopIsWaiting(_runLoopRef)) &#123;</span><br><span class="line">        NSLog(@&quot;RunLoop 正在等待事件输入&quot;);</span><br><span class="line">        &#x2F;&#x2F;添加输入事件</span><br><span class="line">        CFRunLoopSourceSignal(_source);</span><br><span class="line">        &#x2F;&#x2F;唤醒线程，线程唤醒后发现由事件需要处理，于是立即处理事件</span><br><span class="line">        CFRunLoopWakeUp(_runLoopRef);</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        NSLog(@&quot;RunLoop 正在处理事件&quot;);</span><br><span class="line">        &#x2F;&#x2F;添加输入事件，当前正在处理一个事件，当前事件处理完成后，立即处理当前新输入的事件</span><br><span class="line">        CFRunLoopSourceSignal(_source);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>此输入源需要处理的后台事件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static void fire(void* info)&#123;</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;我现在正在处理后台任务&quot;);</span><br><span class="line"></span><br><span class="line">printf(&quot;%s&quot;,info);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2016-11-24 10:42:24.045 TestRunloop3[4683:238183] starting thread.......</span><br><span class="line">2016-11-24 10:42:26.045 TestRunloop3[4683:238082] RunLoop 正在等待事件输入</span><br><span class="line">2016-11-24 10:42:31.663 TestRunloop3[4683:238183] 我现在正在处理后台任务</span><br><span class="line">hello</span><br><span class="line">2016-11-24 10:42:31.663 TestRunloop3[4683:238183] end thread.......</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>例中可见我们创建一个自定义的输入源，绑定了一个函数，一个参数，并且用这个输入源，实现了线程间的通信。</p>
<p>大概讲一下：</p>
<blockquote>
<p>1、<code>CFRunLoopRef _runLoopRef;</code>就不用说了，就是CF的runloop。</p>
</blockquote>
<blockquote>
<p>2、<code>CFRunLoopSourceContext _source_context;</code>注意到例中用了一个c函数<code>bzero(&amp;_source_context, sizeof(_source_context));</code>来初始化。</p>
</blockquote>
<p>其实它本质是一个结构体如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;version</span><br><span class="line">Version number of the structure. Must be 0.</span><br><span class="line">info</span><br><span class="line">An arbitrary pointer to program-defined data, which can be associated with the CFRunLoopSource</span><br><span class="line"> at creation time. This pointer is passed to all the callbacks defined in the context.</span><br><span class="line">retain</span><br><span class="line">A retain callback for your program-defined info </span><br><span class="line">pointer. Can be NULL.</span><br><span class="line">release</span><br><span class="line">A release callback for your program-defined info </span><br><span class="line">pointer. Can be NULL.</span><br><span class="line">copyDescription</span><br><span class="line">A copy description callback for your program-</span><br><span class="line">defined info pointer. Can be NULL.</span><br><span class="line">equal</span><br><span class="line">An equality test callback for your program-defined </span><br><span class="line">info pointer. Can be NULL.</span><br><span class="line">hash</span><br><span class="line">A hash calculation callback for your program-</span><br><span class="line">defined info pointer. Can be NULL.</span><br><span class="line">schedule</span><br><span class="line">A scheduling callback for the run loop source. </span><br><span class="line">This callback is called when the source is added to a run loop mode. Can be NULL.</span><br><span class="line">cancel</span><br><span class="line">A cancel callback for the run loop source. This </span><br><span class="line">callback is called when the source is removed from a run loop mode. Can be NULL.</span><br><span class="line">perform</span><br><span class="line">A perform callback for the run loop source. This </span><br><span class="line">callback is called when the source has fired.</span><br><span class="line"></span><br><span class="line">typedef struct &#123;</span><br><span class="line">CFIndex version;</span><br><span class="line">void * info;</span><br><span class="line">const void (retain)(const void info);</span><br><span class="line">void (release)(const void info);</span><br><span class="line">CFStringRef (copyDescription)(const void info);</span><br><span class="line">Boolean (equal)(const void *info1, const void info2);</span><br><span class="line">CFHashCode (hash)(const void info);</span><br><span class="line">void (schedule)(void info, CFRunLoopRef rl, CFRunLoopMode mode);</span><br><span class="line">void (cancel)(void info, CFRunLoopRef rl, CFRunLoopMode mode);</span><br><span class="line">void (perform)(void *info);</span><br><span class="line">&#125; CFRunLoopSourceContext;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p> <code>bzero(&amp;_source_context, sizeof(_source_context));</code>所以这个函数其实就是把所有内容先置为0。</p>
<p><code>CFRunLoopSourceRef _source;</code>这个是自定义输入源中最重要的一个参数。它用来连接runloop与<br>CFRunLoopSourceContext中的一些配置项，<strong>注意我们自定义的输入源，必须由我们手动来触发</strong>。需要先<br><code>CFRunLoopSourceSignal(_source);</code>在看当前runloop是否在休眠中，来看是否需要调用<br><code>CFRunLoopWakeUp(_runLoopRef);</code>(一般都是要调用的)。</p>
<h3 id="定时源"><a href="#定时源" class="headerlink" title="定时源:"></a>定时源:</h3><ul>
<li>定时源在预设的时间点同步方式传递消息。定时器是线程通知自己做某事的一种方法。</li>
<li>尽管定时器可以产生基于时间的通知，但它并不是实时机制。和输入源一样，定时器也和 runloop 的特定模式相关。如果定时器所在的模式当前未被 runloop 监视，那么定时器将不会开始知道 runloop 运行在响应的模式下。类似的。如果定时器在 runloop 处理某一事件期间开始，定时器会一直等待直到下次 runloop 开始响应的处理程序。如果 runloop 不运行了，那么定时器也永远不启动。</li>
<li>配置定时源:<br>Cocoa 中可以使用以下 NSTimer 类方法来创建并调配一个定时器:􏰂</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[NSTimer scheduledTimerWithTimeInterval:&lt;#(NSTimeInterval)#&gt; target:&lt;#(nonnull id)#&gt; selector:&lt;#(nonnull SEL)#&gt; userInfo:&lt;#(nullable id)#&gt; repeats:&lt;#(BOOL)#&gt;</span><br><span class="line"></span><br><span class="line">[NSTimer timerWithTimeInterval:&lt;#(NSTimeInterval)#&gt; target:&lt;#(nonnull id)#&gt; selector:&lt;#(nonnull SEL)#&gt; userInfo:&lt;#(nullable id)#&gt; repeats:&lt;#(BOOL)#&gt;]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当然还有Block ,invocation的形式，就不做赘述了。<br>第一种timer默认是把加到了NSDefaultRunLoopMode模式下。<br>第二种timer没有默认值，我们使用的使用必须调用<br><code>[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSDefaultRunLoopMode];</code>去给它指定一个mode。</p>
<h3 id="Core-Foundation-创建定时器"><a href="#Core-Foundation-创建定时器" class="headerlink" title="Core Foundation 创建定时器"></a>Core Foundation 创建定时器</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CFRunLoopRef runLoop &#x3D; CFRunLoopGetCurrent();</span><br><span class="line">CFRunLoopTimerContext context &#x3D; &#123;0, NULL, NULL, NULL, NULL&#125;;</span><br><span class="line">CFRunLoopTimerRef timer &#x3D; CFRunLoopTimerCreate(kCFAllocatorDefault, 0.1, 0.3, 0, 0,</span><br><span class="line">&amp;myCFTimerCallback, &amp;context);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>最后用一张runloop运行时的流程图来梳理一下我们这些源触发的顺序<br><img src="http://upload-images.jianshu.io/upload_images/2702646-60d6d86082e68ce0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="RunLoop_1.png"></p>
<p>如图所示，首先我要明确一个知识点：<strong>runloop跑一圈，只能执行一个事件。</strong></p>
<p><strong>timer和source0进入runloop中，都只是通知Observer我要处理，但是还是会有 678睡眠唤醒这一步。但是source1如果有，就会直接跳到第9步去执行。</strong></p>
<p>我们前面也讲过第7步，这里再提一下。它是一直阻塞在这一行的，直到：</p>
<ul>
<li><p>a.soruce1来了。</p>
</li>
<li><p>b.定时器启动。 </p>
</li>
<li><p>c.runloop超时。</p>
</li>
<li><p>d.runloop被显示唤醒CFRunLoopWakeUp(runloop) (也就是source0来了)。</p>
<p>这里可能大家会奇怪了，之前不是说source1有的话就直接跳到第9步去执行了么？但是仔细想想，如果runloop正处在睡眠状态下，这时候有个soruce1来了，是不是也需要唤醒runloop~</p>
</li>
</ul>
<h3 id="Run-Loop的Observer"><a href="#Run-Loop的Observer" class="headerlink" title="Run Loop的Observer"></a>Run Loop的Observer</h3><p>上图提到了Observer，顺带简单讲讲吧：<br>Core Foundation层的接口可以定义一个Run Loop的观察者在— Run Loop进入以下某个状态时得到通知：</p>
<ul>
<li>Run loop的进入</li>
<li>Run loop处理一个Timer的时刻</li>
<li>Run loop处理一个Input Source的时刻</li>
<li>Run loop进入睡眠的时刻</li>
<li>Run loop被唤醒的时刻，但在唤醒它的事件被处理之前</li>
<li>Run loop的终止</li>
<li>Observer的创建以及添加到Run Loop中需要使用Core Foundation的接口：<br>方法很简单如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 创建observer</span><br><span class="line">CFRunLoopObserverRef observer &#x3D; CFRunLoopObserverCreateWithHandler(CFAllocatorGetDefault(), kCFRunLoopAllActivities, YES, 0, ^(CFRunLoopObserverRef observer, CFRunLoopActivity activity) &#123;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 添加观察者：监听RunLoop的状态</span><br><span class="line">CFRunLoopAddObserver(CFRunLoopGetCurrent(), observer, kCFRunLoopDefaultMode);</span><br><span class="line">&#x2F;&#x2F; 释放Observer</span><br><span class="line">CFRelease(observer);</span><br></pre></td></tr></table></figure>

<p> 方法就是创建一个observer，绑定一个runloop和模式，而block回调就是监听到runloop每种状态的时候会触发。</p>
<p>  其中<code>CFRunLoopActivity</code>是一枚举值，与每种状态对应：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123;</span><br><span class="line">kCFRunLoopEntry &#x3D; (1UL &lt;&lt; 0), &#x2F;&#x2F; 1 &#x2F;&#x2F; 即将进入Loop</span><br><span class="line">kCFRunLoopBeforeTimers &#x3D; (1UL &lt;&lt; 1), &#x2F;&#x2F; 2 &#x2F;&#x2F; 即将处理 Timer</span><br><span class="line">kCFRunLoopBeforeSources &#x3D; (1UL &lt;&lt; 2), &#x2F;&#x2F; 4 即将处理 Source</span><br><span class="line">kCFRunLoopBeforeWaiting &#x3D; (1UL &lt;&lt; 5), &#x2F;&#x2F; 32 &#x2F;&#x2F; 即将进入休眠</span><br><span class="line">kCFRunLoopAfterWaiting &#x3D; (1UL &lt;&lt; 6), &#x2F;&#x2F; 64</span><br><span class="line">&#x2F;&#x2F; 刚从休眠中唤醒</span><br><span class="line">kCFRunLoopExit &#x3D; (1UL &lt;&lt; 7), &#x2F;&#x2F; 128 &#x2F;&#x2F; 即将退出Loop</span><br><span class="line">kCFRunLoopAllActivities &#x3D; 0x0FFFFFFFU &#x2F;&#x2F; 可以监听以上所有状态</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="RunLoop-与线程的关系"><a href="#RunLoop-与线程的关系" class="headerlink" title="RunLoop 与线程的关系"></a>RunLoop 与线程的关系</h2><p>iOS 开发中能遇到两个线程对象: pthread_t 和 NSThread,过去苹果有份文档标明了 NSThread 只是 pthread_t 的封装，但那份文档已经失效了，现在它们也有可能都是直接包装自最底层的 mach thread。</p>
<p>苹果并没有提供这两个对象相互转换的接口，但不管怎么样，可以肯定的是 pthread_t 和 NSThread 是一一对应的。比如，你可以通过 pthread_main_thread_np() 或 [NSThread mainThread] 来获取主线程；也可以通过 pthread_self() 或 [NSThread currentThread] 来获取当前线程。CFRunLoop 是基于 pthread 来管理的。</p>
<p>苹果不允许直接创建 RunLoop，它只提供了两个自动获取的函数：CFRunLoopGetMain() 和 CFRunLoopGetCurrent()。 这两个函数内部的逻辑大概是下面这样:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; 全局的Dictionary，key 是 pthread_t， value 是 CFRunLoopRef</span><br><span class="line">static CFMutableDictionaryRef loopsDic;</span><br><span class="line">&#x2F;&#x2F;&#x2F; 访问 loopsDic 时的锁</span><br><span class="line">static CFSpinLock_t loopsLock;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;&#x2F; 获取一个 pthread 对应的 RunLoop。</span><br><span class="line">CFRunLoopRef _CFRunLoopGet(pthread_t thread) &#123;</span><br><span class="line">    OSSpinLockLock(&amp;loopsLock);</span><br><span class="line">    </span><br><span class="line">    if (!loopsDic) &#123;</span><br><span class="line">        &#x2F;&#x2F; 第一次进入时，初始化全局Dic，并先为主线程创建一个 RunLoop。</span><br><span class="line">        loopsDic &#x3D; CFDictionaryCreateMutable();</span><br><span class="line">        CFRunLoopRef mainLoop &#x3D; _CFRunLoopCreate();</span><br><span class="line">        CFDictionarySetValue(loopsDic, pthread_main_thread_np(), mainLoop);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;&#x2F; 直接从 Dictionary 里获取。</span><br><span class="line">    CFRunLoopRef loop &#x3D; CFDictionaryGetValue(loopsDic, thread));</span><br><span class="line">    </span><br><span class="line">    if (!loop) &#123;</span><br><span class="line">        &#x2F;&#x2F;&#x2F; 取不到时，创建一个</span><br><span class="line">        loop &#x3D; _CFRunLoopCreate();</span><br><span class="line">        CFDictionarySetValue(loopsDic, thread, loop);</span><br><span class="line">        &#x2F;&#x2F;&#x2F; 注册一个回调，当线程销毁时，顺便也销毁其对应的 RunLoop。</span><br><span class="line">        _CFSetTSD(..., thread, loop, __CFFinalizeRunLoop);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    OSSpinLockUnLock(&amp;loopsLock);</span><br><span class="line">    return loop;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">CFRunLoopRef CFRunLoopGetMain() &#123;</span><br><span class="line">    return _CFRunLoopGet(pthread_main_thread_np());</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">CFRunLoopRef CFRunLoopGetCurrent() &#123;</span><br><span class="line">    return _CFRunLoopGet(pthread_self());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的代码可以看出，线程和 RunLoop 之间是一一对应的，其关系是保存在一个全局的 Dictionary 里。线程刚创建时并没有 RunLoop，如果你不主动获取，那它一直都不会有。RunLoop 的创建是发生在第一次获取时，RunLoop 的销毁是发生在线程结束时。你只能在一个线程的内部获取其 RunLoop（<code>主线程除外</code>）。</p>
<h2 id="RunLoop-对外的接口"><a href="#RunLoop-对外的接口" class="headerlink" title="RunLoop 对外的接口"></a>RunLoop 对外的接口</h2><p>在 CoreFoundation 里面关于 RunLoop 有5个类:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CFRunLoopRef</span><br><span class="line">CFRunLoopModeRef</span><br><span class="line">CFRunLoopSourceRef</span><br><span class="line">CFRunLoopTimerRef</span><br><span class="line">CFRunLoopObserverRef</span><br></pre></td></tr></table></figure>

<p>其中 CFRunLoopModeRef 类并没有对外暴露，只是通过 CFRunLoopRef 的接口进行了封装。他们的关系如下:<br><img src="https://blog.ibireme.com/wp-content/uploads/2015/05/RunLoop_0.png"></p>
<p>一个 RunLoop 包含若干个 Mode，每个 Mode 又包含若干个 Source/Timer/Observer。每次调用 RunLoop 的主函数时，只能指定其中一个 Mode，这个Mode被称作 CurrentMode。如果需要切换 Mode，只能退出 Loop，再重新指定一个 Mode 进入。这样做主要是为了分隔开不同组的 Source/Timer/Observer，让其互不影响。</p>
<p><code>CFRunLoopSourceRef</code> 是事件产生的地方。Source有两个版本：<code>Source0</code> 和 <code>Source1</code>。</p>
<blockquote>
<p>Source0 只包含了一个回调（函数指针），它并不能主动触发事件。使用时，你需要先调用 <code>CFRunLoopSourceSignal(source)</code>，将这个 Source 标记为待处理，然后手动调用 <code>CFRunLoopWakeUp(runloop)</code> 来唤醒 RunLoop，让其处理这个事件。<br>Source1 包含了一个 <code>mach_port</code> 和一个回调（函数指针），被用于通过内核和其他线程相互发送消息。这种 Source 能主动唤醒 RunLoop 的线程，其原理在下面会讲到。</p>
</blockquote>
<p><code>CFRunLoopTimerRef</code> 是基于时间的触发器，它和 NSTimer 是<code>toll-free bridged</code> 的，可以混用。其包含一个时间长度和一个回调（函数指针）。当其加入到 RunLoop 时，RunLoop会注册对应的时间点，当时间点到时，RunLoop会被唤醒以执行那个回调。</p>
<p><code>CFRunLoopObserverRef</code> 是观察者，每个 Observer 都包含了一个回调（函数指针），当 RunLoop 的状态发生变化时，观察者就能通过回调接受到这个变化。可以观测的时间点有以下几个：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123;</span><br><span class="line">    kCFRunLoopEntry         &#x3D; (1UL &lt;&lt; 0), &#x2F;&#x2F; 即将进入Loop</span><br><span class="line">    kCFRunLoopBeforeTimers  &#x3D; (1UL &lt;&lt; 1), &#x2F;&#x2F; 即将处理 Timer</span><br><span class="line">    kCFRunLoopBeforeSources &#x3D; (1UL &lt;&lt; 2), &#x2F;&#x2F; 即将处理 Source</span><br><span class="line">    kCFRunLoopBeforeWaiting &#x3D; (1UL &lt;&lt; 5), &#x2F;&#x2F; 即将进入休眠</span><br><span class="line">    kCFRunLoopAfterWaiting  &#x3D; (1UL &lt;&lt; 6), &#x2F;&#x2F; 刚从休眠中唤醒</span><br><span class="line">    kCFRunLoopExit          &#x3D; (1UL &lt;&lt; 7), &#x2F;&#x2F; 即将退出Loop</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面的 <code>Source/Timer/Observer</code> 被统称为 <code>mode item</code>，一个 item 可以被同时加入多个 mode。但一个 item 被重复加入同一个 mode 时是不会有效果的。如果一个 mode 中一个 item 都没有，则 RunLoop 会直接退出，不进入循环。</p>
<h2 id="RunLoop-的-Mode"><a href="#RunLoop-的-Mode" class="headerlink" title="RunLoop 的 Mode"></a>RunLoop 的 Mode</h2><p><code>CFRunLoopMode</code> 和 <code>CFRunLoop</code> 的结构大致如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct __CFRunLoopMode &#123;</span><br><span class="line">    CFStringRef _name;            &#x2F;&#x2F; Mode Name, 例如 @&quot;kCFRunLoopDefaultMode&quot;</span><br><span class="line">    CFMutableSetRef _sources0;    &#x2F;&#x2F; Set</span><br><span class="line">    CFMutableSetRef _sources1;    &#x2F;&#x2F; Set</span><br><span class="line">    CFMutableArrayRef _observers; &#x2F;&#x2F; Array</span><br><span class="line">    CFMutableArrayRef _timers;    &#x2F;&#x2F; Array</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">struct __CFRunLoop &#123;</span><br><span class="line">    CFMutableSetRef _commonModes;     &#x2F;&#x2F; Set</span><br><span class="line">    CFMutableSetRef _commonModeItems; &#x2F;&#x2F; Set&lt;Source&#x2F;Observer&#x2F;Timer&gt;</span><br><span class="line">    CFRunLoopModeRef _currentMode;    &#x2F;&#x2F; Current Runloop Mode</span><br><span class="line">    CFMutableSetRef _modes;           &#x2F;&#x2F; Set</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里有个概念叫 “CommonModes”：一个 Mode 可以将自己标记为”Common”属性（通过将其 ModeName 添加到 RunLoop 的 “commonModes” 中）。每当 RunLoop 的内容发生变化时，RunLoop 都会自动将 <code>_commonModeItems</code> 里的 <code>Source/Observer/Timer</code> 同步到具有 “Common” 标记的所有Mode里。</p>
<p>应用场景举例：主线程的 RunLoop 里有两个预置的 Mode：<code>kCFRunLoopDefaultMode</code> 和 <code>UITrackingRunLoopMode</code>。这两个 Mode 都已经被标记为”Common”属性。DefaultMode 是 App 平时所处的状态，<code>TrackingRunLoopMode</code> 是追踪 ScrollView 滑动时的状态。当你创建一个 Timer 并加到 DefaultMode 时，Timer 会得到重复回调，但此时滑动一个TableView时，RunLoop 会将 mode 切换为 <code>TrackingRunLoopMode</code>，这时 Timer 就不会被回调，并且也不会影响到滑动操作。</p>
<p>有时你需要一个 Timer，在两个 Mode 中都能得到回调，一种办法就是将这个 Timer 分别加入这两个 Mode。还有一种方式，就是将 Timer 加入到顶层的 RunLoop 的 “commonModeItems” 中。”commonModeItems” 被 RunLoop 自动更新到所有具有”Common”属性的 Mode 里去。</p>
<ul>
<li>CFRunLoop对外暴露的管理 Mode 接口只有下面2个:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CFRunLoopAddCommonMode(CFRunLoopRef runloop, CFStringRef modeName);</span><br><span class="line">CFRunLoopRunInMode(CFStringRef modeName, ...);</span><br></pre></td></tr></table></figure>

<ul>
<li>Mode 暴露的管理 mode item 的接口有下面几个：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CFRunLoopAddSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFStringRef modeName);</span><br><span class="line"></span><br><span class="line">CFRunLoopAddObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFStringRef modeName);</span><br><span class="line"></span><br><span class="line">CFRunLoopAddTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFStringRef mode);</span><br><span class="line"></span><br><span class="line">CFRunLoopRemoveSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFStringRef modeName);</span><br><span class="line"></span><br><span class="line">CFRunLoopRemoveObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFStringRef modeName);</span><br><span class="line"></span><br><span class="line">CFRunLoopRemoveTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFStringRef mode);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>你只能通过 mode name 来操作内部的 mode，当你传入一个新的 mode name 但 RunLoop 内部没有对应 mode 时，RunLoop会自动帮你创建对应的 <code>CFRunLoopModeRef</code>。对于一个 RunLoop 来说，其内部的 mode 只能增加不能删除。</p>
<p>苹果公开提供的 Mode 有两个：<code>kCFRunLoopDefaultMode (NSDefaultRunLoopMode)</code> 和 <code>UITrackingRunLoopMode</code>，你可以用这两个 Mode Name 来操作其对应的 Mode。</p>
<p>同时苹果还提供了一个操作 Common 标记的字符串：<code>kCFRunLoopCommonModes (NSRunLoopCommonModes)</code>，你可以用这个字符串来操作 Common Items，或标记一个 Mode 为 “Common”。使用时注意区分这个字符串和其他 mode name。</p>
<h2 id="苹果用-RunLoop-实现的功能"><a href="#苹果用-RunLoop-实现的功能" class="headerlink" title="苹果用 RunLoop 实现的功能"></a>苹果用 RunLoop 实现的功能</h2><h3 id="AutoreleasePool"><a href="#AutoreleasePool" class="headerlink" title="AutoreleasePool"></a>AutoreleasePool</h3><p>App启动后，苹果在主线程 RunLoop 里注册了两个 Observer，其回调都是 <code>_wrapRunLoopWithAutoreleasePoolHandler()</code>。</p>
<p>第一个 Observer 监视的事件是 <code>Entry</code>(即将进入Loop)，其回调内会调用 <code>_objc_autoreleasePoolPush()</code> 创建自动释放池。其 order 是-2147483647，优先级最高，保证创建释放池发生在其他所有回调之前。</p>
<p>第二个 Observer 监视了两个事件： <code>BeforeWaiting</code>(准备进入休眠) 时调用<code>_objc_autoreleasePoolPop()</code> 和 <code>_objc_autoreleasePoolPush()</code> 释放旧的池并创建新池；Exit(即将退出Loop) 时调用 <code>_objc_autoreleasePoolPop()</code> 来释放自动释放池。这个 Observer 的 order 是 2147483647，优先级最低，保证其释放池子发生在其他所有回调之后。</p>
<p>在主线程执行的代码，通常是写在诸如事件回调、Timer回调内的。这些回调会被 RunLoop 创建好的 AutoreleasePool 环绕着，所以不会出现内存泄漏，开发者也不必显示创建 Pool 了。</p>
<h3 id="事件响应"><a href="#事件响应" class="headerlink" title="事件响应"></a>事件响应</h3><p>苹果注册了一个 Source1 (基于 mach port 的) 用来接收系统事件，其回调函数为 <code>__IOHIDEventSystemClientQueueCallback()。</code></p>
<p>当一个硬件事件(触摸/锁屏/摇晃等)发生后，首先由 <code>IOKit.framework</code> 生成一个 <code>IOHIDEvent</code> 事件并由 <code>SpringBoard</code> 接收。这个过程的详细情况可以参考<a href="http://iphonedevwiki.net/index.php/IOHIDFamily">这里</a>。<code>SpringBoard</code> 只接收按键(锁屏/静音等)，触摸，加速，接近传感器等几种 Event，随后用 <code>mach port</code> 转发给需要的App进程。随后苹果注册的那个 Source1 就会触发回调，并调用 <code>_UIApplicationHandleEventQueue()</code> 进行应用内部的分发。</p>
<p><code>_UIApplicationHandleEventQueue()</code> 会把 <code>IOHIDEvent</code> 处理并包装成 UIEvent 进行处理或分发，其中包括识别 UIGesture/处理屏幕旋转/发送给 UIWindow 等。通常事件比如 UIButton 点击、touchesBegin/Move/End/Cancel 事件都是在这个回调中完成的。</p>
<h3 id="手势识别"><a href="#手势识别" class="headerlink" title="手势识别"></a>手势识别</h3><p>当上面的 <code>_UIApplicationHandleEventQueue() </code>识别了一个手势时，其首先会调用 <code>Cancel</code> 将当前的 <code>touchesBegin/Move/End </code>系列回调打断。随后系统将对应的 <code>UIGestureRecognizer</code> 标记为待处理。</p>
<p>苹果注册了一个 Observer 监测 <code>BeforeWaiting</code> (Loop即将进入休眠) 事件，这个Observer的回调函数是 <code>_UIGestureRecognizerUpdateObserver()</code>，其内部会获取所有刚被标记为待处理的 GestureRecognizer，并执行GestureRecognizer的回调。</p>
<p>当有 UIGestureRecognizer 的变化(创建/销毁/状态改变)时，这个回调都会进行相应处理</p>
<h3 id="界面更新"><a href="#界面更新" class="headerlink" title="界面更新"></a>界面更新</h3><p>当在操作 UI 时，比如改变了 Frame、更新了 <code>UIView/CALayer </code>的层次时，或者手动调用了 <code>UIView/CALayer</code> 的 <code>setNeedsLayout/setNeedsDisplay</code>方法后，这个 <code>UIView/CALayer</code> 就被标记为待处理，并被提交到一个全局的容器去。</p>
<p>苹果注册了一个 Observer 监听 <code>BeforeWaiting</code>(即将进入休眠) 和 <code>Exit</code> (即将退出Loop) 事件，回调去执行一个很长的函数：<br><code>_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()</code>。这个函数里会遍历所有待处理的 <code>UIView/CAlayer</code> 以执行实际的绘制和调整，并更新 UI 界面。</p>
<h3 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h3><p>NSTimer 其实就是 <code>CFRunLoopTimerRef</code>，他们之间是 toll-free bridged 的。一个 NSTimer 注册到 RunLoop 后，RunLoop 会为其重复的时间点注册好事件。例如 10:00, 10:10, 10:20 这几个时间点。RunLoop为了节省资源，并不会在非常准确的时间点回调这个Timer。Timer 有个属性叫做 Tolerance (宽容度)，标示了当时间点到后，容许有多少最大误差。</p>
<p>如果某个时间点被错过了，例如执行了一个很长的任务，则那个时间点的回调也会跳过去，不会延后执行。就比如等公交，如果 10:10 时我忙着玩手机错过了那个点的公交，那我只能等 10:20 这一趟了。</p>
<p><code>CADisplayLink</code> 是一个和屏幕刷新率一致的定时器（但实际实现原理更复杂，和 NSTimer 并不一样，其内部实际是操作了一个 Source）。如果在两次屏幕刷新之间执行了一个长任务，那其中就会有一帧被跳过去（和 NSTimer 相似），造成界面卡顿的感觉。在快速滑动TableView时，即使一帧的卡顿也会让用户有所察觉。Facebook 开源的 AsyncDisplayLink 就是为了解决界面卡顿的问题，其内部也用到了 RunLoop，这个稍后我会再单独写一页博客来分析。</p>
<h3 id="PerformSelecter"><a href="#PerformSelecter" class="headerlink" title="PerformSelecter"></a>PerformSelecter</h3><p>当调用 NSObject 的 <code>performSelecter:afterDelay:</code> 后，实际上其内部会创建一个 Timer 并添加到当前线程的 RunLoop 中。所以如果当前线程没有 RunLoop，则这个方法会失效。</p>
<p>当调用 <code>performSelector:onThread:</code> 时，实际上其会创建一个 Timer 加到对应的线程去，同样的，如果对应线程没有 RunLoop 该方法也会失效。</p>
<h3 id="关于GCD"><a href="#关于GCD" class="headerlink" title="关于GCD"></a>关于GCD</h3><p>实际上 RunLoop 底层也会用到 GCD 的东西</p>
<p>当调用 dispatch_async(dispatch_get_main_queue(), block) 时，libDispatch 会向主线程的 RunLoop 发送消息，RunLoop会被唤醒，并从消息中取得这个 block，并在回调 <strong>CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE</strong>() 里执行这个 block。但这个逻辑仅限于 dispatch 到主线程，dispatch 到其他线程仍然是由 libDispatch 处理的。</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>至此 本次关于RunLoop的所有内容总结完成,主要是汇总下面的两篇文章,看那么长的文章其实很大程度锻炼耐心呀！</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://www.jianshu.com/p/4d5b6fc33519">基于runloop的线程保活、销毁与通信</a><br><a href="http://blog.ibireme.com/2015/05/18/runloop/">深入理解RunLoop</a></p>
]]></content>
      <categories>
        <category>iOS基础</category>
      </categories>
      <tags>
        <tag>Runloop</tag>
      </tags>
  </entry>
</search>
