<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>SVProgressHUD的简单封装</title>
    <url>/2016/09/01/ALiProgressHud/</url>
    <content><![CDATA[<p> 项目中，大多数时候都是在view或者控制器中进行弹窗的操作，有时候仅仅是为了一个弹窗还要把状态从view或者model中传到控制器进行弹窗，这相当的麻烦，为什么不让所有的NSObject都可以弹窗呢！</p>
<a id="more"></a>

<h4 id="1、目的"><a href="#1、目的" class="headerlink" title="1、目的"></a>1、目的</h4><p> 项目中，大多数时候都是在view或者控制器中进行弹窗的操作，有时候仅仅是为了一个弹窗还要把状态从view或者model中传到控制器进行弹窗，这相当的麻烦，为什么不让所有的NSObject都可以弹窗呢！</p>
<h4 id="2、具体的方法"><a href="#2、具体的方法" class="headerlink" title="2、具体的方法"></a>2、具体的方法</h4><p>废话不多说直接上方法，相信不用我解释大家都可以看得懂</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&#x2F;**<br> *  显示纯文本 加一个转圈<br> *<br> *  @param aText 要显示的文本<br> *&#x2F;<br>- (void)showText:(NSString *)aText;<br><br>&#x2F;**<br> *  显示错误信息<br> *<br> *  @param aText 错误信息文本<br> *&#x2F;<br>- (void)showErrorText:(NSString *)aText;<br><br>&#x2F;**<br> *  显示成功信息<br> *<br> *  @param aText 成功信息文本<br> *&#x2F;<br>- (void)showSuccessText:(NSString *)aText;<br><br>&#x2F;**<br> *  只显示一个加载框<br> *&#x2F;<br>- (void)showLoading;<br><br>&#x2F;**<br> *  隐藏加载框（所有类型的加载框 都可以通过这个方法 隐藏）<br> *&#x2F;<br>- (void)dismissLoading;<br><br>&#x2F;**<br> *  显示百分比<br> *<br> *  @param progress 百分比（整型 100 &#x3D; 100%）<br> *&#x2F;<br>- (void)showProgress:(NSInteger)progress;<br><br>&#x2F;**<br> *  显示图文提示<br> *<br> *  @param image 自定义的图片<br> *  @param aText 要显示的文本<br> *&#x2F;<br>- (void)showImage:(UIImage*)image text:(NSString*)aText;<br><br><br></code></pre></td></tr></table></figure>

<p><code>如果你想自定义显示的图片 可以在ALiProgressHUD中替换那几张图片即可</code></p>
<p>demo演示：</p>
<p><img src="https://i.niupic.com/images/2016/09/08/RnE9pQ.gif" alt="demo"></p>
<h4 id="3、总结"><a href="#3、总结" class="headerlink" title="3、总结"></a>3、总结</h4><p> 项目中有很多让我们头疼的问题，就不要让这一个小小的弹窗困扰我们了。如果你还需要其他的样式 欢迎给我提issues，我会及时回复的！</p>
]]></content>
      <categories>
        <category>开源代码</category>
      </categories>
      <tags>
        <tag>弹窗,SVProgressHUD</tag>
      </tags>
  </entry>
  <entry>
    <title>抽象工厂模式</title>
    <url>/2016/09/27/AbstractFactoryPattern/</url>
    <content><![CDATA[<p>在上一篇工厂模式中，我开了一家pizza店，生意非常好哇，然后我就想着在国内多开几家分店。但是，问题来了，我如何确保每个地方pizza原材料的质量呢？接下来 我们可以使用抽象工厂方法来解决这个问题。</p>
<a id="more"></a>

<h4 id="1、定义"><a href="#1、定义" class="headerlink" title="1、定义"></a>1、定义</h4><p>抽象工厂模式：提供一个借口，用于创建相关或依赖对象的家族，而不需要明确指定具体类。</p>
<p>抽象工厂允许客户使用抽象的接口来创建一组相关的产品，而不需要知道实际产品的具体产品是什么。这样一来，客户就从具体的产品中解耦。</p>
<h4 id="2、使用场景"><a href="#2、使用场景" class="headerlink" title="2、使用场景"></a>2、使用场景</h4><p>前言中我也说道了，我的店目前要在全国到处都开分店，如何保证使用高质量的原材料，保证我的pizza的口味。</p>
<p>因此，我决定在全国各地建造原料加工厂，这时又有另外一个问题需要我考虑？如何保证每一个加工厂的材料标准。因此，我决定要制作一套各种口味pizza的制作标准，同时根据地理位置的不同做一些改变。</p>
<p>这样的话，如果需要新建加工厂只需要让这个加工厂按照我制作的这个标准对食材进行加工即可（具体的加工厂要遵照我指定的协议，实现协议中的各原材料的制作方法）。</p>
<p>结合前面的工厂模式，我只需要在创建各类Pizza的时候将就近的Pizza的加工厂传递过去就可以达到就近取材就近加工的目的了。</p>
<h4 id="3、思考"><a href="#3、思考" class="headerlink" title="3、思考"></a>3、思考</h4><p>1、如果我有一个协议，让每一个加工厂都遵守这个协议，那么是不是意味着，如果某一个加工厂需要修改东西我就需要在这个协议中做相应的修改，或者说我要加一个新的pizza，我需要修改协议和相应的类这可能会导致我修改很多类！</p>
<p>的确是这样的，因为我们使用抽象工厂就是要把很多相关的内容做一个集合，这就要求我们的这个接口必须 <code>全</code>。这也是抽象工厂模式的一个弊端！</p>
<p>2、感觉跟工厂模式的区别只在于一个使用了类的继承，另一个使用了对象的组合？</p>
<p>首先，两者的功能都是把应用程序从特定的实现中解耦出来。工厂模式是通过子类创建对象，客户只需要知道抽象类型，子类去负责具体类型。抽象工厂提供一个用来创建一个产品家族的抽象类型，这个类型的实例定义产品被生产的方法。</p>
<h4 id="4、具体实现"><a href="#4、具体实现" class="headerlink" title="4、具体实现"></a>4、具体实现</h4><p><img src="https://i.niupic.com/images/2016/09/27/0PVAm3.png" alt="协议抽象"></p>
<p>下面我们重新整理一下整个点餐的过程<br>1、创建一个store的实例<br>PizzaStore *store = [[BJPizzaStore alloc] init];</p>
<p>2、用户点单<br>[store orderPizza:1];</p>
<p>3、制作Pizza<br>Pizza *pizza = [self createPizza:1];</p>
<p>4、createPizza的具体实现<br>Pizza *pizza = [[BJCheesePizza alloc] initWith:BJFactory];</p>
<p>这里BJFactory是提前创建好的一个加工厂的实例对象。</p>
<p>5、调用BJFactory的准备原材料的方法</p>
<ul>
<li>(void)prepare{<br>  dough = [factory createDough];<br>  sauce = [factory createSauce];<br>}</li>
</ul>
<p>6、继续接着调用工厂方法中封装的那一套。</p>
<p><img src="https://i.niupic.com/images/2016/09/27/gbrJZW.png" alt="运行结果"></p>
<p><a href="https://github.com/LeeWongSnail/Head-First-DesignPattern/tree/master/FactoryPattern">代码放在这里了</a></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>工厂设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>App组件化文章收集</title>
    <url>/2016/06/12/App%E7%BB%84%E4%BB%B6%E5%8C%96%E6%96%87%E7%AB%A0%E6%94%B6%E9%9B%86/</url>
    <content><![CDATA[<p>公司打算新启一个APP，希望实现组件化，或者说我们几个对组件化毫无所知的人，打算用起来这个牛逼的东西，下面是我搜集的一些文章，以及我对这些文章的理解。</p>
<a id="more"></a>


<h4 id="1、组件的管理"><a href="#1、组件的管理" class="headerlink" title="1、组件的管理"></a>1、组件的管理</h4><p>目前网上找到的主要有三个：</p>
<p>1、<a href="https://github.com/mogujie/MGJRouter.git">蘑菇街</a></p>
<p>2、<a href="https://github.com/casatwy/CTMediator.git">casatwy大神</a></p>
<p>3、<a href="https://github.com/Lede-Inc/LDBusMediator.git">LDBusMediator</a> </p>
<p>4、<a href="https://github.com/joeldev/JLRoutes">JLRoutes</a></p>
<p>5、<a href="https://github.com/Huohua/HHRouter">HHRouter</a></p>
<p>下面我会仔细的看一下这几个架构方面的解析，判断到底该选择哪一个！</p>
]]></content>
      <categories>
        <category>组件化</category>
      </categories>
      <tags>
        <tag>文章收集</tag>
        <tag>组件化</tag>
      </tags>
  </entry>
  <entry>
    <title>装饰者模式</title>
    <url>/2016/09/18/DecoratorMode/</url>
    <content><![CDATA[<p>最近买了本设计模式的书Header First 非常喜欢其中的讲解方式。虽然买了有一段时间了但是没有认真的看过。这段时间工作相对没有那么难了，所以抽出点时间看一下这本书，同时，在这里做一下分享，希望可以帮到你！</p>
<a id="more"></a>

<h4 id="1、定义"><a href="#1、定义" class="headerlink" title="1、定义"></a>1、定义</h4><p><code>装饰者模式</code>：动态地将责任附加到对象上，若要扩展功能，装饰者提供了比继承更有弹性的替代方案。</p>
<p><code>给爱用继承的人一个全新的设计眼界</code></p>
<h4 id="2、使用场景"><a href="#2、使用场景" class="headerlink" title="2、使用场景"></a>2、使用场景</h4><p> 比如，我们现在有一个需求，建设一个<code>家</code>。首先我们需要<code>房子</code>，其次我们需要去装修这所房子。很明显在装修的过程中我们可能要用很多的<code>材料</code>，而且还要买很多的<code>家具</code>。那么在我做预算的时候我就要知道这个家的<code>总造价</code>,那么我如何更快更好的获取到这个房子的总造价呢？</p>
<p> 由于每个家具的造价是不相同的，而具体的价格只有家具本身最清楚。因此简单的讲，我们可以设置一个<code>父类</code>(家)，各种家具作为<code>子类</code>。父类针对每一个子类拥有两个属性（是否使用这个家具，这个家具的价格是多少）。这样父类在计算总价格的时候就可以通过判断是<code>否使用某一类家具</code>，如果使用那么在计算的时候就<code>加上</code>这个家具的<code>价格</code>。</p>
<p> 但是，每次我要添置一个新的家具，我就要修改父类中的方法，这完全违背了我们面向对象的设计原则。这时候就该装饰者模式大显身手了。</p>
<p> 装饰者模式，其实说白了就是组合的方式，存在一个主体，同时也存在很多与主体同类型的装饰品，一个复杂的主题可以通过一个单纯的主题和许多装饰品通过复杂的组合方式组合成一个复杂的主题。</p>
<p> 例如，我们有一个<code>房子</code>，这个房子作为<code>主体</code>，同时我们还有很多<code>家具</code>(家具和房子都是我们的<code>家</code>的<code>子类</code>)，我们从这些子类中选择一个作为主体(房子),选择其他的作为装饰者(家具等)，这样我们通过组合就能组合出一个漂亮的<code>家</code>。这其中要注意哪一个是主题哪一个是主题，哪一个是装饰者。</p>
<h4 id="3、思考"><a href="#3、思考" class="headerlink" title="3、思考"></a>3、思考</h4><p>  咦？？？？？，我们在使用装饰者模式，<code>家具和房子都是我们的家的子类</code>,这么明显的继承，显然违背了我们少用继承多用组合的设计原则啊！什么鬼！！！</p>
<p>  这里我们的确是使用了继承，但是要注意，我们这里使用继承的目的和使用继承与之前的区别。</p>
<p>  这里我们使用继承的目的是使装饰者和被装饰者是相同类型，也就是说有共同的父类。</p>
<p>  这里的继承与以往不同，以往的继承我们主要是想做到一些方法或者属性的继承，属于功能性的继承，但是这里我们的继承属于类型继承。</p>
<p>  这样，我们的装饰者和被装饰者属于同一种类型，那么我们在使用的时候就可以使用装饰者取代被装饰者，或者使用被装饰者取代装饰者。</p>
<h4 id="4、修改思路"><a href="#4、修改思路" class="headerlink" title="4、修改思路"></a>4、修改思路</h4><p>那么我们如何使用装饰者模式去实现我们的这个需求呢。</p>
<p>首先我们的家具和房子必须同属一个父类（确保二者的类型是相同的，保证互相可代替性）。</p>
<p>其次：作为主体，我们从父类继承了一个方法（比如cost()价格），对于其他的装饰者，我们也实现一个cost()方法。</p>
<p>我们如果要计算总的造价，比如要计算一个带有冰箱，电视机，空调，洗衣机的房子的总造价。那么最简单的方法是计算一个带冰箱的家的造价+带电视机的家的造价+带空调、洗衣机的家的造价+房子的造价 = 总造价。</p>
<p>对于装饰者和被装饰者的关系，可以通过下图来表述</p>
<p><img src="https://i.niupic.com/images/2016/09/19/4fl4aI.png" alt="关系图"></p>
<h4 id="5、具体实现"><a href="#5、具体实现" class="headerlink" title="5、具体实现"></a>5、具体实现</h4><ul>
<li>1、确定一个父类（Family）</li>
<li>2、这个父类有两个子类（装饰者和被装饰者）家具和房子</li>
<li>3、对于装饰者，每一个装饰者都有一个属性（family）一个方法cost()<br> 一个构造函数（传入family的初始值）,同时cost方法是将属性family<br>  的cost()+自己的价格</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">    cost() &#123;<br>    <br>	return 0.4 + family.cost();<br>	<br>&#125;<br></code></pre></td></tr></table></figure>


<ul>
<li>4、对于被装饰者，我们要实现一个cost()方法</li>
</ul>
<p>我们计算总造价的时候，是通过：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">Family *f1 &#x3D; house();<br><br>f1 &#x3D; bridge(f1);<br><br>f1 &#x3D; washmachine(f1);<br><br>f1 &#x3D; tv(f1);<br><br>f1 &#x3D; aircondition(f1);<br><br>nslog(f1.cost());<br><br></code></pre></td></tr></table></figure>

<p>通过这种方式我们可以计算出房子的具体造价，具体实现的如下图所示：</p>
<p><img src="https://i.niupic.com/images/2016/09/19/sPN5r6.png" alt="具体实现"></p>
<p>具体的代码实现放到<a href="https://github.com/LeeWongSnail/Head-First-DesignPattern/tree/master/DecoratePattern">这里</a></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>装饰者模式</tag>
      </tags>
  </entry>
  <entry>
    <title>工厂模式</title>
    <url>/2016/09/26/Factory-Pattern/</url>
    <content><![CDATA[<p>最近买了本设计模式的书Header First 非常喜欢其中的讲解方式。虽然买了有一段时间了但是没有认真的看过。这段时间工作相对没有那么难了，所以抽出点时间看一下这本书，同时，在这里做一下分享，希望可以帮到你！</p>
<a id="more"></a>

<h4 id="1、定义"><a href="#1、定义" class="headerlink" title="1、定义"></a>1、定义</h4><p>工厂方法模式：定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法让类的实例化推迟到子类。</p>
<p>所有工厂模式都用来封装对象的创建，工厂方法模式通过让子类决定该创建的对象是什么，来达到将对象创建的过程封装的目的。</p>
<h4 id="2、使用场景"><a href="#2、使用场景" class="headerlink" title="2、使用场景"></a>2、使用场景</h4><p>假如我有一个披萨店，刚开始没有分店也只是提供了北京口味的pizza。所以我的创建很简单。</p>
<p><img src="https://i.niupic.com/images/2016/09/26/MZGIaS.png" alt="我的pizza"></p>
<p>但是后来用户给我反馈，因为他们来自不同的地区所以希望我提供，北京口味、东北口味的披萨。</p>
<p>OK 那么我在点单的时候让用户自主的去选择order(type);<br>那么我的点单的方法改成了这样</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">- (void)order:(NSInteger)aType<br>&#123;<br>    Pizza *pizza &#x3D; nil;<br>    if (type &#x3D;&#x3D; @&quot;东北&quot;) &#123;<br>        pizza &#x3D; DBPizza();<br>    &#125; else if (type &#x3D;&#x3D; @&quot;北京&quot;)&#123;<br>        pizza &#x3D; BJPizza();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>后来生意更好了，全国开了很多分店，就会不断的加入更多的其他口味的pizza，同时也有可能有很多pizza的口味因为不符合要求被下架。所以这可能导致我的点餐方法越来越复杂。</p>
<p>同时，因为全国都有分店，分店中可能很多同一口味的做法都不同，所以这时候要考虑把这个全国都使用的方法下方到地方，不再做统一的管理。</p>
<p>首先想到的肯定是把这个方法抽出来，单独放到一个类中。这个类实际上就是一个工厂类。我们将要点餐的type传入之后由这个工厂类决定到底实例化哪一种pizza。</p>
<h4 id="3、思考"><a href="#3、思考" class="headerlink" title="3、思考"></a>3、思考</h4><p> 1、这么做的好处是什么？还是只是做了简单的代码的分离。</p>
<p> 我们这里，在这个工厂类中只是提供了这一个方法，之后我们可能还会有其他的工厂方法，都可以放到这个类中，所以这个工厂方法为代码以后的扩展提供了方便，同时如果以后需要修改或者添加可以直接修改这个类就可以了。</p>
<p>2、对于pizza的工厂方法，我们可能有很多的类型比如BJPizzaFactory,DBPizzaFactory 如果有很多的这种工厂方法，我们如何做统一的管理呢？</p>
<p>我们可以设置一个基类，这个基类用来控制Pizza的整个制作流程，同时提供一个抽象方法createPizza，我们让BJPizzaFactory,DBPizzaFactory继承自这个类，同时实现createPizza这个抽象方法。</p>
<h4 id="4、修改思路"><a href="#4、修改思路" class="headerlink" title="4、修改思路"></a>4、修改思路</h4><p>1、客户点单<br>PizzaStore bjPizzaStore = new BJPizzaStore();<br>bjPizzaStore.orderPizza(“cheese”);</p>
<p>2、制作pizza<br>Pizza pizza = createPizza(“cheese”);</p>
<p>3、其他流程<br>pizza.bake();<br>pizza.cut();<br>pizza.box();</p>
<h4 id="5、具体实现"><a href="#5、具体实现" class="headerlink" title="5、具体实现"></a>5、具体实现</h4><p><img src="https://i.niupic.com/images/2016/09/26/6NdcNG.png" alt="流程"></p>
<p><img src="https://i.niupic.com/images/2016/09/27/5O6pj1.png" alt="结果"></p>
<p><a href="https://github.com/LeeWongSnail/Head-First-DesignPattern/tree/master/FactoryPattern">代码实现在这里</a></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>工厂模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Git使用笔记之冲突解决</title>
    <url>/2019/07/14/Git%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3/</url>
    <content><![CDATA[<p>我们公司产品有两条线 一个是针对日本地区的一个独立APP(B),另一个是针对除日本地区之外的其他的地区的APP(A) 。B是基于A的某个分支建立的,并且删除了部分功能,在过去的一段时间内两条产品线各自为战,但是前段时间公司希望将A中的某个功能直接迁移到B上,为此我们开始了下面的工作。</p>
<a id="more"></a>

<h3 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h3><p>对于这个任务我们分为下面三步：</p>
<blockquote>
<p>1、因为B是基于A创建的所以有些基础的部分二者是相同的(双方都有修改),所以第一步是抽取公共部分。<br>2、在A中将希望移植的功能与A的其他功能解耦(可以来来1中公共的部分)<br>3、将2中抽取的功能移植到B中</p>
</blockquote>
<p>额,有点跑偏了,我们这片文章主要是想介绍git的使用,但是上面为什么从重构开始说呢？那是因为在重构的过程中我们大量修改了现有工程的目录结构,之前工程大都是虚拟文件夹,重构后我们统一使用实体文件夹管理。但是我们在重构项目的过程中,还是有新的需求在不断的添加在以旧的工程目录结构为标准的项目中。在我们完成模块迁移后就发现了一个重要的问题：合代码！！！</p>
<p>下面我来简单的描述下这个悲伤的故事：<br>因为项目的目录结构被大量的修改,所以配置文件<code>project.pbxproj</code>有大量的冲突,配置文件的冲突大概分为两类：文件位置冲突、文件夹位置冲突。对于文件又可以分为:<code>both modified</code>、<code>deleted by us</code>、<code>new file</code>、<code>added by us</code>、<code>added by them</code> 这几大类。</p>
<p>先来看下<code>project.pbxproj</code>这个文件的结构：</p>
<p><img src="https://s2.ax1x.com/2019/07/21/e9zHkn.png" alt="e9zHkn.png"></p>
<h3 id="冲突类型"><a href="#冲突类型" class="headerlink" title="冲突类型"></a>冲突类型</h3><p>下面来简单的看下这几种冲突：</p>
<h4 id="配置文件冲突"><a href="#配置文件冲突" class="headerlink" title="配置文件冲突"></a>配置文件冲突</h4><h5 id="文件位置冲突"><a href="#文件位置冲突" class="headerlink" title="文件位置冲突"></a>文件位置冲突</h5><p><img src="https://s2.ax1x.com/2019/07/21/eCSS0J.jpg" alt="eCSS0J.jpg"></p>
<p>对于这种冲突，我们一般的解决方法是领边都保留。</p>
<h5 id="文件夹位置冲突"><a href="#文件夹位置冲突" class="headerlink" title="文件夹位置冲突"></a>文件夹位置冲突</h5><p><img src="https://s2.ax1x.com/2019/07/21/eCSPt1.jpg" alt="eCSPt1.jpg"></p>
<p><img src="https://s2.ax1x.com/2019/07/21/eCSkp6.jpg" alt="eCSkp6.jpg"></p>
<p><img src="https://s2.ax1x.com/2019/07/21/eCSene.jpg" alt="eCSene.jpg"></p>
<h4 id="类文件冲突"><a href="#类文件冲突" class="headerlink" title="类文件冲突"></a>类文件冲突</h4><h5 id="both-modified"><a href="#both-modified" class="headerlink" title="both modified"></a>both modified</h5><p>双方都有修改</p>
<p><img src="https://s2.ax1x.com/2019/07/21/eCSgHJ.jpg" alt="eCSgHJ.jpg"></p>
<h5 id="deleted-by-us"><a href="#deleted-by-us" class="headerlink" title="deleted by us"></a>deleted by us</h5><p>本地分支删除(也有可能是位置被修改),但是需要注意,本地分支如果移动位置且远端分支有修改那么本地分支会标记为deleted by us 远端的标记为new file。这时候我们需要对比两个文件,保留修改。</p>
<h5 id="new-file"><a href="#new-file" class="headerlink" title="new file"></a>new file</h5><p>新增文件,但是不要被这个名称迷惑,这里面很有可能是本地分支修改了位置,但是远端分支做了修改,但是因为本地的配置文件之前的位置已经没有这个文件了,所以在合并代码的时候会被标识为new file</p>
<h5 id="added-by-us"><a href="#added-by-us" class="headerlink" title="added by us"></a>added by us</h5><p>本地分支添加的文件,注意这里也有可能是从之前文件夹移动到新文件夹的文件</p>
<h5 id="added-by-them"><a href="#added-by-them" class="headerlink" title="added by them"></a>added by them</h5><p>远端分支添加</p>
<h4 id="问题和难点"><a href="#问题和难点" class="headerlink" title="问题和难点"></a>问题和难点</h4><h5 id="1、配置文件的合并"><a href="#1、配置文件的合并" class="headerlink" title="1、配置文件的合并"></a>1、配置文件的合并</h5><p>从上面分类中我们也可以看到,文件位置的冲突其实都好解决,但是文件夹位置的冲突,我们真的很难解决这个地方非常耗时。而且<code>project.pbxproj</code>这个文件是非常脆弱的,只要我们有一个地方没有修改正确 我们的工程都无法正常打开。所以我们一般在修改这个文件冲突的时候都选择两者都保留 或者根据文件夹的ID去查找。但是有些位置我们甚至无法做到两者都保留</p>
<p><img src="https://s2.ax1x.com/2019/07/21/eCSHDe.jpg" alt="eCSHDe.jpg"></p>
<p>这种情况下我们为了尽快可以打开项目,然后通过编译的方式查看刚才删除文件夹。我们可能会直接删除其中一个。</p>
<h5 id="2、范围的确定"><a href="#2、范围的确定" class="headerlink" title="2、范围的确定"></a>2、范围的确定</h5><p>因为第一步的操作过程中,给我们埋下了坑,第二步的时候需要我们找到,可能某些文件的实体文件是存在的但是项目中没有引用(第一步直接删除),当然 还有另外的可能就是:本地分支已经删除,远端还保留,那么这些文件实际上是需要删除。另外也有可能是本地分支移动了这个文件的位置导致某个文件在本地存有两份。</p>
<p>所以针对这种情况,我们需要仔细分析,然后在去解决冲突。</p>
<p>总结：根据上面的描述,我们在每次主分支发布新版本,重构代码版本需要合并新分支代码的时候,我们都要预留大概3-5天的时间去合并代码。耗时又费力。</p>
<h3 id="mergepbx"><a href="#mergepbx" class="headerlink" title="mergepbx"></a>mergepbx</h3><p>先来介绍一下使用方法：</p>
<h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>可以直接使用 brew 直接安装 mergepbx</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">brew install mergepbx<br></code></pre></td></tr></table></figure>

<h4 id="将mergepbx设置添加到〜-gitconfig"><a href="#将mergepbx设置添加到〜-gitconfig" class="headerlink" title="将mergepbx设置添加到〜/ .gitconfig"></a>将mergepbx设置添加到〜/ .gitconfig</h4><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">git config --global merge.mergepbx.name“Xcode项目文件合并”<br>git config --global merge.mergepbx.driver“mergepbx％O％A％B”<br></code></pre></td></tr></table></figure>

<h4 id="配置-gitconfig"><a href="#配置-gitconfig" class="headerlink" title="配置 .gitconfig"></a>配置 .gitconfig</h4><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">[合并“mergepbx”]<br>    name &#x3D; Xcode项目文件合并<br>    driver &#x3D; mergepbx％O％A％B<br></code></pre></td></tr></table></figure>

<h4 id="gitattributes"><a href="#gitattributes" class="headerlink" title=".gitattributes"></a>.gitattributes</h4><p>在项目的目录下(与.git同级)新建一个.gitattributes文件 同时在里面写入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">* .pbxproj merge &#x3D; mergepbx<br></code></pre></td></tr></table></figure>

<h4 id="git-merge"><a href="#git-merge" class="headerlink" title="git merge"></a>git merge</h4><p>这时候 在使用本地分支merge远程 我们惊奇的发现 <code>project.pbxproj</code>这个该死的玩意没有冲突。感觉都已经要成功一半的样子。</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><h4 id="首先看下-gitattributes"><a href="#首先看下-gitattributes" class="headerlink" title="首先看下 .gitattributes"></a>首先看下 <code>.gitattributes</code></h4><p>gitattributes文件中的每一行都是以下格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">pattern        attr1 attr2 ...<br></code></pre></td></tr></table></figure>

<p>.gitattributes实际上是定义在发生冲突时，应该采取的行动，比如merge=ours就表示文件冲突时使用原文件内容，merge=theirs表示使用其他分支的文件内容。</p>
<p>我们上面的定义表示 在发生冲突的时候使用mergepbx来确定冲突解决方法</p>
<h4 id="然后我们在来看下-gitconfig"><a href="#然后我们在来看下-gitconfig" class="headerlink" title="然后我们在来看下 .gitconfig"></a>然后我们在来看下 <code>.gitconfig</code></h4><p>这个文件表示 git的配置信息</p>
<p>我们通过</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">git config --global merge.mergepbx.name“Xcode项目文件合并”<br>git config --global merge.mergepbx.driver“mergepbx％O％A％B”<br></code></pre></td></tr></table></figure>
<p>这两句 实际上就是在.gitconfig中添加了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">[合并“mergepbx”]<br>    name &#x3D; Xcode项目文件合并<br>    driver &#x3D; mergepbx％O％A％B<br></code></pre></td></tr></table></figure>
<p>这两行</p>
<h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><p><a href="https://qiita.com/kaneshin/items/1deebde685c973fda6b8">pbxprojファイルのマージが便利になるmergepbxをインストールするスクリプト書いた</a></p>
<p><a href="https://www.jianshu.com/p/50cc564b58ce">iOSXcodeProject的内部结构分析</a></p>
<p><a href="https://nicreals.github.io/Gear/Xcode.html">XCodeConfig</a></p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>冲突</tag>
      </tags>
  </entry>
  <entry>
    <title>OSSMaker 使用详解</title>
    <url>/2018/09/02/OSSURLMontage/</url>
    <content><![CDATA[<p>项目中,当我们要在列表页展示图片时,为了提升图片的加载速度,同时兼顾显示效果。一般我们会采用展示缩略图的形式去加载图片。这时我们就会用到阿里云OSS的图片地址拼接策略。</p>
<a id="more"></a>

<h1 id="OSSMaker-使用详解"><a href="#OSSMaker-使用详解" class="headerlink" title="OSSMaker 使用详解"></a>OSSMaker 使用详解</h1><p>项目中,当我们要在列表页展示图片时,为了提升图片的加载速度,同时兼顾显示效果。一般我们会采用展示缩略图的形式去加载图片。这时我们就会用到阿里云OSS的图片地址拼接策略。</p>
<h2 id="Aliyun图片裁剪拼接参数简介"><a href="#Aliyun图片裁剪拼接参数简介" class="headerlink" title="Aliyun图片裁剪拼接参数简介"></a>Aliyun图片裁剪拼接参数简介</h2><h3 id="图片缩放"><a href="#图片缩放" class="headerlink" title="图片缩放"></a>图片缩放</h3><p>操作名称：<code>resize</code></p>
<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
<th>取值范围</th>
<th>当前是否支持</th>
</tr>
</thead>
<tbody><tr>
<td>m</td>
<td>指定缩略的模式：lfit：等比缩放，限制在指定w与h的矩形内的最大图片。mfit：等比缩放，延伸出指定w与h的矩形框外的最小图片。fill：固定宽高，将延伸出指定w与h的矩形框外的最小图片进行居中裁剪。pad：固定宽高，缩略填充。fixed：固定宽高，强制缩略</td>
<td>lfit、mfit、fill、pad、fixed，默认为lfit。</td>
<td>已支持</td>
</tr>
<tr>
<td>w</td>
<td>指定目标缩略图的宽度。</td>
<td>1-4096</td>
<td>已支持</td>
</tr>
<tr>
<td>h</td>
<td>指定目标缩略图的高度。</td>
<td>1-4096</td>
<td>已支持</td>
</tr>
<tr>
<td>l</td>
<td>指定目标缩略图的最长边。</td>
<td>1-4096</td>
<td>已支持</td>
</tr>
<tr>
<td>s</td>
<td>指定目标缩略图的最短边。</td>
<td>1-4096</td>
<td>已支持</td>
</tr>
<tr>
<td>limit</td>
<td>指定当目标缩略图大于原图时是否处理。值是 1 表示不处理；值是 0 表示处理。</td>
<td>0/1, 默认是 1</td>
<td>未支持</td>
</tr>
<tr>
<td>color</td>
<td>当缩放模式选择为pad（缩略填充）时，可以选择填充的颜色(默认是白色)参数的填写方式：采用16进制颜色码表示，如00FF00（绿色）。</td>
<td>[000000-FFFFFF]</td>
<td>未支持</td>
</tr>
</tbody></table>
<p><code>注意:</code></p>
<ul>
<li><p>1 对于原图：</p>
<blockquote>
<p>图片格式只能是：jpg、png、bmp、gif、webp、tiff。<br>文件大小不能超过20 MB。<br>使用图片旋转时图片的宽或者高不能超过4096。</p>
</blockquote>
</li>
<li><p>2 对于缩略图：对缩略后的图片大小有限制，目标缩略图宽与高的乘积不能超过 4096 x 4096，且单边长度不能超过 4096 x 4。</p>
</li>
<li><p>3 当只指定宽度或者高度时，在等比缩放的情况下，都会默认进行单边的缩放。在固定宽高的模式下，会默认宽高一样的情况下进行缩略。</p>
</li>
<li><p>4 如果只指定宽度或者高度，原图按原图格式返回。如果想保存成其他格式，详细可以查看质量变换及格式转换。</p>
</li>
<li><p>5 调用resize，默认是不允许放大。即如果请求的图片对原图大，那么返回的仍然是原图。如果想取到放大的图片，即增加参数调用limit,0 （如：<a href="https://image-demo.oss-cn-hangzhou.aliyuncs.com/example.jpg?x-oss-process=image/resize,w_500,limit_0%EF%BC%89">https://image-demo.oss-cn-hangzhou.aliyuncs.com/example.jpg?x-oss-process=image/resize,w_500,limit_0）</a></p>
</li>
</ul>
<h3 id="图片裁剪"><a href="#图片裁剪" class="headerlink" title="图片裁剪"></a>图片裁剪</h3><h4 id="内切圆"><a href="#内切圆" class="headerlink" title="内切圆"></a>内切圆</h4><p>操作名称：<code>circle</code></p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
<th>取值</th>
<th>是否支持</th>
</tr>
</thead>
<tbody><tr>
<td>r</td>
<td>从图片取出的圆形区域的半径</td>
<td>半径 r 不能超过原图的最小边的一半。如果超过，则圆的大小仍然是原圆的最大内切圆</td>
<td>已支持</td>
</tr>
</tbody></table>
<p><code>注意：</code></p>
<ul>
<li><p>如果图片的最终格式是 png、webp、 bmp 等支持透明通道的图片，那么图片非圆形区域的地方将会以透明填充。如果图片的最终格式是 jpg，那么非圆形区域是以白色进行填充。推荐保存成 png 格式。</p>
</li>
<li><p>如果指定半径大于原图最大内切圆的半径，则圆的大小仍然是图片的最大内切圆。</p>
</li>
</ul>
<h3 id="圆角矩形"><a href="#圆角矩形" class="headerlink" title="圆角矩形"></a>圆角矩形</h3><p>操作名称：<code>rounded-corners</code></p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
<th>取值</th>
<th>是否支持</th>
</tr>
</thead>
<tbody><tr>
<td>r</td>
<td>将图片切出圆角，指定圆角的半径。</td>
<td>[1, 4096] 生成的最大圆角的半径不能超过原图的最小边的一半。</td>
<td>已支持</td>
</tr>
</tbody></table>
<h2 id="之前的做法"><a href="#之前的做法" class="headerlink" title="之前的做法"></a>之前的做法</h2><p>对于图片的展示一般我们提前知晓图片要展示的宽高,或者知道图片的高度宽度自适应或者知道宽度高度自适应。</p>
<h3 id="定义一个该位置图片需要拼接的字符串常量"><a href="#定义一个该位置图片需要拼接的字符串常量" class="headerlink" title="定义一个该位置图片需要拼接的字符串常量"></a>定义一个该位置图片需要拼接的字符串常量</h3><p><code>static NSString *URL_SCALE_DUBLIST_AVATAR = @&quot;x-oss-process=image/resize,m_mfit,h_210,w_210/rounded-corners,r_9/format,png&quot;; </code></p>
<p>当我们需要展示的时候 将这个常量直接添加到我们要展示的图片的后面,就可以拿到我们要展示的缩略图了。</p>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>上面的这种做法最直观同时也最简单。但是如果每个列表展示的图片宽高均不相同 那么我们就要定义无数个字符串常量来满足我们的需求。</p>
<h2 id="改进方法"><a href="#改进方法" class="headerlink" title="改进方法"></a>改进方法</h2><p>由于大多数情况下我们展示的图片宽高都不尽相同,这些字符串常量基本上复用的可能性不是太大(当然为了提高图片缓存的利用率我们需要跟UI协调尽量统一)。</p>
<p>如果我们不去定义每处展示的字符串常量,那么我们可以通过在每个地方单独通过参数的方式传给我们的管理对象 我需要设置的属性(宽度/高度/圆角/内切圆/图片展示模式)。由于这里要传递的参数比较多,因此通过普通的工厂方法去实现的话会导致代码的可读性方面降低。同时使用者也需要书写大量的代码。因此,这里 推出链式调用的方式去拼接字符串。</p>
<h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-built_in">NSString</span> *res = <span class="hljs-keyword">self</span>.coverURL.absoluteString.maker.resize.contentMode(@(OSSImageResizeContentModelTypeMfit)).height(@<span class="hljs-number">60</span>).width(@<span class="hljs-number">106</span>).resultString;<br><br></code></pre></td></tr></table></figure>

<p>这里是我们想要将图片切为宽度是106 高度为60 contentMode为Fit样式的展示。</p>
<p><code>注意:</code> 最终实际拼接出的图片的<code>宽高</code>为根据外部传入的参数 <code>乘以</code> 当前屏幕的 <code>Scale</code>,因此会根据当前设备去取2x还是3x图。</p>
<p>通过上面这样的拼接我们就可以将我们需要设置的各项参数拼接到图片URL的尾部。</p>
<h2 id="内部实现简介"><a href="#内部实现简介" class="headerlink" title="内部实现简介"></a>内部实现简介</h2><p>为了方便使用,这里将图片拼接的<code>maker</code>方法放到了字符串的分类中。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">- (ULOSSImageMaker *)maker<br>&#123;<br>    <span class="hljs-keyword">if</span> (!objc_getAssociatedObject(<span class="hljs-keyword">self</span>, &amp;makerName)) &#123;<br>        ULOSSImageMaker  *maker = [[ULOSSImageMaker alloc] initWithBaseURLString:<span class="hljs-keyword">self</span>];<br>        objc_setAssociatedObject(<span class="hljs-keyword">self</span>, &amp;makerName, maker, OBJC_ASSOCIATION_RETAIN_NONATOMIC);<br>    &#125;<br>    <span class="hljs-keyword">return</span> objc_getAssociatedObject(<span class="hljs-keyword">self</span>, &amp;makerName);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在这里我们创建了一个 <code>ULOSSImageMaker</code> 对象,在这个类中包含两个方法: </p>
<ul>
<li>初始化方法 </li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">- (<span class="hljs-keyword">instancetype</span>)initWithBaseURLString:(<span class="hljs-built_in">NSString</span> *)aURLString<br>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span> = [<span class="hljs-keyword">super</span> init]) &#123;<br>        <span class="hljs-keyword">self</span>.baseURLString = [<span class="hljs-built_in">NSString</span> stringWithFormat:<span class="hljs-string">@&quot;%@?x-oss-process=image&quot;</span>,aURLString];<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>resize的实现方法</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">- (ULOSSImageResize *)resize<br>&#123;<br>    <span class="hljs-built_in">NSString</span> *actionString = [<span class="hljs-keyword">self</span>.baseURLString stringByAppendingString:<span class="hljs-string">@&quot;/resize&quot;</span>];<br>    ULOSSImageResize *action = [[ULOSSImageResize alloc] initWithBaseURLString:actionString];<br>    <span class="hljs-keyword">return</span> action;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这里在<code>resize</code>方法中我们我们创建了一个<code>ULOSSImageResize</code>对象,几乎所有的针对图片的缩放操作我们都放在了这个对象中进行。</p>
<h2 id="具体代码实现"><a href="#具体代码实现" class="headerlink" title="具体代码实现"></a>具体代码实现</h2><p>设置宽度</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><br>- (ResizeHandler)width<br>&#123;<br>    <span class="hljs-keyword">return</span> ^(<span class="hljs-built_in">NSNumber</span> *attr) &#123;<br>        <span class="hljs-keyword">self</span>.oss_w = [<span class="hljs-built_in">NSNumber</span> numberWithFloat:attr.floatValue*<span class="hljs-keyword">self</span>.curScale];<br>        [<span class="hljs-keyword">self</span> addOSSImageAttributeValue:<span class="hljs-keyword">self</span>.oss_w.stringValue type:oss_w];<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>;<br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>链接拼接：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">- (<span class="hljs-keyword">void</span>)addOSSImageAttributeValue:(<span class="hljs-built_in">NSString</span> *)atrri type:(<span class="hljs-built_in">NSString</span> *)type<br>&#123;<br>    <span class="hljs-built_in">NSString</span> *tem = [<span class="hljs-built_in">NSString</span> stringWithFormat:<span class="hljs-string">@&quot;,%@%@&quot;</span>, type, atrri];<br>    <span class="hljs-keyword">self</span>.baseURLString = [<span class="hljs-keyword">self</span>.baseURLString stringByAppendingString:tem];<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="还存在的问题"><a href="#还存在的问题" class="headerlink" title="还存在的问题"></a>还存在的问题</h2><ul>
<li>对于属性的支持目前还没有全部支持 只是支持了项目中使用到的</li>
<li>对于枚举类型的支持提示效果不佳 且需要转换成NSNumber类型</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>OSS拼接本身是一个跟业务耦合度很低的逻辑,因此在实现的时候我们尽量将方法设置的尽可能的简单。通过链式调用的方式不仅可以很好的提示使用者使用方法,同时也降低了与业务代码的耦合。</p>
]]></content>
      <categories>
        <category>iOS进阶</category>
      </categories>
      <tags>
        <tag>oss</tag>
      </tags>
  </entry>
  <entry>
    <title>二维码生成扫描和识别(基于系统提供方法)</title>
    <url>/2016/09/07/QRCode/</url>
    <content><![CDATA[<p> 现在越来越多的App添加了一个扫码的功能，方便而且很实用，但是目前对弈iOS来说有些比较知名的库（比如<a href="https://github.com/TheLevelUp/ZXingObjC">ZXingObjC</a>）库都比较大，而实际上，在iOS 7.0之后系统在AVFoundation框架中就已经实现了对于二维码扫描和生成的的支持，我的方法主要是对系统的一些东西稍作封装（<a href="https://github.com/LeeWongSnail/QRCode">QRCode</a>）</p>
<a id="more"></a>

<h4 id="1、目的"><a href="#1、目的" class="headerlink" title="1、目的"></a>1、目的</h4><p> 现在越来越多的App添加了一个扫码的功能，方便而且很实用，但是目前对弈iOS来说有些比较知名的库（比如<a href="https://github.com/TheLevelUp/ZXingObjC">ZXingObjC</a>）库都比较大，而实际上，在iOS 7.0之后系统在AVFoundation框架中就已经实现了对于二维码扫描和生成的的支持，我的方法主要是对系统的一些东西稍作封装（<a href="https://github.com/LeeWongSnail/QRCode">QRCode</a>）</p>
<h4 id="2、生成二维码"><a href="#2、生成二维码" class="headerlink" title="2、生成二维码"></a>2、生成二维码</h4><p>目前见到的二维码一般是两种，中间有图片和没有图片的(通常是APP图标或者个人头像)或者是为二维码添加了背景颜色。这里我提供了三个方法，可以满足这几种需求。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&#x2F;**<br> *  生成二维码图片的方法<br> *<br> *  @param string 二维码包含的内容<br> *  @param size   图片的尺寸<br> *  @param topimg 如果中间需要添加 头像可以传入此参数<br> *<br> *  @return 包含要生成内容的二维码图片<br> *&#x2F;<br> <br>+ (UIImage *)qrImageForString:(NSString *)string <br>	imageSize:(CGFloat)size Topimg:(UIImage *)topimg;<br><br>&#x2F;**<br> *  生成二维码图片的方法<br> *<br> *  @param string       二维码包含的内容<br> *  @param size         图片的尺寸<br> *  @param pointType    点的类型（QRPointRect，<br> 										QRPointRound）<br> *  @param positionType 位置的类型 （QRPositionNormal，<br> 										QRPositionRound）<br> *  @param color        背景颜色<br> *<br> *  @return 包含要生成内容的二维码图片<br> *&#x2F;<br>+(UIImage *)qrImageForString:(NSString *)string <br>				    imageSize:(CGFloat)size <br>				withPointType:(QRPointType)pointType<br>			withPositionType:	<br>				 			(QRPositionType)positionType<br>				    withColor:(UIColor *)color;<br><br>&#x2F;**<br> *  生成二维码图片的方法<br> *<br> *  @param string 二维码包含的内容<br> *  @param size    图片的尺寸<br> *  @param topimg 如果中间需要添加 头像可以传入此参数<br> *  @param color  背景颜色<br> *<br> *  @return 包含要生成内容的二维码图片<br> *&#x2F;<br> <br>+(UIImage*)qrImageForString:(NSString *)string <br>				  imageSize:(CGFloat)size <br>				     Topimg:(UIImage *)topimg <br>				  withColor:(UIColor*)color;<br>				  <br></code></pre></td></tr></table></figure>

<h4 id="3、二维码扫描"><a href="#3、二维码扫描" class="headerlink" title="3、二维码扫描"></a>3、二维码扫描</h4><p>这里 需要重要注意的是 rectOfInterest属性的设置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br>&#x2F;&#x2F;它的作用就是设置扫描范围<br>output.rectOfInterest &#x3D; scanCrop;<br><br>这个CGRect参数和普通的Rect范围不太一样，它的四个值的范围都是0-1，表示比例。<br><br>rectOfInterest都是按照横屏来计算的 所以当竖屏的情况下 x轴和y轴要交换一下。<br><br>宽度和高度设置的情况也是类似。<br><br></code></pre></td></tr></table></figure>

<p>具体的扫描结果通过遵守<code>AVCaptureMetadataOutputObjectsDelegate</code>协议并实现</p>
<p><code>-(void)captureOutput:(AVCaptureOutput *)captureOutput didOutputMetadataObjects:(NSArray *)metadataObjects fromConnection:(AVCaptureConnection *)connection</code></p>
<p>代理方法就可以拿到</p>
<p><img src="https://i.niupic.com/images/2016/09/07/2ea1uC.gif" alt="扫描"></p>
<h4 id="4、其他的使用场景"><a href="#4、其他的使用场景" class="headerlink" title="4、其他的使用场景"></a>4、其他的使用场景</h4><p>除了最常见的扫描识别二维码的方式之外 还有点击弹出框 选择识别图中二维码，或者 长按直接识别二维码的方式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&#x2F;**<br> *  识别图中的二维码<br> *<br> *  @param aImage      图片<br> *  @param aCompletion 识别完成的回调<br> *&#x2F;<br>- (void)recognitionQRCodeFromImage:(UIImageView *)aImage<br>		 completion:(void (^)(NSString *result,<br>		 					 NSError *error))aCompletion;<br><br></code></pre></td></tr></table></figure>
<p><img src="https://i.niupic.com/images/2016/09/07/f1hIfp.gif" alt="长按识别"></p>
<h4 id="5、总结"><a href="#5、总结" class="headerlink" title="5、总结"></a>5、总结</h4><p>这样的话在我们日常使用中常见的几种对于二维码的操作，基本可以实现。希望这个demo对你有所帮助。</p>
]]></content>
      <categories>
        <category>iOS进阶</category>
      </categories>
      <tags>
        <tag>QRCode</tag>
      </tags>
  </entry>
  <entry>
    <title>SDWebImage解析</title>
    <url>/2016/01/26/SDWebImage-1/</url>
    <content><![CDATA[<p>最近，公司的活比较少，所以特地抽出来一点时间，看了一下SDWebImage的源码，并写了这篇文章，查看源码的过程中看了很多相关的文章，总体思路是划分为几个大模块，会分几个博客讲述，下面提供了目录。</p>
<a id="more"></a>

<h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><ul>
<li>0、一张图片的下载流程</li>
<li>1、<a href="http://leewongsnail.github.io/blog/2016/01/27/sdwebimageyuan-ma-jie-xi-xia-zai/">图片的下载</a></li>
<li>2、<a href="http://leewongsnail.github.io/blog/2016/01/27/sdwebimageyuan-ma-jie-xi-huan-cun/">图片的缓存</a></li>
<li>3、分类的解析</li>
<li>4、SD常识汇总</li>
</ul>
<h3 id="SDWebImage的层次结构："><a href="#SDWebImage的层次结构：" class="headerlink" title="SDWebImage的层次结构："></a>SDWebImage的层次结构：</h3><p><img src="http://draveness.me/content/images/2015/04/Untitled-2.png" alt="icon"></p>
<p>接下来，就按照图片下载的流程来分析一下SDWebImage</p>
<h3 id="图片下载和缓存流程"><a href="#图片下载和缓存流程" class="headerlink" title="图片下载和缓存流程"></a>图片下载和缓存流程</h3><p>这一步主要就是跟踪一个图片的下载流程，通过这个流程，我们可以大致的了解SD的图片下载过程中的重要的方法以及处理问题的步骤！</p>
<p><code>方法过程</code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">最外层图片下载 可以添加占位图<br>- (void)sd_setImageWithURL:(NSURL *)url placeholderImage:(UIImage *)placeholder options:(SDWebImageOptions)options <br><br></code></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">添加一个对于下载进度的监听的回调，下载完成的回调<br>- (void)sd_setImageWithURL:(NSURL *)url placeholderImage:(UIImage *)placeholder options:(SDWebImageOptions)options progress:(SDWebImageDownloaderProgressBlock)progressBlock completed:(SDWebImageCompletionBlock)completedBlock <br><br></code></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">开始下载（包括查找缓存的过程）<br>- (id &lt;SDWebImageOperation&gt;)downloadImageWith<br>					URL:(NSURL *)url<br>                   options:(SDWebImageOptions)options<br>                   progress:(SDWebImageDownloaderProgressBlock)progressBlock<br>                   completed:(SDWebImageCompletionWithFinishedBlock)completedBlock <br><br></code></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">查找图片<br>- (NSOperation *)queryDiskCacheForKey:(NSString *)key done:(SDWebImageQueryCompletedBlock)doneBlock <br></code></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">从缓存SDImageCache中查找图片<br>- (UIImage *)imageFromMemoryCacheForKey:(NSString *)key <br>如果查找到图片<br></code></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">从磁盘中查找图片<br>- (UIImage *)diskImageForKey:(NSString *)key<br><br></code></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">开始下载<br>- (id &lt;SDWebImageOperation&gt;)downloadImageWith<br>						URL:(NSURL *)url <br>						options:										(SDWebImageDownloaderOptions)options<br>						 progress:							(SDWebImageDownloaderProgressBlock)progressBlock<br>						  completed:(SDWebImageDownloaderCompletedBlock)completedBlock <br><br></code></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">添加下载进度的回调<br>- (void)addProgressCallback:								(SDWebImageDownloaderProgressBlock)progressBlock <br>			  completedBlock:								(SDWebImageDownloaderCompletedBlock)completedBlock<br>			   forURL:(NSURL *)url<br>			 createCallback:				<br>			 (SDWebImageNoParamsBlock)createCallback<br><br></code></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">下载的请求<br>- (id)initWithRequest:(NSURLRequest *)request<br>              options:(SDWebImageDownloaderOptions)options<br>             progress:(SDWebImageDownloaderProgressBlock)progressBlock<br>            completed:(SDWebImageDownloaderCompletedBlock)completedBlock<br>            cancelled:(SDWebImageNoParamsBlock)cancelBlock <br><br></code></pre></td></tr></table></figure>
<p>上面是简单的通过对一个图片的下载跟踪过程，整理出来的几个比较重要的方法,图片下载的流程就是-先从缓存中查找看是否已经下载-如果有直接显示，如果没有从磁盘中查找-如果找到现将图片移动到缓存中，在显示图片，如果没有找到开始下载；</p>
<p>在下面对这一步简单描述的各个流程进行简单的细化，过程中可能会存在一些问题，我们能也暂时说不清楚，会用重点的标志标记一下，希望看到这篇文章的同学也可以跟我联系，共同学习；</p>
<h3 id="1、图片的下载"><a href="#1、图片的下载" class="headerlink" title="1、图片的下载"></a>1、<a href="http://leewongsnail.github.io/blog/2016/01/27/sdwebimageyuan-ma-jie-xi-xia-zai/">图片的下载</a></h3><h3 id="2、图片的缓存"><a href="#2、图片的缓存" class="headerlink" title="2、图片的缓存"></a>2、<a href="http://leewongsnail.github.io/blog/2016/01/27/sdwebimageyuan-ma-jie-xi-huan-cun/">图片的缓存</a></h3><h3 id="3、缓存管理"><a href="#3、缓存管理" class="headerlink" title="3、缓存管理"></a>3、<a href="http://leewongsnail.github.io/blog/2016/01/27/sdwebimageyuan-ma-jie-xi-huan-cun-guan-li/">缓存管理</a></h3><h3 id="4、图片处理"><a href="#4、图片处理" class="headerlink" title="4、图片处理"></a>4、<a href="http://leewongsnail.github.io/blog/2016/01/27/sdwebimageyuan-ma-jie-xi-tu-pian-chu-li/">图片处理</a></h3><h3 id="5、多线程方面的注意-待写"><a href="#5、多线程方面的注意-待写" class="headerlink" title="5、多线程方面的注意(待写)"></a>5、多线程方面的注意(待写)</h3>]]></content>
      <categories>
        <category>源码分析</category>
      </categories>
      <tags>
        <tag>SDWebImage</tag>
        <tag>流程</tag>
      </tags>
  </entry>
  <entry>
    <title>SDWebImage - 缓存</title>
    <url>/2016/01/27/SDWebImage-3/</url>
    <content><![CDATA[<p>SDWebImage的缓存可以说是这个框架的一个重大的有点，下面我们就来了解一下这个框架的缓存是如何实现的。</p>
<p>从整体来说，SDWebImage的缓存分为两部分SDImageCache使用NSCache实现，另一部分磁盘缓存，使用NSFileManager实现</p>
<a id="more"></a>

<h4 id="下载后的图片缓存"><a href="#下载后的图片缓存" class="headerlink" title="下载后的图片缓存"></a>下载后的图片缓存</h4><p>图片下载成功之后的缓存</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">- (void)storeImage:(UIImage *)image recalculateFromImage:(BOOL)recalculate imageData:(NSData *)imageData forKey:(NSString *)key toDisk:(BOOL)toDisk<br><br></code></pre></td></tr></table></figure>
<h4 id="1、图片下载成功之后缓存到Cache中"><a href="#1、图片下载成功之后缓存到Cache中" class="headerlink" title="1、图片下载成功之后缓存到Cache中"></a>1、图片下载成功之后缓存到Cache中</h4><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">@property (strong, nonatomic) NSCache *memCache;<br><br>    &#x2F;&#x2F; if memory cache is enabled<br>    if (self.shouldCacheImagesInMemory) &#123;<br>        NSUInteger cost &#x3D; SDCacheCostForImage(image);<br>        [self.memCache setObject:image forKey:key cost:cost];<br>    &#125;<br><br></code></pre></td></tr></table></figure>
<p>self.memCache实际上就是一个NSCache,类似于字典的一种存储方式，需要传入图片的消耗</p>
<h4 id="2、图片下载成功之后缓存到磁盘"><a href="#2、图片下载成功之后缓存到磁盘" class="headerlink" title="2、图片下载成功之后缓存到磁盘"></a>2、图片下载成功之后缓存到磁盘</h4><p><code>注意：</code>这里在图片保存之前有一个图片格式转换的过程（*-&gt;PNG）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&#x2F;&#x2F; 如果image存在，但是需要重新计算(recalculate)或者data为空<br>&#x2F;&#x2F; 那就要根据image重新生成新的data<br>&#x2F;&#x2F; 不过要是连image也为空的话，那就别存了<br>if (image &amp;&amp; (recalculate || !data)) &#123;<br>&#x2F;&#x2F;#if TARGET_OS_IPHONE<br>    &#x2F;&#x2F; 我们需要判断image是PNG还是JPEG<br>    &#x2F;&#x2F; PNG的图片很容易检测出来，因为它们有一个特定的标示 (http:&#x2F;&#x2F;<br>    		www.w3.org&#x2F;TR&#x2F;PNG-Structure.html)<br>    &#x2F;&#x2F; PNG图片的前8个字节不许符合下面这些值(十进制表示)<br>    &#x2F;&#x2F; 137 80 78 71 13 10 26 10<br><br>    &#x2F;&#x2F; 如果imageData为空l (举个例子，比如image在下载后需要transform，<br>    		那么就imageData就会为空)<br>    &#x2F;&#x2F; 并且image有一个alpha通道, 我们将该image看做PNG以避免透明度<br>    		(alpha)的丢失（因为JPEG没有透明色）<br>	&#x2F;&#x2F;通过AlphaInfo获取图片的先关信息<br>	int alphaInfo &#x3D; CGImageGetAlphaInfo(image.CGImage);<br>	&#x2F;&#x2F; 该image中确实有透明信息，就认为image为PNG<br>    BOOL hasAlpha &#x3D; !(alphaInfo &#x3D;&#x3D; kCGImageAlphaNone ||<br>			  alphaInfo &#x3D;&#x3D; kCGImageAlphaNoneSkipFirst ||<br>              alphaInfo &#x3D;&#x3D; kCGImageAlphaNoneSkipLast);<br>    &#x2F;&#x2F;疑问：是否为PNG格式的图片和透明度有什么关系<br>    BOOL imageIsPng &#x3D; hasAlpha;<br><br>	&#x2F;&#x2F; 但是如果我们已经有了imageData，我们就可以直接根据data中前几个字节<br>		判断是不是PNG<br>   if ([imageData length] &gt;&#x3D; [kPNGSignatureData length]) &#123;<br>   		&#x2F;&#x2F; ImageDataHasPNGPreffix就是为了判断imageData前8个字节<br>   			是不是符合PNG标志<br>      imageIsPng &#x3D; ImageDataHasPNGPreffix(imageData);<br>   &#125;<br>   &#x2F;&#x2F;格式转换<br>   if (imageIsPng) &#123;<br>       data &#x3D; UIImagePNGRepresentation(image);<br>   &#125;<br>    else &#123;<br>        data &#x3D; UIImageJPEGRepresentation(image, (CGFloat)1.0);<br>   &#125;<br>&#x2F;&#x2F;#else<br>    data &#x3D; [NSBitmapImageRep representationOfImageRepsInArray:<br>    				image.representations <br>    				usingType: NSJPEGFileType properties:nil];<br>&#x2F;&#x2F;#endif<br>&#125;<br><br><br></code></pre></td></tr></table></figure>

<p>图片个格式处理转换完成之后，将这个图片保存到本地</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br>&#x2F;&#x2F; 首先判断disk cache的文件路径是否存在，不存在的话就创建一个<br>&#x2F;&#x2F; disk cache的文件路径是存储在_diskCachePath中的<br>if (![_fileManager fileExistsAtPath:_diskCachePath]) &#123;<br>    [_fileManager createDirectoryAtPath:_diskCachePath <br>    		withIntermediateDirectories:YES <br>    				attributes:nil error:NULL];<br>&#125;<br><br> &#x2F;&#x2F; get cache Path for image key<br> 获取图片保存的路径：<br> NSString *fullNamespace &#x3D; [@&quot;com.hackemist.SDWebImageCache.&quot; stringByAppendingString:ns];<br> 图片放在cache目录下<br> [directory stringByAppendingPathComponent:fullNamespace]<br> 最终地址：<br> 目录+图片名（cachekey的MD5）<br>&#x2F;&#x2F; 根据image的key(一般情况下理解为image的url)组合成最终的文件路径<br>&#x2F;&#x2F; 上面那个生成的文件路径只是一个文件目录，就跟&#x2F;cache&#x2F;images&#x2F;img1.png和<br>	cache&#x2F;images&#x2F;的区别一样<br>&#x2F;&#x2F; defaultCachePathForKey后面会详解<br> NSString *cachePathForKey &#x3D; [self defaultCachePathForKey:key];<br> &#x2F;&#x2F; transform to NSUrl<br> NSURL *fileURL &#x3D; [NSURL fileURLWithPath:cachePathForKey];<br><br> [_fileManager createFileAtPath:cachePathForKey <br> 						contents:data attributes:nil];<br><br> &#x2F;&#x2F; disable iCloud backup<br> &#x2F;&#x2F;iCloud 不备份<br> if (self.shouldDisableiCloud) &#123;<br>     [fileURL setResourceValue:[NSNumber numberWithBool:YES]<br>     	 				forKey:NSURLIsExcludedFromBackupKey<br>     	  				 error:nil];<br> &#125;<br><br><br></code></pre></td></tr></table></figure>


<h3 id="缓存图片的查找："><a href="#缓存图片的查找：" class="headerlink" title="缓存图片的查找："></a>缓存图片的查找：</h3><h4 id="根据cachekey-判断这个图片是否缓存过"><a href="#根据cachekey-判断这个图片是否缓存过" class="headerlink" title="根据cachekey 判断这个图片是否缓存过"></a>根据cachekey 判断这个图片是否缓存过</h4><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">- (NSOperation *)queryDiskCacheForKey:(<br>NSString *)key done:(SDWebImageQueryCompletedBlock)doneBlock<br><br></code></pre></td></tr></table></figure>

<h4 id="从缓存中查找"><a href="#从缓存中查找" class="headerlink" title="从缓存中查找"></a>从缓存中查找</h4><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">- (UIImage *)imageFromMemoryCacheForKey:(NSString *)key<br><br>UIImage *image &#x3D; [self imageFromMemoryCacheForKey:key];<br>if (image) &#123;<br>    doneBlock(image, SDImageCacheTypeMemory);<br>    return nil;<br>&#125;<br><br>如果查找到了，直接返回图片，如果没找到请看下一步<br><br></code></pre></td></tr></table></figure>

<h4 id="从磁盘中查找"><a href="#从磁盘中查找" class="headerlink" title="从磁盘中查找"></a>从磁盘中查找</h4><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">NSOperation *operation &#x3D; [NSOperation new];<br> dispatch_async(self.ioQueue, ^&#123;<br>     if (operation.isCancelled) &#123;<br>         return;<br>     &#125;<br><br>     @autoreleasepool &#123;<br>         UIImage *diskImage &#x3D; [self diskImageForKey:key];<br>         if (diskImage &amp;&amp; self.shouldCacheImagesInMemory) &#123;<br>             NSUInteger cost &#x3D; <br>             			SDCacheCostForImage(diskImage);<br>             [self.memCache setObject:diskImage forKey:key cost:cost];<br>         &#125;<br><br>         dispatch_async(dispatch_get_main_queue(), ^&#123;<br>             doneBlock(diskImage, SDImageCacheTypeDisk);<br>         &#125;);<br>     &#125;<br> &#125;);<br><br></code></pre></td></tr></table></figure>

<p>在磁盘中查找此图片</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">- (UIImage *)diskImageForKey:(NSString *)key &#123;<br>    NSData *data &#x3D; [self diskImageDataBySearchingAllPathsForKey:key];<br>    if (data) &#123;<br>        UIImage *image &#x3D; [UIImage sd_imageWithData:data];<br>        image &#x3D; [self scaledImageForKey:key image:image];<br>        if (self.shouldDecompressImages) &#123;<br>            image &#x3D; [UIImage decodedImageWithImage:image];<br>        &#125;<br>        return image;<br>    &#125;<br>    else &#123;<br>        return nil;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>根据key获取到本地磁盘中关于这个图片的数据，注意这里stringByDeletingPathExtension方法以后可以多借鉴</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">- (NSData *)diskImageDataBySearchingAllPathsForKey:(NSString *)key &#123;<br>    NSString *defaultPath &#x3D; [self defaultCachePathForKey:key];<br>    NSData *data &#x3D; [NSData dataWithContentsOfFile:defaultPath];<br>    if (data) &#123;<br>        return data;<br>    &#125;<br><br>    &#x2F;&#x2F; checking the key with and without the extension<br>    data &#x3D; [NSData dataWithContentsOfFile:<br>    			[defaultPath stringByDeletingPathExtension]];<br>    if (data) &#123;<br>        return data;<br>    &#125;<br><br>    NSArray *customPaths &#x3D; [self.customPaths copy];<br>    for (NSString *path in customPaths) &#123;<br>        NSString *filePath &#x3D; <br>        				[self cachePathForKey:key inPath:path];<br>        NSData *imageData &#x3D; <br>        				[NSData dataWithContentsOfFile:filePath];<br>        				<br>        if (imageData) &#123;<br>            return imageData;<br>        &#125;<br><br>        &#x2F;&#x2F; checking the key with and without the extension<br>        imageData &#x3D; <br>        			[NSData dataWithContentsOfFile:<br>        			[filePath stringByDeletingPathExtension]];<br>        if (imageData) &#123;<br>            return imageData;<br>        &#125;<br>    &#125;<br><br>    return nil;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>根据key，获取这个图片在本地如果存在的话，返回图片的路径，这里的方法和图片下载完成之后图片的存储地址的生成是相同的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">- (NSString *)defaultCachePathForKey:(NSString *)key &#123;<br>    return [self cachePathForKey:key inPath:self.diskCachePath];<br>&#125;<br><br>- (NSString *)cachePathForKey:(NSString *)key inPath:(NSString *)path &#123;<br>    NSString *filename &#x3D; [self cachedFileNameForKey:key];<br>    return [path stringByAppendingPathComponent:filename];<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>对图片名称进行MD5的方法（可以保留做一个工具方法）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">- (NSString *)cachedFileNameForKey:(NSString *)key &#123;<br>    const char *str &#x3D; [key UTF8String];<br>    if (str &#x3D;&#x3D; NULL) &#123;<br>        str &#x3D; &quot;&quot;;<br>    &#125;<br>    <br>    &#x2F;&#x2F; 使用了MD5进行加密处理<br>    &#x2F;&#x2F; 开辟一个16字节（128位：md5加密出来就是128bit）的空间<br>    unsigned char r[CC_MD5_DIGEST_LENGTH];<br>    &#x2F;&#x2F; 官方封装好的加密方法<br>    &#x2F;&#x2F; 把str字符串转换成了32位的16进制数列（这个过程不可逆转） <br>    	存储到了r这个空间中<br>    CC_MD5(str, (CC_LONG)strlen(str), r);<br>    &#x2F;&#x2F; 最终生成的文件名就是 &quot;md5码&quot;+&quot;.文件类型&quot;<br>    NSString *filename &#x3D; <br>    				     [NSString stringWithFormat:<br>    						@&quot;%02x%02x%02x%02x%02x%02x%02x%02x<br>    						%02x%02x%02x%02x%02x%02x%02x%02x%@&quot;,<br>              r[0], r[1], r[2], r[3], r[4], r[5], r[6], <br>              r[7], r[8], r[9], r[10], r[11], r[12], r[13], <br>              r[14], r[15], <br>              [[key pathExtension] isEqualToString:@&quot;&quot;] <br>              ? @&quot;&quot; <br>              : [NSString stringWithFormat:@&quot;.%@&quot;, [key 											pathExtension]]];<br><br>    return filename;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>计算图片的消耗</p>
<pre><code>cost 被用来计算缓存中所有对象的代价。当内存受限或者所有缓存对象的总代价超过了最大允许的值时，缓存会移除其中的一些对象。
通常，精确的 cost 应该是对象占用的字节数</code></pre>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">FOUNDATION_STATIC_INLINE NSUInteger SDCacheCostForImage(UIImage *image) &#123;<br>	&#x2F;&#x2F;这里我觉得这样写不是很好，如果这样写就更直观了<br>	&#x2F;&#x2F; return (height * scale) * (width * scale)<br>	<br>    return image.size.height * image.size.width * image.scale * image.scale;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>图片找到之后</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">dispatch_main_sync_safe(^&#123;<br>  __strong __typeof(weakOperation) strongOperation &#x3D;<br>  												 weakOperation;<br>  if (strongOperation &amp;&amp; !strongOperation.isCancelled) &#123;<br>     completedBlock(image, nil, cacheType, YES, url);<br>  &#125;<br>&#125;);<br> @synchronized (self.runningOperations) &#123;<br>    [self.runningOperations removeObject:operation];<br> &#125;<br><br></code></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>源码分析</category>
      </categories>
      <tags>
        <tag>SDWebImage</tag>
        <tag>NSCache</tag>
        <tag>SDImageCache</tag>
      </tags>
  </entry>
  <entry>
    <title>SDWebImage - 图片处理</title>
    <url>/2016/01/27/SDWebImage-5/</url>
    <content><![CDATA[<p>本篇文章主要是介绍了，在SDWebImage源码查看过程中的一些对于图片处理的方法，这些方法可能在平时的工作中也会用到，所以单独拿出来一篇文章来介绍这些方法。</p>
<p>关于图片处理的方法个人本身了解的并不深，初期阶段可能只是简单的介绍一下，添加一些自己的理解，如果有问题，还请大家不吝赐教。</p>
<a id="more"></a>


<h4 id="图片的解码"><a href="#图片的解码" class="headerlink" title="图片的解码"></a>图片的解码</h4><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">+ (UIImage *)decodedImageWithImage:(UIImage *)image &#123;<br>    &#x2F;&#x2F; while downloading huge amount of images<br>    &#x2F;&#x2F; autorelease the bitmap context<br>    &#x2F;&#x2F; and all vars to help system to free memory<br>    &#x2F;&#x2F; when there are memory warning.<br>    &#x2F;&#x2F; on iOS7, do not forget to call<br>    &#x2F;&#x2F; [[SDImageCache sharedImageCache] clearMemory];<br>    <br>    @autoreleasepool&#123;<br>        &#x2F;&#x2F; do not decode animated images<br>        if (image.images) &#123; return image; &#125;<br>    <br>        CGImageRef imageRef &#x3D; image.CGImage;<br>    <br>        CGImageAlphaInfo alpha &#x3D; CGImageGetAlphaInfo(imageRef);<br>        BOOL anyAlpha &#x3D; (alpha &#x3D;&#x3D; kCGImageAlphaFirst<br>        	 			||alpha &#x3D;&#x3D; kCGImageAlphaLast<br>        	 			||alpha &#x3D;&#x3D;kCGImageAlphaPremultipliedFirst<br>        	 			||alpha&#x3D;&#x3D;kCGImageAlphaPremultipliedLast);<br>    <br>        if (anyAlpha) &#123; return image; &#125;<br>    <br>        size_t width &#x3D; CGImageGetWidth(imageRef);<br>        size_t height &#x3D; CGImageGetHeight(imageRef);<br>    <br>        &#x2F;&#x2F; current<br>        CGColorSpaceModel imageColorSpaceModel &#x3D; <br>        CGColorSpaceGetModel(CGImageGetColorSpace(imageRef));<br>        <br>        CGColorSpaceRef colorspaceRef &#x3D; <br>        						CGImageGetColorSpace(imageRef);<br>        <br>        bool unsupportedColorSpace &#x3D; (imageColorSpaceModel &#x3D;&#x3D; 0<br>         	|| imageColorSpaceModel &#x3D;&#x3D; -1<br>			|| imageColorSpaceModel &#x3D;&#x3D; kCGColorSpaceModelCMYK <br>			|| imageColorSpaceModel&#x3D;&#x3D;kCGColorSpaceModelIndexed);<br>		<br>        if (unsupportedColorSpace)<br>            colorspaceRef &#x3D; CGColorSpaceCreateDeviceRGB();<br>    <br>        CGContextRef context &#x3D; CGBitmapContextCreate(NULL, <br>        						width,height,<br>						CGImageGetBitsPerComponent(imageRef),<br>                               0,colorspaceRef,<br>                               kCGBitmapByteOrderDefault | 								kCGImageAlphaPremultipliedFirst);<br>    <br>        &#x2F;&#x2F; Draw the image into the context and retrieve the new <br>        	image, which will now have an alpha layer<br>        	<br>        CGContextDrawImage(context, CGRectMake(0, 0, width,<br>        					 height), imageRef);<br>        					 <br>        CGImageRef imageRefWithAlpha &#x3D; <br>        					CGBitmapContextCreateImage(context);<br>        					<br>        UIImage *imageWithAlpha &#x3D; [UIImage <br>        					imageWithCGImage:imageRefWithAlpha <br>        					           scale:image.scale <br>        					orientation:image.imageOrientation];<br>    <br>        if (unsupportedColorSpace)<br>            CGColorSpaceRelease(colorspaceRef);<br>        <br>        CGContextRelease(context);<br>        CGImageRelease(imageRefWithAlpha);<br>        <br>        return imageWithAlpha;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>


<h4 id="由NSData转换为UIImage"><a href="#由NSData转换为UIImage" class="headerlink" title="由NSData转换为UIImage"></a>由NSData转换为UIImage</h4><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br>+ (UIImage *)sd_imageWithData:(NSData *)data &#123;<br>    if (!data) &#123;<br>        return nil;<br>    &#125;<br>    <br>    UIImage *image;<br>    NSString *imageContentType &#x3D; [NSData <br>    						sd_contentTypeForImageData:data];<br>    						<br>    if ([imageContentType isEqualToString:@&quot;image&#x2F;gif&quot;]) &#123;<br>        image &#x3D; [UIImage sd_animatedGIFWithData:data];<br>    &#125;<br>#ifdef SD_WEBP<br>    else if ([imageContentType isEqualToString:@&quot;image&#x2F;webp&quot;])<br>    &#123;<br>        image &#x3D; [UIImage sd_imageWithWebPData:data];<br>    &#125;<br>#endif<br>    else &#123;<br>        image &#x3D; [[UIImage alloc] initWithData:data];<br>        UIImageOrientation orientation &#x3D; [self <br>        				sd_imageOrientationFromImageData:data];<br>        				<br>        if (orientation !&#x3D; UIImageOrientationUp) &#123;<br>            image &#x3D; [UIImage imageWithCGImage:image.CGImage<br>                                        scale:image.scale<br>                                  orientation:orientation];<br>        &#125;<br>    &#125;<br><br><br>    return image;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h4 id="根据图片的NSData判断这个图片的类型"><a href="#根据图片的NSData判断这个图片的类型" class="headerlink" title="根据图片的NSData判断这个图片的类型"></a>根据图片的NSData判断这个图片的类型</h4><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">+ (NSString *)sd_contentTypeForImageData:(NSData *)data &#123;<br>    uint8_t c;<br>    [data getBytes:&amp;c length:1];<br>    switch (c) &#123;<br>        case 0xFF:<br>            return @&quot;image&#x2F;jpeg&quot;;<br>        case 0x89:<br>            return @&quot;image&#x2F;png&quot;;<br>        case 0x47:<br>            return @&quot;image&#x2F;gif&quot;;<br>        case 0x49:<br>        case 0x4D:<br>            return @&quot;image&#x2F;tiff&quot;;<br>        case 0x52:<br>            &#x2F;&#x2F; R as RIFF for WEBP<br>            if ([data length] &lt; 12) &#123;<br>                return nil;<br>            &#125;<br><br>            NSString *testString &#x3D; [[NSString alloc] <br>            initWithData:<br>            	[data subdataWithRange:NSMakeRange(0, 12)] <br>            				  encoding:NSASCIIStringEncoding];<br>            				<br>            if ([testString hasPrefix:@&quot;RIFF&quot;]<br>             &amp;&amp; [testString hasSuffix:@&quot;WEBP&quot;]<br>             )<br>             &#123;<br>                return @&quot;image&#x2F;webp&quot;;<br>            &#125;<br><br>            return nil;<br>    &#125;<br>    return nil;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h4 id="NSData转Gif"><a href="#NSData转Gif" class="headerlink" title="NSData转Gif"></a>NSData转Gif</h4><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">+ (UIImage *)sd_animatedGIFWithData:(NSData *)data &#123;<br>    if (!data) &#123;<br>        return nil;<br>    &#125;<br><br>    CGImageSourceRef source &#x3D;<br>    					 CGImageSourceCreateWithData((__bridge 										CFDataRef)data, NULL);<br><br>    size_t count &#x3D; CGImageSourceGetCount(source);<br><br>    UIImage *animatedImage;<br><br>    if (count &lt;&#x3D; 1) &#123;<br>        animatedImage &#x3D; [[UIImage alloc] initWithData:data];<br>    &#125;<br>    else &#123;<br>        NSMutableArray *images &#x3D; [NSMutableArray array];<br><br>        NSTimeInterval duration &#x3D; 0.0f;<br><br>        for (size_t i &#x3D; 0; i &lt; count; i++) &#123;<br>            CGImageRef image &#x3D; <br>            			CGImageSourceCreateImageAtIndex(source, <br>            									      i, NULL);<br><br>            duration +&#x3D; [self sd_frameDurationAtIndex:i <br>            									source:source];<br><br>            [images addObject:[UIImage imageWithCGImage:image <br>            					scale:[UIScreen mainScreen].scale <br>            			  orientation:UIImageOrientationUp]];<br><br>            CGImageRelease(image);<br>        &#125;<br><br>        if (!duration) &#123;<br>            duration &#x3D; (1.0f &#x2F; 10.0f) * count;<br>        &#125;<br><br>        animatedImage &#x3D; [UIImage animatedImageWithImages:images<br>        									  duration:duration];<br>    &#125;<br><br>    CFRelease(source);<br><br>    return animatedImage;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h4 id="讲一个webP转换为UIImage"><a href="#讲一个webP转换为UIImage" class="headerlink" title="讲一个webP转换为UIImage"></a>讲一个webP转换为UIImage</h4><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">+ (UIImage *)sd_imageWithWebPData:(NSData *)data &#123;<br>    WebPDecoderConfig config;<br>    if (!WebPInitDecoderConfig(&amp;config)) &#123;<br>        return nil;<br>    &#125;<br><br>    if (WebPGetFeatures(data.bytes, data.length,<br>    					 &amp;config.input) !&#x3D; VP8_STATUS_OK) &#123;<br>        return nil;<br>    &#125;<br><br>    config.output.colorspace &#x3D; config.input.has_alpha ?<br>    								 MODE_rgbA : MODE_RGB;<br>    config.options.use_threads &#x3D; 1;<br><br>    &#x2F;&#x2F; Decode the WebP image data into a RGBA value array.<br>    if (WebPDecode(data.bytes, data.length, &amp;config) !&#x3D; <br>    									VP8_STATUS_OK)<br>    &#123;<br>        return nil;<br>    &#125;<br><br>    int width &#x3D; config.input.width;<br>    int height &#x3D; config.input.height;<br>    if (config.options.use_scaling) &#123;<br>        width &#x3D; config.options.scaled_width;<br>        height &#x3D; config.options.scaled_height;<br>    &#125;<br><br>    &#x2F;&#x2F; Construct a UIImage from the decoded RGBA value array.<br>    CGDataProviderRef provider &#x3D;<br>    CGDataProviderCreateWithData(NULL,<br>     		config.output.u.RGBA.rgba,<br>     		 config.output.u.RGBA.size,<br>     		  FreeImageData);<br>     		  <br>    CGColorSpaceRef colorSpaceRef &#x3D; <br>    							CGColorSpaceCreateDeviceRGB();<br>    							<br>    CGBitmapInfo bitmapInfo &#x3D; config.input.has_alpha ? <br>    kCGBitmapByteOrder32Big | kCGImageAlphaPremultipliedLast<br>     : 0;<br>    <br>    size_t components &#x3D; config.input.has_alpha ? 4 : 3;<br>    <br>    CGColorRenderingIntent renderingIntent &#x3D;<br>    								 kCGRenderingIntentDefault;<br>    								 <br>    CGImageRef imageRef &#x3D; CGImageCreate(width, height, 8, components * 8, components * width, colorSpaceRef, bitmapInfo, provider, NULL, NO, renderingIntent);<br><br>    CGColorSpaceRelease(colorSpaceRef);<br>    CGDataProviderRelease(provider);<br><br>    UIImage *image &#x3D; [[UIImage alloc] initWithCGImage:imageRef];<br>    CGImageRelease(imageRef);<br><br>    return image;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h4 id="其他格式"><a href="#其他格式" class="headerlink" title="其他格式"></a>其他格式</h4><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">其他格式的图片的转换比较简单，直接使用<br>[[UIImage alloc] initWithData:data];<br>就可以<br><br></code></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>源码分析</category>
      </categories>
      <tags>
        <tag>SDWebImage</tag>
        <tag>图片解码</tag>
        <tag>图片格式</tag>
      </tags>
  </entry>
  <entry>
    <title>常用的SQL语句</title>
    <url>/2018/04/12/Userful-SQL/</url>
    <content><![CDATA[<p>SQL 是一门 ANSI 的标准计算机语言，用来访问和操作数据库系统。SQL 语句用于取回和更新数据库中的数据。SQL 可与数据库程序协同工作，比如 MS Access、DB2、Informix、MS SQL Server、Oracle、Sybase 以及其他数据库系统。</p>
<a id="more"></a>

<h2 id="SQL-SELECT-语句"><a href="#SQL-SELECT-语句" class="headerlink" title="SQL SELECT 语句"></a>SQL SELECT 语句</h2><p>语法：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> 列名称 <span class="hljs-keyword">FROM</span> 表名称<br>或者<br><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> 表名称<br></code></pre></td></tr></table></figure>
<p><code>注释</code>：SQL 语句对大小写不敏感。SELECT 等效于 select。</p>
<h2 id="SQL-SELECT-DISTINCT-语句"><a href="#SQL-SELECT-DISTINCT-语句" class="headerlink" title="SQL SELECT DISTINCT 语句"></a>SQL SELECT DISTINCT 语句</h2><p>在表中，可能会包含重复值。这并不成问题，不过，有时您也许希望仅仅列出不同（distinct）的值。</p>
<p>语法：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> 列名称 <span class="hljs-keyword">FROM</span> 表名称<br><br></code></pre></td></tr></table></figure>

<h2 id="SQL-WHERE-子句"><a href="#SQL-WHERE-子句" class="headerlink" title="SQL WHERE 子句"></a>SQL WHERE 子句</h2><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> 列名称 <span class="hljs-keyword">FROM</span> 表名称 <span class="hljs-keyword">WHERE</span> 列 运算符 值<br><br></code></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>操作符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>=</td>
<td>等于</td>
</tr>
<tr>
<td>&lt;&gt;</td>
<td>不等于</td>
</tr>
</tbody></table>
<blockquote>
<p>   | 大于<br>&lt;    | 小于<br>=    | 大于等于<br>&lt;=    | 小于等于<br>BETWEEN    | 在某个范围内<br>LIKE    | 搜索某种模式</p>
</blockquote>
<h2 id="SQL-AND-amp-OR-运算符"><a href="#SQL-AND-amp-OR-运算符" class="headerlink" title="SQL AND &amp; OR 运算符"></a>SQL AND &amp; OR 运算符</h2><p>AND 和 OR 可在 WHERE 子语句中把两个或多个条件结合起来。<br>如果第一个条件和第二个条件都成立，则 AND 运算符显示一条记录。<br>如果第一个条件和第二个条件中只要有一个成立，则 OR 运算符显示一条记录。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> Persons <span class="hljs-keyword">WHERE</span> firstname=<span class="hljs-string">&#x27;Thomas&#x27;</span> <span class="hljs-keyword">OR</span> lastname=<span class="hljs-string">&#x27;Carter&#x27;</span><br><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> Persons <span class="hljs-keyword">WHERE</span> FirstName=<span class="hljs-string">&#x27;Thomas&#x27;</span> <span class="hljs-keyword">AND</span> LastName=<span class="hljs-string">&#x27;Carter&#x27;</span><br><br></code></pre></td></tr></table></figure>

<h2 id="SQL-ORDER-BY-子句"><a href="#SQL-ORDER-BY-子句" class="headerlink" title="SQL ORDER BY 子句"></a>SQL ORDER BY 子句</h2><p>ORDER BY 语句用于对结果集进行排序。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> Company, OrderNumber <span class="hljs-keyword">FROM</span> Orders <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> Company<br><span class="hljs-keyword">SELECT</span> Company, OrderNumber <span class="hljs-keyword">FROM</span> Orders <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> Company <span class="hljs-keyword">DESC</span><br><br></code></pre></td></tr></table></figure>

<h2 id="SQL-INSERT-INTO-语句"><a href="#SQL-INSERT-INTO-语句" class="headerlink" title="SQL INSERT INTO 语句"></a>SQL INSERT INTO 语句</h2><p>INSERT INTO 语句用于向表格中插入新的行。</p>
<p>语法：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> 表名称 <span class="hljs-keyword">VALUES</span> (值<span class="hljs-number">1</span>, 值<span class="hljs-number">2</span>,....)<br><br></code></pre></td></tr></table></figure>

<p>我们也可以指定所要插入数据的列：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> table_name (列<span class="hljs-number">1</span>, 列<span class="hljs-number">2</span>,...) <span class="hljs-keyword">VALUES</span> (值<span class="hljs-number">1</span>, 值<span class="hljs-number">2</span>,....)<br><br></code></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> Persons <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">&#x27;Gates&#x27;</span>, <span class="hljs-string">&#x27;Bill&#x27;</span>, <span class="hljs-string">&#x27;Xuanwumen 10&#x27;</span>, <span class="hljs-string">&#x27;Beijing&#x27;</span>)<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> Persons (LastName, Address) <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">&#x27;Wilson&#x27;</span>, <span class="hljs-string">&#x27;Champs-Elysees&#x27;</span>)<br></code></pre></td></tr></table></figure>

<h2 id="SQL-UPDATE-语句"><a href="#SQL-UPDATE-语句" class="headerlink" title="SQL UPDATE 语句"></a>SQL UPDATE 语句</h2><p>Update 语句用于修改表中的数据。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">UPDATE</span> 表名称 <span class="hljs-keyword">SET</span> 列名称 = 新值 <span class="hljs-keyword">WHERE</span> 列名称 = 某值<br><br></code></pre></td></tr></table></figure>

<p>例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">UPDATE</span> Person <span class="hljs-keyword">SET</span> Address = <span class="hljs-string">&#x27;Zhongshan 23&#x27;</span>, City = <span class="hljs-string">&#x27;Nanjing&#x27;</span><br><span class="hljs-keyword">WHERE</span> LastName = <span class="hljs-string">&#x27;Wilson&#x27;</span><br></code></pre></td></tr></table></figure>

<h2 id="SQL-DELETE-语句"><a href="#SQL-DELETE-语句" class="headerlink" title="SQL DELETE 语句"></a>SQL DELETE 语句</h2><p>DELETE 语句用于删除表中的行。</p>
<p>语法：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> 表名称 <span class="hljs-keyword">WHERE</span> 列名称 = 值<br><br></code></pre></td></tr></table></figure>

<p>删除所有的行</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> table_name<br>或者<br><span class="hljs-keyword">DELETE</span> * <span class="hljs-keyword">FROM</span> table_name<br><br></code></pre></td></tr></table></figure>

<p>例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> Person <span class="hljs-keyword">WHERE</span> LastName = <span class="hljs-string">&#x27;Wilson&#x27;</span> <br><br></code></pre></td></tr></table></figure>

<h2 id="SQL-PRIMARY-KEY-约束"><a href="#SQL-PRIMARY-KEY-约束" class="headerlink" title="SQL PRIMARY KEY 约束"></a>SQL PRIMARY KEY 约束</h2><p>PRIMARY KEY 约束唯一标识数据库表中的每条记录。<br>主键必须包含唯一的值。<br>主键列不能包含 NULL 值。<br>每个表都应该有一个主键，并且每个表只能有一个主键。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> Persons<br>(<br>Id_P <span class="hljs-built_in">int</span> <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,<br>LastName <span class="hljs-built_in">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,<br>FirstName <span class="hljs-built_in">varchar</span>(<span class="hljs-number">255</span>),<br>Address <span class="hljs-built_in">varchar</span>(<span class="hljs-number">255</span>),<br>City <span class="hljs-built_in">varchar</span>(<span class="hljs-number">255</span>),<br>PRIMARY <span class="hljs-keyword">KEY</span> (Id_P)<br>)<br></code></pre></td></tr></table></figure>

<p>如果在表已存在的情况下为 “Id_P” 列创建 PRIMARY KEY 约束，请使用下面的 SQL：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> Persons<br><span class="hljs-keyword">ADD</span> PRIMARY <span class="hljs-keyword">KEY</span> (Id_P)<br></code></pre></td></tr></table></figure>

<p>撤销 PRIMARY KEY 约束</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> Persons<br><span class="hljs-keyword">DROP</span> PRIMARY <span class="hljs-keyword">KEY</span><br></code></pre></td></tr></table></figure>


<h2 id="SQL-FOREIGN-KEY-约束"><a href="#SQL-FOREIGN-KEY-约束" class="headerlink" title="SQL FOREIGN KEY 约束"></a>SQL FOREIGN KEY 约束</h2><p>一个表中的 FOREIGN KEY 指向另一个表中的 PRIMARY KEY。</p>
<p>FOREIGN KEY 约束用于预防破坏表之间连接的动作。<br>FOREIGN KEY 约束也能防止非法数据插入外键列，因为它必须是它指向的那个表中的值之一。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> Orders<br>(<br>Id_O <span class="hljs-built_in">int</span> <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,<br>OrderNo <span class="hljs-built_in">int</span> <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,<br>Id_P <span class="hljs-built_in">int</span>,<br>PRIMARY <span class="hljs-keyword">KEY</span> (Id_O),<br><span class="hljs-keyword">FOREIGN</span> <span class="hljs-keyword">KEY</span> (Id_P) <span class="hljs-keyword">REFERENCES</span> Persons(Id_P)<br>)<br></code></pre></td></tr></table></figure>
<p>如果在 “Orders” 表已存在的情况下为 “Id_P” 列创建 FOREIGN KEY 约束，请使用下面的 SQL：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> Orders<br><span class="hljs-keyword">ADD</span> <span class="hljs-keyword">FOREIGN</span> <span class="hljs-keyword">KEY</span> (Id_P)<br><span class="hljs-keyword">REFERENCES</span> Persons(Id_P)<br></code></pre></td></tr></table></figure>

<p>撤销 FOREIGN KEY 约束</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> Orders<br><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">FOREIGN</span> <span class="hljs-keyword">KEY</span> fk_PerOrders<br></code></pre></td></tr></table></figure>

<h2 id="SQL-JOIN"><a href="#SQL-JOIN" class="headerlink" title="SQL JOIN"></a>SQL JOIN</h2><p>SQL join 用于根据两个或多个表中的列之间的关系，从这些表中查询数据。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> Persons.LastName, Persons.FirstName, Orders.OrderNo<br><span class="hljs-keyword">FROM</span> Persons, Orders<br><span class="hljs-keyword">WHERE</span> Persons.Id_P = Orders.Id_P<br></code></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> Persons.LastName, Persons.FirstName, Orders.OrderNo<br><span class="hljs-keyword">FROM</span> Persons<br><span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> Orders<br><span class="hljs-keyword">ON</span> Persons.Id_P = Orders.Id_P<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> Persons.LastName<br></code></pre></td></tr></table></figure>

<p>不同的 SQL JOIN</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">JOIN: 如果表中有至少一个匹配，则返回行<br>LEFT JOIN: 即使右表中没有匹配，也从左表返回所有的行<br>RIGHT JOIN: 即使左表中没有匹配，也从右表返回所有的行<br>FULL JOIN: 只要其中一个表中存在匹配，就返回行<br></code></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>SQL 数据库</category>
      </categories>
      <tags>
        <tag>数据库 查询 插入 更新</tag>
      </tags>
  </entry>
  <entry>
    <title>基于CTMediator的组件间跳转</title>
    <url>/2016/09/26/alimediator/</url>
    <content><![CDATA[<p>  大概在去年，APP组件化讨论的非常热，各类组件化的文章也非常的多，看了其中的几篇，也是写的挺不错，我的这个思路就是继承其中一位采用(Target-Action)思路实现跳转解耦的。</p>
<a id="more"></a>

<h4 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h4><p>  大概在去年，APP组件化讨论的非常热，各类组件化的文章也非常的多，看了其中的几篇，也是写的挺不错，我的这个思路就是继承其中一位采用(Target-Action)思路实现跳转解耦的。</p>
<p>  我看过的几个<a href="http://leewongsnail.github.io/2016/06/12/App%E7%BB%84%E4%BB%B6%E5%8C%96%E6%96%87%E7%AB%A0%E6%94%B6%E9%9B%86/">文章</a>,这里跟大家分享一下。这篇文章的demo我放到了<a href="https://github.com/LeeWongSnail/ALiMediator">这里</a></p>
<h4 id="2、跳转方法实现（借用casatwy图片）"><a href="#2、跳转方法实现（借用casatwy图片）" class="headerlink" title="2、跳转方法实现（借用casatwy图片）"></a>2、跳转方法实现（借用casatwy图片）</h4><h5 id="2-1-方案的架构图"><a href="#2-1-方案的架构图" class="headerlink" title="2.1 方案的架构图"></a>2.1 方案的架构图</h5><p><img src="https://i.niupic.com/images/2016/09/08/xk7Jto.png" alt="mediator"></p>
<h5 id="2-2-调用方式"><a href="#2-2-调用方式" class="headerlink" title="2.2 调用方式"></a>2.2 调用方式</h5><p><img src="https://i.niupic.com/images/2016/09/08/nZc6mm.png" alt="Method"></p>
<h4 id="3、项目相关"><a href="#3、项目相关" class="headerlink" title="3、项目相关"></a>3、项目相关</h4><p>  我的项目中，将每一个模块，放在一个文件夹内，将每一个模块看做一个APP，在APP内部高度封装，必要时可将整个模块复用。千万不要因为某一个模块比较小就将其放到一个大的模块中，我认为只要感觉这个模块有一定的复用性，都要把他抽出来，即使这个项目不能服用，其他项目可能也可以复用。比如 分享 搜索。</p>
<h4 id="4、最后"><a href="#4、最后" class="headerlink" title="4、最后"></a>4、最后</h4><p>  我所写的只是 我对组件化的一个入门的小理解，感觉组件化大势所趋。如果觉得这篇文章没有什么，不妨去拜读一下 前面我提供的那几篇文章。希望对你有帮助。</p>
]]></content>
      <categories>
        <category>组件化</category>
      </categories>
      <tags>
        <tag>组件跳转 中间者模式 CTMediator</tag>
      </tags>
  </entry>
  <entry>
    <title>组件化设计方案</title>
    <url>/2020/07/25/appmodule/</url>
    <content><![CDATA[<p>随着多个功能需要在多个业务线短时间内实现功能同步，我们需要将新增功能模块和已有的功能模块逐步组件化，以达到多个业务线间可快速同步的效果</p>
<a id="more"></a>

<h3 id="何为组件"><a href="#何为组件" class="headerlink" title="何为组件"></a>何为组件</h3><p>既然要实现组件化 那么什么样的叫做组件呢?<br>组件我们可以根据功能性和颗粒度的不同分为</p>
<ul>
<li>基础组件</li>
<li>独立功能组件</li>
<li>独立业务组件</li>
</ul>
<p>我们先看下对于整个APP架构，我们的层次划分</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggo04wwswaj30lf0dc3zp.jpg"></p>
<p>对于不同的业务组件我们的拆分方法和颗粒度是不同的下面我们来分别介绍一下这三种组件的设计方案</p>
<h2 id="基础组件"><a href="#基础组件" class="headerlink" title="基础组件"></a>基础组件</h2><p>基础组件是我们实现上层业务的基础，因此我们需要颗粒度较细的去拆分，根据上面的架构图我们可以看到这里所说基础组件就是APP架构中的最底层。</p>
<p>对于放到基础组件中的代码，我们务必需要遵守下面几个条件:</p>
<ul>
<li>基础组件中的代码必须无任何依赖(可依赖三方)</li>
<li>基础组件中的代码不涉及任何业务</li>
<li>基础组件中的代码为上层组件服务，尽可能精简，功能也尽可能通用</li>
<li>基础组件中不应包含任何资源文件</li>
</ul>
<h2 id="独立功能组件"><a href="#独立功能组件" class="headerlink" title="独立功能组件"></a>独立功能组件</h2><p>独立功能组件，实际上是对上层常用功能的封装，比如基类、数据库、网络、图片下载和展示等。拆分的颗粒度同样要求较细，相似的功能应尽可能的拆分。</p>
<p>独立功能组件在层次结构上位于基础组件的上层，可依赖基础组件的代码。</p>
<p>对于放到独立功能组件中的代码，我们务必遵守下面几个条件:</p>
<ul>
<li>功能独立，每个组件代码要求遵守单一功能原则，不可合并类似功能的组件为一个大组件</li>
<li>明确每个组件所属类别，例如：UI控件、网络模块</li>
<li>每个功能模块如果依赖上层的配置 需要提供明确的接口供上层设置</li>
<li>功能设计不涉及业务开关，如果需要那么提供配置来进行功能区分</li>
<li>如果独立的功能有资源文件，那么资源文件考虑由外部配置，或者提供支持多条业务线的资源文件包</li>
<li>多个独立功能组件间尽量减少依赖关系，尤其不可互相依赖</li>
<li>独立功能组件必须是多个模块共用的，不可将只有某个模块使用的组件放入</li>
<li>独立功能组件不可依赖上层组件</li>
</ul>
<h2 id="独立业务组件"><a href="#独立业务组件" class="headerlink" title="独立业务组件"></a>独立业务组件</h2><p>独立业务组件，顾名思义一个独立的业务功能模块，是某个业务的多个功能模块的集合。往往也是我们组件化过程中最复杂和最难的部分，当然也是我们这篇文章中重点介绍的部分。</p>
<p>下面我们来详细的介绍下，业务组件化的主要流程：</p>
<ul>
<li>组件代码模块化</li>
<li>组件内引用外部解耦</li>
<li>组件外引用组件内方法解耦</li>
<li>组件资源整理</li>
<li>组件间的跳转</li>
<li>组件多业务兼容</li>
</ul>
<p>下面我们来详细的描述这几个流程</p>
<h3 id="组件代码模块化"><a href="#组件代码模块化" class="headerlink" title="组件代码模块化"></a>组件代码模块化</h3><p>模块化，实际上是组件化过程中的一个中间形态，对于不是太复杂的工程中实际上做到模块化就可以了，但是对于较为复杂的工程组件化才是其终极形态。</p>
<h4 id="组件代码归纳集中"><a href="#组件代码归纳集中" class="headerlink" title="组件代码归纳集中"></a>组件代码归纳集中</h4><p>这一步我们主要的工作是:将同属于该业务的分散在各个位置的功能页面集中到一个文件夹中。如果之前的项目就是根据业务模块按照MVC或者MVVM的实体文件夹结构来划分的，那么恭喜你，这一步的工作量可以大大减少。</p>
<p>而对于将要移动到业务组件中的业务代码，我们需要确认该功能模块是否隶属于该业务模块。实际上这是对整个项目的业务模块划分，这样我们才能比较清楚的了解每个业务模块应该包含哪些内容。</p>
<p><code>注意</code>:代码集中时务必要使用实体文件夹进行管理</p>
<h4 id="按照组件结构模块化"><a href="#按照组件结构模块化" class="headerlink" title="按照组件结构模块化"></a>按照组件结构模块化</h4><p>再将业务模块代码集中到独立文件夹后，我们可以根据组件化的模块结构对业务组件代码重新进行文件结构划分。</p>
<p>下面我们先看下组件化结构中文件夹结构划分，以及每个文件夹下代码的功能</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggo47497wdj30xb08dacc.jpg"></p>
<p>当然在这个过程中，我们可以再次检查是否有遗漏的未移动的代码，同时要将外部涉及该业务模块的代码删除，统一移动到组件模块中进行统一的管理</p>
<h3 id="抽取组件中的各类常量"><a href="#抽取组件中的各类常量" class="headerlink" title="抽取组件中的各类常量"></a>抽取组件中的各类常量</h3><p>在将业务组件的代码都归纳整理之后，我们需要抽取该业务模块中的一些常量。</p>
<p>下面我们罗列了其中的集中类型的常量，如图所示：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggo51fpm4bj30jr06iaao.jpg"></p>
<p>我们需要将之前写死在代码中的常量提取到这几个文件中，实现统一管理。</p>
<h3 id="组件内引用外部解耦"><a href="#组件内引用外部解耦" class="headerlink" title="组件内引用外部解耦"></a>组件内引用外部解耦</h3><p>组件化过程中，其实最复杂的就是解耦。首先我们需要知道组件内引用了多少外部业务组件的类，然后分别进行解耦。</p>
<p>这一步的操作流程：</p>
<ul>
<li><p>通过查看组件中的每一个类，确认头文件和实现文件中对外部类的引用，然后通过文档进行记录。</p>
</li>
<li><p>将项目中的其他业务删除只保留当前组件化的业务模块，保证可以编译通过，进而找到之前隐藏未发现的依赖并记录。</p>
</li>
<li><p>确认记录的每一个类该如何解决，解决方法大抵分为下面几种方法</p>
<p>  1、将依赖外部的类复制一份放到组件中<br>  2、将依赖的方法抽取放到组件中<br>  3、将依赖的类解耦后放到独立功能组件中<br>  4、如果只是跳转依赖，那么记录后 在后续考虑如何解耦</p>
</li>
</ul>
<p>这一步操作完成后，我们实现了组件对外部依赖的耦合，且当前项目在只保留基础组件、独立项目组件和该业务组件时可以编译通过。</p>
<h3 id="组件外引用组件内方法解耦"><a href="#组件外引用组件内方法解耦" class="headerlink" title="组件外引用组件内方法解耦"></a>组件外引用组件内方法解耦</h3><p>完成组件内对外部的引用解耦之后，我们下一步要做的就是组件外部内内部的引用。</p>
<p>这一步的操作流程:</p>
<ul>
<li><p>将该模块从项目中移除通过编译报错的方式确认外部对改模块的依赖并记录成wiki</p>
</li>
<li><p>对于这部分发现的依赖主要有下面几种解决方法</p>
<p>  1、如果是外部跳转到该组件，那么需要改为调用该组件提供的跳转方法，进行跳转同时进行解耦</p>
<p>  2、如果外部依赖了组件内的某些类或者方法那么可以采取类似解决内因外耦合的方式通过复制类，复制方法或者通过非显示调用的方式进行解耦。</p>
</li>
</ul>
<p>这一步操作完成后，我们基本上已经实现了代码层面的解耦！</p>
<h3 id="组件资源整理"><a href="#组件资源整理" class="headerlink" title="组件资源整理"></a>组件资源整理</h3><p>组件的资源包括下面几个：</p>
<ul>
<li>国际化资源(不同语言文字转换)</li>
<li>图片资源(尤其是图片上有中文，或者图片与APP的icon有关)</li>
<li>文件资源(lottie资源、plist配置文件)</li>
</ul>
<p>我们首先需要将该组件用到的说有图片资源，放到一起，然后根据上面这三种类型对资源进行分类。其次我们需要将差异化的资源(例如图片上有中文的图片),根据不同业务线(业务线A、业务线B、业务线C)分别建立一个资源文件夹。</p>
<p>经过上述的整理最终的资源文件夹结构应该是</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggo9p64slcj30hn03kglt.jpg"></p>
<p>在不同的业务线即不同的APP中，我们使用图中的Public Resource和对应业务线的Resource。</p>
<p>在这一步操作完成后，我们基本上实现了不同业务线在该组件的资源整理和使用。</p>
<h2 id="组件间的跳转"><a href="#组件间的跳转" class="headerlink" title="组件间的跳转"></a>组件间的跳转</h2><p>组件间的跳转，实际上是组件化中最重要的一部，因为经过上面的这些操作，我们将组件的代码从主工程中剥离，且可以独立编译通过。但是这个模块目前并没有与主工程链接起来。</p>
<p>所以组件间跳转实际上就是在主工程中将所有的组件链接起来。</p>
<p>组件化时，组件间的跳转大体有两种思路：</p>
<ul>
<li>1、基于 URL Router、ModuleManager的跳转(目前博客已删除活设置为私有)</li>
<li>2、基于Target-Action的组件间跳转</li>
<li>3、iOS 组件化方案探索</li>
</ul>
<p>第三篇博客(Bang神)实际上比较了方案1和方案2两种做法，下面是从文章中摘抄出的总结：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">上面论述下方案1(Target-Action)确实比方案2+方案3(Router)简单明了，没有 注册表常驻内存&#x2F;参数传<br>递限制&#x2F;调用分散 这些缺点，方案1多做的一步是需要对所有组件方法进行一层 wrapper，但若想要明确提供<br>组件的方法和参数类型，解耦统一处理，方案2和方案3同样需要多加这层。<br></code></pre></td></tr></table></figure>
<p>但是，对于目前项目来说，盲目的迁移到Router或者Mediator实现组件间的跳转显然不太实际，而且维护的成本较高。</p>
<p>因此，我们采取的方法是在之前跳转的基础上稍加改动，并结合使用ProtocolKit进行解耦。</p>
<p>项目中之前就存在一个JumpUtil类这个类管理了项目中页面间的跳转，不过仍然可能会存在某些直接创建对应目标控制器并通过PUSH或Present方式跳转到对应页面。</p>
<p>因此 我们要做的第一件事为：将所有跳转到当前组件内页面的跳转方法统一改到JumpUtil中实现。每个模块我们通过创建JumpUtil对应分类的方式进行跳转的管理。通过这种方式，外部类在往组件中页面跳转时只需要引用JumpUtil对应的分类即可，不需要引用对应的控制器。</p>
<p>对于组件内部需要跳转到组件外的场景，我们使用ProtocolKit的方式进行解耦。</p>
<p><code>ProtocolKit 实际上是为对应的某个协议写一个默认实现。即我们声明了某个协议之后，不需要设置代理，直接调用协议中的方法。即可调用到我们写的默认实现中。</code></p>
<p>下面我们贴出ProtoclKit的核心源码:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">// For a magic reserved keyword color, use @defs(your_protocol_name)</span><br><span class="hljs-comment">//defs 只是 _pk_extension 的别名，为了提供一个更加合适的名字作为接口 使用的时候用@defs()</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> defs _pk_extension</span><br><br><span class="hljs-comment">// 我们使用的时候用@defs(Protocol)实际上是调用_pk_extension_imp方法</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> _pk_extension($protocol) _pk_extension_imp($protocol, _pk_get_container_class($protocol))</span><br><br><span class="hljs-comment">// 这个宏实际上是创建了一个隐藏类(container_class) 这个类遵守protocol这个协议</span><br><span class="hljs-comment">// 然后在load方法中调用内部实现的load(load方法也是在main函数执行之前执行的)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> _pk_extension_imp($protocol, $container_class) \</span><br>    protocol $protocol; \<br>    <span class="hljs-class"><span class="hljs-keyword">@interface</span> $<span class="hljs-title">container_class</span> : <span class="hljs-title">NSObject</span> &lt;$<span class="hljs-title">protocol</span>&gt; @<span class="hljs-title">end</span> \</span><br>    <span class="hljs-class"><span class="hljs-keyword">@implementation</span> $<span class="hljs-title">container_class</span> \</span><br>    + (<span class="hljs-keyword">void</span>)load &#123; \<br>        _pk_extension_load(<span class="hljs-class"><span class="hljs-keyword">@protocol</span>($<span class="hljs-title">protocol</span>), $<span class="hljs-title">container_class</span>.<span class="hljs-title">class</span>); \</span><br>    &#125; \<br><br><span class="hljs-comment">// _pk_get_container_class 实际上就是生成一个类名</span><br><span class="hljs-comment">// 可以看到这个类名实际上是由类名+协议名+count(一个计数器每次调用会自动加一)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> _pk_get_container_class($protocol) _pk_get_container_class_imp($protocol, __COUNTER__)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> _pk_get_container_class_imp($protocol, $counter) _pk_get_container_class_imp_concat(__PKContainer_, $protocol, $counter)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> _pk_get_container_class_imp_concat($a, $b, $c) $a ## $b ## _ ## $c</span><br><br><span class="hljs-keyword">void</span> _pk_extension_load(Protocol *protocol, Class containerClass);<br></code></pre></td></tr></table></figure>

<p>因此当A组件中的某个事件响应要跳转到B组件中的某个页面时</p>
<p>之前的写法：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-meta">#import <span class="hljs-meta-string">&quot;BViewController.h&quot;</span></span><br>- (<span class="hljs-keyword">void</span>)moduleAJumpToModuleB &#123;<br>    BViewController *bVc = [[BViewController alloc] init];<br>    [<span class="hljs-keyword">self</span>.navigationController pushViewController:bVc animated:<span class="hljs-literal">YES</span>];<br>&#125;<br></code></pre></td></tr></table></figure>
<p>修改之后的写法：</p>
<p>新建protocol</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-class"><span class="hljs-keyword">@protocol</span> <span class="hljs-title">ULModuleBJumpDelegate</span> &lt;<span class="hljs-title">NSObject</span>&gt;</span><br><br>- (<span class="hljs-keyword">void</span>)moduleAJumpToModuleB;<br><br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure>

<p>首先当前类应遵守这个协议 <code>ULModuleBJumpDelegate</code></p>
<p>跳转方法改为直接调用协议中的方法</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">- (<span class="hljs-keyword">void</span>)moduleAJumpToModuleBMediator &#123;<br>    [<span class="hljs-keyword">self</span> ul_moduleAJumpToModuleB];<br>&#125;<br></code></pre></td></tr></table></figure>

<p>最后，在组件外新建一个解耦类ULModuleBMediator并实现对应方法</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-meta">#import <span class="hljs-meta-string">&quot;BViewController.h&quot;</span></span><br><br><span class="hljs-keyword">@defs</span>(ULModuleBJumpDelegate)<br><br>- (<span class="hljs-keyword">void</span>)ul_moduleAJumpToModuleB &#123;<br>    BViewController *bVc = [[BViewController alloc] init];<br>    [<span class="hljs-keyword">self</span>.navigationController pushViewController:bVc animated:<span class="hljs-literal">YES</span>];<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这样我们就解除了，在A模块要跳转到B模块时必须导入B模块的相关类的问题，上面声明的协议放在A组件内，组件的实现放到外部主工程中。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对于一个成熟的项目，尤其是创建时间比较久的项目，组件化是一个任重而道远的过程，组件化过程中，我们要本着小步快走的方式，逐步进行组件化。同时也避免因为组件化而影响业务需求的进度。但组件化后，对于各个业务模块的维护有比较明显的提升同时组件在不同业务线之间进行复用也能更加的方便和快速。所以，组件化是项目的终极目标。</p>
]]></content>
      <categories>
        <category>组件化</category>
      </categories>
      <tags>
        <tag>组件化</tag>
      </tags>
  </entry>
  <entry>
    <title>block的那些事</title>
    <url>/2018/02/27/block-something/</url>
    <content><![CDATA[<p>Blocks是C语言的扩充功能，而Apple 在OS X Snow Leopard 和 iOS 4中引入了这个新功能“Blocks”。从那开始，Block就出现在iOS和Mac系统各个API中，并被大家广泛使用。一句话来形容Blocks，带有自动变量（局部变量）的匿名函数。</p>
<a id="more"></a>

<h1 id="Block的那些事"><a href="#Block的那些事" class="headerlink" title="Block的那些事"></a>Block的那些事</h1><h2 id="Block-基础"><a href="#Block-基础" class="headerlink" title="Block 基础"></a>Block 基础</h2><h4 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h4><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Block_layout</span> &#123;</span><br>    <span class="hljs-keyword">void</span> *isa;  <span class="hljs-comment">//指向block的类型</span><br>    <span class="hljs-keyword">int</span> flags;  <span class="hljs-comment">//附加信息</span><br>    <span class="hljs-keyword">int</span> reserved;   <span class="hljs-comment">//block内部的变量数</span><br>    <span class="hljs-keyword">void</span> (*invoke)(<span class="hljs-keyword">void</span> *, ...);    <span class="hljs-comment">//函数指针，指向block具体的函数调用地址</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Block_descriptor</span> *<span class="hljs-title">descriptor</span>;</span>    <span class="hljs-comment">//附加描述信息，比如变量数、大小、copy和dispose辅助操作函数指针</span><br>    <span class="hljs-comment">/* Imported variables. */</span><br>    <span class="hljs-comment">//复制到结构体中的外部局部变量或变量地址</span><br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Block_descriptor</span> &#123;</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">int</span> reserved;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">int</span> size;<br>    <span class="hljs-keyword">void</span> (*copy)(<span class="hljs-keyword">void</span> *dst, <span class="hljs-keyword">void</span> *src);<br>    <span class="hljs-keyword">void</span> (*dispose)(<span class="hljs-keyword">void</span> *);<br>&#125;;<br><br></code></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/1194012-1739b7e85e46b4db.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/510" alt="结构"></p>
<p>block中也存在一个isa指针,因此在OC中block也是被当做一个对象来看待的。</p>
<h4 id="Block的类型"><a href="#Block的类型" class="headerlink" title="Block的类型"></a>Block的类型</h4><h5 id="NSConcreteStackBlock"><a href="#NSConcreteStackBlock" class="headerlink" title="NSConcreteStackBlock"></a>NSConcreteStackBlock</h5><ul>
<li><p>只用到外部局部变量、成员属性变量，且没有强指针引用的block都是StackBlock。<br>StackBlock的生命周期由系统控制的，一旦返回之后，就被系统销毁了。</p>
</li>
<li><p>_NSConcreteStackBlock是不持有对象的。</p>
</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">//以下是在MRC下执行的</span><br>    <span class="hljs-built_in">NSObject</span> * obj = [[<span class="hljs-built_in">NSObject</span> alloc]init];<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;1.Block外 obj = %lu&quot;</span>,(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>)obj.retainCount);<br>    <br>    <span class="hljs-keyword">void</span> (^myBlock)(<span class="hljs-keyword">void</span>) = ^&#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;Block中 obj = %lu&quot;</span>,(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>)obj.retainCount);<br>    &#125;;<br>    <br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;2.Block外 obj = %lu&quot;</span>,(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>)obj.retainCount);<br>    <br>    myBlock();<br></code></pre></td></tr></table></figure>

<p>打印结果:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">1.Block外 obj &#x3D; 1<br>2.Block外 obj &#x3D; 1<br>Block中 obj &#x3D; 1<br></code></pre></td></tr></table></figure>

<p>由于_NSConcreteStackBlock所属的变量域一旦结束，那么该Block就会被销毁。<br>因此,在ARC环境下，编译器会自动的判断，把Block自动的从栈copy到堆。</p>
<p>下面四种情况下会将block从栈自动copy到堆上:</p>
<ul>
<li>1.手动调用copy</li>
<li>2.Block是函数的返回值</li>
<li>3.Block被强引用，Block被赋值给__strong或者id类型</li>
<li>4.调用系统API入参中含有usingBlcok的方法</li>
</ul>
<p><code>注意</code>:copy方法可以将block从栈上copy到堆上,dispose方法可以将堆上的block销毁。</p>
<h5 id="NSConcreteMallocBlock"><a href="#NSConcreteMallocBlock" class="headerlink" title="NSConcreteMallocBlock"></a>NSConcreteMallocBlock</h5><ul>
<li><p>有强指针引用或copy修饰的成员属性引用的block会被复制一份到堆中成为MallocBlock，没有强指针引用即销毁，生命周期由程序员控制</p>
</li>
<li><p>_NSConcreteMallocBlock是持有对象的。</p>
</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">//以下是在MRC下执行的</span><br><span class="hljs-built_in">NSObject</span> * obj = [[<span class="hljs-built_in">NSObject</span> alloc]init];<br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;1.Block外 obj = %lu&quot;</span>,(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>)obj.retainCount);<br>    <br><span class="hljs-keyword">void</span> (^myBlock)(<span class="hljs-keyword">void</span>) = [^&#123;<br>   <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;Block中 obj = %lu&quot;</span>,(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>)obj.retainCount);<br>&#125;<span class="hljs-keyword">copy</span>];<br>    <br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;2.Block外 obj = %lu&quot;</span>,(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>)obj.retainCount);<br>    <br>myBlock();<br>    <br>[myBlock release];<br>    <br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;3.Block外 obj = %lu&quot;</span>,(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>)obj.retainCount);<br><br></code></pre></td></tr></table></figure>

<p>打印结果:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-number">1.</span>Block外 obj = <span class="hljs-number">1</span><br><span class="hljs-number">2.</span>Block外 obj = <span class="hljs-number">2</span><br>Block中 obj = <span class="hljs-number">2</span><br><span class="hljs-number">3.</span>Block外 obj = <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>

<h5 id="NSConcreteGlobalBlock"><a href="#NSConcreteGlobalBlock" class="headerlink" title="NSConcreteGlobalBlock"></a>NSConcreteGlobalBlock</h5><ul>
<li><p>没有用到外界变量或只用到全局变量、静态变量的block为_NSConcreteGlobalBlock，生命周期从创建到应用程序结束。</p>
</li>
<li><p>_NSConcreteGlobalBlock也不持有对象</p>
</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">//以下是在MRC下执行的</span><br><span class="hljs-keyword">void</span> (^myBlock)(<span class="hljs-keyword">void</span>) = ^&#123;<br>   <br>   <span class="hljs-built_in">NSObject</span> * obj = [[<span class="hljs-built_in">NSObject</span> alloc]init];<br>   <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;Block中 obj = %lu&quot;</span>,(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>)obj.retainCount);<br>&#125;;<br>    <br>myBlock();<br><br></code></pre></td></tr></table></figure>

<p>打印结果:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">Block 中 obj = <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>

<h5 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h5><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">-(<span class="hljs-keyword">void</span>)method &#123; <br><span class="hljs-comment">//在ARC环境下，Block也是存在__NSStackBlock的时候的，平时见到最多的是_NSConcreteMallocBlock，是因为我们会对Block有赋值操作，所以ARC下，block 类型通过=进行传递时，会导致调用objc_retainBlock-&gt;_Block_copy-&gt;_Block_copy_internal方法链。并导致 __NSStackBlock__ 类型的 block 转换为 __NSMallocBlock__ 类型。</span><br>  <span class="hljs-keyword">int</span> a = <span class="hljs-number">3</span>;<br>  <span class="hljs-keyword">void</span>(^block)() = ^&#123;<br>      NSLog(@<span class="hljs-string">&quot;调用block%d&quot;</span>,a);<span class="hljs-comment">//这里的变量a，和self.string是一样效果</span><br>  &#125;;<br>  NSLog(@<span class="hljs-string">&quot;%@&quot;</span>,block);<br><span class="hljs-comment">//打印结果:&lt;__NSMallocBlock__: 0x7fc498746000&gt;</span><br><span class="hljs-comment">//此时后面的匿名函数赋值给block指针（创建带名字的block），且引用了外部局部变量,block会copy到堆</span><br><br>NSLog(@<span class="hljs-string">&quot;%@&quot;</span>,^&#123;NSLog(@<span class="hljs-string">&quot;调用block%d&quot;</span>,a);&#125;);<br><span class="hljs-comment">//打印结果:&lt;__NSStackBlock__: 0x7fff54f0c700&gt;</span><br><span class="hljs-comment">//匿名函数无赋值操作，只存于栈上，会不定释放</span><br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> b = <span class="hljs-number">2</span>;<br><br><span class="hljs-keyword">void</span>(^block)() = ^&#123;<br>      NSLog(@<span class="hljs-string">&quot;调用block%d&quot;</span>,b);<span class="hljs-comment">//若不引用任何变量，也是__NSGloBalBlock__</span><br>&#125;;<br>  NSLog(@<span class="hljs-string">&quot;%@&quot;</span>,block);<br>  &#125;<br><span class="hljs-comment">//打印结果:&lt;__NSGloBalBlock__: 0x7fc498746000&gt;</span><br><span class="hljs-comment">//此时引用了全局变量,block放在全局区</span><br></code></pre></td></tr></table></figure>

<h2 id="Block与循环引用"><a href="#Block与循环引用" class="headerlink" title="Block与循环引用"></a>Block与循环引用</h2><p>什么情况下会出现循环引用呢？</p>
<h3 id="单向引用"><a href="#单向引用" class="headerlink" title="单向引用"></a>单向引用</h3><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">void</span> (^block1)() = ^&#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%@&quot;</span>,<span class="hljs-keyword">self</span>.view);<br>    &#125;;<br></code></pre></td></tr></table></figure>
<p>很明显这里是不会出现循环引用的。block虽然强引用了self但是self并没有强引用block</p>
<h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">[<span class="hljs-built_in">UIView</span> animateWithDuration:<span class="hljs-number">1</span> animations:^&#123;<br>   <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%@&quot;</span>,<span class="hljs-keyword">self</span>.view);<br>&#125;];<br></code></pre></td></tr></table></figure>

<p>这样也不会产生循环引用,因为这是一个类方法,self没办法强引用一个类。</p>
<h3 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h3><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">self</span>.testBlock = ^(<span class="hljs-built_in">NSString</span> *text) &#123;<br>   <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%@&quot;</span>,<span class="hljs-keyword">self</span>.view);<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>这里是 self强引用了testblock 同时在block中也强引用了self。因此这回导致循环引用。</p>
<p>类似的还有:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">self</span>.testBlock = ^(<span class="hljs-built_in">NSString</span> *text) &#123;<br>   <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%@&quot;</span>,_arr);<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>即使没有出现self的字眼,这种情况下依然会发生循环引用。</p>
<p>正常情况下,如果出现明显的循环引用,编译器是会给我们提示的</p>
<p><img src="http://og0h689k8.bkt.clouddn.com/18-5-12/59352221.jpg"></p>
<h3 id="block参数"><a href="#block参数" class="headerlink" title="block参数"></a>block参数</h3><h4 id="纯粹的参数"><a href="#纯粹的参数" class="headerlink" title="纯粹的参数"></a>纯粹的参数</h4><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">[<span class="hljs-keyword">self</span> doSomthing1:^&#123;<br>   <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;str111:%@&quot;</span>,<span class="hljs-keyword">self</span>.str);<br>&#125;];<br>    <br>[<span class="hljs-keyword">self</span> doSomthing2:^(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b) &#123;<br>   <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;str111:%@&quot;</span>,<span class="hljs-keyword">self</span>.str);<br>&#125;];<br><br>- (<span class="hljs-keyword">void</span>)doSomthing1:(<span class="hljs-keyword">void</span>(^)())block&#123;<br><span class="hljs-keyword">if</span>(block)&#123;<br>   block();<br>&#125;<br>&#125;<br>- (<span class="hljs-keyword">void</span>)doSomthing2:(<span class="hljs-keyword">void</span> (^)(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b))block&#123;<br>    <span class="hljs-keyword">if</span>(block)&#123;<br>        block(<span class="hljs-number">3</span>,<span class="hljs-number">4</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>对于上面的这两种情况,block其实都是作为参数,虽然block中持有了self但是self并没有持有block。因此这里不会产生循环引用的问题。</p>
<h4 id="参数被引用"><a href="#参数被引用" class="headerlink" title="参数被引用"></a>参数被引用</h4><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">[<span class="hljs-keyword">self</span> doSomthing3:^(<span class="hljs-built_in">NSString</span> *text) &#123;<br>   <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;str111:%@&quot;</span>,<span class="hljs-keyword">self</span>.str);<br>&#125;];<br><br>- (<span class="hljs-keyword">void</span>)doSomthing3:(Block)block&#123;<br>    <span class="hljs-keyword">if</span>(block)&#123;<br>        <span class="hljs-keyword">self</span>.testBlock = block;<br>        block(<span class="hljs-string">@&quot;111&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在<code>doSomthing3</code>方法中,self对block进行了强引用,这里就会造成循环引用。这种循环引用也称为间接的循环引用,而且这种循环引用编译器是无法提示的。所以,在日常工作中不太容易被发现。</p>
<h4 id="系统自带的block"><a href="#系统自带的block" class="headerlink" title="系统自带的block"></a>系统自带的block</h4><p>有时候我们会有一种错觉,系统自带的一些block中使用self不会产生循环引用。</p>
<p>很可惜,这的确是错觉！</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">[[<span class="hljs-built_in">NSNotificationCenter</span> defaultCenter] addObserverForName:<span class="hljs-string">@&quot;testblock&quot;</span> object:<span class="hljs-literal">nil</span> queue:<span class="hljs-literal">nil</span> usingBlock:^(<span class="hljs-built_in">NSNotification</span> * _Nonnull note) &#123;<br>   <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%@&quot;</span>,<span class="hljs-keyword">self</span>.view);<br>&#125;];<br></code></pre></td></tr></table></figure>

<p>编译器不会提示有循环引用,但是的的确确这里会产生循环引用。所以还是老老实实的使用weakself,千万不要有这种错觉！</p>
<h3 id="AFN中的循环引用"><a href="#AFN中的循环引用" class="headerlink" title="AFN中的循环引用"></a>AFN中的循环引用</h3><p>我们在使用AFN进行网络请求的时候,实际上不需要关注网络回调中可能出现的循环引用,这是因为在AFN的内部做了处理。切断了循环引用链。</p>
<p>那么 我们是否就可以彻底的相信了AFN的处理而不需要自己做处理了呢？</p>
<p>看看下面的例子:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">- (<span class="hljs-keyword">void</span>)afnBlock<br>&#123;<br>    AFHTTPSessionManager *mgr = [AFHTTPSessionManager manager];<br>    mgr.responseSerializer = [AFHTTPResponseSerializer serializer];<br>    <br>    <br>    <span class="hljs-comment">//2.1 创建请求对象</span><br>    <span class="hljs-built_in">NSURLRequest</span> *request = [<span class="hljs-built_in">NSURLRequest</span> requestWithURL:[<span class="hljs-built_in">NSURL</span> URLWithString:<span class="hljs-string">@&quot;https://meishubao-static.oss-cn-hangzhou.aliyuncs.com/logs/2018-05/09/121214/bba24fa9ed53970478cdbf640d69620a.zip&quot;</span>]];<br>    <br>    <span class="hljs-built_in">NSURLSessionDownloadTask</span> *downloadTask = [mgr downloadTaskWithRequest:request progress:^(<span class="hljs-built_in">NSProgress</span> * _Nonnull downloadProgress) &#123;<span class="hljs-comment">//进度</span><br>        <br>    &#125; destination:^<span class="hljs-built_in">NSURL</span> * _Nonnull(<span class="hljs-built_in">NSURL</span> * _Nonnull targetPath, <span class="hljs-built_in">NSURLResponse</span> * _Nonnull response) &#123;<br>        <span class="hljs-built_in">NSString</span> *caches = [<span class="hljs-built_in">NSSearchPathForDirectoriesInDomains</span>(<span class="hljs-built_in">NSCachesDirectory</span>, <span class="hljs-built_in">NSUserDomainMask</span>, <span class="hljs-literal">YES</span>) lastObject];<br>        <span class="hljs-comment">//拼接文件全路径</span><br>        <span class="hljs-built_in">NSString</span> *fullpath = [caches stringByAppendingPathComponent:response.suggestedFilename];<br>        <span class="hljs-built_in">NSURL</span> *filePathUrl = [<span class="hljs-built_in">NSURL</span> fileURLWithPath:fullpath];<br>        sleep(<span class="hljs-number">20</span>);<br>        <span class="hljs-keyword">return</span> filePathUrl;<br>        <br>    &#125; completionHandler:^(<span class="hljs-built_in">NSURLResponse</span> * _Nonnull response, <span class="hljs-built_in">NSURL</span> * _Nonnull filePath, <span class="hljs-built_in">NSError</span> * _Nonnull error) &#123;<br>        <br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%@&quot;</span>,<span class="hljs-keyword">self</span>.str);<br>  <br>    &#125;];<br>    <br>    <span class="hljs-comment">//3.启动任务</span><br>    [downloadTask resume];<br>&#125;<br></code></pre></td></tr></table></figure>

<p>正常情况下,在网络请求的回调中强引用了self,但是self并没有强引用这个网络请求。因此这里不会形成循环引用。</p>
<p>如果self强引用了网络请求(request)且request的回调中也强引用了self是否会造成循环引用呢？</p>
<p>正常情况,这是很明显的循环引用。但是实际上这并不会造成循环引用。因此 AFN肯定在内部做了一些事情。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">readwrite</span>, <span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-built_in">NSMutableDictionary</span> *mutableTaskDelegatesKeyedByTaskIdentifier;<br></code></pre></td></tr></table></figure>

<p>我们关注一下AFN的这个属性,其作用是用来保存当前正在进行的所有请求。</p>
<p>开始请求的时候:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">self</span>.mutableTaskDelegatesKeyedByTaskIdentifier[@(task.taskIdentifier)] = delegate;<br></code></pre></td></tr></table></figure>
<p>将delegate与task进行绑定。</p>
<p>网络请求结束的时候:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">- (<span class="hljs-keyword">void</span>)removeDelegateForTask:(<span class="hljs-built_in">NSURLSessionTask</span> *)task &#123;<br>    <span class="hljs-built_in">NSParameterAssert</span>(task);<br><br>    [<span class="hljs-keyword">self</span>.lock lock];<br>    [<span class="hljs-keyword">self</span> removeNotificationObserverForTask:task];<br>    [<span class="hljs-keyword">self</span>.mutableTaskDelegatesKeyedByTaskIdentifier removeObjectForKey:@(task.taskIdentifier)];<br>    [<span class="hljs-keyword">self</span>.lock unlock];<br>&#125;<br></code></pre></td></tr></table></figure>
<p>解除task和delegate的绑定。</p>
<p>尝试一下把下面这句话注释掉:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">[self.mutableTaskDelegatesKeyedByTaskIdentifier removeObjectForKey:@(task.taskIdentifier)];<br></code></pre></td></tr></table></figure>

<p>你会惊奇的发现,<code>这个网络请求导致了当前进行网络请求的控制器无法被释放!!! </code></p>
<p>所以,AFN中可以大胆使用self而不用考虑循环引用都是因为这一句。在网络请求成功之后 手动的将self与block与self的引用关系切断。</p>
<p>当然正常情况下,控制器不会持有这个请求。那么是否就表示正常情况下,我们使用AFN的时候完全不用考虑循环应用的情况了呢？</p>
<p>答案是否定的！</p>
<p>来看看这段代码:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">self</span>.task = [mgr downloadTaskWithRequest:<span class="hljs-keyword">self</span>.request progress:^(<span class="hljs-built_in">NSProgress</span> * _Nonnull downloadProgress) &#123;<span class="hljs-comment">//进度</span><br>        <br>    &#125; destination:^<span class="hljs-built_in">NSURL</span> * _Nonnull(<span class="hljs-built_in">NSURL</span> * _Nonnull targetPath, <span class="hljs-built_in">NSURLResponse</span> * _Nonnull response) &#123;<br>        <span class="hljs-built_in">NSString</span> *caches = [<span class="hljs-built_in">NSSearchPathForDirectoriesInDomains</span>(<span class="hljs-built_in">NSCachesDirectory</span>, <span class="hljs-built_in">NSUserDomainMask</span>, <span class="hljs-literal">YES</span>) lastObject];<br>        <span class="hljs-comment">//拼接文件全路径</span><br>        <span class="hljs-built_in">NSString</span> *fullpath = [caches stringByAppendingPathComponent:response.suggestedFilename];<br>        <span class="hljs-built_in">NSURL</span> *filePathUrl = [<span class="hljs-built_in">NSURL</span> fileURLWithPath:fullpath];<br>        sleep(<span class="hljs-number">20</span>);<br>        <span class="hljs-keyword">return</span> filePathUrl;<br>        <br>    &#125; completionHandler:^(<span class="hljs-built_in">NSURLResponse</span> * _Nonnull response, <span class="hljs-built_in">NSURL</span> * _Nonnull filePath, <span class="hljs-built_in">NSError</span> * _Nonnull error) &#123;<br>        <br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%@&quot;</span>,<span class="hljs-keyword">self</span>.str);<br>  <br>    &#125;];<br></code></pre></td></tr></table></figure>

<p>其实与上面的网络请求唯一的区别是多了一个:</p>
<p><code>sleep(20);</code> </p>
<p>我们用sleep方法模拟一个特别慢的网络请求。当网络请求开始之后，用户在等待一段时间之后发现网络请求还没有成功,于是退出了当前的页面。</p>
<p>这个时候网络请求没有成功,因此上面我们提到的那个关键的那句话还没有走。这也就导致了这个控制器无法被释放！ 因此AFN的这个处理也不是绝对安全的。</p>
<p>为了可以让这个控制器完全释放,我们还是老老实实的使用<code>weakself</code>。</p>
<h3 id="Masonry中的block"><a href="#Masonry中的block" class="headerlink" title="Masonry中的block"></a>Masonry中的block</h3><p>我们先看一下代码</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">- (<span class="hljs-keyword">void</span>)masonryBlock<br>&#123;<br>    <span class="hljs-keyword">self</span>.lab = [[<span class="hljs-built_in">UILabel</span> alloc] init];<br>    <span class="hljs-keyword">self</span>.lab.textColor = [<span class="hljs-built_in">UIColor</span> redColor];<br>    <span class="hljs-keyword">self</span>.lab.text = <span class="hljs-string">@&quot;测试&quot;</span>;<br>    [<span class="hljs-keyword">self</span>.view addSubview:<span class="hljs-keyword">self</span>.lab];<br>    [<span class="hljs-keyword">self</span>.lab mas_makeConstraints:^(MASConstraintMaker *make) &#123;<br>        make.centerX.equalTo(<span class="hljs-keyword">self</span>.view.mas_centerX);<br>        make.centerY.equalTo(<span class="hljs-keyword">self</span>.view.mas_centerY);<br>    &#125;];<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们都知道循环引用的条件是互相持有,很明显block持有了self那么我们看一下self是否持有block就可以了,我们看一下下面的代码</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">- (<span class="hljs-built_in">NSArray</span> *)mas_makeConstraints:(<span class="hljs-keyword">void</span>(^)(MASConstraintMaker *))block &#123;<br>    <span class="hljs-keyword">self</span>.translatesAutoresizingMaskIntoConstraints = <span class="hljs-literal">NO</span>;<br>    MASConstraintMaker *constraintMaker = [[MASConstraintMaker alloc] initWithView:<span class="hljs-keyword">self</span>];<br>    block(constraintMaker);<br>    <span class="hljs-keyword">return</span> [constraintMaker install];<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这是view的分类,相当于方法调用中的<code>self.lab</code>。上面的代码我们可以看出self并没有持有block。所以这里绝对不会产生循环引用的问题。</p>
<h3 id="block循环引用-可用之处"><a href="#block循环引用-可用之处" class="headerlink" title="block循环引用 可用之处"></a>block循环引用 可用之处</h3><p>在我们使用block的场景中有这样一种场景,为了避免循环引用,我们需要在block中使用weakself,但是我们又希望我们的block被保证可以执行(如果self被释放block中的内容可能无法执行或者部分被执行)。</p>
<p>比如你有一个后台的任务，希望任务执行完后，通知另外一个实例。</p>
<p>我们该怎么做？</p>
<p>这时候 我们可以构造一个循环引用,然后在手动切断这个循环引用</p>
<p>这里我们有两种做法：</p>
<p>第一种: 参考AFN</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs OBJC">__<span class="hljs-keyword">weak</span> __<span class="hljs-keyword">typeof</span>(<span class="hljs-keyword">self</span>)weakSelf = <span class="hljs-keyword">self</span>;<br>AFNetworkReachabilityStatusBlock callback = ^(AFNetworkReachabilityStatus status) &#123;<br>    __<span class="hljs-keyword">strong</span> __<span class="hljs-keyword">typeof</span>(weakSelf)strongSelf = weakSelf;<br><br>    strongSelf.networkReachabilityStatus = status;<br>    <span class="hljs-keyword">if</span> (strongSelf.networkReachabilityStatusBlock) &#123;<br>        strongSelf.networkReachabilityStatusBlock(status);<br>    &#125;<br><br>&#125;;<br></code></pre></td></tr></table></figure>

<p>在block内部添加一个对self的强引用,这样就会产生循环应用,这样就可以保证block的内容一定会完整的被执行(如果self被销毁了有可能block被释放了压根不会被执行)。在block执行完成之后 因为strongSelf是一个局部变量在执行完之后会就置为nil,因此循环引用链也会被断开。</p>
<p>第二种: 参考猿题库</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs OBJC"><span class="hljs-comment">//  YTKBaseRequest.m</span><br>- (<span class="hljs-keyword">void</span>)clearCompletionBlock &#123;<br>    <span class="hljs-comment">// nil out to break the retain cycle.</span><br>    <span class="hljs-keyword">self</span>.successCompletionBlock = <span class="hljs-literal">nil</span>;<br>    <span class="hljs-keyword">self</span>.failureCompletionBlock = <span class="hljs-literal">nil</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>因为block强引用了self,那么如果我们在网络请求结束之后将block置为nil,来破坏到循环引用链那么也可以达到这个效果。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本篇文章总结了在平时工作中常用block相关的基础,后面会在写一篇进阶,主要介绍__block这个关键字。可以在<a href="http://www.leewong.cn/2018/04/25/what-did-block-do/#more">这里</a>看哦！</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul>
<li>1、<a href="https://bestswifter.com/strong-weak-dance/">对 Strong-Weak Dance 的思考</a></li>
<li>2、<a href="https://mp.weixin.qq.com/s?__biz=MjM5NTIyNTUyMQ==&mid=562061603&idx=1&sn=bd19562add018ab521a4581b1c2fba2d&scene=19#wechat_redirect">唐巧公众号文章</a></li>
<li>3、<a href="http://yolynn.com/2016/11/01/block/">block基础到进阶</a></li>
<li>4、<a href="https://www.jianshu.com/p/fc2f4d207d25">实际开发中-Block导致循环引用的问题</a></li>
<li>5、<a href="https://blog.csdn.net/DonnyDN/article/details/77750751">iOS中Block使用注意点及常见问题浅析</a></li>
</ul>
]]></content>
      <categories>
        <category>iOS基础</category>
      </categories>
      <tags>
        <tag>Block 循环引用 内存管理 引用计数</tag>
      </tags>
  </entry>
  <entry>
    <title>Fastlane iOS</title>
    <url>/2017/10/12/fastlane-learning/</url>
    <content><![CDATA[<p>因为公司目前的项目需要一个项目打多个包,打包实际上是一个纯体力活,所以为了提升效率,之前同事写了一个利用Fastlane自动打包的脚本,最近项目不忙,所以看看文档总结一下！</p>
<a id="more"></a>

<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="确保安装了最新的-Xcode-command-line-tools"><a href="#确保安装了最新的-Xcode-command-line-tools" class="headerlink" title="确保安装了最新的 Xcode command line tools"></a>确保安装了最新的 Xcode command line tools</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">xcode-select --install<br><br></code></pre></td></tr></table></figure>

<h3 id="安装Fastlane"><a href="#安装Fastlane" class="headerlink" title="安装Fastlane"></a>安装Fastlane</h3><p><img src="http://og0h689k8.bkt.clouddn.com/17-10-12/29284112.jpg" alt="安装Fastlane"></p>
<p>只需要这两步,安装过程就大功告成,下面开始把玩fastlane</p>
<h2 id="初始化Fastlane"><a href="#初始化Fastlane" class="headerlink" title="初始化Fastlane"></a>初始化Fastlane</h2><p>进入到你的项目的根目录(与xcodeproj文件同级目录下)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">fastlane init<br></code></pre></td></tr></table></figure>

<p>期间会让你输入 Apple ID 和密码<br><img src="http://og0h689k8.bkt.clouddn.com/17-10-12/59536373.jpg" alt="输入密码"></p>
<p>确认信息<br><img src="http://og0h689k8.bkt.clouddn.com/17-10-12/67960903.jpg" alt="确认信息"></p>
<p>会自动下载现存的截图<br><img src="http://og0h689k8.bkt.clouddn.com/17-10-12/73492697.jpg" alt="下载现存的截图"></p>
<p>初始化完成后的目录结构<br><img src="http://og0h689k8.bkt.clouddn.com/17-10-12/31492902.jpg" alt="目录结构"></p>
<p>至此 fastlane就初始化完成了,再接再厉！！！</p>
<h2 id="截图"><a href="#截图" class="headerlink" title="截图"></a>截图</h2><p>每次发布新版本的时候截图是一件比较恶心的事情(虽然16年更新之后我们只需要上传最大尺寸的机型就可以适配),fastlane也可以为我们解决这件事！</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">fastlane snapshot init<br></code></pre></td></tr></table></figure>
<p>初始化成功之后 我们可以得到<br><img src="http://og0h689k8.bkt.clouddn.com/17-10-12/84919492.jpg"></p>
<h3 id="导入文件"><a href="#导入文件" class="headerlink" title="导入文件"></a>导入文件</h3><p>导入上一步生成的SnapshotHelper.swift文件到你的UITest目录下<br><code>注意:</code>如果你是OC的项目这里要设置一下桥接</p>
<p><img src="http://upload-images.jianshu.io/upload_images/594219-109d427d7a9e4cb8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="桥接"></p>
<p>注意 对于 SnapshotHelper.swift<br><img src="http://og0h689k8.bkt.clouddn.com/17-10-12/54904384.jpg"></p>
<h3 id="导入头文件"><a href="#导入头文件" class="headerlink" title="导入头文件"></a>导入头文件</h3><p>这个头文件是系统默认生成的，不用我们手动创建，我们在拖入Siwft文件之后，直接引用就可以。 没有智能提示，所以不必惊慌，保证#import’target名称-Swift.h’正确就可以了。</p>
<h3 id="录制"><a href="#录制" class="headerlink" title="录制"></a>录制</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">(void)setUp: 方法在XCTestCase的测试方法调用之前调用，可以在测试之前创建在test case方法中需要用到的一些对象等<br>(void)tearDown: 当测试全部结束之后调用tearDown方法，法则在全部的test case执行结束之后清理测试现场，释放资源删除不用的对象等<br>(void)testExample: 测试代码执行性能<br></code></pre></td></tr></table></figure>


<h3 id="添加截图代码"><a href="#添加截图代码" class="headerlink" title="添加截图代码"></a>添加截图代码</h3><p>在setUp方法中添加</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">XCUIApplication *app &#x3D; [[XCUIApplication alloc] init];<br>[Snapshot setupSnapshot:app];<br>[app launch];<br></code></pre></td></tr></table></figure>

<p>在在录制步骤产生的步骤代码中加入（testExample中）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">[Snapshot snapshot:@&quot;01LoginScreen&quot; waitForLoadingIndicator:YES];<br></code></pre></td></tr></table></figure>

<p><img src="http://og0h689k8.bkt.clouddn.com/17-10-12/90575579.jpg"></p>
<h3 id="修改Snapfile文件"><a href="#修改Snapfile文件" class="headerlink" title="修改Snapfile文件"></a>修改Snapfile文件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">要截图的设备 默认所有的设备<br># A list of devices you want to take the screenshots from<br> devices([<br>   &quot;iPhone 7&quot;,<br>   &quot;iPhone 7 Plus&quot;,<br>   &quot;iPhone 6&quot;<br> ])<br><br>支持的语言,对于支持多语言的应用比较有利<br>languages([<br>  &quot;en-US&quot;,<br>  #&quot;de-DE&quot;,<br>  #&quot;it-IT&quot;,<br>  #[&quot;pt&quot;, &quot;pt_BR&quot;] # Portuguese with Brazilian locale<br>])<br><br></code></pre></td></tr></table></figure>

<h3 id="生成截图"><a href="#生成截图" class="headerlink" title="生成截图"></a>生成截图</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">fastlane snapshot<br></code></pre></td></tr></table></figure>
<p><img src="http://og0h689k8.bkt.clouddn.com/17-10-12/99858121.jpg"><br><img src="http://og0h689k8.bkt.clouddn.com/17-10-12/85295801.jpg"></p>
<h2 id="添加边框"><a href="#添加边框" class="headerlink" title="添加边框"></a>添加边框</h2><h3 id="安装ImageMagick"><a href="#安装ImageMagick" class="headerlink" title="安装ImageMagick"></a>安装ImageMagick</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">brew install libpng jpeg imagemagick<br><br></code></pre></td></tr></table></figure>

<p>下载最新的边框</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">fastlane frameit setup<br><br></code></pre></td></tr></table></figure>

<h3 id="生成带边框的截图"><a href="#生成带边框的截图" class="headerlink" title="生成带边框的截图"></a>生成带边框的截图</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">fastlane frameit<br><br></code></pre></td></tr></table></figure>

<p><img src="http://og0h689k8.bkt.clouddn.com/17-10-13/46969300.jpg" alt="结果"></p>
<h2 id="pem-生成推送证书"><a href="#pem-生成推送证书" class="headerlink" title="pem 生成推送证书"></a>pem 生成推送证书</h2><p>命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">fastlane pem<br></code></pre></td></tr></table></figure>

<ul>
<li>1、创建新的签名请求(signing request)</li>
<li>2、创建新的推送证书( push certification)</li>
<li>3、下载这个证书(certificate)</li>
<li>4、在当前工作目录创建新的 .pem 文件,你可以上传到你的服务器</li>
</ul>
<p><code>pem不会revoke已经存在的证书,也不会下载已经存在的证书,因为私钥仅在创建的机器上可用</code></p>
<p>实用命令</p>
<p>如果你已经有一个可用的推送证书(certificate),而且有效期至少还有30天以上，pem就不会创建新的证书。如果你想要创建新的，使用force：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">fastlane pem --force<br></code></pre></td></tr></table></figure>

<p>还可传参数,如:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">fastlane pem -a com.krausefx.app -u username<br></code></pre></td></tr></table></figure>

<p>生成开发证书:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">fastlane pem --development<br></code></pre></td></tr></table></figure>

<p>给p12文件设置密码:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">fastlane pem -p &quot;MyPass&quot;<br></code></pre></td></tr></table></figure>

<p>可以指定输出名字:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">fastlane pem -o my.pem<br></code></pre></td></tr></table></figure>

<p>列出可用命令选项:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">fastlane pem --help<br></code></pre></td></tr></table></figure>


<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>–development</td>
<td>[VALUE] Renew the development push certificate instead of the production one (PEM_DEVELOPMENT)</td>
</tr>
<tr>
<td>–generate_p12</td>
<td>[VALUE] Generate a p12 file additionally to a PEM file (PEM_GENERATE_P12_FILE)</td>
</tr>
<tr>
<td>–active_days_limit</td>
<td>STRING If the current certificate is active for less than this number of days, generate a new one. Default value is 30 days (PEM_ACTIVE_DAYS_LIMIT)</td>
</tr>
<tr>
<td>–force</td>
<td>[VALUE]      Create a new push certificate, even if the current one is active for 30 (or PEM_ACTIVE_DAYS_LIMIT) more days (PEM_FORCE)</td>
</tr>
<tr>
<td>-s, –save_private_key</td>
<td>[VALUE] Set to save the private RSA key (PEM_SAVE_PRIVATEKEY)</td>
</tr>
<tr>
<td>-a, –app_identifier</td>
<td>STRING The bundle identifier of your app (PEM_APP_IDENTIFIER)</td>
</tr>
<tr>
<td>-u, –username</td>
<td>STRING Your Apple ID Username (PEM_USERNAME)</td>
</tr>
<tr>
<td>-b, –team_id</td>
<td>STRING The ID of your Developer Portal team if you’re in multiple teams (PEM_TEAM_ID)</td>
</tr>
<tr>
<td>-l, –team_name</td>
<td>STRING The name of your Developer Portal team if you’re in multiple teams (PEM_TEAM_NAME)</td>
</tr>
<tr>
<td>-p, –p12_password</td>
<td>STRING The password that is used for your p12 file (PEM_P12_PASSWORD)</td>
</tr>
</tbody></table>
<h2 id="签名"><a href="#签名" class="headerlink" title="签名"></a>签名</h2><p>sign可以创建，更新，下载和修复 provisioning profiles（使用一个命令）。<br>它支持App Store，Ad Hoc，开发和企业配置文件，并支持好的特性，如自动添加所有测试设备。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">下载最新的应用配置文件<br>更新配置配置文件，当它已过期<br>修复配置配置文件，当它坏了<br>创建新的配置配置文件（如果尚不存在）<br>支持App Store，Ad Hoc和Development Profile<br>支持多个Apple帐户，将您的凭据安全地存储在钥匙串中<br>支持多个团队(multiple Teams)<br>支持企业应用配置(Enterprise Profiles)<br></code></pre></td></tr></table></figure>

<p>进入工程目录后</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">fastlane sigh #默认会在当前文件夹下生成针对appstore的&#96;.mobileprovision&#96;<br></code></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>fastlane sigh</td>
<td>App Store profile 或 InHouse profile</td>
</tr>
<tr>
<td>fastlane sigh -a com.krausefx.app -u username</td>
<td>指定bundle identifier 和 username(apple id)</td>
</tr>
<tr>
<td>fastlane sigh –adhoc</td>
<td>生成Ad Hoc profile</td>
</tr>
<tr>
<td>fastlane sigh –development</td>
<td>生成 development profile</td>
</tr>
<tr>
<td>fastlane sigh -o “./Certificates/“</td>
<td>指定输出文件夹</td>
</tr>
<tr>
<td>fastlane sigh download_all</td>
<td>下载所有的 provisioning profiles</td>
</tr>
<tr>
<td>fastlane sigh –help</td>
<td>列出帮助</td>
</tr>
</tbody></table>
<p>高级使用</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>fastlane sigh –skip_install</td>
<td>默认情况下，sigh将下载的配置文件安装在您的机器上。 如果只想生成配置文件并跳过安装,使用该命令</td>
</tr>
<tr>
<td>fastlane sigh -a com.krausefx.app -u username -q “myProfile.mobileprovision”</td>
<td>用特定的名字保存,使用 -q</td>
</tr>
<tr>
<td>fastlane sigh –skip_certificate_verification</td>
<td>跳过验证安装在本机上的 code signing identity</td>
</tr>
<tr>
<td>fastlane sigh –force</td>
<td>如果您需要更新配置配置文件，而不管其状态如何，请使用–force选项。这给您一个具有最大生命周期的配置文件。 –force还会将所有可用的设备添加到此配置文件中。</td>
</tr>
<tr>
<td>fastlane sigh –help</td>
<td>查看帮助:列出可用参数和命令</td>
</tr>
</tbody></table>
<p>结合fastlane 使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">lane :beta do<br>  cert<br>  sigh(force: true)<br>end<br></code></pre></td></tr></table></figure>

<p><code>force：true将确保在每次运行时重新生成配置配置文件。 这将使得sign总是使用正确的签名证书(signing certificate),证书将会被安装到本机上。</code></p>
<p>所有参数</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>–adhoc</td>
<td>[VALUE]      Setting this flag will generate AdHoc profiles instead of App Store Profiles (SIGH_AD_HOC)</td>
</tr>
<tr>
<td>–development</td>
<td>[VALUE] Renew the development certificate instead of the production one (SIGH_DEVELOPMENT)</td>
</tr>
<tr>
<td>–skip_install</td>
<td>[VALUE] By default, the certificate will be added to your local machine. Setting this flag will skip this action (SIGH_SKIP_INSTALL)</td>
</tr>
<tr>
<td>-f, –force</td>
<td>[VALUE]  Renew provisioning profiles regardless of its state - to automatically add all devices for ad hoc profiles (SIGH_FORCE)</td>
</tr>
<tr>
<td>-a, –app_identifier</td>
<td>STRING The bundle identifier of your app (SIGH_APP_IDENTIFIER)</td>
</tr>
<tr>
<td>-u, –username</td>
<td>STRING Your Apple ID Username (SIGH_USERNAME)</td>
</tr>
<tr>
<td>-b, –team_id</td>
<td>STRING The ID of your Developer Portal team if you’re in multiple teams (SIGH_TEAM_ID)</td>
</tr>
<tr>
<td>-l, –team_name</td>
<td>STRING The name of your Developer Portal team if you’re in multiple teams (SIGH_TEAM_NAME)</td>
</tr>
<tr>
<td>-n, –provisioning_name</td>
<td>STRING The name of the profile that is used on the Apple Developer Portal (SIGH_PROVISIONING_PROFILE_NAME)</td>
</tr>
<tr>
<td>–ignore_profiles_with_different_name</td>
<td>[VALUE] Use in combination with :provisioning_name - when true only profiles matching this exact name will be downloaded(SIGH_IGNORE_PROFILES_WITH_DIFFERENT_NAME)</td>
</tr>
<tr>
<td>-o, –output_path</td>
<td>STRING Directory in which the profile should be stored(SIGH_OUTPUT_PATH)</td>
</tr>
<tr>
<td>-i, –cert_id</td>
<td>STRING The ID of the code signing certificate to use (e.g. 78ADL6LVAA)  (SIGH_CERTIFICATE_ID)</td>
</tr>
<tr>
<td>-c, –cert_owner_name</td>
<td>STRING The certificate name to use for new profiles, or to renew with. (e.g. “Felix Krause”) (SIGH_CERTIFICATE)</td>
</tr>
<tr>
<td>-q, –filename</td>
<td>STRING Filename to use for the generated provisioning profile (must include .mobileprovision) (SIGH_PROFILE_FILE_NAME)</td>
</tr>
<tr>
<td>-w, –skip_fetch_profiles</td>
<td>[VALUE] Skips the verification of existing profiles which is useful if you have thousands of profiles (SIGH_SKIP_FETCH_PROFILES)</td>
</tr>
<tr>
<td>-z, –skip_certificate_verification</td>
<td>[VALUE] Skips the verification of the certificates for every existing profiles. This will make sure the provisioning profile can be used on the local machine(SIGH_SKIP_CERTIFICATE_VERIFICATION)</td>
</tr>
<tr>
<td>-p, –platform</td>
<td>[VALUE] Set the provisioning profile’s platform (i.e. ios, tvos) (SIGH_PLATFORM)</td>
</tr>
<tr>
<td>–template_name</td>
<td>STRING The name of provisioning profile template. If the developer account has provisioning profile templates, template name can be found by inspecting the Entitlements drop-down while creating/editing a provisioning profile(SIGH_PROVISIONING_PROFILE_TEMPLATE_NAME)</td>
</tr>
</tbody></table>
<h2 id="自动打包"><a href="#自动打包" class="headerlink" title="自动打包"></a>自动打包</h2><p>用法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">fastlane gym<br>#fastlane gym --export_method ad-hoc<br>#fastlane gym --export_method enterprise<br>#fastlane gym --export_method app-store<br></code></pre></td></tr></table></figure>

<p>当然可以增加一些配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">fastlane gym --workspace &quot;Example.xcworkspace&quot; --scheme &quot;AppName&quot; --clean<br><br></code></pre></td></tr></table></figure>

<p>选择Xcode:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">DEVELOPER_DIR&#x3D;&quot;&#x2F;Applications&#x2F;Xcode6.2.app&quot; gym<br><br></code></pre></td></tr></table></figure>

<p>列出可用参数列表:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">fastlane gym --help<br></code></pre></td></tr></table></figure>

<p>运行遇到错误,使用verbose模式获取更多信息:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">fastlane gym --verbose<br><br></code></pre></td></tr></table></figure>

<p>如果您没有上传到App Store或TestFlight，请设置正确的导出方法:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">fastlane gym --export_method ad-hoc<br><br></code></pre></td></tr></table></figure>

<p>要使用bool参数,确保这么使用gym:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">fastlane gym --include_bitcode true --include_symbols false<br><br></code></pre></td></tr></table></figure>

<p>获取xcodebuild输出,请到~/Library/Logs/gym查看。</p>
<p>gym 的常用参数</p>
<p> Options for build:</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>-w, –workspace</td>
<td>STRING Path to the workspace file (GYM_WORKSPACE)</td>
</tr>
<tr>
<td>-p, –project</td>
<td>STRING Path to the project file (GYM_PROJECT)</td>
</tr>
<tr>
<td>-s, –scheme</td>
<td>STRING  The project’s scheme. Make sure it’s marked as <code>Shared</code> (GYM_SCHEME)</td>
</tr>
<tr>
<td>-c, –clean</td>
<td>[VALUE]  Should the project be cleaned before building it? (GYM_CLEAN)</td>
</tr>
<tr>
<td>-o, –output_directory</td>
<td>STRING The directory in which the ipa file should be stored in (GYM_OUTPUT_DIRECTORY)</td>
</tr>
<tr>
<td>-n, –output_name</td>
<td>STRING The name of the resulting ipa file (GYM_OUTPUT_NAME)</td>
</tr>
<tr>
<td>-q, –configuration</td>
<td>STRING The configuration to use when building the app. Defaults to ‘Release’ (GYM_CONFIGURATION)</td>
</tr>
<tr>
<td>-a, –silent</td>
<td>[VALUE] Hide all information that’s not necessary while building (GYM_SILENT)</td>
</tr>
<tr>
<td>-i, –codesigning_identity</td>
<td>STRING The name of the code signing identity to use. It has to match the name exactly. e.g. ‘iPhone Distribution: SunApps GmbH’ (GYM_CODE_SIGNING_IDENTITY)</td>
</tr>
<tr>
<td>–skip_package_ipa</td>
<td>[VALUE] Should we skip packaging the ipa? (GYM_SKIP_PACKAGE_IPA)</td>
</tr>
<tr>
<td>-m, –include_symbols</td>
<td>[VALUE] Should the ipa file include symbols? (GYM_INCLUDE_SYMBOLS)</td>
</tr>
<tr>
<td>-z, –include_bitcode</td>
<td>[VALUE] Should the ipa file include bitcode? (GYM_INCLUDE_BITCODE)</td>
</tr>
<tr>
<td>-j, –export_method</td>
<td>STRING Method used to export the archive. Valid values are: app-store, ad-hoc, package, enterprise, development, developer-id (GYM_EXPORT_METHOD)</td>
</tr>
<tr>
<td>–export_options</td>
<td>[VALUE] Specifies path to export options plist. Use ‘xcodebuild -help’ to print the full set of available options (GYM_EXPORT_OPTIONS)</td>
</tr>
<tr>
<td>–export_xcargs</td>
<td>STRING Pass additional arguments to xcodebuild for the package phase. Be sure to quote the setting names and values e.g. OTHER_LDFLAGS=”-ObjC -lstdc++” (GYM_EXPORT_XCARGS)</td>
</tr>
<tr>
<td>–skip_build_archive</td>
<td>[VALUE] Export ipa from previously built xarchive. Uses archive_path as source (GYM_SKIP_BUILD_ARCHIVE)</td>
</tr>
<tr>
<td>–build_path</td>
<td>STRING  The directory in which the archive should be stored in (GYM_BUILD_PATH)</td>
</tr>
<tr>
<td>-b, –archive_path</td>
<td>STRING The path to the created archive (GYM_ARCHIVE_PATH)</td>
</tr>
<tr>
<td>-f, –derived_data_path</td>
<td>STRING The directory where built products and other derived data will go (GYM_DERIVED_DATA_PATH)</td>
</tr>
<tr>
<td>-u, –result_bundle</td>
<td>[VALUE] Location of the Xcode result bundle (GYM_RESULT_BUNDLE)</td>
</tr>
<tr>
<td>-l, –buildlog_path</td>
<td>STRING The directory where to store the build log (GYM_BUILDLOG_PATH)</td>
</tr>
<tr>
<td>-k, –sdk STRING</td>
<td>The SDK that should be used for building the application (GYM_SDK)</td>
</tr>
<tr>
<td>–toolchain</td>
<td>[VALUE]  The toolchain that should be used for building the application (e.g. com.apple.dt.toolchain.Swift_2_3, org.swift.30p620160816a) (GYM_TOOLCHAIN)</td>
</tr>
<tr>
<td>-d, –destination</td>
<td>STRING Use a custom destination for building the app (GYM_DESTINATION)</td>
</tr>
<tr>
<td>-g, –export_team_id</td>
<td>STRING Optional: Sometimes you need to specify a team id when exporting the ipa file (GYM_EXPORT_TEAM_ID)</td>
</tr>
<tr>
<td>-x, –xcargs</td>
<td>STRING  Pass additional arguments to xcodebuild for the build phase. Be sure to quote the setting names and values e.g. OTHER_LDFLAGS=”-ObjC -lstdc++” (GYM_XCARGS)</td>
</tr>
<tr>
<td>-y, –xcconfig</td>
<td>STRING Use an extra XCCONFIG file to build your app (GYM_XCCONFIG)</td>
</tr>
<tr>
<td>-r, –suppress_xcode_output</td>
<td>[VALUE] Suppress the output of xcodebuild to stdout. Output is still saved in buildlog_path (SUPPRESS_OUTPUT)</td>
</tr>
<tr>
<td>–disable_xcpretty</td>
<td>[VALUE] Disable xcpretty formatting of build output (DISABLE_XCPRETTY)</td>
</tr>
<tr>
<td>–xcpretty_test_format</td>
<td>[VALUE] Use the test (RSpec style) format for build output (XCPRETTY_TEST_FORMAT)</td>
</tr>
<tr>
<td>–xcpretty_formatter</td>
<td>STRING A custom xcpretty formatter to use (XCPRETTY_FORMATTER)</td>
</tr>
<tr>
<td>–xcpretty_report_junit</td>
<td>STRING Have xcpretty create a JUnit-style XML report at the provided path (XCPRETTY_REPORT_JUNIT)</td>
</tr>
<tr>
<td>–xcpretty_report_html</td>
<td>STRING Have xcpretty create a simple HTML report at the provided path (XCPRETTY_REPORT_HTML)</td>
</tr>
<tr>
<td>–xcpretty_report_json</td>
<td>STRING Have xcpretty create a JSON compilation database at the provided path (XCPRETTY_REPORT_JSON)</td>
</tr>
<tr>
<td>–analyze_build_time</td>
<td>[VALUE] Analyze the project build time and store the output in ‘culprits.txt’ file (GYM_ANALYZE_BUILD_TIME)</td>
</tr>
<tr>
<td>–xcpretty_utf</td>
<td>[VALUE] Have xcpretty us</td>
</tr>
</tbody></table>
<p>至此打包基本完成！！！</p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="http://www.bijishequ.com/detail/434702?p=">自动化工具Fastlane笔记三: snapshot自动截图基础+示例</a><br><a href="https://stackoverflow.com/questions/32044603/xcode-7-ui-debugging-recording-no-buildable-for-testable/33384426#33384426">无法录制</a><br><a href="https://tyrad.cc/archives/93.html">fastlane - snapshot 自动截图</a><br><a href="https://whlsxl.github.io/fastlane1/">小团队的自动化发布－Fastlane带来的全自动化发布</a><br><a href="http://www.devzhang.cn/2017/07/17/fastLane%E5%85%A5%E9%97%A8%E4%B9%8Bsnapshot/">fastlane入门之snapshot</a><br><a href="https://zhuanlan.zhihu.com/p/20739972">fastlane 之截图自动化</a><br><a href="https://tyrad.cc/archive.html">fastlane</a></p>
]]></content>
      <categories>
        <category>自动打包</category>
      </categories>
      <tags>
        <tag>Fastlane,截图,签名,自动打包</tag>
      </tags>
  </entry>
  <entry>
    <title>Xcode之断点调试</title>
    <url>/2020/07/25/howtousexcodebreakpoint/</url>
    <content><![CDATA[<p>Xcode这个开发工具的使用相信每一个iOS开发者都已经可以熟练使用，但是要说到所有功能都详细了解，想必人数不多，这篇文章主要介绍xcode的断点调试功能。</p>
<a id="more"></a>

<p>##简介</p>
<h3 id="Xcode断点调试"><a href="#Xcode断点调试" class="headerlink" title="Xcode断点调试"></a>Xcode断点调试</h3><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh3oilaohxj30ve0jmtbt.jpg"></p>
<p>上图是我们使用Xcode进行断点调试时，上图底部图标从左到右功能分别如下：</p>
<ul>
<li>启用/禁用断点（点击后变灰色，所有断点失效；再点击变蓝色，所有断点生效）</li>
<li>继续执行程序（点击后跳过本次断点，继续执行程序）</li>
<li>执行下一步（点击后执行第23行代码）</li>
<li>进入方法（点击后进入-testLog方法）</li>
<li>跳出方法（在-testLog方法内部点击后回到第22行代码）</li>
</ul>
<p>除了这些功能，我们还可以编辑断点，在断点出右键选择<code>Edit BreakPoint</code></p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh3oq80owkj30qg09itkn.jpg"></p>
<p>下面我们来分别介绍下这几个选项以及如何设置这些选项:</p>
<h4 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h4><p><code>Condition</code>表示断点条件。开发者可以在<code>Condition</code>输入框中设置触发断点的条件。比如上面for循环的例子我们可以在<code>Condition</code>条件中添加条件</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh3ovyntb5j31600e0h1s.jpg"></p>
<p>这样我们的断点只有在<code>index==5</code>时才会被触发,这样就有利于我们在某些for循环时只有在满足某个条件时才触发断点。</p>
<h4 id="Ignore"><a href="#Ignore" class="headerlink" title="Ignore"></a>Ignore</h4><p><code>Ignore</code>为忽略次数,同样我们在上面for循环的例子中可以将<code>Ignore</code>设置为5，那么断点第一次触发时index=6时。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh3p5pghn0j30va0dk40p.jpg"></p>
<h4 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h4><p>Action为触发动作。Action可以添加多条，在触发断点后，会紧接着执行设定的Actions。Action有6种执行类型，其中较常用的有Debugger Command和Log message。</p>
<h5 id="Debugger-Command"><a href="#Debugger-Command" class="headerlink" title="Debugger Command"></a>Debugger Command</h5><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gh3pxix809j315m0jgqp9.jpg"></p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gh3q07f1x0j31740ou1kx.jpg"></p>
<h5 id="Log-Message"><a href="#Log-Message" class="headerlink" title="Log Message"></a>Log Message</h5><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gh3q601k8qj319s0latzt.jpg"></p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gh3qbe3athj316s0le7uf.jpg"></p>
<p>当然log的信息还可以读出来</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gh3qdqls9pj30qg0g0wym.jpg"></p>
<p>试一下吧，有惊喜！！！</p>
<h4 id="Options"><a href="#Options" class="headerlink" title="Options"></a>Options</h4><p><code>Options</code>控制在执行断点对应的<code>Actions</code>后是否自动继续执行程序。勾选后<code>Options</code>后，断点被触发后不进入<code>Debug</code>界面。</p>
<p>接下来看下断点的正题</p>
<h2 id="断点"><a href="#断点" class="headerlink" title="断点"></a>断点</h2><h3 id="断点类型"><a href="#断点类型" class="headerlink" title="断点类型"></a>断点类型</h3><p>我们在Xocde中添加断点时有几种类型的断点：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gh3ql0796sj30gk0ree17.jpg"></p>
<p>下面我们来介绍下我们常用的集中类型的断点：</p>
<h4 id="Exception-Breakpoint（异常断点）"><a href="#Exception-Breakpoint（异常断点）" class="headerlink" title="Exception Breakpoint（异常断点）"></a>Exception Breakpoint（异常断点）</h4><p>当我们添加了一个<code>Exception BreakPoint </code>时，实际上是添加了一个全局断点</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh45yjnc3vj30na0a012t.jpg"></p>
<p>正常情况下我们的代码崩溃后，如果没有全局断点 代码会崩溃在main函数中，但是我们如果添加了全局断点，代码发生崩溃时，就会自动崩溃到出现问题的哪一行代码，比较方便我们去定位问题。</p>
<h4 id="Symbolic-Breakpoint-符号断点"><a href="#Symbolic-Breakpoint-符号断点" class="headerlink" title="Symbolic Breakpoint (符号断点)"></a>Symbolic Breakpoint (符号断点)</h4><p>当我们添加一个符号断点时，会自动为我们弹出自定义面板，</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh46crks7lj310a0fohaa.jpg"></p>
<p>与普通断点相比，符号断点的编辑界面多出来Symbol和Module两个输入框。下面我们来看下这两个输入框的作用。</p>
<h5 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h5><p>可以在Symbol输入框中设置断点出发方法/函数。在Symbol中设置一个方法/函数后，运行程序并执行到此方法时会触发断点。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gh4nyg02l0j31k00oob0j.jpg"></p>
<p>如果是C语言方法那么直接使用方法名就可以</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gh4o13mn2vj31ka0pq4qh.jpg"></p>
<h5 id="Module"><a href="#Module" class="headerlink" title="Module"></a>Module</h5><p>可以在Module输入框中设置Symbol中的函数所在的库，以避免不同库中存在名字相同的方法/函数，默认不用填写。</p>
<h5 id="Condition-1"><a href="#Condition-1" class="headerlink" title="Condition"></a>Condition</h5><p>与普通断点的用法基本一致<br>在Condition输入框中设置<code>$arg3==nil</code>，就会限制断点在满足第一个参数和第二个参数都为nil时才会被触发。但是实际上使用下面这种写法才可以<br><code>[(NSString *)$arg3 length] == 0</code></p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh4orcbwjxj31790u01kx.jpg"></p>
<p>这里我们可以用来判断某个方法再被调用时，哪里的参数传递是有问题的。</p>
<h4 id="Watch-Breakpoint-监控断点"><a href="#Watch-Breakpoint-监控断点" class="headerlink" title="Watch Breakpoint(监控断点)"></a>Watch Breakpoint(监控断点)</h4><p>有时候我们需要监听某个变量的值的变化</p>
<p>添加断点<br><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh4rzvcuwcj31c30u0tff.jpg"><br>断点结果<br><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh4s00sz7jj30tm0t4k1g.jpg"></p>
<p>很可惜没有发现监听数组个数变化的断点</p>
<h3 id="断点的应用"><a href="#断点的应用" class="headerlink" title="断点的应用"></a>断点的应用</h3><h4 id="查看UI控件约束冲突"><a href="#查看UI控件约束冲突" class="headerlink" title="查看UI控件约束冲突"></a>查看UI控件约束冲突</h4><p>我们先看下下面这段代码:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">- (<span class="hljs-keyword">void</span>)addVCSubView &#123;<br>    <span class="hljs-built_in">UIView</span> *contentView = [[<span class="hljs-built_in">UIView</span> alloc] init];<br>    contentView.backgroundColor = [<span class="hljs-built_in">UIColor</span> blueColor];<br>    [<span class="hljs-keyword">self</span>.view addSubview:contentView];<br>    [contentView mas_makeConstraints:^(MASConstraintMaker *make) &#123;<br>        make.center.equalTo(<span class="hljs-keyword">self</span>.view);<br>        make.width.height.equalTo(@<span class="hljs-number">200</span>);<br>    &#125;];<br><br><br>    <span class="hljs-built_in">UIView</span> *view = [[<span class="hljs-built_in">UIView</span> alloc] init];<br>    view.backgroundColor = [<span class="hljs-built_in">UIColor</span> greenColor];<br>    [contentView addSubview:view];<br>    [view mas_makeConstraints:^(MASConstraintMaker *make) &#123;<br>        make.centerX.equalTo(contentView);<br>        make.centerY.equalTo(contentView);<br>        make.top.equalTo(contentView.mas_top).offset(<span class="hljs-number">20</span>);<br>        make.width.height.equalTo(@<span class="hljs-number">100</span>);<br>    &#125;];<br>&#125;<br></code></pre></td></tr></table></figure>

<p>具体的展示如图:</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghc98hkth0j30jg0fe74c.jpg"></p>
<p>从图中我们可以很明显的看到绿色的子视图的宽高并不相同，同样在控制台上我们也看到了这样的输出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs log">2020-08-02 10:16:30.755508+0800 APPLaunchTime[1629:28678] [LayoutConstraints] Unable to simultaneously satisfy constraints.<br>	Probably at least one of the constraints in the following list is one you don&#39;t want. <br>	Try this: <br>		(1) look at each constraint and try to figure out which you don&#39;t expect; <br>		(2) find the code that added the unwanted constraint or constraints and fix it. <br>(<br>    &quot;&lt;MASLayoutConstraint:0x600000e183c0 UIView:0x7fa513e11cc0.height &#x3D;&#x3D; 200&gt;&quot;,<br>    &quot;&lt;MASLayoutConstraint:0x600000e181e0 UIView:0x7fa516604e70.centerY &#x3D;&#x3D; UIView:0x7fa513e11cc0.centerY&gt;&quot;,<br>    &quot;&lt;MASLayoutConstraint:0x600000e18600 UIView:0x7fa516604e70.top &#x3D;&#x3D; UIView:0x7fa513e11cc0.top + 20&gt;&quot;,<br>    &quot;&lt;MASLayoutConstraint:0x600000e186c0 UIView:0x7fa516604e70.height &#x3D;&#x3D; 100&gt;&quot;<br>)<br><br>Will attempt to recover by breaking constraint <br>&lt;MASLayoutConstraint:0x600000e186c0 UIView:0x7fa516604e70.height &#x3D;&#x3D; 100&gt;<br><br>Make a symbolic breakpoint at UIViewAlertForUnsatisfiableConstraints to catch this in the debugger.<br>The methods in the UIConstraintBasedLayoutDebugging category on UIView listed in &lt;UIKitCore&#x2F;UIView.h&gt; may also be helpful.<br><br></code></pre></td></tr></table></figure>

<p>控制台提示我们 下面列表中的约束其中有一个是不需要的，同时当前展示的样子是系统通过移除了哪个约束后展示出来的</p>
<h5 id="约束问题是什么"><a href="#约束问题是什么" class="headerlink" title="约束问题是什么"></a>约束问题是什么</h5><p>我们先看下控制台输出的提示</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs log">&quot;&lt;MASLayoutConstraint:0x600000e183c0 UIView:0x7fa513e11cc0.height &#x3D;&#x3D; 200&gt;&quot;,<br>&quot;&lt;MASLayoutConstraint:0x600000e181e0 UIView:0x7fa516604e70.centerY &#x3D;&#x3D; UIView:0x7fa513e11cc0.centerY&gt;&quot;,<br>&quot;&lt;MASLayoutConstraint:0x600000e18600 UIView:0x7fa516604e70.top &#x3D;&#x3D; UIView:0x7fa513e11cc0.top + 20&gt;&quot;,<br>&quot;&lt;MASLayoutConstraint:0x600000e186c0 UIView:0x7fa516604e70.height &#x3D;&#x3D; 100&gt;&quot;<br></code></pre></td></tr></table></figure>

<p>上面的提示中设计到两个UIView对象，<code>0x600000e183c0</code>和<code>0x7fa513e11cc0</code>,通过查看上面的约束提示，我们发现<code>height</code>,<code>centerY</code>,<code>top</code>,<code>height</code> 这几个约束都是垂直方向的约束。</p>
<p>上面的提示还有下面这句</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">Will attempt to recover by breaking constraint <br>&lt;MASLayoutConstraint:<span class="hljs-number">0x600000e186c0</span> <span class="hljs-built_in">UIView</span>:<span class="hljs-number">0x7fa516604e70</span>.height == <span class="hljs-number">100</span>&gt;<br></code></pre></td></tr></table></figure>
<p>尝试通过break高度为100的约束来正确展示这个视图，而结合我们上面展示的图片 没有生效的约束是<code>height=100</code>与上面的描述一致。</p>
<p>那通过上面的分析我们得出这次约束的问题是：</p>
<p>控件<code>0x600000e183c0</code>和<code>0x7fa516604e70</code>在垂直方向存在约束冲突，目前系统通过移除<code>UIView:0x7fa516604e70.height == 100</code>约束来展示UI，如果系统的修改与你的预期不符，可以通过修改上面提到的四个约束中的一个来展示出正确的UI。</p>
<h5 id="哪个视图约束有问题"><a href="#哪个视图约束有问题" class="headerlink" title="哪个视图约束有问题"></a>哪个视图约束有问题</h5><p>分析出约束的问题后，我们需要定位到底是哪两个视图出现了约束问题。</p>
<h6 id="通过内存地址定位"><a href="#通过内存地址定位" class="headerlink" title="通过内存地址定位"></a>通过内存地址定位</h6><p>我们可以通过查看层次结果，然后通过出现约束问题的视图的内存地址进行筛选，这样我们就能容易的定位到出现问题的视图。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghcaasl8hij31730u0hdt.jpg"></p>
<h6 id="通过lldb命令"><a href="#通过lldb命令" class="headerlink" title="通过lldb命令"></a>通过lldb命令</h6><p>我们还可以通过设置出现问题的视图的背景颜色来定位到底是哪个视图出现问题，当然是用lldb命令的前提是我们需要在合适的地方添加断点。</p>
<p>首先我们需要在项目中添加约束冲突(符号断点)断点，添加方法如下</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghcc7adgyej30qg0f8wvz.jpg"></p>
<p>添加了这个断点后，在应用启动遇到约束冲突的位置系统会，直接有约束冲突的位置设置断点，下面截取一部分发生断点时的提示</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs log">*UIButton:0x10b091670&#39;注册&#x2F;登录&#39;- AMBIGUOUS LAYOUT for UIButton:0x10b091670&#39;注册&#x2F;登录&#39;.minY&#123;id: 159&#125;   UIButtonLabel:0x10b15fb60&#39;注册&#x2F;登录&#39;<br><br> *UILabel:0x10b08f790&#39;群组&#39;- AMBIGUOUS LAYOUT for UILabel:0x10b08f790&#39;群组&#39;.minX&#123;id: 136&#125;, UILabel:0x10b08f790&#39;群组&#39;.minY&#123;id: 138&#125;, UILabel:0x10b08f790&#39;群组&#39;.Width&#123;id: 135&#125;, UILabel:0x10b08f790&#39;群组&#39;.Height&#123;id: 140&#125;<br><br></code></pre></td></tr></table></figure>

<p>这里我们可以通过关键词 <code>AMBIGUOUS LAYOUT</code> 来获取所有存在约束冲突的位置，因为log中有了按钮或者label的文案我们可以很快的定位到具体位置。</p>
<p>当然 如果层次非常深，或者我们无法通过文案进行区分，我们还可以通过下面的命令修改视图的背景颜色来定位出现约束冲突的视图。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs lldb">expr ((UILabel *)0x10b091670).backgroundColor &#x3D; [UIColor yellowColor];<br></code></pre></td></tr></table></figure>

<p>结果如下图：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghccdb25i4j30ku1120yj.jpg"></p>
<p>通过上面的方法我们可以定位到出现问题的视图控件，那么我们 下一步就要看如何去解决这个约束冲突。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过上面的方法我们可以准确的定位出出现约束冲突的控件是什么，约束冲突的原因是什么，那么接下来我们就需要根据自己的场景以及控制台给出的提示去判断目标的布局是什么样的，怎么去改。</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://stackoverflow.com/questions/26389273/how-to-trap-on-uiviewalertforunsatisfiableconstraints">How to trap on UIViewAlertForUnsatisfiableConstraints?</a></p>
<p><a href="https://www.jianshu.com/p/b2ab97a3b3b8">有歧义(AMBIGUOUS LAYOUT)的约束布局调试方法</a></p>
]]></content>
      <categories>
        <category>iOS进阶</category>
      </categories>
      <tags>
        <tag>Xcode,breakPoint</tag>
      </tags>
  </entry>
  <entry>
    <title>大数组的排序</title>
    <url>/2018/05/04/huge-array-sort/</url>
    <content><![CDATA[<p>之前有一个同事问我,如何对一个非常大的数组进行排序,最开始的思路是:化整为零 合并排序。但实际上具体的一些细节还是有待商榷,因此 这里写一篇文章来具体来总结一下。</p>
<a id="more"></a>

<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>假如一个数组中有1亿个数字,那么要对这个数组从小到大进行排序,我们该如何操作！</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>其实对于这种数据量比较大的问题,思路基本上都是一致的:</p>
<ul>
<li>首先,化整为零,对于那么大的一个数据,我们肯定不能直接对其进行操作,而是采用<code>某种方式</code>将这个数组划分成多个比较小的数组;</li>
<li>然后,我们在对这些比较小的数组采用<code>某种方式</code>进行排序;</li>
<li>最后,我们将所有排好序的数组采用<code>某种方式</code>合并到一个数组中。</li>
</ul>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>从上面的思路可以看出 要完成对这个大数组的排序,我们需要三个步骤,这三个步骤中我们可以采用不同的方法。下面我们就详细的看一下 每一步我们可以采用什么方法。</p>
<h3 id="化整为零"><a href="#化整为零" class="headerlink" title="化整为零"></a>化整为零</h3><p>那么我们采用何种方法化整为零呢？其实要看我们后面的算法需求(数组合并),化整为零其实就是将这个很大的数组分成若干个小块。</p>
<p>那么这些小块之间有什么关系呢？ 有序还是无序？</p>
<h4 id="数组间是有序的"><a href="#数组间是有序的" class="headerlink" title="数组间是有序的"></a>数组间是有序的</h4><p>如果我们要求划分出的数组块之间是有序的 也就是说 第一个数组块中的数 均小于第二个数组块中的数,那么我们很容易想到 快速排序 根据一个中间值 一次排序就可以将整个数组分成两部分,左边的比中间值小右边的比中间值大。</p>
<p>快速排序,思路其实是递归。但是这一步其实我们只是想将这个数组分组。那么我们可以设置一个表示每个子数组块大小的值。在递归的过程中 如果发现子数组的长度已经小于等于这个值 那么我们第一步化整为零完成。退出这次的快速排序。</p>
<p><code>注意</code>: 对于子数组的大小,个人感觉不需要过小(&lt;1000),因为如果采用快速排序进行分组,如果要分成每组只有1000条数据,递归的层数约为15层 个人感觉这属于比较深的递归了。需要考虑是否会造成内存溢出。</p>
<h5 id="内存溢出"><a href="#内存溢出" class="headerlink" title="内存溢出:"></a>内存溢出:</h5><p>溢出的意思就是越界，操作系统会给每个进程分配一个最大上限的堆栈空间，如果超过了这个内存空间大小程序就会coredump，就像你使用int *pi = new int[100000000];会崩溃一样，因为这里堆溢出了。<br>操作系统分配给一个进程的栈空间是2M，堆空间在32位机器上是4G。如果你的进程的栈空间使用超过了2M就会栈溢出，堆使用超过4G就会堆溢出。</p>
<p>那么递归为什么会导致栈溢出呢？相信大家知道栈的出入规则，先入后出，递归的话那么先入的一直不能出栈，会一致存在栈空间中，这样就容易导致栈满而溢出。</p>
<p>若递归调用次数太多，就会只入栈不出栈，于是堆栈就被压爆了，此为栈溢出</p>
<h4 id="数组间是无序的"><a href="#数组间是无序的" class="headerlink" title="数组间是无序的"></a>数组间是无序的</h4><p>如果我们对划分出来的子数组间没有要求,那么我们可以很简单的 通过一个表示子数组长度的值,将这个大的数组划分成多个小的数组。</p>
<p>不过如果不要求子数组之间是否有序,那么我们可以让数组的大小尽可能小(空间换时间),方便后面对子数组进行排序。</p>
<h3 id="对较小的数组排序"><a href="#对较小的数组排序" class="headerlink" title="对较小的数组排序"></a>对较小的数组排序</h3><p>对一个相对较小的数组排序的方法有很多,快速排序 选择排序都可以考虑。</p>
<p>这里贴一张图,常用的算法的时间和空间复杂度:</p>
<p><img src="https://img-blog.csdn.net/20161009171515225" alt="常用算法"></p>
<h3 id="数组合并"><a href="#数组合并" class="headerlink" title="数组合并"></a>数组合并</h3><p>数组的合并,如果在第一步的时候选择的是划分子数组之间是有序的,这一步我们只需要将划分好的数组合并一下就可以了。这样就可以实现对这个大的数组的排序。</p>
<p>如果第一步我们选择的是子数组间无序,那么我们就要在合并的时候,我们可以采取类似归并排序的方法对这些长度较小的数组进行合并。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上面所说的方法其实都可以实现排序的功能。但是对于数据非常多的情况，通常我们将数据全部读入内存在进行排序是非常困难的,因此在第一步的时候，如果我们选择的是将整个数据划分成有序块.那么我们要把所有的数据读到内存,而且快速排序的使用递归的思路更是大大的加大了排序过程中的内存占用。因此,一般情况 我们都采用先划分成小块(无序),然后每一个小块排序完成之后在进行多路归并排序。</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://blog.csdn.net/hzhsan/article/details/50476401">在c++中尾递归，普通递归，循环的效率对比</a></p>
<p><a href="https://blog.csdn.net/guyulongcs/article/details/7520467">10^n个整数（亿级）的排序</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>Time Profiler 使用</title>
    <url>/2018/12/22/iOS-Time-Profiler-%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>自从到现在的公司半年一来,业务上一直在不停的迭代。为了维持版本的迭代速度,代码review变得不再像之前那么严苛。导致近期出现了几个比较严重的问题,趁着周末的时间,使用Time Profiler好好的检测一下应用及时发现问题,解决问题。</p>
<a id="more"></a>

<h2 id="现状"><a href="#现状" class="headerlink" title="现状"></a>现状</h2><p>近期慢慢开始越来越多的线上用户反馈应用卡的问题,出现问题的页面主要集中在：</p>
<blockquote>
<p>1、登录卡住,实际已经登录成功但是一直卡在登录的loading页面<br>2、进入直播间的页面卡住<br>3、进入个人主页卡住</p>
</blockquote>
<p>出现问题的机型 基本都集中在iPhone 6上,虽说iPhone 6是属于比较旧的机型了,但是在用户中所占的比重还是挺多的(苹果的不作为导致大家都没有理由去换新手机了)。</p>
<p>听到用户反馈这个问题,其实第一感觉 对于2.3两个页面我们大概都能知道原因,因为界面比较复杂,而且要预加载部分信息,所以在较旧的设备上卡是正常的。对于登录页面其实我百思不得解。</p>
<p>现状就说到这里,下面开始干……</p>
<h2 id="性能检测工具"><a href="#性能检测工具" class="headerlink" title="性能检测工具"></a>性能检测工具</h2><p>对于iOS项目,苹果爸爸其实在Xcode中已经为我们提供了一套性能检测工具：</p>
<p><img src="https://ws1.sinaimg.cn/large/006tNbRwgy1fyfoorfbu7j316s0o0ad5.jpg" alt="工具套装"> </p>
<p>对于这些工具 可以做一个简单的分类：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2189300-2ed3883fb57c9abb.jpg" alt="工具分类"></p>
<p>可以根据自己的实际情况 去选择不同的工具,废话不多说,开干！！！</p>
<h2 id="Time-Profiler"><a href="#Time-Profiler" class="headerlink" title="Time Profiler"></a>Time Profiler</h2><p>根据我们的实际情况,首先是卡顿,所以我要知道 应用中的耗时操作到底在哪里,是否有一些耗时操作放到了主线程,导致应用的卡顿。</p>
<p>下面我们主要玩玩这个小东西：</p>
<p><img src="http://www.samirchen.com/images/use-instruments/time_profiler.png" alt="Time Profiler"></p>
<h3 id="选择正确的应用和正确的设备"><a href="#选择正确的应用和正确的设备" class="headerlink" title="选择正确的应用和正确的设备"></a>选择正确的应用和正确的设备</h3><p><img src="http://www.samirchen.com/images/use-instruments/instruments_trace_document_toolbar_target_menus.png"></p>
<p>温馨提示:<code>应用必须是已安装的哦</code></p>
<h3 id="开始检测"><a href="#开始检测" class="headerlink" title="开始检测"></a>开始检测</h3><p>点击红色按钮我们就可以开始对我们选中设备和选中的应用进行检测了。</p>
<h4 id="界面简单介绍"><a href="#界面简单介绍" class="headerlink" title="界面简单介绍"></a>界面简单介绍</h4><p><img src="https://img-blog.csdnimg.cn/20181120232259625.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hlbGxvX0h3Yw==,size_16,color_FFFFFF,t_70" alt="界面"></p>
<ul>
<li>各个线程的采集数据汇总</li>
<li>点击1中的某一行，可以看到采集到的堆栈，注意2区域的右上角，可以选择隐藏系统的符号</li>
<li>可以选择关注的队列/CPU等。</li>
<li>可以用pinch手势来放大缩小时间范围，鼠标可以拖动选择一段区域</li>
</ul>
<h4 id="检测结果"><a href="#检测结果" class="headerlink" title="检测结果"></a>检测结果</h4><p><img src="https://ws1.sinaimg.cn/large/006tNbRwgy1fyfp35i5jjj31240u0n1w.jpg" alt="结果"></p>
<p>额,顿时有种 裤子都脱了你给我看这个！！(问号脸)</p>
<h5 id="正确展示检测信息"><a href="#正确展示检测信息" class="headerlink" title="正确展示检测信息"></a>正确展示检测信息</h5><p>遇到这种事,一定要告诉自己:你一定不是第一个遇到这个问题的人。所以呢 谷歌一下 你就知道</p>
<p><img src="https://img-blog.csdnimg.cn/20181120232618275.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hlbGxvX0h3Yw==,size_16,color_FFFFFF,t_70" alt="谷歌"></p>
<p>原因：<code>打包模式没有开启dSYM或者debug symbols</code> 所以 将debug切换到 <code>DWARF with dSYM File</code></p>
<p>下面 我们重新跑一次！</p>
<p><img src="https://ws4.sinaimg.cn/large/006tNbRwgy1fyfpef2oycj31l20q2guf.jpg" alt="结果"></p>
<p>好像虽然有一些我比较熟悉的类出现,但是面对这样的提示,我依然是一脸懵逼呀！</p>
<h5 id="筛选检测信息"><a href="#筛选检测信息" class="headerlink" title="筛选检测信息"></a>筛选检测信息</h5><p><code>Time Profiler</code> 默认将检测的所有信息都返回给我们,所以,如果想快速的定位问题 我们需要正确的筛选这些信息。</p>
<p><img src="https://ws4.sinaimg.cn/large/006tNbRwgy1fyfpk0wywhj30q00a2agv.jpg" alt="小秘密"></p>
<p>在上图的位置处,Time Profiler 给我们这几个选项,首先来看看这几个选项是什么意思：</p>
<ul>
<li>Separate by State：线程分离，状态分开显示 ，例如：Running状态</li>
<li>Separate by Thread：按线程分开进行分析。容易找出消耗资源的问题线程，特别是对于主线程，因为主线程要处理和渲染所有的接口数据及UI视图，当主线程受到阻塞性操作，一定会造成程序的卡顿，或停止响应。</li>
<li>Invert Call Tree：反向显示调用树。把调用层级最深的方法显示在最上面，容易找到最耗时的操作。</li>
<li>Hide System Libraries：隐藏缺失的符号。把干扰信息屏蔽掉，即把列表中因为系统架构，或DSYM文件缺失造成奇怪的十六进制的数值。</li>
<li>Flatten Recursion：拼合递归。把同一递归函数产生的多条堆栈合并为一条。</li>
<li>Top Functions：找到最耗时的函数或方法。</li>
</ul>
<p>依据我们的情况可以选择 <code>Separate by Thread</code> 和 <code>Hide System Libraries</code> </p>
<h5 id="结果分析"><a href="#结果分析" class="headerlink" title="结果分析"></a>结果分析</h5><p><img src="https://ws3.sinaimg.cn/large/006tNbRwgy1fyfps8sxaaj312w0f2jvm.jpg"></p>
<p>筛选之后 我们可以拿到上面的记过,对于卡顿的问题,一般是因为有一些操作应该放在子线程去做的,结果放到了主线程中,因此 我们把重点放在主线程上</p>
<p><img src="https://ws4.sinaimg.cn/large/006tNbRwgy1fyfpuy0druj31bs0m0n52.jpg" alt="主线程"></p>
<p>在上面这张图中,我们就可以比较清晰的看到 我们在项目中书写的一些方法。每一行的前面,就是这一行代码对应的耗时时间。</p>
<p>现在我们需要操作一下手机,然后看一下出问题的这段时间,都有哪些耗时操作。</p>
<p>在分析耗时的时候 我们可以看到前面两列<code>Weight</code>和 <code>Self Weight</code> 这两列表示总的耗时和当前行在总耗时中的比重,因此我们可以直接排除掉<code>Self Weight</code>为0的行。</p>
<p><img src="https://ws1.sinaimg.cn/large/006tNbRwgy1fyfq2ae1ucj30ca074mxw.jpg" alt="比重"></p>
<p>这样我们一层层的展开就可以找到耗时的具体方法了</p>
<p><img src="https://ws1.sinaimg.cn/large/006tNbRwgy1fyfq60dao5j317x0u047h.jpg" alt="定位具体方法"></p>
<p>如果层级太深,我们可以双击某一行进入一个新的页面,单独看这一行展开的内容</p>
<p><img src="https://ws3.sinaimg.cn/large/006tNbRwgy1fyfq84bijuj310g08g0ts.jpg"></p>
<p>在这个页面 如果我们想定位到具体的代码,我们可以直接双击该行,就可以直接打开 对应耗时的那一行代码</p>
<p><img src="https://ws3.sinaimg.cn/large/006tNbRwgy1fyfq98zz4ij31kw0pijyg.jpg"></p>
<p>这样我们就可以根据实际情况,针对出现问题的代码进行修改和优化！</p>
<p>另外 我们可以对页面中出现的多个耗时操作进行排序</p>
<p><img src="https://img-blog.csdnimg.cn/20181120232517981.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hlbGxvX0h3Yw==,size_16,color_FFFFFF,t_70"></p>
<h3 id="耗时操作检测完成"><a href="#耗时操作检测完成" class="headerlink" title="耗时操作检测完成"></a>耗时操作检测完成</h3><p>通常很明显的页面卡顿都是因为将某些耗时操作放到了主线程中,解决方法也很简单,将一些复杂计算或者网络请求放到子线程中去执行。</p>
<p>当然,还有其他的页面会导致页面卡顿,比如,当界面有大量的shadow，mask或者有非常多的View/Layer，GPU渲染纹理和顶点的时候可能会有压力。</p>
<p>总结一下,页面卡顿的原因主要分为两大类：CPU瓶颈和GPU瓶颈。</p>
<p>所以<code>Time Profiler</code>能做的只是对于CPU使用率的监控。对于GPU的监控 我们应该去是用<code>Core Animation</code></p>
]]></content>
      <categories>
        <category>iOS优化</category>
      </categories>
      <tags>
        <tag>耗时 主线程 xCode</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS10 适配</title>
    <url>/2016/09/19/iOS10-adapter/</url>
    <content><![CDATA[<p> iOS 10 已经出来有一段时间了，beta版没有勇气去尝试，在苹果推送正式版之后马上升级，首先还是看了一下自己的APP是否有崩溃的问题，不过都还好问题不大，哈哈！！！</p>
<a id="more"></a>


<h4 id="1、使用权限"><a href="#1、使用权限" class="headerlink" title="1、使用权限"></a>1、使用权限</h4><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br>&lt;!-- 相册 --&gt; <br>&lt;key&gt;NSPhotoLibraryUsageDescription&lt;&#x2F;key&gt;<br> <br>&lt;string&gt;App需要您的同意,才能访问相册&lt;&#x2F;string&gt; <br><br>&lt;!-- 相机 --&gt; <br>&lt;key&gt;NSCameraUsageDescription&lt;&#x2F;key&gt; <br><br>&lt;string&gt;App需要您的同意,才能访问相机&lt;&#x2F;string&gt; <br><br>&lt;!-- 麦克风 --&gt; <br>&lt;key&gt;NSMicrophoneUsageDescription&lt;&#x2F;key&gt; <br><br>&lt;string&gt;App需要您的同意,才能访问麦克风&lt;&#x2F;string&gt; <br>&lt;!-- 位置 --&gt; <br><br>&lt;key&gt;NSLocationUsageDescription&lt;&#x2F;key&gt; <br><br>&lt;string&gt;App需要您的同意,才能访问位置&lt;&#x2F;string&gt; <br><br>&lt;!-- 在使用期间访问位置 --&gt; <br><br>&lt;key&gt;NSLocationWhenInUseUsageDescription&lt;&#x2F;key&gt; <br><br>&lt;string&gt;App需要您的同意,才能在使用期间访问位置&lt;&#x2F;string&gt; <br><br>&lt;!-- 始终访问位置 --&gt; <br><br>&lt;key&gt;NSLocationAlwaysUsageDescription&lt;&#x2F;key&gt; <br><br>&lt;string&gt;App需要您的同意,才能始终访问位置&lt;&#x2F;string&gt; <br><br>&lt;!-- 日历 --&gt; <br><br>&lt;key&gt;NSCalendarsUsageDescription&lt;&#x2F;key&gt; <br><br>&lt;string&gt;App需要您的同意,才能访问日历&lt;&#x2F;string&gt; <br><br>&lt;!-- 提醒事项 --&gt; <br><br>&lt;key&gt;NSRemindersUsageDescription&lt;&#x2F;key&gt; <br><br>&lt;string&gt;App需要您的同意,才能访问提醒事项&lt;&#x2F;string&gt; <br><br>&lt;!-- 运动与健身 --&gt; <br><br>&lt;key&gt;NSMotionUsageDescription&lt;&#x2F;key&gt; <br><br>&lt;string&gt;App需要您的同意,才能访问运动与健身&lt;&#x2F;string&gt;<br> <br>&lt;!-- 健康更新 --&gt; <br><br>&lt;key&gt;NSHealthUpdateUsageDescription&lt;&#x2F;key&gt; <br><br>&lt;string&gt;App需要您的同意,才能访问健康更新 &lt;&#x2F;string&gt; <br><br>&lt;!-- 健康分享 --&gt; <br><br>&lt;key&gt;NSHealthShareUsageDescription&lt;&#x2F;key&gt; <br><br>&lt;string&gt;App需要您的同意,才能访问健康分享&lt;&#x2F;string&gt; <br><br>&lt;!-- 蓝牙 --&gt; <br><br>&lt;key&gt;NSBluetoothPeripheralUsageDescription&lt;&#x2F;key&gt;<br> <br>&lt;string&gt;App需要您的同意,才能访问蓝牙&lt;&#x2F;string&gt; <br><br>&lt;!-- 媒体资料库 --&gt; <br><br>&lt;key&gt;NSAppleMusicUsageDescription&lt;&#x2F;key&gt; <br><br>&lt;string&gt;App需要您的同意,才能访问媒体资料库&lt;&#x2F;string&gt;<br><br></code></pre></td></tr></table></figure>


<p><a href="https://pan.baidu.com/s/1mhTA03I">直接下载</a></p>
<h4 id="2、TabBarshadowImage设置"><a href="#2、TabBarshadowImage设置" class="headerlink" title="2、TabBarshadowImage设置"></a>2、TabBarshadowImage设置</h4><p>iOS10跟新之后之前tabbar设置shadowimage的方法不起作用了，但是这个<br>方法还是可以的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">UITabBar *tabbar &#x3D; [UITabBar appearance];<br>[tabbar setBackgroundImage:[UIImage new]];<br>[tabbar setShadowImage:[UIImage new]];<br><br></code></pre></td></tr></table></figure>


<h4 id="3、Label文字显示不全的问题"><a href="#3、Label文字显示不全的问题" class="headerlink" title="3、Label文字显示不全的问题"></a>3、Label文字显示不全的问题</h4><p>iOS 10更新后发现英文字母显示没问题，在显示中文的时候UILabel的宽度计算有问题</p>
<p>解决方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">UILabel *myLabel &#x3D; [UILabel new];<br><br>&#x2F;*UIFont 的preferredFontForTextStyle: 意思是指定一个样式，并让<br>字体大小符合用户设定的字体大小。 *&#x2F;<br><br>myLabel.font &#x3D;[UIFont preferredFontForTextStyle: UIFontTextStyleHeadline];<br><br> &#x2F;*<br> Indicates whether the corresponding element should <br> automatically update its font when the device’s <br> UIContentSizeCategory is changed.<br> <br> For this property to take effect, the element’s font <br> must be a font vended using +preferredFontForTextStyle: <br> or <br>  <br>+preferredFontForTextStyle:compatibleWithTraitCollection:<br>  with a valid UIFontTextStyle.<br> *&#x2F;<br> <br>&#x2F;&#x2F;是否更新字体的变化<br><br>myLabel.adjustsFontForContentSizeCategory &#x3D; YES;<br><br></code></pre></td></tr></table></figure>
<p><code>目前没有找到可以整体修改的方法</code></p>
<h4 id="4、真彩色的显示"><a href="#4、真彩色的显示" class="headerlink" title="4、真彩色的显示"></a>4、真彩色的显示</h4><p>真彩色的显示会根据光感应器来自动的调节达到特定环境下显示与性能的平衡效果,如果需要这个功能的话,可以在info.plist-Source Code里配置:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;key&gt;UIWhitePointAdaptivityStyle&lt;&#x2F;key&gt;<br><br>它有五种取值,分别是:<br>&#x2F;&#x2F; 标准模式<br>&lt;string&gt;UIWhitePointAdaptivityStyleStandard&lt;&#x2F;string&gt;<br>&#x2F;&#x2F; 阅读模式<br>&lt;string&gt;UIWhitePointAdaptivityStyleReading&lt;&#x2F;string&gt;<br>&#x2F;&#x2F; 图片模式 <br>&lt;string&gt;UIWhitePointAdaptivityStylePhoto&lt;&#x2F;string&gt; <br>&#x2F;&#x2F; 视频模式<br>&lt;string&gt;UIWhitePointAdaptivityStyleVideo&lt;&#x2F;string&gt; <br>&#x2F;&#x2F; 游戏模式<br>&lt;string&gt;UIWhitePointAdaptivityStyleStandard&lt;&#x2F;string&gt; <br><br>五种模式的显示效果是从上往下递减,也就是说如果你的项目是图片处理类的,你选择的是阅读模式,给选择太好的效果会影响性能<br><br></code></pre></td></tr></table></figure>

<h4 id="5、更智能的键盘选择"><a href="#5、更智能的键盘选择" class="headerlink" title="5、更智能的键盘选择"></a>5、更智能的键盘选择</h4><p>系统可以在某些情况下自动选择适当的键盘，并提高键盘修正和主动与其他文本输入机会的整合。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&#x2F;&#x2F; The textContentType property is to provide the <br>keyboard with extra information about the semantic intent <br>of the text document.<br><br>@property(nonatomic,copy) UITextContentType <br>textContentType NS_AVAILABLE_IOS(10_0); &#x2F;&#x2F; default is nil<br><br>UITextContentTypeName            <br>UITextContentTypeNamePrefix      <br>UITextContentTypeGivenName       <br>UITextContentTypeMiddleName      UITextContentTypeFamilyName      <br>UITextContentTypeNameSuffix      <br>UITextContentTypeNickname        <br>UITextContentTypeJobTitle        <br>UITextContentTypeOrganizationName<br>UITextContentTypeLocation        <br>UITextContentTypeFullStreetAddres<br>UITextContentTypeStreetAddressLin<br>UITextContentTypeStreetAddressLin<br>UITextContentTypeAddressCity     <br>UITextContentTypeAddressState    <br>UITextContentTypeAddressCityAndSt<br>UITextContentTypeSublocality     <br>UITextContentTypeCountryName     <br>UITextContentTypePostalCode      <br>UITextContentTypeTelephoneNumber <br>UITextContentTypeEmailAddress    <br>UITextContentTypeURL             <br>UITextContentTypeCreditCardNumber<br><br><br></code></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>系统适配</category>
      </categories>
      <tags>
        <tag>iOS10,适配</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS11 Adatper</title>
    <url>/2017/10/09/iOS11-Adatper/</url>
    <content><![CDATA[<p>iOS来了一段时间了,每次系统更新,在体验New Feature的同时,我们要做的还有适配,因为我们的App包含iPhone和iPad,所以这里的总结包含了这两种设备的适配！</p>
<p>废话不多说,上干货！</p>
<a id="more"></a>

<h4 id="iOS11的判断"><a href="#iOS11的判断" class="headerlink" title="iOS11的判断"></a>iOS11的判断</h4><pre><code>#define IOS11OrLater    (@available(iOS 11.0, *))</code></pre>
<h4 id="导航栏高度"><a href="#导航栏高度" class="headerlink" title="导航栏高度"></a>导航栏高度</h4><p>导航栏高度一直是固定的64P, 到了iOS11这个规则被打破了！84!</p>
<p>iOS11之前</p>
<p><img src="https://user-gold-cdn.xitu.io/2017/10/3/a25e13e4a7c7dc403e3abe4f236632af?imageView2/0/w/1280/h/960" alt="iOS11之前"></p>
<p>iOS11之后</p>
<p><img src="https://user-gold-cdn.xitu.io/2017/10/3/db7501bdf726081e561998c37af3b77f?imageView2/0/w/1280/h/960" alt="iOS11之后"></p>
<p>其次,之前title和titleview是二选一的,在iOS11中可以通过开启</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&#x2F;&#x2F;根据prefersLargeTitles设置, 默认为NO;<br> self.navigationController.navigationBar.prefersLargeTitles &#x3D; YES;<br> <br></code></pre></td></tr></table></figure>

<p>来选择设置大标题</p>
<p><img src="http://og0h689k8.bkt.clouddn.com/17-10-9/95933026.jpg" alt="设置效果"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">self.navigationController.navigationBar.prefersLargeTitles &#x3D; YES;<br>self.title &#x3D; @&quot;这个是大标题&quot;;<br><br>UIView *titleView &#x3D; [[UIView alloc] initWithFrame:CGRectMake(0, 0,SCREEN_W , 44)]; &#x2F;&#x2F;高度&lt;&#x3D;44<br>titleView.backgroundColor &#x3D; [UIColor redColor];<br><br>UILabel *label &#x3D; [UILabel new];<br>label.text &#x3D; @&quot;这是TitleView(位置可以调整)&quot;;<br>label.textColor &#x3D; [UIColor whiteColor];<br>label.font &#x3D; [UIFont systemFontOfSize:18];<br>label.frame &#x3D; CGRectMake(10, 10, SCREEN_W, 44); &#x2F;&#x2F;高度超过默认44 会向下偏移<br>[titleView addSubview:label];<br><br>self.navigationItem.titleView &#x3D; titleView;<br><br></code></pre></td></tr></table></figure>

<p><code>titleView支持autolayout，这要求titleView必须是能够自撑开的或实现了- intrinsicContentSize</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs C">- (CGSize)intrinsicContentSize &#123;<br>    <span class="hljs-keyword">return</span> UILayoutFittingExpandedSize;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h4 id="tabBar-高度"><a href="#tabBar-高度" class="headerlink" title="tabBar 高度"></a>tabBar 高度</h4><p>底部区域主要是iPhoneX与其他机型不一样, 一般机型高度为49, iPhoneX为83;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">#define kTabBarHeight ([[UIApplication sharedApplication] statusBarFrame].size.height&gt;20?83:49)<br><br></code></pre></td></tr></table></figure>

<h4 id="导航栏返回按钮"><a href="#导航栏返回按钮" class="headerlink" title="导航栏返回按钮"></a>导航栏返回按钮</h4><p><img src="http://upload-images.jianshu.io/upload_images/2057602-aa6daf4862ed7bf2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="返回按钮"></p>
<p>之前如果通过某种方式自定义返回按钮,因为API的改变可能导致返回按钮下移</p>
<p>iOS 11之前</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">UIImage *backButtonImage &#x3D; [[UIImage imageNamed:@&quot;icon_tabbar_back&quot;]<br>    resizableImageWithCapInsets:UIEdgeInsetsMake(0, 18, 0, 0)];<br>[[UIBarButtonItem appearance] setBackButtonBackgroundImage:backButtonImage<br>                                                  forState:UIControlStateNormal<br>                                               barMetrics:UIBarMetricsDefault];<br>[[UIBarButtonItem appearance] setBackButtonTitlePositionAdjustment:UIOffsetMake(0, -60)<br>                                                    forBarMetrics:UIBarMetricsDefault];<br>                                                    <br></code></pre></td></tr></table></figure>
<p>iOS 11 中setBackButtonTitlePositionAdjustment:UIOffsetMake没法把按钮移出navigation bar。</p>
<p>解决方法是设置navigationController的backIndicatorImage和backIndicatorTransitionMaskImage</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">UIImage *backButtonImage &#x3D; [[UIImage imageNamed:@&quot;icon_tabbar_back&quot;] imageWithRenderingMode:UIImageRenderingModeAlwaysOriginal];<br>self.navigationBar.backIndicatorImage &#x3D; backButtonImage;<br>self.navigationBar.backIndicatorTransitionMaskImage &#x3D; backButtonImage;<br><br></code></pre></td></tr></table></figure>

<h4 id="automaticallyAdjustsScrollViewInsets废除"><a href="#automaticallyAdjustsScrollViewInsets废除" class="headerlink" title="automaticallyAdjustsScrollViewInsets废除"></a>automaticallyAdjustsScrollViewInsets废除</h4><p><img src="http://upload-images.jianshu.io/upload_images/2057602-5780671d66dccdb0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="inset"><br>iOS 11中ViewController的automaticallyAdjustsScrollViewInsets属性被废弃了，导致了 一些隐藏了系统导航栏或者自定义导航栏</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">self.automaticallyAdjustsScrollViewInsets &#x3D; NO;<br>self.extendedLayoutIncludesOpaqueBars &#x3D; YES;<br>self.edgesForExtendedLayout &#x3D; UIRectEdgeTop;<br></code></pre></td></tr></table></figure>

<p>automaticallyAdjustsScrollViewInsets属性被废弃了，顶部就多了一定的inset</p>
<p>解决方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">if (@available(iOS 11.0, *)) &#123;<br>    self.tableView.contentInsetAdjustmentBehavior &#x3D; UIScrollViewContentInsetAdjustmentNever;<br>&#125; else &#123;<br>    self.automaticallyAdjustsScrollViewInsets &#x3D; NO;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="tableview-header的问题"><a href="#tableview-header的问题" class="headerlink" title="tableview header的问题"></a>tableview header的问题</h4><p><img src="http://upload-images.jianshu.io/upload_images/2057602-81c74d7c47ab2be6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="右边为正确样式"></p>
<p>iOS 11中如果不实现-tableView: viewForFooterInSection: 和 -tableView: viewForHeaderInSection:，那么-tableView: heightForHeaderInSection:和- tableView: heightForFooterInSection:不会被调用。</p>
<p>这是因为estimatedRowHeight estimatedSectionHeaderHeight estimatedSectionFooterHeight三个高度估算属性由默认的0变成了UITableViewAutomaticDimension，导致高度计算不对，解决方法是实现对应方法或吧这三个属性设为0</p>
<h4 id="tableview新特性"><a href="#tableview新特性" class="headerlink" title="tableview新特性"></a>tableview新特性</h4><blockquote>
<p>设置delaysContentTouches为NO, 不会立即触发cell的响应事件;<br>两根手指快速的轻击cell，可以同时选中两个cell进入编辑状态。如果两个手指存在不同步问题，则<br>  会默认识别其中的一个手指表示单选cell;<br>新增了一个属性separatorInsetReference可以自定义一个cell分割线的边距;<br>cell或者表头表尾默认采用自适应高度的方案(造成UI紊乱的原因);<br>增加了numberOfLines属性来实现类似于UILabel一样的高度自适应变化;</p>
</blockquote>
<h4 id="获取地理位置权限的问题"><a href="#获取地理位置权限的问题" class="headerlink" title="获取地理位置权限的问题"></a>获取地理位置权限的问题</h4><p>在IOS11，原有的NSLocationAlwaysUsageDeion被降级为NSLocationWhenInUseUsageDeion;</p>
<p>需要在plist文件中配置NSLocationAlwaysAndWhenInUseUsageDeion，系统框才会弹出;使用requestAlwaysAuthorization获取权限 IOS11系统弹框会把几种权限级别全部列出，供用户选择;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">NSLocationUsageDescription<br>获取地理位置，精准推送服务<br>NSLocationWhenInUseUsageDescription<br>获取地理位置，精准推送服务<br>NSLocationAlwaysUsageDescription<br>App需要您的同意,才能始终访问位置<br>NSLocationAlwaysAndWhenInUseUsageDeion<br>App需要您的同意,才能始终访问位置<br></code></pre></td></tr></table></figure>

<h4 id="获取相册权限"><a href="#获取相册权限" class="headerlink" title="获取相册权限"></a>获取相册权限</h4><p>iOS11以前：<br>NSPhotoLibraryUsageDescription：访问相册和存储照片到相册（读写），会出现用户授权;</p>
<p>iOS11之后：<br>NSPhotoLibraryUsageDescription：无需添加。默认开启访问相册权限（读），无需用户授权;<br>NSPhotoLibraryAddUsageDescription： 添加内容到相册（写），会出现用户授权;</p>
<h4 id="xib编译问题"><a href="#xib编译问题" class="headerlink" title="xib编译问题"></a>xib编译问题</h4><p>一般是打开以前的工程, 编译的时候xib报错, 例如:</p>
<p><code>warning: Internationalization is not available when compiling for targets before iOS 6.0</code></p>
<p>解决办法：<br>选择编译错误的xib文件，找到Builds for 改为iOS 7.0 and Later</p>
<p><img src="https://user-gold-cdn.xitu.io/2017/10/3/4173ca5c988545dc956a7ff3a6883248?imageView2/0/w/1280/h/960" alt="iOS 7.0 and Later"></p>
<h4 id="iPhone-X-屏幕适配"><a href="#iPhone-X-屏幕适配" class="headerlink" title="iPhone X 屏幕适配"></a>iPhone X 屏幕适配</h4><p>添加iPhoneX的Launch图1125x2436<br>使用LaunchScreen来当做缓冲页或者修改Assets中的LaunchImage，添加iPhoneX的Launch图1125*2436（竖屏);</p>
<p><img src="http://og0h689k8.bkt.clouddn.com/17-10-9/25051633.jpg" alt="点击选中iOS8会自动"></p>
<p><img src="http://og0h689k8.bkt.clouddn.com/17-10-9/33437597.jpg"></p>
<h4 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h4><p><a href="http://www.cocoachina.com/ios/20170915/20580.html">简书App适配iOS 11</a><br><a href="http://www.jianshu.com/p/efbc8619d56b">iOS 11 安全区域适配总结</a><br><a href="https://juejin.im/entry/59d3712ef265da0651672a6d?utm_source=gold_browser_extension">iOS11问题汇总</a></p>
]]></content>
      <categories>
        <category>系统适配</category>
      </categories>
      <tags>
        <tag>iOS11,适配</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题——ChenYilong-总结</title>
    <url>/2015/08/13/interview-note-2/</url>
    <content><![CDATA[<p>本文是 看了github上 《招聘一个靠谱的iOS程序员》提供的面试题之后做的一些总结，内容大多为其中的一些摘抄。</p>
<a id="more"></a>

<h3 id="1、-objc-msgForward函数是做什么的，直接调用它将会发生什么？"><a href="#1、-objc-msgForward函数是做什么的，直接调用它将会发生什么？" class="headerlink" title="1、_objc_msgForward函数是做什么的，直接调用它将会发生什么？"></a>1、_objc_msgForward函数是做什么的，直接调用它将会发生什么？</h3><pre><code>_objc_msgForward是 IMP 类型，用于消息转发的：当向一个对象发送一条消息，但它并没有实现的时候，_objc_msgForward会尝试做消息转发。

在上篇中的《objc中向一个对象发送消息[obj foo]和objc_msgSend()函数之间有什么关系？》曾提到objc_msgSend在“消息传递”中的作用。在“消息传递”过程中，objc_msgSend的动作比较清晰：首先在 Class 中的缓存查找 IMP （没缓存则初始化缓存），如果没找到，则向父类的 Class 查找。如果一直查找到根类仍旧没有实现，则用_objc_msgForward函数指针代替 IMP 。最后，执行这个 IMP 。

为了展示消息转发的具体动作，这里尝试向一个对象发送一条错误的消息，并查看一下_objc_msgForward是如何进行转发的。</code></pre>
<p><img src="https://camo.githubusercontent.com/c06953c83cf1fd56eff670b88e4c3e0cc739c62d/687474703a2f2f692e696d6775722e636f6d2f556a626d5676422e706e67" alt="icon"></p>
<p>操作过程：<br><img src="https://camo.githubusercontent.com/c5d6a506acdf37eefcb090e3f7911d85186623f4/687474703a2f2f692e696d6775722e636f6d2f414145527a31542e706e67" alt="icon"><br>    结合《NSObject官方文档》，排除掉 NSObject 做的事，剩下的就是_objc_msgForward消息转发做的几件事：</p>
<pre><code>调用resolveInstanceMethod:方法 (或 resolveClassMethod:)。允许用户在此时为该 Class 动态添加实现。如果有实现了，则调用并返回YES，那么重新开始objc_msgSend流程。这一次对象会响应这个选择器，一般是因为它已经调用过class_addMethod。如果仍没实现，继续下面的动作。

调用forwardingTargetForSelector:方法，尝试找到一个能响应该消息的对象。如果获取到，则直接把消息转发给它，返回非 nil 对象。否则返回 nil ，继续下面的动作。注意，这里不要返回 self ，否则会形成死循环。

调用methodSignatureForSelector:方法，尝试获得一个方法签名。如果获取不到，则直接调用doesNotRecognizeSelector抛出异常。如果能获取，则返回非nil：创建一个 NSlnvocation 并传给forwardInvocation:。

调用forwardInvocation:方法，将第3步获取到的方法签名包装成 Invocation 传入，如何处理就在这里面了，并返回非ni。

调用doesNotRecognizeSelector: ，默认的实现是抛出异常。如果第3步没能获得一个方法签名，执行该步骤。</code></pre>
<p>下面回答下第二个问题“直接_objc_msgForward调用它将会发生什么？”</p>
<p>_objc_msgForward 方法解析</p>
<table>
<thead>
<tr>
<th align="left">–</th>
<th align="center">_objc_msgForward参数</th>
<th align="right">类型</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="center">所属对象</td>
<td align="right">id类型</td>
</tr>
<tr>
<td align="left">2</td>
<td align="center">方法名</td>
<td align="right">SEL类型</td>
</tr>
<tr>
<td align="left">3</td>
<td align="center">可变参数</td>
<td align="right">可变参数类型</td>
</tr>
</tbody></table>
<p>为了直观，我们可以通过如下方式定义一个 IMP类型 ：</p>
<pre><code>typedef void (*voidIMP)(id, SEL, ...)

一旦调用_objc_msgForward，将跳过查找 IMP 的过程，直接触发“消息转发”，
如果调用了_objc_msgForward，即使这个对象确实已经实现了这个方法，你也会告诉objc_msgSend：
“我没有在这个对象里找到这个方法的实现”
有哪些场景需要直接调用_objc_msgForward？最常见的场景是：你想获取某方法所对应的NSInvocation对象。举例说明：
JSPatch （Github 链接）就是直接调用_objc_msgForward来实现其核心功能的：

JSPatch（） 以小巧的体积做到了让JS调用/替换任意OC方法，让iOS APP具备热更新的能力、
作者的博文《JSPatch实现原理详解》详细记录了实现原理，有兴趣可以看下。</code></pre>
<h3 id="2、runtime如何实现weak变量的自动置nil？"><a href="#2、runtime如何实现weak变量的自动置nil？" class="headerlink" title="2、runtime如何实现weak变量的自动置nil？"></a>2、runtime如何实现weak变量的自动置nil？</h3><pre><code>runtime 对注册的类， 会进行布局，对于 weak 对象会放入一个 hash 表中。 用 weak 指向的对象内存地址作为 key，当此对象的引用计数为0的时候会 dealloc，假如 weak 指向的对象内存地址是a，那么就会以a为键， 在这个 weak 表中搜索，找到所有以a为键的 weak 对象，从而设置为 nil。
我们可以设计一个函数（伪代码）来表示上述机制：
objc_storeWeak(&amp;a, b)函数：
objc_storeWeak函数把第二个参数--赋值对象（b）的内存地址作为键值key，将第一个参数--weak修饰的属性变量（a）的内存地址（&amp;a）作为value，注册到 weak 表中。如果第二个参数（b）为0（nil），那么把变量（a）的内存地址（&amp;a）从weak表中删除，
你可以把objc_storeWeak(&amp;a, b)理解为：objc_storeWeak(value, key)，并且当key变nil，将value置nil。</code></pre>
<p>注意：</p>
<pre><code>在b非nil时，a和b指向同一个内存地址，在b变nil时，a变nil。此时向a发送消息不会崩溃：在Objective-C中向nil发送消息是安全的。

而如果a是由assign修饰的，则： 在b非nil时，a和b指向同一个内存地址，在b变nil时，a还是指向该内存地址，变野指针。此时向a发送消息极易崩溃。
原因：第一种情况a适用weak修饰 在b被置为nil的时候会遍历所有指向这块内存地址的指针 将这些指针置为ni 
    第二种情况a适用assign修饰，在b被置为nil的时候 不会将a指向的对象置为nil，所以默认a仍然指向原来的地址 但是这块地址被释放或者重新利用之后 现存的数据类型和原来的可能不一样了，所以可能出现野指针的问题</code></pre>
<h3 id="3、objc-initWeak和objc-destroyWeak解释"><a href="#3、objc-initWeak和objc-destroyWeak解释" class="headerlink" title="3、objc_initWeak和objc_destroyWeak解释"></a>3、objc_initWeak和objc_destroyWeak解释</h3><pre><code> 通过objc_initWeak函数初始化“附有weak修饰符的变量（obj1）”，在变量作用域结束时通过objc_destoryWeak函数释放该变量（obj1）。</code></pre>
<p>方法的内部实现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">objc_initWeak函数的实现是这样的：在将“附有weak修饰符的变量（obj1）”初始化为0（nil）后，会将“赋值对象”（obj）作为参数，调用objc_storeWeak函数。<br><br>	obj1 &#x3D; 0；<br>	obj_storeWeak(&amp;obj1, obj)<br></code></pre></td></tr></table></figure>

<p>weak 修饰的指针默认值是 nil （在Objective-C中向nil发送消息是安全的）<br>然后obj_destroyWeak函数将0（nil）作为参数，调用objc_storeWeak函数<br>objc_storeWeak(&amp;obj1, 0);</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">id obj1;<br>obj1 &#x3D; 0;<br>objc_storeWeak(&amp;obj1, obj);<br>&#x2F;* ... obj的引用计数变为0，被置nil ... *&#x2F;<br>objc_storeWeak(&amp;obj1, 0);<br></code></pre></td></tr></table></figure>
<p>objc_storeWeak函数把第二个参数–赋值对象（obj）的内存地址作为键值，将第一个参数–weak修饰的属性变量（obj1）的内存地址注册到 weak 表中。如果第二个参数（obj）为0（nil），那么把变量（obj1）的地址从weak表中删除</p>
<h3 id="4、能否向编译后得到的类中增加实例变量？能否向运行时创建的类中添加实例变量？为什么？"><a href="#4、能否向编译后得到的类中增加实例变量？能否向运行时创建的类中添加实例变量？为什么？" class="headerlink" title="4、能否向编译后得到的类中增加实例变量？能否向运行时创建的类中添加实例变量？为什么？"></a>4、能否向编译后得到的类中增加实例变量？能否向运行时创建的类中添加实例变量？为什么？</h3><pre><code>不能向编译后得到的类中增加实例变量；</code></pre>
<p>能向运行时创建的类中添加实例变量；<br>解释下：</p>
<pre><code>因为编译后的类已经注册在 runtime 中，类结构体中的 objc_ivar_list 实例变量的链表 和 instance_size 实例变量的内存大小已经确定，同时runtime 会调用 class_setIvarLayout 或 class_setWeakIvarLayout 来处理 strong weak 引用。所以不能向存在的类中添加实例变量；

运行时创建的类是可以添加实例变量，调用 class_addIvar 函数。但是得在调用 objc_allocateClassPair 之后，objc_registerClassPair 之前，原因同上。</code></pre>
<h3 id="5、runloop和线程有什么关系"><a href="#5、runloop和线程有什么关系" class="headerlink" title="5、runloop和线程有什么关系"></a>5、runloop和线程有什么关系</h3><p>1、主线程的run loop默认是启动的。<br>    iOS的应用程序里面，程序启动后会有一个如下的main()函数</p>
<pre><code>int main(int argc, char * argv[]) &#123;
@autoreleasepool &#123;
    return UIApplicationMain(argc, argv, nil,     NSStringFromClass([AppDelegate class]));
&#125;
&#125;
重点是UIApplicationMain()函数，这个方法会为main thread设置一个NSRunLoop对象，这就解释了：为什么我们的应用可以在无人操作的时候休息，需要让它干活的时候又能立马响应。
对其它线程来说，run loop默认是没有启动的，如果你需要更多的线程交互则可以手动配置和启动，如果线程只是去执行一个长时间的已确定的任务则不需要。
在任何一个 Cocoa 程序的线程中，都可以通过以下代码来获取到当前线程的 run loop 。
NSRunLoop *runloop = [NSRunLoop currentRunLoop];</code></pre>
<p><a href="http://blog.csdn.net/wzzvictory/article/details/9237973">《Objective-C之run loop详解》</a></p>
<h3 id="6、不手动指定autoreleasepool的前提下，一个autorealese对象在什么时刻释放？（比如在一个vc的viewDidLoad中创建）"><a href="#6、不手动指定autoreleasepool的前提下，一个autorealese对象在什么时刻释放？（比如在一个vc的viewDidLoad中创建）" class="headerlink" title="6、不手动指定autoreleasepool的前提下，一个autorealese对象在什么时刻释放？（比如在一个vc的viewDidLoad中创建）"></a>6、不手动指定autoreleasepool的前提下，一个autorealese对象在什么时刻释放？（比如在一个vc的viewDidLoad中创建）</h3><pre><code>分两种情况：手动干预释放时机、系统自动去释放。

手动干预释放时机--指定autoreleasepool 就是所谓的：当前作用域大括号结束时释放。
系统自动去释放--不手动指定autoreleasepool

Autorelease对象出了作用域之后，会被添加到最近一次创建的自动释放池中，并会在当前的 runloop 迭代结束时释放。</code></pre>
<p><img src="https://camo.githubusercontent.com/56f8ea718f47679e7771d247d8f6f820de2e0ab5/687474703a2f2f6936312e74696e797069632e636f6d2f32386b6f6477702e6a7067" alt="icon"></p>
<pre><code>我们都是知道： 所有 autorelease 的对象，在出了作用域之后，会被自动添加到最近创建的自动释放池中。

但是如果每次都放进应用程序的 main.m 中的 autoreleasepool 中，迟早有被撑满的一刻。这个过程中必定有一个释放的动作。何时？

在一次完整的运行循环结束之前，会被销毁。

那什么时间会创建自动释放池？运行循环检测到事件并启动后，就会创建自动释放池。

子线程的 runloop 默认是不工作，无法主动创建，必须手动创建。
@autoreleasepool 当自动释放池被销毁或者耗尽时，会向自动释放池中的所有对象发送 release 消息，释放自动释放池中的所有对象。
如果在一个vc的viewDidLoad中创建一个 Autorelease对象，那么该对象会在 viewDidAppear 方法执行前就被销毁了。
如果在一个vc的viewDidLoad中创建一个 Autorelease对象，那么该对象会在 viewDidAppear 方法执行前就被销毁了。</code></pre>
<p><a href="http://blog.sunnyxx.com/2014/10/15/behind-autorelease/">《黑幕背后的Autorelease》</a></p>
<h3 id="7、BAD-ACCESS在什么情况下出现？"><a href="#7、BAD-ACCESS在什么情况下出现？" class="headerlink" title="7、BAD_ACCESS在什么情况下出现？"></a>7、BAD_ACCESS在什么情况下出现？</h3><pre><code>访问了野指针，比如对一个已经释放的对象执行了release、访问已经释放对象的成员变量或者发消息。 死循环</code></pre>
<h3 id="8、苹果是如何实现autoreleasepool的？"><a href="#8、苹果是如何实现autoreleasepool的？" class="headerlink" title="8、苹果是如何实现autoreleasepool的？"></a>8、苹果是如何实现autoreleasepool的？</h3><pre><code>autoreleasepool 以一个队列数组的形式实现,主要通过下列三个函数完成.

objc_autoreleasepoolPush
objc_autoreleasepoolPop
objc_autorelease
看函数名就可以知道，对 autorelease 分别执行 push，和 pop 操作。销毁对象时执行release操作。</code></pre>
<p><img src="https://camo.githubusercontent.com/1e77679169328e5128722b3268bf9a488fc00ae2/687474703a2f2f6936302e74696e797069632e636f6d2f31356d666a31312e6a7067" alt="icon"></p>
<h3 id="9、-如何用GCD同步若干个异步调用？（如根据若干个url异步加载多张图片，然后在都下载完成后合成一张整图"><a href="#9、-如何用GCD同步若干个异步调用？（如根据若干个url异步加载多张图片，然后在都下载完成后合成一张整图" class="headerlink" title="9、 如何用GCD同步若干个异步调用？（如根据若干个url异步加载多张图片，然后在都下载完成后合成一张整图"></a>9、 如何用GCD同步若干个异步调用？（如根据若干个url异步加载多张图片，然后在都下载完成后合成一张整图</h3><pre><code>dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
dispatch_group_t group = dispatch_group_create();
dispatch_group_async(group, queue, ^&#123; /*加载图片1 */ &#125;);
dispatch_group_async(group, queue, ^&#123; /*加载图片2 */ &#125;);
dispatch_group_async(group, queue, ^&#123; /*加载图片3 */ &#125;); 
dispatch_group_notify(group, dispatch_get_main_queue(),     ^&#123;
        // 合并图片
&#125;);</code></pre>
<h3 id="10、apple用什么方式实现对一个对象的KVO？"><a href="#10、apple用什么方式实现对一个对象的KVO？" class="headerlink" title="10、apple用什么方式实现对一个对象的KVO？"></a>10、apple用什么方式实现对一个对象的KVO？</h3><pre><code>当你观察一个对象时，一个新的类会被动态创建。这个类继承自该对象的原本的类，并重写了被观察属性的 setter 方法。重写的 setter 方法会负责在调用原 setter 方法之前和之后，通知所有观察对象：值的更改。最后通过 isa 混写（isa-swizzling） 把这个对象的 isa 指针 ( isa 指针告诉 Runtime 系统这个对象的类是什么 ) 指向这个新创建的子类，对象就神奇的变成了新创建的子类的实例</code></pre>
<p><img src="https://camo.githubusercontent.com/9517b0d78961b5f32cf3392b99964f2e1f79fb35/687474703a2f2f6936322e74696e797069632e636f6d2f7379353775722e6a7067" alt="icon"></p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>靠谱的iOS程序员</tag>
      </tags>
  </entry>
  <entry>
    <title>数组和字典的小知识</title>
    <url>/2016/03/30/ios-arrayandDict/</url>
    <content><![CDATA[<p>最近出去面试的时候被问到了这个问题，回来之后觉得这个问题需要好好的思考一下，因此总结了几个和数组以及字典相关的知识点，目前暂未完成，有时间会陆续的完善！</p>
<a id="more"></a>

<h4 id="1、前言"><a href="#1、前言" class="headerlink" title="1、前言"></a>1、前言</h4><p>前几天出去面试一下，面试官问了一个问题</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">一个数组 使用下面两种方式获取数组中的第一个元素有什么区别<br><br>数组 Arr<br><br>1、arr.firstObject<br>2、arr[0]<br><br></code></pre></td></tr></table></figure>

<p> 当下，我只是回答了，当数组为空时，使用第一种方法获取数组的第一个元素不<br> 会崩溃，使用第二种方法获取数据的时候会发生崩溃。但是具体的原因，的确不<br> 怎么清楚，所以 回答的不怎么理想，回来之后总结一下关于这里的内容</p>
<h4 id="2、官网解释"><a href="#2、官网解释" class="headerlink" title="2、官网解释"></a>2、官网解释</h4><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&#x2F;&#x2F;&#x2F; Returns the first element of &#96;self&#96;, or &#96;nil&#96; if &#96;self&#96; is empty.<br>&#x2F;&#x2F;&#x2F;<br>&#x2F;&#x2F;&#x2F; - Complexity: O(1)<br>public var first: Self.Generator.Element? &#123; get &#125;<br><br><br></code></pre></td></tr></table></figure>

<p>相较于直接使用objectAtIndex，其实是多加了一个判断</p>
<h4 id="3、扩展"><a href="#3、扩展" class="headerlink" title="3、扩展"></a>3、扩展</h4><p>遇到这个问题，我又想到了数组的老搭档–&gt;字典</p>
<p><img src="http://i.niupic.com/images/2016/03/29/eMawJg.png" alt="icon"></p>
<p>结果很明显，都不会报错，且取出的值均为null</p>
<h4 id="4、其他"><a href="#4、其他" class="headerlink" title="4、其他"></a>4、其他</h4><p>对于具体 为什么使用arr.firstObject不会报错，目前只能<code>猜测</code>为添加了一个判空操作</p>
]]></content>
      <categories>
        <category>iOS基础</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
        <tag>NSArray</tag>
        <tag>NSDictionary</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS基础动画</title>
    <url>/2014/12/11/ios-base-animation/</url>
    <content><![CDATA[<p>简单的介绍了一下，iOS 开发过程中常用的一些基础动画，结合使用的场景能够更好的去了解和实践。</p>
<a id="more"></a>

<h3 id="1、CALayer-图层介绍"><a href="#1、CALayer-图层介绍" class="headerlink" title="1、CALayer 图层介绍"></a>1、CALayer 图层介绍</h3><p>Layer常用属性：<br>下面通过一个简单的Demo来看一下常用的属性:</p>
<p><img src="http://img.hoop8.com/attachments/1601/950757074960.png" alt="layer的常用属性"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&#x2F;&#x2F;设置阴影<br>image.layer.shadowColor &#x3D; [UIColor blackColor].CGColor;<br>&#x2F;&#x2F;设置阴影的偏移<br>image.layer.shadowOffset &#x3D; CGSizeMake(10, 10);<br>&#x2F;&#x2F;设置不透明度<br>image.layer.shadowOpacity &#x3D; 0.5;<br>&#x2F;&#x2F;设置圆角<br>image.layer.cornerRadius &#x3D; 10;<br>&#x2F;&#x2F;必须设置 强制内部子控件支持圆角效果，少了这个设置，UIImageView将没有圆角效果<br>&#x2F;&#x2F;设置之后将没有阴影效果<br>image.layer.masksToBounds &#x3D; YES;<br><br>&#x2F;&#x2F;设置边框<br>image.layer.borderWidth &#x3D; 5.;<br>image.layer.borderColor &#x3D; [UIColor grayColor].CGColor;<br><br>&#x2F;&#x2F;旋转<br>&#x2F;&#x2F;x轴方向缩小为原来的0.5倍<br>image.layer.transform &#x3D; CATransform3DMakeScale(0.5, 1, 0);<br><br></code></pre></td></tr></table></figure>

<h3 id="2、图层的创建"><a href="#2、图层的创建" class="headerlink" title="2、图层的创建"></a>2、图层的创建</h3><p>1、图层的创建</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">CALayer *layer &#x3D; [CALayer layer];<br>layer.bounds &#x3D; CGRectMake(0, 0, 100, 100);<br>layer.position &#x3D; CGPointMake(100, 100);<br>&#x2F;&#x2F;锚点：指明哪一个点在position的位置<br>&#x2F;&#x2F;x,y均在0-1的范围内 （0，0）为原点 （1，1）为右下角<br>layer.anchorPoint &#x3D; CGPointMake(1, 1);<br>layer.backgroundColor &#x3D; [UIColor redColor].CGColor;<br>[self.view.layer addSublayer:layer];<br><br></code></pre></td></tr></table></figure>

<p><code>注意区分position和anchorPoint</code></p>
<p>2、自定义图层的方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">1、间子类继承与CALayer,实现drawInContext:方法<br>2、在控制器中设置代理，实现代理方法回执图层<br><br></code></pre></td></tr></table></figure>

<h3 id="3、CAAnimation"><a href="#3、CAAnimation" class="headerlink" title="3、CAAnimation"></a>3、CAAnimation</h3><h4 id="1、基础动画-CABasicAnimation"><a href="#1、基础动画-CABasicAnimation" class="headerlink" title="1、基础动画 CABasicAnimation"></a>1、基础动画 CABasicAnimation</h4><p>主要包括三种：形变 位置变化 旋转 都是通过设置keyPath实现的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">    CABasicAnimation *anim &#x3D; [CABasicAnimation animation];<br>    <br>&#x2F;&#x2F;    anim.keyPath &#x3D; @&quot;bounds&quot;;  &#x2F;&#x2F;形变<br>&#x2F;&#x2F;    anim.toValue &#x3D; [NSValue valueWithCGRect:CGRectMake(0, 0, 50, 50)];<br>    <br>&#x2F;&#x2F;    anim.keyPath &#x3D; @&quot;position&quot;; &#x2F;&#x2F;位置变化<br>&#x2F;&#x2F;    anim.toValue &#x3D; [NSValue valueWithCGPoint:CGPointMake(300, 300)];  &#x2F;&#x2F;终止点的位置<br>&#x2F;&#x2F;    anim.byValue &#x3D; [NSValue valueWithCGPoint:CGPointMake(100, 100)];    &#x2F;&#x2F;相对移动的位置<br>    <br>    anim.keyPath &#x3D; @&quot;transform&quot;; &#x2F;&#x2F;旋转<br>    &#x2F;&#x2F;围绕x,y轴方向旋转<br>    anim.toValue &#x3D; [NSValue valueWithCATransform3D:CATransform3DMakeRotation(M_PI_4, 1, 1, 0)];<br>    <br>    anim.duration &#x3D; 2.0f;<br>    anim.removedOnCompletion &#x3D; NO;<br>    anim.fillMode &#x3D; @&quot;forwards&quot;;<br>    <br>    [self.layer addAnimation:anim forKey:nil];<br><br></code></pre></td></tr></table></figure>
<h4 id="2、关键帧动画-CAKeyframeAnimation"><a href="#2、关键帧动画-CAKeyframeAnimation" class="headerlink" title="2、关键帧动画 CAKeyframeAnimation"></a>2、关键帧动画 CAKeyframeAnimation</h4><p>可以为动画设置一个路径，让某一个对象按这个路径去运动，可以设置动画的执行节奏</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">    CAKeyframeAnimation *anim &#x3D; [CAKeyframeAnimation animationWithKeyPath:@&quot;position&quot;];<br>    anim.removedOnCompletion &#x3D; NO;<br>    &#x2F;&#x2F;保持最新的状态<br>    anim.fillMode &#x3D; kCAFillModeForwards;<br>    anim.duration &#x3D; 2.f;<br>    CGMutablePathRef path &#x3D; CGPathCreateMutable();<br>&#x2F;&#x2F;    CGPathAddRect(path, NULL, CGRectMake(0, 0, 100, 100));<br>    CGPathAddEllipseInRect(path, NULL, CGRectMake(0, 0, 100, 100));<br>    <br>    anim.path &#x3D; path;<br>    &#x2F;&#x2F;设置动画的执行节奏<br>    anim.timingFunction &#x3D; [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseOut];<br>    <br>    [self.layer addAnimation:anim forKey:nil];<br><br></code></pre></td></tr></table></figure>

<h4 id="3、转场动画-CATransition"><a href="#3、转场动画-CATransition" class="headerlink" title="3、转场动画 CATransition"></a>3、转场动画 CATransition</h4><p>1、view的转场动画</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">CATransition *transition &#x3D; [CATransition animation];<br>transition.duration &#x3D; 2.f;<br>transition.timingFunction &#x3D; [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseOut];<br><br>transition.type &#x3D; @&quot;push&quot;;<br>transition.subtype &#x3D; kCATransitionFromTop;<br><br>[_animationView exchangeSubviewAtIndex:0 withSubviewAtIndex:1];<br><br>[_animationView.layer addAnimation:transition forKey:@&quot;myAnimation&quot;];<br></code></pre></td></tr></table></figure>

<p>2、控制器的专场动画</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">CATransition *transition &#x3D; [CATransition animation];<br>transition.duration &#x3D; 2.f;<br>transition.timingFunction &#x3D; [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseOut];<br><br>transition.type &#x3D; @&quot;rippleEffect&quot;;<br>transition.subtype &#x3D; kCATransitionFromTop;<br><br>[self.navigationController.view.layer addAnimation:transition forKey:@&quot;navAnimation&quot;];<br><br>DetailViewController *detailVc &#x3D; [[DetailViewController alloc] init];<br>[self.navigationController showViewController:detailVc sender:nil];<br><br></code></pre></td></tr></table></figure>
<p><img src="http://img.hoop8.com/attachments/1601/5941760466397.gif" alt="icon"></p>
<p>支持的过渡效果和过渡方向</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&#x2F;* 过渡效果<br> fade     &#x2F;&#x2F;交叉淡化过渡(不支持过渡方向) kCATransitionFade<br> push     &#x2F;&#x2F;新视图把旧视图推出去  kCATransitionPush<br> moveIn   &#x2F;&#x2F;新视图移到旧视图上面   kCATransitionMoveIn<br> reveal   &#x2F;&#x2F;将旧视图移开,显示下面的新视图  kCATransitionReveal<br> cube     &#x2F;&#x2F;立方体翻滚效果<br> oglFlip  &#x2F;&#x2F;上下左右翻转效果<br> suckEffect   &#x2F;&#x2F;收缩效果，如一块布被抽走(不支持过渡方向)<br> rippleEffect &#x2F;&#x2F;滴水效果(不支持过渡方向)<br> pageCurl     &#x2F;&#x2F;向上翻页效果<br> pageUnCurl   &#x2F;&#x2F;向下翻页效果<br> cameraIrisHollowOpen  &#x2F;&#x2F;相机镜头打开效果(不支持过渡方向)<br> cameraIrisHollowClose &#x2F;&#x2F;相机镜头关上效果(不支持过渡方向)<br>*&#x2F;<br>   <br>&#x2F;* 过渡方向<br> kCATransitionFromRight<br> kCATransitionFromLeft<br> kCATransitionFromBottom<br><br></code></pre></td></tr></table></figure>
<p><code>使用的时候一定要注意，有些事苹果私有的API，小心被拒</code></p>
<h4 id="4、动画组-CAAnimationGroup"><a href="#4、动画组-CAAnimationGroup" class="headerlink" title="4、动画组 CAAnimationGroup"></a>4、动画组 CAAnimationGroup</h4><p>将几个动画放到一个动画组里，这些动画会依次执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">CATransition *transition &#x3D; [CATransition animation];<br>transition.duration &#x3D; 2.f;<br>transition.timingFunction &#x3D; [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseOut];<br><br>transition.type &#x3D; @&quot;push&quot;;<br>transition.subtype &#x3D; kCATransitionFromTop;<br><br><br>CATransition *transition1 &#x3D; [CATransition animation];<br>transition1.duration &#x3D; 2.f;<br>transition1.timingFunction &#x3D; [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseOut];<br><br>transition1.type &#x3D; @&quot;moveIn&quot;;<br>transition1.subtype &#x3D; kCATransitionFromTop;<br><br>CAAnimationGroup *group &#x3D; [CAAnimationGroup animation];<br>group.animations &#x3D; @[transition,transition1];<br><br><br>[_animationView exchangeSubviewAtIndex:0 withSubviewAtIndex:1];<br><br>[_animationView.layer addAnimation:group forKey:@&quot;myAnimation&quot;];<br><br></code></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>UI</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
        <tag>CABaseAnimation</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS开发中的小技巧</title>
    <url>/2015/05/05/ios-develop-tips/</url>
    <content><![CDATA[<p>这篇文章主要总结了一部分iOS开发中的小技巧，有些方法对系统有依赖(iOS 8.0以上才可以使用)，一个复杂的问题，通过使用一些小技巧就可以很简单的实现。</p>
<a id="more"></a>


<p>1、<br>用 Property() 这个 macro 在编译时检查一个 class 是否包含一个 property，并取到那个 property 的名字（一个 NSString），配合 Core Data 使用非常方便。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">#define Property(Class, PropertyName) @(((void)(NO &amp;&amp; ((void)[Class nilObject].PropertyName, NO)), # PropertyName))<br></code></pre></td></tr></table></figure>

<p>2、设置透明的导航栏</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">[self.navigationController.navigationBar setBackgroundImage:[UIImage new] forBarMetrics:UIBarMetricsDefault];<br>&#x2F;&#x2F;导航栏底部线清楚<br>self.navigationController.navigationBar.barStyle &#x3D; UIBarStyleBlack;<br>self.navigationController.navigationBar.translucent &#x3D; YES;[self.navigationController.navigationBar setShadowImage:[UIImage new]];<br>self.navigationBar.translucent &#x3D; YES;<br></code></pre></td></tr></table></figure>
<p><img src="https://pic4.zhimg.com/e844607cdaa057885b84142de2e3c297_b.jpg" alt="icon"></p>
<p>3、iOS8 以上 侧滑多按钮</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">- (nullable NSArray<br>*)tableView:(UITableView *)tableView editActionsForRowAtIndexPath:(NSIndexPath *)indexPath<br><br>返回一个UITableViewRowAction数组，每一个&quot;Action&quot;代表一个侧滑删除的Button。这样侧滑每一行Cell可以有更多按钮提供给用户交互。<br><br></code></pre></td></tr></table></figure>

<p>4、设置banner中的图片的时候 一般情况下对图片进行的设置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">1、aspect fill 让图片填充<br>2、clip subviews 如果有图片宽度过宽裁剪超出部分（超出部分不会自动裁剪） <br></code></pre></td></tr></table></figure>

<p>5、使用tableviewcell的时候 最好采用注册-使用的方式不要</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">if( cell &#x3D;&#x3D; nil )<br></code></pre></td></tr></table></figure>
<p>太low</p>
<p>6、最好不要再用#define定义常量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">原因：1、宏只是进行字符串替换   2  如果作为一个第三方的容易和现有的宏冲突 如果非要用 必须加上 if define<br><br>如何定义常量<br>static NSString const kImageWidth&#x3D; 80.f<br>使用这种方式定义<br></code></pre></td></tr></table></figure>

<p>7、手动调用一个按钮的点击事件（适合于使用RAC或者block的情况）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">[cell.callTeacherBtn sendActionsForControlEvents:UIControlEventTouchUpInside];<br><br></code></pre></td></tr></table></figure>
<p>8、控制台输出 想要的数据</p>
<p><img src="http://ww1.sinaimg.cn/bmiddle/cb8a22eagw1eys7l6nzz5j20gb07ajsw.jpg" alt="icon"></p>
<p>这个略叼啊！！！！</p>
<p>9、tableview 动态计算行高</p>
<p>方法1：传入这个cell对应的模型，然后一次进行计算<br>方法2：传入模型，根据模型更新约束会改变的控件的约束，刷新界面，获取最下面的空间的最大高度</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&#x2F;&#x2F;在表格cell中 计算出高度<br>-(CGFloat)rowHeightWithCellModel:(HomeModel *)homeModel<br>&#123;<br>    _homeModel&#x3D;homeModel;<br>    __weak __typeof(&amp;*self)weakSelf &#x3D; self;<br>    &#x2F;&#x2F;设置标签的高度<br>    [self.content mas_makeConstraints:^(MASConstraintMaker *make) &#123;<br>        &#x2F;&#x2F; weakSelf.contentLabelH  这个会调用下面的懒加载方法<br>        make.height.mas_equalTo(weakSelf.contentLabelH);<br>    &#125;];<br>    <br>    &#x2F;&#x2F; 2. 更新约束<br>    [self layoutIfNeeded];<br>    <br>    &#x2F;&#x2F;3.  视图的最大 Y 值<br>    CGFloat h&#x3D; CGRectGetMaxY(self.content.frame);<br>   <br>    return h+marginW; &#x2F;&#x2F;最大的高度+10<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>方法2的优化版：</p>
<pre><code>缓存行高，可以通过在这个cell对应的模型中增加一个属性，在第二次计算的事后，判断这个值是否为0如果不为0，就是用这个值</code></pre>
<p>方法3：预估行高</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">思路1：使用tableview代理方法estimatedHeightForRowAtIndexPath 给一个预估的行高，这样可以大量的减少行高的计算，但是在实际应用中，如果给出的这个预估的行高和真是的行高差别较大的时候 会出现cell窜动的现象<br><br></code></pre></td></tr></table></figure>

<p><img src="http://s6.51cto.com/wyfs02/M01/6E/F4/wKiom1WMuObjSUiVABLXImYoZ_o796.gif" alt="icon"></p>
<p>因此对于，tableview中cell有不同的样式的时候不要采用这个方法。</p>
<p>iOS8新特性方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">self.tableView.estimatedRowHeight &#x3D; 50.0f; <br>self.tableView.rowHeight &#x3D; UITableViewAutomaticDimension; <br></code></pre></td></tr></table></figure>
<p>使用这种方法 苹果会帮你把行高都计算了</p>
<p>10、获取CollectionView当前cell的indexPath</p>
<p>注意：仅适用于 一个界面只显示一个cell，但是 [self.collectionView indexPathsForVisibleItems] 返回的有时候个数不只是一个 所以第三种方法是最安全的（前两种方法适用于一般的情况，不适用于二级联动的情况）</p>
<p>方法1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">- (void)collectionView:(UICollectionView *)collectionView<br>  didEndDisplayingCell:(UICollectionViewCell *)cell<br>    forItemAtIndexPath:(NSIndexPath *)indexPath &#123;<br>    &#x2F;&#x2F; 获取当前显示的cell的下标<br>    NSIndexPath *firstIndexPath &#x3D; [[self.collectionView indexPathsForVisibleItems] firstObject]; &#x2F;&#x2F;一定要第一个<br>    &#x2F;&#x2F; 赋值给记录当前坐标的变量<br>    self.currentIndexPath &#x3D; firstIndexPath;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>方法2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">- (void)scrollViewDidEndDecelerating:(UIScrollView *)scrollView &#123;<br>    &#x2F;&#x2F; 获取当前显示的cell的下标<br>    NSIndexPath *firstIndexPath &#x3D; [[self.collectionView indexPathsForVisibleItems] firstObject];<br>    &#x2F;&#x2F; 赋值给记录当前坐标的变量<br>    self.currentIndexPath &#x3D; firstIndexPath;<br>    &#x2F;&#x2F; 更新底部的数据 <br>    &#x2F;&#x2F; ...<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>方法3：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">- (void)scrollViewDidEndDecelerating:(UIScrollView *)scrollView &#123;<br>    &#x2F;&#x2F; 将collectionView在控制器view的中心点转化成collectionView上的坐标<br>    CGPoint pInView &#x3D; [self.view convertPoint:self.collectionView.center toView:self.collectionView];<br>    &#x2F;&#x2F; 获取这一点的indexPath<br>    NSIndexPath *indexPathNow &#x3D; [self.collectionView indexPathForItemAtPoint:pInView];<br>    &#x2F;&#x2F; 赋值给记录当前坐标的变量<br>    self.currentIndexPath &#x3D; indexPathNow;<br>    &#x2F;&#x2F; 更新底部的数据 <br>    &#x2F;&#x2F; ...<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>11、rangeOfString:&amp;rangeOfString:option:<br>在平时的使用中大家都比较习惯使用，下面这种方式！</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">NSString *str &#x3D; @&quot;:&#x2F;lalalal&quot;;<br><br>NSRange range &#x3D; [str rangeOfString:@&quot;:&quot;];<br></code></pre></td></tr></table></figure>
<p>但是，这里的range.lenght = 0;<br>跟重要的是 len = str.length; 结果len = 0; </p>
<p>原因：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">Unicode对于组成有两种形式：合成形式与分解形式。<br>而NSString的rangeOfString，这个api对此的支持是这样的。rangeOfString，默认不是按照码元来查找的，也就是不是按照literalSearch.虽然它里面包含&quot;:&quot;，但是，这两个字符可以合成另一个与其等价的字符，所以就找不到了。<br> <br></code></pre></td></tr></table></figure>

<p>12、获取launchImage的方法</p>
<pre><code>launchimage程序启动过程中加载的那张图片，加载完毕就会消失，但有时候我们不希望他那么快的消失，比如需要添加广告页的时候，这时候 我们就需要获取到这张图片，把他作为背景图</code></pre>
<p>获取这张图片的方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">1 为不同分辨率的屏幕设置不同的图片名称，使用的时候通过拼接图片名称的方式获取，但是这种方式比较依赖于图片的命名，一旦屏幕分辨率改变了 就需要改动<br><br>2、通过下面的代码 从bundle中读取，前提是 图片通过Asset.xcassets设置<br><br>&#96;&#96;&#96;&#96;<br><br></code></pre></td></tr></table></figure>
<pre><code>NSArray* imagesDict = [[[NSBundle mainBundle] infoDictionary] valueForKey:@&quot;UILaunchImages&quot;];
for (NSDictionary* dict in imagesDict)
&#123;
    CGSize imageSize = CGSizeFromString(dict[@&quot;UILaunchImageSize&quot;]);

    if (CGSizeEqualToSize(imageSize, viewSize) &amp;&amp; [viewOrientation isEqualToString:dict[@&quot;UILaunchImageOrientation&quot;]])
    &#123;
        launchImage = dict[@&quot;UILaunchImageName&quot;];
    &#125;
&#125;</code></pre>
<p>   launchImage 就是这张图片的名称</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br><br>13、设置tableviewcell的分割线左对齐<br><br></code></pre></td></tr></table></figure>
<p>if ([[[UIDevice currentDevice] systemVersion] floatValue] &gt;= 7) {</p>
<p>self.tableView.separatorInset = UIEdgeInsetsMake(0, 0, 0, 0);</p>
<p>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">查看更多的设置方法：<br>[分割线左对齐](http:&#x2F;&#x2F;www.skyfox.org&#x2F;ios7-tableview-separatorinset-ajust.html)<br><br><br>14、去掉tableview中section的headerview粘性<br><br></code></pre></td></tr></table></figure>
<ul>
<li>(void)scrollViewDidScroll:(UIScrollView *)scrollView<br>{<br>  CGFloat sectionHeaderHeight = 40;<br>  if (scrollView.contentOffset.y&lt;=sectionHeaderHeight&amp;&amp;scrollView.contentOffset.y&gt;=0) {  <pre><code>  scrollView.contentInset = UIEdgeInsetsMake(-scrollView.contentOffset.y, 0, 0, 0);  </code></pre>
  }<br>  else if (scrollView.contentOffset.y&gt;=sectionHeaderHeight) {  <pre><code>  scrollView.contentInset = UIEdgeInsetsMake(-sectionHeaderHeight, 0, 0, 0);  </code></pre>
  }<br>}</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br>15、纯手码布局的好帮手<br><br>	使用下面的这个宏，在你做界面布局的时候，有些控件通常要根据屏幕的尺寸设置，使用这个宏就可以以6P为基准，直接拿到你想要的转换之后的数值了<br>	<br>	#define SYRealValue(value) ((value)&#x2F;414.0f*[UIScreen mainScreen].bounds.size.width)<br>	<br>	<br>16、如何隐藏tableview中的某一行<br><br></code></pre></td></tr></table></figure>
<ul>
<li>(CGFloat) tableView:(UITableView *)tableView heightForRowAtIndexPath:<br>(NSIndexPath *)indexPath {<br>  return indexPath.row == 3 ? 0 : 40;<br>}</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">这样未必有效果吧，有时可能会出现：<br>![图片超出喽](http:&#x2F;&#x2F;upload-images.jianshu.io&#x2F;upload_images&#x2F;139317-120fc766b0282440.png?imageMogr2&#x2F;auto-orient&#x2F;strip%7CimageView2&#x2F;2&#x2F;w&#x2F;1240)<br><br>所以还需要另外一句<br><br></code></pre></td></tr></table></figure>
<ul>
<li>(void)tableView:(UITableView *)tableView willDisplayCell:(UITableViewCell *)cell forRowAtIndexPath:(NSIndexPath *)indexPath {<br>  cell.clipsToBounds = YES;<br>}</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br>17、如何改变UITextfield的placeholder的颜色<br>集成UITextfield重写这个方法<br><br></code></pre></td></tr></table></figure>
<ul>
<li>(void) drawPlaceholderInRect:(CGRect)rect {<br>  [[UIColor blueColor] setFill];<br>  [self.placeholder drawInRect:rect withFont:self.font lineBreakMode:UILineBreakModeTailTruncation alignment:self.textAlignment];<br>}</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">也可以使用KVC<br><br></code></pre></td></tr></table></figure>
<p>[textField setValue:[UIColor blueColor] forKeyPath:@”_placeholderLabel.textColor”]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br>18、本来我的statusbar是lightcontent的，结果用UIImagePickerController会导致我的statusbar的样式变成黑色，怎么办？<br><br></code></pre></td></tr></table></figure>
<ul>
<li>(void)navigationController:(UINavigationController *)navigationController willShowViewController:(UIViewController *)viewController animated:(BOOL)animated<br>{<br>  [[UIApplication sharedApplication] setStatusBarStyle:UIStatusBarStyleLightContent];<br>}</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br>19、如何修改tableviewcell中选中符号的颜色<br><br></code></pre></td></tr></table></figure>
<p>_mTableView.tintColor = [UIColor redColor];</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br>20、ScrollView莫名其妙不能在viewController划到顶怎么办?<br><br>这个可能是设置了导航栏的背景图片导致的<br><br></code></pre></td></tr></table></figure>
<p>self.automaticallyAdjustsScrollViewInsets = NO;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br>21、怎么点击self.view就让键盘收起,需要添加一个tapGestures么<br><br></code></pre></td></tr></table></figure>
<ul>
<li>(void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event<br>{<br> [self.view endEditing:YES];<br>}</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br>22、怎么像safari一样滑动的时候隐藏navigationbar?<br><br></code></pre></td></tr></table></figure>
<p>navigationController.hidesBarsOnSwipe = Yes</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br>23、打印app中的所有windows<br><br></code></pre></td></tr></table></figure>
<p>UIWindow 的私有类方法<br>+allWindowsIncludingInternalWindows: onlyVisibleWindows:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br>![icon](http:&#x2F;&#x2F;ww1.sinaimg.cn&#x2F;mw690&#x2F;92172277jw1f2e25kp8ihj20mn06xjti.jpg)<br><br><br>24、收起键盘的几种方式<br><br>1、点击return 收起键盘<br><br></code></pre></td></tr></table></figure>
<p>首先，设置键盘的return键，同事设置UITextFieldDelegate为self<br>然后，实现代理方法textFieldShouldReturn，在这个方法中让textField放弃第一响应者</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br>2、点击背景后收起键盘<br><br></code></pre></td></tr></table></figure>
<ul>
<li>(void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches<br>withEvent:(UIEvent *)event{<br>   //实现该方法是需要注意view需要是继承UIControl而来的<br>  [self.view endEditing:YES];<br>}</li>
</ul>
<p>这里也可以添加一个手势UITapGestureRecognizer</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br>3、不用view实现endEditing方法<br><br></code></pre></td></tr></table></figure>
<p>如果比较难获得viewController的view时，可以采用这个方法</p>
<p>[[[UIApplication sharedApplication] keyWindow]<br>endEditing:YES];</p>
<p>或者</p>
<p>[[UIApplication sharedApplication] sendAction:@selector(resignFirstResponder) to:nil from:nil forEvent:nil];</p>
<pre><code>

25、导出沙盒文件

plist文件中加入
Application supports iTunes file sharing
YES
在iTunes中就可以看到沙盒文件了

、、、、、、未完待续、、、、、、
</code></pre>
]]></content>
      <categories>
        <category>iOS基础</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
        <tag>tips</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS 内存管理</title>
    <url>/2016/03/04/ios-memory-management/</url>
    <content><![CDATA[<p>这篇文章简单的根据几个常见的面试题，引导出了iOS在ARC模式下仍需要注意的一些内存管理方面的小知识，本文中提到的一些知识点需要仔细的考虑。</p>
<a id="more"></a>

<h4 id="1、存储空间的类别和管理方式"><a href="#1、存储空间的类别和管理方式" class="headerlink" title="1、存储空间的类别和管理方式"></a>1、存储空间的类别和管理方式</h4><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br>1、栈区（stack）——由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。<br><br>2、堆区（heap）——一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表。<br><br>3、全局区（静态区）（static）——全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。程序结束后由系统释放。<br><br>4、文字常量区——常量字符串就是放在这里的。程序结束后由系统释放。<br><br>5、程序代码区——存放函数体的二进制代码。<br><br></code></pre></td></tr></table></figure>


<h5 id="1、NSString-str-”111”"><a href="#1、NSString-str-”111”" class="headerlink" title="1、NSString *str = @”111”"></a>1、NSString *str = @”111”</h5><p>首先str是一个指针，这种指针变量本身肯定是在栈空间，而@”111”是一个常量<br>字符串，注意iOS中NSString所指向的NSString是一个常量，分配在常量区，<br>你可能会问，常量存储区不是不能改变吗？我们可以验证下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">NSString *str1 &#x3D; @&quot;121&quot;;<br>NSLog(@&quot;%p&quot;,str1);<br>&#x2F;&#x2F; 两个打印结果相同，可以证明str1指向一个常量<br>NSLog(@&quot;%p&quot;,@&quot;121&quot;);  <br>&#x2F;&#x2F; 而通过subString 等方法返回的是一个新的常量,NSNumber同理<br><br></code></pre></td></tr></table></figure>

<p>关于NSString的分析 可以参考<a href="https://blog.cnbluebox.com/blog/2014/04/16/nsstringte-xing-fen-xi-xue-xi/">这篇文章</a></p>
<h5 id="3、OC和C在数组表示中的区别"><a href="#3、OC和C在数组表示中的区别" class="headerlink" title="3、OC和C在数组表示中的区别"></a>3、OC和C在数组表示中的区别</h5><p><img src="http://i.niupic.com/images/2016/03/07/pg9E5w.jpg" alt="NSArray"></p>
<h5 id="2、使用copy和strong修饰数组的区别"><a href="#2、使用copy和strong修饰数组的区别" class="headerlink" title="2、使用copy和strong修饰数组的区别"></a>2、使用copy和strong修饰数组的区别</h5><p>代码：</p>
<p>@property (nonatomic, strong) NSString *str1;</p>
<p>@property (nonatomic, copy) NSString *str2;</p>
<p>结果：</p>
<p><img src="http://i.niupic.com/images/2016/03/07/3XJhmA.png" alt="string"></p>
<h5 id="3、自动释放池的使用"><a href="#3、自动释放池的使用" class="headerlink" title="3、自动释放池的使用"></a>3、自动释放池的使用</h5><p><img src="http://i.niupic.com/images/2016/03/07/wThjRM.png" alt="autorelaesepool"></p>
<p><code>附赠 </code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br>测试代码耗时的方法：<br>NSLog(@&quot;开始&quot;);<br>CFAbsoluteTime start &#x3D; CFAbsoluteTimeGetCurrent();<br>[self answer1];<br>CFAbsoluteTime end &#x3D; CFAbsoluteTimeGetCurrent();<br>NSLog(@&quot;外部 %f&quot;, end - start); <br><br></code></pre></td></tr></table></figure>

<h5 id="2、const关键字"><a href="#2、const关键字" class="headerlink" title="2、const关键字"></a>2、const关键字</h5><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">const char *p;<br>char const *p;  <br>char * const p;  <br>const char * const p;<br> <br>参考答案：<br><br>const char *p定义了一个指向不可变的字符串的字符指针，可以这么看：const char *为类型，p是变量。<br>char const *p与上一个是一样的。<br>char * const p定义了一个指向字符串的指针，该指针值不可改变，即不可改变指向。这么看：char *是类型，const是修饰变量p，也就是说p是一个常量<br>const char * const p定义了一个指向不可变的字符串的字符指针，且该指针也不可改变指向。这一个就很容易看出来了。两个const分别修饰，因此都是不可变的。<br><br><br>int age &#x3D; 10;<br>int money &#x3D; 200;<br><br>&#x2F;&#x2F; const修饰的是*p1<br>int const * p1 &#x3D; &amp;age;<br><br><br>&#x2F;&#x2F; const修饰的是p2<br>int * const p2 &#x3D; &amp;age;<br><br>*p1 &#x3D; 999; &#x2F;&#x2F; 错误<br>p1 &#x3D; &amp;money;  &#x2F;&#x2F; 正确<br>*p2 &#x3D; 999; &#x2F;&#x2F; 正确<br>p2 &#x3D; &amp;money; &#x2F;&#x2F; 错误<br><br>&#x2F;&#x2F; OC字符串常量的定义<br>NSString * const url &#x3D; @&quot;http:&#x2F;&#x2F;baidu.com&quot;;<br>url &#x3D; @&quot;http:&#x2F;&#x2F;apple.com&quot;; &#x2F;&#x2F; 错误<br><br><br></code></pre></td></tr></table></figure>

<h4 id="4、static-关键字"><a href="#4、static-关键字" class="headerlink" title="4、static 关键字"></a>4、static 关键字</h4><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">static的作用<br>-修饰&#96;局部变量&#96; ：修改的是&#96;生命周期&#96;<br><br>1&gt; 被static修饰的局部变量，在整个程序运行过程中，都只有一份内存<br>2&gt; 被static修饰的局部变量，并没有改变作用域<br><br> 修饰&#96;全局变量&#96; ： 修改的是&#96;作用域&#96;<br><br>1&gt; 没有被static修饰的全局变量，能被项目中的任何文件访问<br>2&gt; 被static修饰的全局变量，只能被本文件访问（定义这个变量的文件）<br><br></code></pre></td></tr></table></figure>



<h4 id="3、iOS内存管理-来自标哥"><a href="#3、iOS内存管理-来自标哥" class="headerlink" title="3、iOS内存管理(来自标哥)"></a>3、iOS内存管理(来自标哥)</h4><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">描述一下iOS的内存管理，在开发中对于内存的使用和优化包含哪些方面。我们在开发中应该注意哪些问题。<br><br>内存管理准则：谁强引用过，谁就在不再使用时使引用计数减一。<br><br>对于内存的使用和优化常见的有以下方面：<br><br>重用问题：如UITableViewCells、UICollectionViewCells、UITableViewHeaderFooterViews设置正确的reuseIdentifier，充分重用。<br><br>尽量把views设置为不透明：当opque为NO的时候，图层的半透明取决于图片和其本身合成的图层为结果，可提高性能。<br><br>不要使用太复杂的XIB&#x2F;Storyboard：载入时就会将XIB&#x2F;storyboard需要的所有资源，包括图片全部载入内存，即使未来很久才会使用。那些相比纯代码写的延迟加载，性能及内存就差了很多。<br><br>选择正确的数据结构：学会选择对业务场景最合适的数组结构是写出高效代码的基础。比如，数组: 有序的一组值。使用索引来查询很快，使用值查询很慢，插入&#x2F;删除很慢。字典: 存储键值对，用键来查找比较快。集合: 无序的一组值，用值来查找很快，插入&#x2F;删除很快。<br><br>gzip&#x2F;zip压缩：当从服务端下载相关附件时，可以通过gzip&#x2F;zip压缩后再下载，使得内存更小，下载速度也更快。<br><br>延迟加载：对于不应该使用的数据，使用延迟加载方式。对于不需要马上显示的视图，使用延迟加载方式。比如，网络请求失败时显示的提示界面，可能一直都不会使用到，因此应该使用延迟加载。<br><br>数据缓存：对于cell的行高要缓存起来，使得reload数据时，效率也极高。而对于那些网络数据，不需要每次都请求的，应该缓存起来，可以写入数据库，也可以通过plist文件存储。<br><br>处理内存警告：一般在基类统一处理内存警告，将相关不用资源立即释放掉<br>重用大开销对象：一些objects的初始化很慢，比如NSDateFormatter和NSCalendar，但又不可避免地需要使用它们。通常是作为属性存储起来，防止反复创建。<br><br>避免反复处理数据：许多应用需要从服务器加载功能所需的常为JSON或者XML格式的数据。在服务器端和客户端使用相同的数据结构很重要。<br><br>使用Autorelease Pool：在某些循环创建临时变量处理数据时，自动释放池以保证能及时释放内存。<br><br>正确选择图片加载方式：详情阅读细读UIImage加载方式<br><br></code></pre></td></tr></table></figure>

<h4 id="4、数组名称与数组首元素地址"><a href="#4、数组名称与数组首元素地址" class="headerlink" title="4、数组名称与数组首元素地址"></a>4、数组名称与数组首元素地址</h4><hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">int array[3] &#x3D; &#123;11, 22, 33&#125;;<br>&#x2F;&#x2F; array可看做是一个指针：指向array[0]（某个数组元素），指向是int类型的数据（4个字节的数据）<br>&#x2F;&#x2F; &amp;array[0]可看做是一个指针：指向array[0]（某个数组元素），指向是int类型的数据（4个字节的数据）<br>&#x2F;&#x2F; &amp;array可看做是一个指针：指向array（整个数组），指向int[3]类型的数据（12个字节的数据）<br><br>&#x2F;&#x2F; &amp;array[0] &#x3D;&#x3D;&#x3D; array<br></code></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">int array[2][3] &#x3D; &#123;<br>            &#123;1, 11, 111&#125;,<br>            &#123;2, 22, 222&#125;<br>        &#125;;<br>&#x2F;&#x2F; array[0] : 指向array[0][0]元素（4个字节的空间）<br>&#x2F;&#x2F; array[1] : 指向array[1][0]元素（4个字节的空间）<br>&#x2F;&#x2F; &amp;array[0][0] : 指向array[0][0]元素（4个字节的空间）<br>&#x2F;&#x2F; &amp;array[1][0] : 指向array[1][0]元素（4个字节的空间）<br>&#x2F;&#x2F; array : 指向array[0]（数组&#123;1, 11, 111&#125;，12个字节的空间）<br>&#x2F;&#x2F; &amp;array : 指向array（整个数组，24个字节的空间）<br><br>&#x2F;&#x2F; array[0] &#x3D;&#x3D;&#x3D; &amp;array[0][0]<br>&#x2F;&#x2F; array[1] &#x3D;&#x3D;&#x3D; &amp;array[1][0]<br>&#x2F;&#x2F; array &#x3D;&#x3D;&#x3D; &amp;array[0]<br></code></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>iOS进阶</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
        <tag>Memory Management</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS 第三方支付</title>
    <url>/2016/03/07/ios-third-payment/</url>
    <content><![CDATA[<p>APP中我们常用的第三方支付主要是：微信支付和支付宝支付，去年公司的项目<br>中加入了两种支付方式，特地总结如下：</p>
<a id="more"></a>

<h4 id="支付流程"><a href="#支付流程" class="headerlink" title="支付流程"></a>支付流程</h4><h5 id="1、支付流程图"><a href="#1、支付流程图" class="headerlink" title="1、支付流程图"></a>1、支付流程图</h5><p><img src="https://pay.weixin.qq.com/wiki/doc/api/img/chapter8_3_1.png" alt="支付流程图"></p>
<h5 id="2、添加URL"><a href="#2、添加URL" class="headerlink" title="2、添加URL"></a>2、添加URL</h5><p><img src="http://i.niupic.com/images/2016/03/08/6m4jJv.png" alt="icon"></p>
<h5 id="3、导入SDK"><a href="#3、导入SDK" class="headerlink" title="3、导入SDK"></a>3、导入SDK</h5><p><img src="http://i.niupic.com/images/2016/03/08/bBUVlA.png" alt="SDK"></p>
<h5 id="4、注册自己的微信ID"><a href="#4、注册自己的微信ID" class="headerlink" title="4、注册自己的微信ID"></a>4、注册自己的微信ID</h5><p><img src="http://i.niupic.com/images/2016/03/08/4a26sD.png" alt="icon"></p>
<h5 id="5、具体流程"><a href="#5、具体流程" class="headerlink" title="5、具体流程"></a>5、具体流程</h5><h6 id="1、点击支付"><a href="#1、点击支付" class="headerlink" title="1、点击支付"></a>1、点击支付</h6><p>需要判断是保证金支付还是订单支付，下面的方法以微信支付为例</p>
<h6 id="2、获取订单信息（服务端交互）"><a href="#2、获取订单信息（服务端交互）" class="headerlink" title="2、获取订单信息（服务端交互）"></a>2、获取订单信息（服务端交互）</h6><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&#x2F;&#x2F;保证金支付<br>- (RACSignal *)wechatPayDepositWithOrder:(ArtOrder *)order<br><br>&#x2F;&#x2F;订单支付<br>- (RACSignal *)wechatPayWithOrder:(ArtOrder *)order<br><br></code></pre></td></tr></table></figure>

<p>这里订单支付和保证金支付有点不同：</p>
<p>保证金支付是与这个订单无关的，所以在与服务端交互的时候不需要传递具体上项目或者商品的相关信息，只是传递一个保证金的金额即可，而在订单支付的过程中，我们需要将这次付款行为的商品相关信息传递给服务端。然后服务端与微信提供的接口进行交互获取订单信息</p>
<h6 id="3、获取订单信息"><a href="#3、获取订单信息" class="headerlink" title="3、获取订单信息"></a>3、获取订单信息</h6><p>与服务端交互完成后会返回一个PayReq的对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&#x2F;*! @brief 第三方向微信终端发起支付的消息结构体<br> *<br> *  第三方向微信终端发起支付的消息结构体，微信终端处理后会向第三方返回处理结果<br> * @see PayResp<br> *&#x2F;<br>@interface PayReq : BaseReq<br><br>&#x2F;** 商家向财付通申请的商家id *&#x2F;<br>@property (nonatomic, retain) NSString *partnerId;<br>&#x2F;** 预支付订单 *&#x2F;<br>@property (nonatomic, retain) NSString *prepayId;<br>&#x2F;** 随机串，防重发 *&#x2F;<br>@property (nonatomic, retain) NSString *nonceStr;<br>&#x2F;** 时间戳，防重发 *&#x2F;<br>@property (nonatomic, assign) UInt32 timeStamp;<br>&#x2F;** 商家根据财付通文档填写的数据和签名 *&#x2F;<br>@property (nonatomic, retain) NSString *package;<br>&#x2F;** 商家根据微信开放平台文档对数据做的签名 *&#x2F;<br>@property (nonatomic, retain) NSString *sign;<br><br>@end<br><br></code></pre></td></tr></table></figure>
<p><a href="http://www.jianshu.com/p/362fcbbf107c">参数详细介绍</a></p>
<h5 id="4、调用微信API等待返回"><a href="#4、调用微信API等待返回" class="headerlink" title="4、调用微信API等待返回"></a>4、调用微信API等待返回</h5><p>从服务端获取到了订单的信息之后，需要调用微信的API提供的这个接口，传递数据，跳转到微信客户端 用户进行支付，自己的应用等待用户操作之后的回调</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&#x2F;*! @brief 发送请求到微信，等待微信返回onResp<br> *<br> * 函数调用后，会切换到微信的界面。第三方应用程序等待微信返回onResp。微信在异步处理完成后一定会调用onResp。支持以下类型<br> * SendAuthReq、SendMessageToWXReq、PayReq等。<br> * @param req 具体的发送请求，在调用函数后，请自己释放。<br> * @return 成功返回YES，失败返回NO。<br> *&#x2F;<br> <br>+(BOOL) sendReq:(BaseReq*)req;<br><br></code></pre></td></tr></table></figure>

<h6 id="5、-用户进行支付操作"><a href="#5、-用户进行支付操作" class="headerlink" title="5、 用户进行支付操作"></a>5、 用户进行支付操作</h6><p><img src="http://i.niupic.com/images/2016/03/08/NKqM4k.png" alt="pay1"></p>
<h6 id="6、-支付结果回调"><a href="#6、-支付结果回调" class="headerlink" title="6、 支付结果回调"></a>6、 支付结果回调</h6><p><img src="http://i.niupic.com/images/2016/03/08/rPZfFA.png" alt="pay2"></p>
<p>支付动作结束之后，微信会调用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&#x2F;*! @brief 发送一个sendReq后，收到微信的回应<br> *<br> * 收到一个来自微信的处理结果。调用一次sendReq后会收到onResp。<br> * 可能收到的处理结果有SendMessageToWXResp、SendAuthResp等。<br> * @param resp具体的回应内容，是自动释放的<br> *&#x2F;<br> <br>-(void) onResp:(BaseResp*)resp;<br><br></code></pre></td></tr></table></figure>
<p>这里根据返回的状态码做出对应的操作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">switch (resp.errCode) &#123;<br>            case WXSuccess:&#123;<br>                NSLog(@&quot;支付成功－PaySuccess，retcode &#x3D; %d&quot;, <br>                							resp.errCode);<br>                break;<br>            &#125;<br>            case WXErrCodeCommon:&#123;<br>                errorMessage &#x3D; @&quot;支付失败&quot;;<br>                break;<br>            &#125;<br>            case WXErrCodeUserCancel:&#123;<br>                errorMessage &#x3D; @&quot;用户中途取消&quot;;<br>                break;<br>            &#125;<br>            default:&#123;<br>                NSLog(@&quot;错误，retcode &#x3D; %d, retstr &#x3D; %@&quot;, <br>                		resp.errCode,resp.errStr);<br>                errorMessage &#x3D; @&quot;支付失败&quot;;<br>                break;<br>            &#125;<br><br><br></code></pre></td></tr></table></figure>

<p>这样，本次支付就结束了。可以进行下面的操作啦………………</p>
<h5 id="6、微信、支付宝支付中常见的问题"><a href="#6、微信、支付宝支付中常见的问题" class="headerlink" title="6、微信、支付宝支付中常见的问题"></a>6、微信、支付宝支付中常见的问题</h5><ul>
<li><p>1、一定要添加下面的回调</p>
<p>  [[AlipaySDK defaultService] </p>
<pre><code>                  processOrderWithPaymentResult:url
                   standbyCallback:^(NSDictionary
                                        *resultDic) &#123;</code></pre>
<p>  }];<br>  否则可能收不到支付结果的回调</p>
</li>
</ul>
<p> <code>未完…………………………</code></p>
]]></content>
      <categories>
        <category>支付</category>
      </categories>
      <tags>
        <tag>支付</tag>
      </tags>
  </entry>
  <entry>
    <title>ios异常处理之try-catch-finally</title>
    <url>/2018/04/12/ios-try-catch/</url>
    <content><![CDATA[<p>OC中的异常一般是通过传递一个NSError的对象到方法中,如果方法执行错误会直接返回。并没有像JAVA一样大量使用Try catch进行异常的捕获。这是因为try catch无法捕获UncaughtException，而oc中大部分crash如：内存溢出、野指针等都是无法捕获的，而能捕获的只是像数组越界之类。所以try catch对于oc来说，比较鸡肋。虽说是鸡肋 但是我们在某些情况下还是有用的 这里简单介绍一下。</p>
<a id="more"></a>

<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p><img src="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Exceptions/Tasks/Art/flow_control_directive.gif" alt="语法"></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">@try</span><br>&#123;<br>    <span class="hljs-comment">// 业务逻辑</span><br>&#125;<br><span class="hljs-keyword">@catch</span> (异常类型名<span class="hljs-number">1</span> ex)<br>&#123;<br>    <span class="hljs-comment">//异常处理代码</span><br>&#125;<br><span class="hljs-keyword">@catch</span> (异常类型名<span class="hljs-number">2</span> ex)<br>&#123;<br>    <span class="hljs-comment">//异常处理代码</span><br>&#125;<br><span class="hljs-comment">// 可以捕捉 N 个 异常 ...</span><br><span class="hljs-keyword">@finally</span><br>&#123;<br><span class="hljs-comment">//回收资源</span><br>&#125;<br>  <br></code></pre></td></tr></table></figure>

<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">- (<span class="hljs-keyword">void</span>)catchException<br>&#123;<br>    <span class="hljs-built_in">NSArray</span>* array = [[<span class="hljs-built_in">NSArray</span> alloc] init];<br>    <br>    <span class="hljs-keyword">@try</span><br>    &#123;<br>        <span class="hljs-comment">// Attempt access to an empty array</span><br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;Object: %@&quot;</span>, [array objectAtIndex:<span class="hljs-number">0</span>]);<br>        <br>    &#125;<br>    <span class="hljs-comment">//虽然支持捕捉特定类型的NSException 但是 异常的类型确只有NSException这一种 奇怪</span><br>    <span class="hljs-keyword">@catch</span> (<span class="hljs-built_in">NSException</span> *exception)<br>    &#123;<br>        <span class="hljs-comment">// Print exception information</span><br>        <span class="hljs-built_in">NSLog</span>( <span class="hljs-string">@&quot;NSException caught&quot;</span> );<br>        <span class="hljs-built_in">NSLog</span>( <span class="hljs-string">@&quot;Name: %@&quot;</span>, exception.name);<br>        <span class="hljs-built_in">NSLog</span>( <span class="hljs-string">@&quot;Reason: %@&quot;</span>, exception.reason );<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">@finally</span><br>    &#123;<br>        <span class="hljs-comment">// Cleanup, in both success and fail cases</span><br>        <span class="hljs-built_in">NSLog</span>( <span class="hljs-string">@&quot;In finally block&quot;</span>);<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">2018-04-12 17:07:21.895703+0800 TryCatch_Demo[65406:18722039] NSException caught<br>2018-04-12 17:07:21.895808+0800 TryCatch_Demo[65406:18722039] Name: NSRangeException<br>2018-04-12 17:07:21.895889+0800 TryCatch_Demo[65406:18722039] Reason: *** -[__NSArray0 objectAtIndex:]: index 0 beyond bounds for empty NSArray<br>2018-04-12 17:07:21.895970+0800 TryCatch_Demo[65406:18722039] In finally block<br></code></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Apple虽然同时提供了错误处理（NSError）和异常处理（exception）两种机制，但是Apple更加提倡开发者使用NSError来处理程序运行中可恢复的错误。而异常被推荐用来处理不可恢复的错误。</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Exceptions/Tasks/HandlingExceptions.html">官方文档</a></p>
<p><a href="https://www.jianshu.com/p/1cb65e05b3ed">Objective-C中try/catch/finally 使用</a></p>
<p><a href="https://www.jianshu.com/p/f28b9b3f8e44">iOS @try @catch异常机制</a></p>
]]></content>
      <categories>
        <category>iOS优化</category>
      </categories>
      <tags>
        <tag>try catch finally</tag>
      </tags>
  </entry>
  <entry>
    <title>iphone手机流量、内存监控插件</title>
    <url>/2016/09/05/iosuserful%E6%8F%92%E4%BB%B6/</url>
    <content><![CDATA[<p>大家都知道，iOS系统中没有实时流量监控的功能，尤其是最近我们在做直播功能的时候需要知道不同的分辨率我们的推拉流过程中的实时网速，还有一个是实时的查看APP的内存使用情况。</p>
<a id="more"></a>

<h4 id="1、实时流量监控"><a href="#1、实时流量监控" class="headerlink" title="1、实时流量监控"></a>1、实时流量监控</h4><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">- (NSString *)getDataCounters<br>&#123;<br>    BOOL   success;<br>    struct ifaddrs *addrs;<br>    const struct ifaddrs *cursor;<br>    const struct if_data *networkStatisc;<br>    <br>    static int SZNetSent &#x3D; 0;<br>    static int SZNetReceived &#x3D; 0;<br>    int NetSent &#x3D; 0;<br>    int NetReceived &#x3D; 0;<br>    <br>    NSString *name&#x3D;[[NSString alloc]init];<br>    <br>    success &#x3D; getifaddrs(&amp;addrs) &#x3D;&#x3D; 0;<br>    if (success)<br>    &#123;<br>        cursor &#x3D; addrs;<br>        while (cursor !&#x3D; NULL)<br>        &#123;<br>            <br>            name&#x3D;[NSString stringWithFormat:<br>            					@&quot;%s&quot;,cursor-&gt;ifa_name];<br>            <br>            if (cursor-&gt;ifa_addr-&gt;sa_family &#x3D;&#x3D; AF_LINK)<br>            &#123;<br>                if ([name hasPrefix:@&quot;en&quot;])<br>                &#123;<br>                    networkStatisc &#x3D;<br>               			(const struct if_data *) cursor<br>                    		-&gt;ifa_data;<br>                    <br>                    NetSent+&#x3D;networkStatisc-&gt;ifi_obytes;<br>                    <br>                    NetReceived+&#x3D;networkStatisc-<br>                    						&gt;ifi_ibytes;<br>                &#125;<br>                <br>                if ([name hasPrefix:@&quot;pdp_ip&quot;])<br>                &#123;<br>                    networkStatisc &#x3D; <br>                    (const struct if_data *) cursor<br>                    						-&gt;ifa_data;<br>                    						<br>                    NetSent+&#x3D;networkStatisc-&gt;ifi_obytes;<br>                    NetReceived+&#x3D;<br>                    		networkStatisc-&gt;ifi_ibytes;<br>                &#125;<br>            &#125;<br>            <br>            cursor &#x3D; cursor-&gt;ifa_next;<br>        &#125;<br>        <br>        freeifaddrs(addrs);<br>    &#125;<br><br>    CGFloat CZNetSent &#x3D; NetSent - SZNetSent;<br>    CGFloat CZNetReceived &#x3D; NetReceived - SZNetReceived;<br>    SZNetSent &#x3D; NetSent;<br>    SZNetReceived &#x3D; NetReceived;<br>    <br>    NSString *str &#x3D; [NSString stringWithFormat:@&quot;%3.2f -<br>    				 %3.2f KB&#x2F;s&quot;, CZNetSent &#x2F; 1024.,<br>     				CZNetReceived &#x2F; 1024.];<br>    return str;<br>&#125;<br><br></code></pre></td></tr></table></figure>


<h4 id="2、APP内存使用情况"><a href="#2、APP内存使用情况" class="headerlink" title="2、APP内存使用情况"></a>2、APP内存使用情况</h4><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">1、获取APP已使用的内存<br><br>vm_size_t usedMemory(void) &#123;<br>    struct task_basic_info info;<br>    mach_msg_type_number_t size &#x3D; sizeof(info);<br>    kern_return_t kerr &#x3D; task_info(mach_task_self(), TASK_BASIC_INFO, (task_info_t)&amp;info, &amp;size);<br>    return (kerr &#x3D;&#x3D; KERN_SUCCESS) ? info.resident_size : 0; &#x2F;&#x2F; size in bytes<br>&#125;<br><br>2、获取可以使用的内存<br>vm_size_t freeMemory(void) &#123;<br>    mach_port_t host_port &#x3D; mach_host_self();<br>    mach_msg_type_number_t host_size &#x3D; sizeof(vm_statistics_data_t) &#x2F; sizeof(integer_t);<br>    vm_size_t pagesize;<br>    vm_statistics_data_t vm_stat;<br>    <br>    host_page_size(host_port, &amp;pagesize);<br>    (void) host_statistics(host_port, HOST_VM_INFO, (host_info_t)&amp;vm_stat, &amp;host_size);<br>    return vm_stat.free_count * pagesize;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p><code>经过测试这个方法与实际Xcode中显示的内存有一定的差距。不过在用于显示内存占用变化情况的时候还是可以使用的</code></p>
]]></content>
      <categories>
        <category>iOS开发插件</category>
      </categories>
      <tags>
        <tag>流量监控</tag>
        <tag>iOS</tag>
        <tag>内存监控</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS 跳转到设置界面</title>
    <url>/2015/12/05/jump-to-setting/</url>
    <content><![CDATA[<p>在APP开发中 我们会经常遇到，要跳转到设置的某个界面提示用户去设置（开启<br>定位或者其他功能），下面详细的介绍了，跳转到每一个界面的方法</p>
<a id="more"></a>

<h4 id="1、方法"><a href="#1、方法" class="headerlink" title="1、方法"></a>1、方法</h4><p>例子：跳转到定位服务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&#x2F;&#x2F;定位服务设置界面<br>NSURL *url &#x3D; [NSURL URLWithString:@&quot;prefs:root&#x3D;LOCATION_SERVICES&quot;];<br>if ([[UIApplication sharedApplication] canOpenURL:url])<br>&#123;<br>    [[UIApplication sharedApplication] openURL:url];<br><br></code></pre></td></tr></table></figure>
<p>其他界面也是一个类型，不过URL改变一下就可以</p>
<h4 id="2、跳转类型"><a href="#2、跳转类型" class="headerlink" title="2、跳转类型"></a>2、跳转类型</h4><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">About — prefs:root&#x3D;General&amp;path&#x3D;About	&#x2F;&#x2F;关于本机<br>Airplane Mode On — prefs:root&#x3D;AIRPLANE_MODE  &#x2F;&#x2F;飞行模式<br>Auto-Lock — prefs:root&#x3D;General&amp;path&#x3D;AUTOLOCK &#x2F;&#x2F;屏幕锁定<br>Bluetooth — prefs:root&#x3D;General&amp;path&#x3D;Bluetooth	&#x2F;&#x2F;蓝牙设置<br>Date &amp; Time — prefs:root&#x3D;General&amp;path&#x3D;DATE_AND_TIME &#x2F;&#x2F;日期时间<br>FaceTime — prefs:root&#x3D;FACETIME	&#x2F;&#x2F;FaceTime 设置<br>General — prefs:root&#x3D;General	&#x2F;&#x2F;通用<br>Keyboard — prefs:root&#x3D;General&amp;path&#x3D;Keyboard	&#x2F;&#x2F;键盘<br>iCloud — prefs:root&#x3D;CASTLE	 &#x2F;&#x2F;iCloud 用户设置<br>iCloud Storage &amp; Backup  <br>prefs:root&#x3D;CASTLE&amp;path&#x3D;STORAGE_AND_BACKUP &#x2F;&#x2F;iCloud 存储空间<br>International — prefs:root&#x3D;General&amp;path&#x3D;INTERNATIONAL	&#x2F;&#x2F;语言地区<br>Location Services — prefs:root&#x3D;LOCATION_SERVICES &#x2F;&#x2F;定位服务<br>Network — prefs:root&#x3D;General&amp;path&#x3D;Network	&#x2F;&#x2F;通用并非网络<br>Notes — prefs:root&#x3D;NOTES	&#x2F;&#x2F;备忘录<br>Notification — prefs:root&#x3D;NOTIFICATIONS_ID &#x2F;&#x2F;通知	<br>Photos — prefs:root&#x3D;Photos &#x2F;&#x2F;照片与相机<br>Profile — prefs:root&#x3D;General&amp;path&#x3D;ManagedConfigurationList<br>&#x2F;&#x2F; 描述文件<br>Reset — prefs:root&#x3D;General&amp;path&#x3D;Reset &#x2F;&#x2F;还原<br>Sounds — prefs:root&#x3D;Sounds	&#x2F;&#x2F;声音<br>Software Update — 	prefs:root&#x3D;General&amp;path&#x3D;SOFTWARE_UPDATE_LINK &#x2F;&#x2F;软件更新<br>Wallpaper — prefs:root&#x3D;Wallpaper &#x2F;&#x2F;墙纸<br>Wi-Fi — prefs:root&#x3D;WIFI	&#x2F;&#x2F;WiFi<br><br></code></pre></td></tr></table></figure>

<p>总结：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">希望这篇文章可以帮到你！<br></code></pre></td></tr></table></figure>

<p>参考文章:<a href="http://www.superqq.com/blog/2015/12/01/jump-setting-per-page/">iOS开发之如何跳到系统设置里的各种设置界面</a></p>
]]></content>
      <categories>
        <category>iOS基础</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
        <tag>SystemJump</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程 相关概念</title>
    <url>/2016/03/17/multThread-concept/</url>
    <content><![CDATA[<p>这篇文章主要是记录了，我在学习多线程过程中觉得比较重要概念，在这里做一下总结。</p>
<p>文章还会陆续的增加内容，需要持续的更新……</p>
<a id="more"></a>

<h4 id="1、自动释放池"><a href="#1、自动释放池" class="headerlink" title="1、自动释放池"></a>1、自动释放池</h4><h5 id="1、基本定义"><a href="#1、基本定义" class="headerlink" title="1、基本定义"></a>1、基本定义</h5><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">工作原理：自动释放池被销毁或耗尽时会向池中所有对象发送release消息，释放所有的autorelease对象<br><br>创建和销毁：每一次运行循环启动会后会自动创建自动释放池<br><br>程序执行过程中，所有autorelease对象在出了作用域之后，会被添加到最近创建的自动释放池中<br><br></code></pre></td></tr></table></figure>

<h5 id="2、图片示意"><a href="#2、图片示意" class="headerlink" title="2、图片示意"></a>2、图片示意</h5><p><img src="http://i.niupic.com/images/2016/03/21/kFsujE.png" alt="autoreleasepool"></p>
<h4 id="2、运行循环"><a href="#2、运行循环" class="headerlink" title="2、运行循环"></a>2、运行循环</h4><h5 id="1、作用和特性"><a href="#1、作用和特性" class="headerlink" title="1、作用和特性"></a>1、作用和特性</h5><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">作用：保证程序不退出，监听所有时间（手势触摸、时钟触发）<br><br>特性：没有事件时，会休眠，一旦监听到事件，就会立即响应<br><br>每一个线程都有一个runloop 但是主线程的runloop会默认启动（其他线程的runloop默认是关闭的）<br><br></code></pre></td></tr></table></figure>

<h5 id="2、开启一个运行循环的两种种方法"><a href="#2、开启一个运行循环的两种种方法" class="headerlink" title="2、开启一个运行循环的两种种方法"></a>2、开启一个运行循环的两种种方法</h5><ul>
<li>1、 [[NSRunLoop currentRunLoop] run]</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">这种方法一旦开启了运行循环就再也关不了了，也就是说这之后的程序都无法执行了<br><br></code></pre></td></tr></table></figure>

<ul>
<li>2、间隔主动调用</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">每隔一段时间，主动调用一次运行循环并且持续一段时间（这就可以响应这段时间内发生的事件），主动调用可以通过设置标志的方法实现 <br><br></code></pre></td></tr></table></figure>

<p><img src="http://i.niupic.com/images/2016/03/21/0uKCZP.png" alt="runloop"></p>
<h4 id="3、简述retain、strong、assign、weak、copy有什么区别？"><a href="#3、简述retain、strong、assign、weak、copy有什么区别？" class="headerlink" title="3、简述retain、strong、assign、weak、copy有什么区别？"></a>3、简述retain、strong、assign、weak、copy有什么区别？</h4><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">-retain：是MRC，在设置数值的时候，会对引用计数器+1<br>-strong：是ARC,与retain等效<br>-assign:是ARC&#x2F;MRC都有，在设置数值时不会做任何的附加操作<br>    	-MRC中如果不需要引用，就直接使用assign<br>    	-ARC中通常是用来保存基本数据类型<br>-weak是ARC的，用来保存不需要强引用的对象<br>-weak和assign的区别<br>    -assign 指向的对象如果被释放，地址不会有任何变化，效率高，但是风险大，容易造成野指针错误<br>    -weak 指向的对象如果被释放，地址会立即变为nil ,但是在OC中向nil（空指针）发送消息的时候不会报错<br><br><br></code></pre></td></tr></table></figure>

<h4 id="4、响应者链条"><a href="#4、响应者链条" class="headerlink" title="4、响应者链条"></a>4、响应者链条</h4><p>说一下点击了按钮之后，按钮响应点击事件的原理</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">程序启动之后，会创建一个程序的代理（AppDelegate）,didFinishLaunchingWithOptions之后创建一个主运<br>行循环（主运行循环的作用是可以保证程序不退出、负责监听所有事件）当按钮<br>被点击的时候，事件会通过按钮传递给视图（view）进而传递给控制器，然后依<br>次上传到UIWindow，最后到达运行循环，告诉运行循环，btn被点击了，这时<br>候运行循环就会给控制器发消息，告诉控制器按钮被点击了，然后在从上向下的<br>传递过程中，会一次寻找最合适的响应者，而寻找最合适相应者的过程中是通过<br>hitTest方法递归的一层一层的去寻找（主要用到的方法是：hitTest,pointInside方法）<br><br></code></pre></td></tr></table></figure>

<h4 id="5、TCP和UDP的区别"><a href="#5、TCP和UDP的区别" class="headerlink" title="5、TCP和UDP的区别"></a>5、TCP和UDP的区别</h4> <figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"> <br>UDP:(用户数据报协议)---前身是电报<br><br>		-只管发送，不确认对方是否接收到<br>		-将数据及源和目的封装成数据包中，不需要建立连接<br>		-每个数据报的大小限制在64K之内<br>		-因为无需连接，因此是不可靠协议<br>		-不需要建立连接，速度快<br>		-应用：多媒体教室、流媒体视频、广播 实际开发中用的少<br>		<br>TCP:(传输控制协议)<br><br>		-建立连接，行程传输数据的通道<br>		-在连接中进行大数据传输（数据大小不受限制）<br>		-通过三次握手完成连接，是可靠协议，安全送达<br>		-必须建立连接，效率会稍低<br>		-建立连接时的三次握（1老师在吗？ 2我在啊 3我可以问你一个问题吗？）<br>		-断开连接四次握手（1老师我没有问题了，2恩好的，3没有问题我下线了，4好的老师）<br>		<br> <br></code></pre></td></tr></table></figure>

<h4 id="6、通知"><a href="#6、通知" class="headerlink" title="6、通知"></a>6、通知</h4><ul>
<li>1、通知中心是同步的还是异步的？ </li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">同步的<br><br>原因：发生事件，通知中心广播，有可能有多个监听者，设计上使用同步的方式，能保证所有的监听者都对通知做出响应，不会发生遗漏<br><br></code></pre></td></tr></table></figure>

<ul>
<li>2、通知执行的三个步骤</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">1、发送字符串给通知中心<br>2、通知中心广播<br>3、所有的通知监听方法执行完毕后，才继续执行代码<br><br></code></pre></td></tr></table></figure>

<ul>
<li>3、通知里到底有什么</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">-name : 通知的名称的字符串，通知中心本质上就是监听这个字符串<br>-object：发布通知的时候，希望传递给监听者的对象<br>-userInfo：发布通知的时候，希望传递给监听者的附加信息字典<br><br></code></pre></td></tr></table></figure>

<ul>
<li>4、通知和代理有什么区别？</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">- 代理是一对一的，设置delegate属性，在需要的时候，通过delegate调用<br>	selector方法<br>	<br>- 通知是一对多的，只要发生事件，就会以广播的形式，通知所有的监听者<br>		<br>- 通知中心&#x2F;发布通知的对象不需要知道谁是监听者，发布对象和监听者之间的	耦合度很低<br><br>- 监听者需要知道通知的名称字符串，如果发布者还需要传递userInfo字典，<br>	监听者同时需要知道字典的键名<br>	<br>技巧：在OC框架中，如果定义通知，通常通知的名字包含Notification字样，同时key会和通知定义在一起<br>		<br>- 通知监听方法不能有返回值<br><br>- 代理可以有返回值<br><br></code></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>iOS基础</category>
      </categories>
      <tags>
        <tag>自动释放池，运行循环，响应者链条，通知</tag>
      </tags>
  </entry>
  <entry>
    <title>多级滚动视图联动</title>
    <url>/2019/02/24/multiscrollview/</url>
    <content><![CDATA[<p>好像最近都没怎么写UI,最近公司有一个新的模块需要一个多级的列表联动,主要涉及到多个列表滚动时滚动对象的控制以及多个可滚动列表滑动手势处理。</p>
<a id="more"></a>


<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>废话不多说 先看下UI要求的效果</p>
<p><img src="https://ws2.sinaimg.cn/large/006tKfTcly1g0hwl9gmv1g305k09vnpd.gif" alt="效果图"></p>
<h3 id="层次拆分"><a href="#层次拆分" class="headerlink" title="层次拆分"></a>层次拆分</h3><p>通过下面的图 我们将这个效果整体的UI实现大概画一下(按照比较通用的方式 有些地方可以优化)</p>
<p><img src="https://ws3.sinaimg.cn/large/006tKfTcly1g0hsmuviv7j30vf0jy3zd.jpg"></p>
<p>大概的结构就是:</p>
<p><img src="https://ws2.sinaimg.cn/large/006tKfTcly1g0hsxic9t1j31nk0n0n0n.jpg"></p>
<h3 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h3><h4 id="如何让多个可滚动视图手势可以同时相应"><a href="#如何让多个可滚动视图手势可以同时相应" class="headerlink" title="如何让多个可滚动视图手势可以同时相应"></a>如何让多个可滚动视图手势可以同时相应</h4><p>在我们搭建好基本框架 去直接滚动视图的时候 我们发现 我们在滚动最内层tableview时 外面是不动的。也就是说 滚动的手势同时只可以有一个响应者。而最顶部的视图肯定是最优先的响应者。</p>
<p>那么如何让多个滚动视图同时相应一个手势呢？</p>
<p>来看下面的方法</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><br><span class="hljs-comment">// note: returning YES is guaranteed to allow simultaneous recognition. returning NO is not guaranteed to prevent simultaneous recognition, as the other gesture&#x27;s delegate may return YES</span><br>- (<span class="hljs-built_in">BOOL</span>)gestureRecognizer:(<span class="hljs-built_in">UIGestureRecognizer</span> *)gestureRecognizer shouldRecognizeSimultaneouslyWithGestureRecognizer:(<span class="hljs-built_in">UIGestureRecognizer</span> *)otherGestureRecognizer;<br><br></code></pre></td></tr></table></figure>

<p>简单的翻译一下:是否允许多个手势识别器共同识别，一个控件的手势识别后是否阻断手势识别继续向下传播，默认返回NO；如果为YES，响应者链上层对象触发手势识别后，如果下层对象也添加了手势并成功识别也会继续执行，否则上层对象识别后则不再继续传播。</p>
<p>所以我们要做的第一步需要重写这个方法然后返回 YES</p>
<h4 id="多滚动视图协同"><a href="#多滚动视图协同" class="headerlink" title="多滚动视图协同"></a>多滚动视图协同</h4><p>我们可以先分析一下这种场景下滚动的顺序：</p>
<p>首先,假设我们三层的滚动视图 分别为 A B C </p>
<p>向上滚动:</p>
<table>
<thead>
<tr>
<th>状态</th>
<th>A</th>
<th>B</th>
<th>C</th>
<th>状态结束</th>
</tr>
</thead>
<tbody><tr>
<td>状态0</td>
<td>开始滚动</td>
<td>不可滚动</td>
<td>不可滚动</td>
<td>A 滚动到需要停止的区域(offset = contentsize.h-a.left)</td>
</tr>
<tr>
<td>状态1</td>
<td>停止滚动</td>
<td>开始滚动</td>
<td>不可滚动</td>
<td>B 滚动到需要停止的区域 (offset = contentsize.h-b.left)</td>
</tr>
<tr>
<td>状态2</td>
<td>不可滚动</td>
<td>停止滚动</td>
<td>开始滚动</td>
<td>滚动到页面底部</td>
</tr>
<tr>
<td>状态3</td>
<td>不可滚动</td>
<td>不可滚动</td>
<td>不可滚动</td>
<td>C 滚动到顶部(offset == 0)</td>
</tr>
<tr>
<td>状态4</td>
<td>不可滚动</td>
<td>开始滚动</td>
<td>停止滚动</td>
<td>B 滚动到顶部(offset == 0)</td>
</tr>
<tr>
<td>状态5</td>
<td>开始滚动</td>
<td>停止滚动</td>
<td>不可滚动</td>
<td>A 滚动到顶部(offset == 0) 页面整体回到顶部</td>
</tr>
</tbody></table>
<p>那么我们如何控制一个滚动视图是否滚动呢？</p>
<p>这里我们选择的是 设置滚动视图的contentOffset,即在不让某个视图滚动的时候 通过设置其contentOffset.y为某个固定值的方式 不让其滚动。</p>
<p>当然 应该是还有其他的方式,大家可以尝试其他的方式,以及其他的方式可能存在的问题。</p>
<h4 id="多视图之间消息传递"><a href="#多视图之间消息传递" class="headerlink" title="多视图之间消息传递"></a>多视图之间消息传递</h4><p>由最开始的部分我们可以看到,整个页面的视图结构层次非常深,这就给我们带来了一个问题: 如何通知各个视图？</p>
<p>这里我们采用的是: 通知 原因也很简单 耦合性最低。</p>
<h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><p>首先 页面的滚动 我们基本上是通过下面两个属性来控制</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>canScroll</td>
<td>scrollViewDidScroll方法中判断当前控制器是否可以滚动 默认A为YES B/C 为NO</td>
</tr>
<tr>
<td>fixOffset</td>
<td>当scrollView不可以滚动时 将其offset设置为该值 默认为0</td>
</tr>
</tbody></table>
<h4 id="首先对于最底层："><a href="#首先对于最底层：" class="headerlink" title="首先对于最底层："></a>首先对于最底层：</h4><p>默认 canScroll = YES fixOffset = 0</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">- (<span class="hljs-keyword">void</span>)ul_scrollViewDidScroll:(<span class="hljs-built_in">UIScrollView</span> *)scrollView &#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">self</span>.canScroll) &#123; <span class="hljs-comment">// 默认可以滚动</span><br>        [scrollView setContentOffset:<span class="hljs-built_in">CGPointMake</span>(scrollView.contentOffset.x, kULGroupHomeViewControllerMargin)];<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (scrollView.contentOffset.y &gt;= kULGroupHomeViewControllerMargin) &#123; <span class="hljs-comment">// 当滚动到临界值时</span><br>        [scrollView setContentOffset:<span class="hljs-built_in">CGPointMake</span>(scrollView.contentOffset.x, kULGroupHomeViewControllerMargin)];<br>        <span class="hljs-comment">// 发送 顶部视图到达顶部通知 让第中间的scrollView 滚动</span><br>        [[<span class="hljs-built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:kULGroupTopViewGotoTopNotificationName object:<span class="hljs-literal">nil</span> userInfo:@&#123;kULGroupScrollViewCanScroll:<span class="hljs-string">@&quot;1&quot;</span>&#125;];<br>        _canScroll = <span class="hljs-literal">NO</span>; <span class="hljs-comment">// 当自身是否可以滚动设置为NO</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="对于中间的那层"><a href="#对于中间的那层" class="headerlink" title="对于中间的那层:"></a>对于中间的那层:</h4><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">- (<span class="hljs-keyword">void</span>)ul_scrollViewDidScroll:(<span class="hljs-built_in">UIScrollView</span> *)scrollView &#123;<br>    <span class="hljs-comment">// 默认不可以滚动</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">self</span>.canScroll) &#123;<br>        [scrollView setContentOffset:<span class="hljs-keyword">self</span>.fixOffset];<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 先确认 要停止滚动的位置 </span><br>    <span class="hljs-built_in">CGFloat</span> tabOffsetY = [<span class="hljs-keyword">self</span>.tableView rectForSection:<span class="hljs-number">1</span>].origin.y;<br>    <br>    <span class="hljs-built_in">CGFloat</span> offsetY = scrollView.contentOffset.y;<br>    <span class="hljs-comment">// 因为这里调用的比较频繁 这里记录一下之前的状态 </span><br>    _preCanMoveTableView = _canMoveTableView;<br>    <span class="hljs-comment">// 判断 当前是否到达了临界值(不可滚动 到 可以滚动 )</span><br>    <span class="hljs-keyword">if</span> (offsetY&gt;=tabOffsetY) &#123;<br>        scrollView.contentOffset = <span class="hljs-built_in">CGPointMake</span>(<span class="hljs-number">0</span>, tabOffsetY);<br>        _canMoveTableView = <span class="hljs-literal">YES</span>;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        _canMoveTableView = <span class="hljs-literal">NO</span>;<br>    &#125;<br>    <span class="hljs-comment">// 如果状态没有变化 那么不用改变</span><br>    <span class="hljs-keyword">if</span> (_canMoveTableView != _preCanMoveTableView) &#123;<br>        <span class="hljs-keyword">if</span> (!_preCanMoveTableView &amp;&amp; _canMoveTableView) &#123;<br>            <span class="hljs-comment">// 由不可以滚动变为可以滚动</span><br>            [[<span class="hljs-built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:kULGroupMiddleViewGotoTopNotificationName object:<span class="hljs-literal">nil</span> userInfo:@&#123;kULGroupScrollViewCanScroll:<span class="hljs-string">@&quot;1&quot;</span>&#125;];<br>            _canScroll = <span class="hljs-literal">NO</span>;<br>            <span class="hljs-keyword">self</span>.fixOffset = scrollView.contentOffset;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(_preCanMoveTableView &amp;&amp; !_canMoveTableView)&#123;<br>            <span class="hljs-comment">// 由可以滚动变为不可以滚动</span><br>            <span class="hljs-keyword">if</span> (!_canScroll) &#123;<br>                scrollView.contentOffset = <span class="hljs-built_in">CGPointMake</span>(<span class="hljs-number">0</span>, tabOffsetY);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 这里为了 大幅度滚动顺畅 当offset &lt; 3 默认就认为已经到达了顶部</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>.canScroll &amp;&amp; offsetY &lt; <span class="hljs-number">3</span>) &#123;<br>        [[<span class="hljs-built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:kULGroupMiddleViewLeaveTopNotificationName object:<span class="hljs-literal">nil</span> userInfo:@&#123;kULGroupScrollViewCanScroll:<span class="hljs-string">@&quot;1&quot;</span>&#125;];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="对于-最顶层"><a href="#对于-最顶层" class="headerlink" title="对于 最顶层"></a>对于 最顶层</h4><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">- (<span class="hljs-keyword">void</span>)ul_scrollViewDidScroll:(<span class="hljs-built_in">UIScrollView</span> *)scrollView &#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">self</span>.canScroll) &#123;<br>        [scrollView setContentOffset:<span class="hljs-built_in">CGPointZero</span>];<br>    &#125;<br>    <span class="hljs-built_in">CGFloat</span> offsetY = scrollView.contentOffset.y;<br>    <span class="hljs-comment">// 是否到达了顶部 如果到达通知第二层去滚动</span><br>    <span class="hljs-keyword">if</span> (offsetY&lt;<span class="hljs-number">0</span>) &#123;<br>        [[<span class="hljs-built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:kULGroupBottomViewLeaveTopNotificationName object:<span class="hljs-literal">nil</span> userInfo:@&#123;kULGroupScrollViewCanScroll:<span class="hljs-string">@&quot;1&quot;</span>&#125;];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面就是我们按照前面分析的规则 在视图滚动的时候 所要做的操作！ </p>
<h4 id="通知及处理"><a href="#通知及处理" class="headerlink" title="通知及处理"></a>通知及处理</h4><p>还有最后一步:通知的处理 </p>
<p>我们先看一下代码里涉及到的几个通知</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">// 顶部进入置顶通知</span><br><span class="hljs-keyword">static</span> <span class="hljs-built_in">NSString</span> *<span class="hljs-keyword">const</span> kULGroupTopViewGotoTopNotificationName = <span class="hljs-string">@&quot;kULGroupTopViewGotoTopNotificationName&quot;</span>;<br><span class="hljs-comment">// 中间view到达顶部通知</span><br><span class="hljs-keyword">static</span> <span class="hljs-built_in">NSString</span> *<span class="hljs-keyword">const</span> kULGroupMiddleViewGotoTopNotificationName = <span class="hljs-string">@&quot;kULGroupMiddleViewGotoTopNotificationName&quot;</span>;<br><span class="hljs-comment">// 中间view离开顶部通知</span><br><span class="hljs-keyword">static</span> <span class="hljs-built_in">NSString</span> *<span class="hljs-keyword">const</span> kULGroupMiddleViewLeaveTopNotificationName = <span class="hljs-string">@&quot;kULGroupMiddleViewLeaveTopNotificationName&quot;</span>;<br><span class="hljs-comment">// 底部view离开顶部通知</span><br><span class="hljs-keyword">static</span> <span class="hljs-built_in">NSString</span> *<span class="hljs-keyword">const</span> kULGroupBottomViewLeaveTopNotificationName = <span class="hljs-string">@&quot;kULGroupBottomViewLeaveTopNotificationName&quot;</span>;<br><br></code></pre></td></tr></table></figure>

<p>其实根据通知的名字 我们就基本可以了解到 收到这些通知的时候我们需要做什么</p>
<table>
<thead>
<tr>
<th>通知名</th>
<th>何时发送</th>
<th>监听者需要做的事</th>
</tr>
</thead>
<tbody><tr>
<td>kULGroupTopViewGotoTopNotificationName</td>
<td>最底层滚动到指定位置</td>
<td>中间层监听 监听到时需要使自己可以滚动</td>
</tr>
<tr>
<td>kULGroupMiddleViewGotoTopNotificationName</td>
<td>中间层滚动到指定位置</td>
<td>最顶部滚动视图 监听 监听到时 让自己可以滚动</td>
</tr>
<tr>
<td>kULGroupMiddleViewLeaveTopNotificationName</td>
<td>中间层从滚动到固定位置的地方离开</td>
<td>中间层监听 监听到时 中间层不可以滚动; 最底层监听 监听到时 最底层可以滚动</td>
</tr>
<tr>
<td>kULGroupBottomViewLeaveTopNotificationName</td>
<td>最顶层滚动到顶部时</td>
<td>最底层监听监听到后 让自己不可以滚动; 中间层监听 监听到后让自己可以滚动</td>
</tr>
</tbody></table>
<p>代码我就不具体的贴出来了,可以到项目里更详细的看一下。</p>
<h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p><img src="https://ws2.sinaimg.cn/large/006tKfTcly1g0huj318olg30ai0h6tkg.gif"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>其实这个结构还是挺复杂的不过在仔细分析实现后,我们发现这个效果其实并没有很难实现。只是在实现之前我们需要把 东西缕清楚。这样我们在去动手写代码的时候才可以有的放矢。</p>
<p>希望本文能够帮到你！！！</p>
]]></content>
      <categories>
        <category>UI</category>
      </categories>
      <tags>
        <tag>多级联动、scrollView</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程</title>
    <url>/2016/03/16/multithread/</url>
    <content><![CDATA[<p>最近工作，相对来说没那么忙了。自认为网络和多线程是我比较弱的模块，所以<br>趁这段时间有空，找了一些网络多线程相关的视频看了一下，这里做一下总结。</p>
<p>这是第一篇，主要介绍了线程的基本概念、队列 的相关知识</p>
<a id="more"></a>


<h4 id="线程的基本概念"><a href="#线程的基本概念" class="headerlink" title="线程的基本概念"></a>线程的基本概念</h4><h5 id="1、创建线程的三种方法"><a href="#1、创建线程的三种方法" class="headerlink" title="1、创建线程的三种方法"></a>1、创建线程的三种方法</h5><ul>
<li>1、alloc init</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">NSThread *thread &#x3D; [[NSThread alloc]<br> 			initWithTarget:self selector:@selector(demo:)<br> 			 		object:@&quot;Thread&quot;]<br> 			 		<br>[thread start];<br><br></code></pre></td></tr></table></figure>

<ul>
<li>2、detachNewThreadSelector</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">[NSThread detachNewThreadSelector:@selector(demo:) 		toTarget:self withObject:@&quot;Detach&quot;];<br><br></code></pre></td></tr></table></figure>

<ul>
<li>3、performSelectorInBackground</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">[self performSelectorInBackground:@selector(demo:) withObject:@&quot;background&quot;];<br><br></code></pre></td></tr></table></figure>

<h5 id="2、线程的常用属性"><a href="#2、线程的常用属性" class="headerlink" title="2、线程的常用属性"></a>2、线程的常用属性</h5><ul>
<li>1、name </li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">线程的名字，在多个线程开发时，可以判断到底是谁在执行任务<br><br></code></pre></td></tr></table></figure>

<ul>
<li>2、threadPriority</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">线程优先级（0~1递增）默认优先级是0.5<br><br>注意：优先级高并不意味着会先被调用，只是表示CUP调用的频	率相对较高<br><br></code></pre></td></tr></table></figure>

<ul>
<li>3、state</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">isExecuting(只读属性，是否正在执行)<br>isFinished（只读属性，线程是否完成）<br>isCancelled（只读属性，线程是否被取消）<br><br></code></pre></td></tr></table></figure>

<ul>
<li>4、stackSize</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">堆栈的大小，线程执行前，堆栈大小为512k，线程执行完毕之后，堆栈大小为0k 内存空间被释放，注意，线程执行完毕之后，由于内存空间已经被释放，不能再次启动<br><br></code></pre></td></tr></table></figure>

<h5 id="3、线程常用的方法"><a href="#3、线程常用的方法" class="headerlink" title="3、线程常用的方法"></a>3、线程常用的方法</h5><ul>
<li>1、currentThread</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">当前线程（1表示主线程，非1表示其他线程）<br><br></code></pre></td></tr></table></figure>

<ul>
<li>2、阻塞方法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">sleepUntilDate:休眠到指定时间<br><br>sleepForTimeInterval:休眠指定时长<br><br></code></pre></td></tr></table></figure>

<ul>
<li>3、exit</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">终止当前线程的执行（注意不要再主线程中执行这个方法）<br><br></code></pre></td></tr></table></figure>

<ul>
<li>4、其他方法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">+isMainThread 是否为主线程<br>+mainThread 返回主线程对象<br>+isMultiThreaded 是否是多线程<br><br></code></pre></td></tr></table></figure>

<h5 id="4、线程状态详解"><a href="#4、线程状态详解" class="headerlink" title="4、线程状态详解"></a>4、线程状态详解</h5><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">新建：实例化线程对象<br><br>就绪：向对象发送start消息，将线程添加到“可调度线程池”等待CUP的调度，其他两种线程的创建方法，都是直接实例化一个线程对象，并将其加入“可调度线程池中”<br><br>运行：CUP负责调度“可调度线程池”中的内容，在线程执行完成前可能会进行多次的运行和就绪的转换，这个转换由CPU负责，程序员不干预<br><br>阻塞：满足某一个预定条件时，可以使用休眠或者锁阻塞线程，具体可以使用下面的几个方法：sleepForTimeInterval、sleepUntilDate、@synchronized(self)<br><br>死亡：死亡方式：1、正常死亡  2、非正常死亡<br>		1、正常死亡  :线程执行完毕 <br>    	2、线程内死亡 :  [NSThread exit]<br>    	   线程外死亡 :[threadObj cancel]<br><br></code></pre></td></tr></table></figure>

<h5 id="5、线程相关注意点"><a href="#5、线程相关注意点" class="headerlink" title="5、线程相关注意点"></a>5、线程相关注意点</h5><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">1、不要使用exit方法杀死主线程<br><br>2、一旦强行终止线程后续的所有代码都不会被执行，因此，在线程终止之前，<br>应该注意释放之前分配的对象，如果是ARC开发，需要注意，清理C语言框架创建的对象，否则会出现内存泄露<br><br>3、多线程的目的：将耗时操作放在后台，不阻塞主线程和用户之间的交互，线<br>程的优先级不要修改，多线程开发要尽量简单，多线程的优点是通过并发提高程<br>序的执行效率<br><br>4、在大型的商业项目中，通常会给线程起名字，因为他们希望如果程序崩溃可<br>以准确的定位到，是哪一个线程出现了问题<br><br>5、多线程的优缺点：<br>优点：能适当提高程序的执行效率，能适当的提高资源利用率（CPU、内存利用<br>率）；<br>缺点：开启线程要占用一定的内存空间，默认情况下一条县城占用512KB，因此<br>如果开启大量的线程，会占用大量的内存空间，降低程序性能<br><br>7、线程安全：在多线程进行读写操作时，仍然能保证数据正确<br><br>8、线程间通讯：performSelectorOnMainThread &quot;线程间通讯&quot;<br> 1. 在主线程执行的方法 <br> 2. 传递给方法的参数  <br> 3. 是否等待被调用方法执行完成，有可能也会等待调用方法的执行完成！几率<br> 	极少！<br><br></code></pre></td></tr></table></figure>

<h5 id="6、锁"><a href="#6、锁" class="headerlink" title="6、锁"></a>6、锁</h5><ul>
<li>1、互斥锁</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">同时时间内，只有一个线程能够执行锁定的代码<br><br>在锁定的时候，其他线程会睡眠，等待条件满足后，再被唤醒<br><br></code></pre></td></tr></table></figure>

<ul>
<li>2、自旋锁</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">同时时间内，只有一个线程能够执行锁定的代码<br><br>在锁定的时候，其他线程会做死循环，一直等待条件满足，性能会好（适合执行非常快，非常短的代码）<br><br></code></pre></td></tr></table></figure>

<h5 id="7、资源抢夺"><a href="#7、资源抢夺" class="headerlink" title="7、资源抢夺"></a>7、资源抢夺</h5><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">现象：多个线程访问同一块资源 进行读写操作 <br>解决方法： 加锁<br><br>1、加互斥锁<br><br>@synchronized(self):<br><br>- 使用互斥锁，在同一个时间，只允许一条线程执行锁中的代码<br>- 互斥锁的代价非常昂贵<br>- 互斥锁的代码范围应该尽可能的小，只要锁住资源读写部分的代码即可<br>- 使用互斥锁会影响并发性能<br><br>2、使用原子属性<br><br>能够实现“单写多读”的数据保护<br><br>- 同一时间只允许一个线程修改属性值，但允许多个线程读取<br>- 有可能出现脏数据--读取数据的值可能会不正确<br>- 原子属性是默认属性，如果不需要考虑线程安全，指定nonatomic<br><br></code></pre></td></tr></table></figure>

<h4 id="2、队列"><a href="#2、队列" class="headerlink" title="2、队列"></a>2、队列</h4><h5 id="1、队列的类型"><a href="#1、队列的类型" class="headerlink" title="1、队列的类型"></a>1、队列的类型</h5><ul>
<li>1、串行队列</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">dispatch_queue_create(&quot;leewong&quot;, NULL);<br>一次只调度一个任务执行，一个任务执行完成后，在调度下一个任务<br><br></code></pre></td></tr></table></figure>

<ul>
<li>2、并发队列</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">dispatch_queue_create(&quot;LeeWong&quot;,DISPATCH_QUEUE_CONCURRENT);<br>可以同时调度多个任务<br><br></code></pre></td></tr></table></figure>

<ul>
<li>3、主队列</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">负责在主线程上调度任务，用于线程间通讯（所有的UI更新都应该在主线程上进行）<br><br></code></pre></td></tr></table></figure>

<ul>
<li>4、全局队列</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">dispatch_get_global_queue(0, 0);与并发队列相比：调度任务的方式相同，全局队列没有队列名称，在MRC开发中，全局队列不需要释放<br><br></code></pre></td></tr></table></figure>

<h5 id="2、队列的执行方式"><a href="#2、队列的执行方式" class="headerlink" title="2、队列的执行方式"></a>2、队列的执行方式</h5><ul>
<li>1、同步 dispatch_sync</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">串行队列：会在当前线程上同步执行<br>并发队列：会在当前线程上同步执行<br>主 队列 ：在主线程上添加同步任务会造成死锁，利用同步任务，可以建立任务<br>		之间的“依赖”关系<br><br></code></pre></td></tr></table></figure>

<ul>
<li>2、异步 dispatch_async</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">串行队列：会开启新的线程调度任务<br>并发队列：会开启新的线程调度任务<br>主队列：等待主线程空闲时调度任务<br><br></code></pre></td></tr></table></figure>

<h5 id="3、队列的选择"><a href="#3、队列的选择" class="headerlink" title="3、队列的选择"></a>3、队列的选择</h5><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">串行队列：对执行效率要求不高，对执行顺序要求高，性能消耗小；<br>并发队列：对执行效率要求高，对执行顺序要求不高，性能消耗大<br><br></code></pre></td></tr></table></figure>

<h5 id="4、GCD"><a href="#4、GCD" class="headerlink" title="4、GCD"></a>4、GCD</h5><h6 id="1、延时"><a href="#1、延时" class="headerlink" title="1、延时"></a>1、延时</h6><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">dispatch_after(when, queue, block);<br><br>参数：从现在起经过多少纳秒；调度任务的队列；异步执行任务<br><br>注意：dispatch_after中的参数是保留dispatch_after这句话执行的时候的参数，如果之后再代码块中语句执行之前，之中包含的参数发生变化，在之后代码块执行的时候，其值不改变<br><br></code></pre></td></tr></table></figure>

<h6 id="2、调度组"><a href="#2、调度组" class="headerlink" title="2、调度组"></a>2、调度组</h6><p>使用场景：需要在多个耗时操作执行完毕之后，在统一做后续处理</p>
<p>创建调度组：<br>dispatch_group_t group = dispatch_group_create();</p>
<ul>
<li>1、dispatch_group_leave、dispatch_group_enter<br><img src="http://i.niupic.com/images/2016/03/21/Kgi9Ow.png" alt="icon"></li>
</ul>
<ul>
<li>2、dispatch_group_notify</li>
</ul>
<p><img src="http://i.niupic.com/images/2016/03/21/gghbm4.png" alt="icon"></p>
<h6 id="3、一次性"><a href="#3、一次性" class="headerlink" title="3、一次性"></a>3、一次性</h6><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">保证某段代码在程序运行过程中只被执行一次，在单例设计模式中被广泛使用<br>dispatch_once是线程安全的<br><br></code></pre></td></tr></table></figure>


<h6 id="4、GCD的排列组合"><a href="#4、GCD的排列组合" class="headerlink" title="4、GCD的排列组合"></a>4、GCD的排列组合</h6><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">- 1、串行队列，同步执行：不会开线程，顺序执行<br> <br>- 2、串行队列，异步执行：会开线程(1条)，顺序执行<br><br>- 3、并发队列，异步执行：会开线程，不会顺序执行，具体开几条线程取决于<br>	队列<br>	<br>- 4、并发队列，同步执行：和串行队列同步执行效果一样<br><br>- 5、主队列，异步执行:不开线程，异步任务必须等待主线程上的任务完成之后<br>	才会被调用<br>	<br>- 6、主队列、同步执行：会发生死锁，因为，同步任务要求必须顺序执行，但<br>	是同步任务必须等待主队列中没有任务可以被调用的时候才会被执行，因此<br>	这两方会造成死锁的情况<br>	<br>- 7、同步任务的特点：可以再多个异步任务调度前，指定一个同步任务，让所<br>	有的异步任务，等待同步任务执行完成，这就是所谓的依赖关系<br>	<br>- 8、全局队列，系统提供给程序员，方便程序员使用的全局队列，有关服务质<br>	量的问题，使用下面的代码能够做到IOS7&amp;IOS8的适配，全局队列本质上<br>	就是一个异步队列<br><br><br></code></pre></td></tr></table></figure>

<h6 id="5、全局队列与串行队列的选择"><a href="#5、全局队列与串行队列的选择" class="headerlink" title="5、全局队列与串行队列的选择"></a>5、全局队列与串行队列的选择</h6><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">全局队列：并发，能够调度多个线程，执行效率高    但是费电<br><br>串行队列：一个接一个，只能够开启一条县城，执行效率地<br>    	但是如果任务之间有依赖关系，可以使用串行队列<br>    	省电，省钱，省流量<br>判断的依据：用户的上网方式<br>    	  -WIFI 可以开多条线程 6条<br>    	  -3G&#x2F;4G 尽量少开线程2~3条<br><br></code></pre></td></tr></table></figure>


<h5 id="5、NSOperation"><a href="#5、NSOperation" class="headerlink" title="5、NSOperation"></a>5、NSOperation</h5><h6 id="1、NSInvocationOperation和NSBlockOperation"><a href="#1、NSInvocationOperation和NSBlockOperation" class="headerlink" title="1、NSInvocationOperation和NSBlockOperation"></a>1、NSInvocationOperation和NSBlockOperation</h6><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">NSInvocationOperation:<br><br>NSOperationQueue *q &#x3D; [[NSOperationQueue alloc] init];<br><br>    for (int i &#x3D; 0; i &lt; 10; i++) &#123;<br>        NSInvocationOperation *op &#x3D; [[NSInvocationOperation<br>       alloc] initWithTarget:self <br>        			selector:@selector(downloadImage:) <br>        			  object:@(i)];<br>        			  <br>        [q addOperation:op];<br>    &#125;<br>    <br>   <br>NSBlockOperation:<br>   <br>NSOperationQueue *q &#x3D; [[NSOperationQueue alloc] init];<br>    	for (int i &#x3D; 0; i&lt;10; i++) &#123;<br>        NSBlockOperation *op &#x3D; [NSBlockOperation 		blockOperationWithBlock:^&#123;<br>            NSLog(@&quot;%@ ---- %d &quot;, [NSThread currentThread], i);<br>        &#125;];<br>        [q addOperation:op];<br>    &#125;<br>    <br>    <br>    <br>    <br>    <br>    <br><br></code></pre></td></tr></table></figure>

<p>执行结果：开启多个线程，不会顺序执行-&gt;GCD并发队列，异步执行任务</p>
<h6 id="2、队列的取消操作"><a href="#2、队列的取消操作" class="headerlink" title="2、队列的取消操作"></a>2、队列的取消操作</h6><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">判断队列是否挂起： isSuspended<br><br>在暂停的时候，队列中的操作数，是包含正在执行的操作的<br><br>再次继续的时候，如果之前执行的操作已经完成，队列中的操作数就只有没有调<br>度的操作<br><br>在设置度列的挂起属性的时候，并不会判断队列中是否有操作，如果不希望用户产生困惑，可以提前判断，判断队列中当前是否有操作<br><br>取消所有操作cancelAllOperations，不会取消正在执行的操作<br><br></code></pre></td></tr></table></figure>

<h6 id="3、操作的依赖关系"><a href="#3、操作的依赖关系" class="headerlink" title="3、操作的依赖关系"></a>3、操作的依赖关系</h6><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">NSOperation 提供了依赖关系,NSOperation的所有操作都是异步执行的，但<br>是为了建立任务之间的依赖，提供了dependency的功能,GCD中，可以直接通过<br>同步任务来实现，可以通过串行队列<br><br>[op2 addDependency:op1]; op1执行完毕之后才可以执行op2<br><br>添加依赖关系之后可以调用 waitUntilFinished 来决定是否等待所有操作完<br>成，但是这种等待是阻塞式的，类似于<br><br>   		dispatch_group_wait(g, DISPATCH_TIME_FOREVER);<br>   		<br>依赖关系可以跨队列指定<br><br></code></pre></td></tr></table></figure>

<p><code>但是要注意不要指定循环依赖，一旦指定了循环依赖，队列就不工作了</code></p>
<h6 id="4、自定义Operation的实现"><a href="#4、自定义Operation的实现" class="headerlink" title="4、自定义Operation的实现"></a>4、自定义Operation的实现</h6><p>目的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">1、将操作部分的代码重构到一个单独的子类完成工作<br><br>2、主要是在开发第三方框架时，会使用，日常开发直接使用operation会比较<br>	方便<br>	<br>3、自定义操作，可以支持队列的取消操作<br><br></code></pre></td></tr></table></figure>

<p>自定义NSOperation的子类的步骤：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br>-重写main方法<br>-添加自动释放池，因为子线程运行循环默认不工作<br><br></code></pre></td></tr></table></figure>

<p>重要提示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">NSOperation默认提供了一个completionBlock的参数，一旦设置了，就会在操作执行完毕之后自动执行<br><br>completionBlock 会在后台线程执行，不会再主线程执行，所以如果需要更新UI，需要注意线程<br><br>completionBlock 不能接受参数，没有返回值，因此在使用的时候，会有很多限制<br><br><br></code></pre></td></tr></table></figure>

<p>注意：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">作为所有c语言程序的入口，自定义操作也需要有自己的main函数，同时子线程<br>的运行循环默认是不开启的，因此也不会主动的区创建自动释放池，因此自定义<br>NSOperation的子类的时候，需要自己添加自动释放池<br><br>		- (void)main &#123;<br>    		@autoreleasepool &#123;&#125;<br>    	&#125;<br>   <br>每一次运行循环的开启，都会创建一个自动释放池，当对象出了他们的作用域之<br>后就会被添加到自动释放池中，在运行循环即将结束的时候，会被销毁（每一个<br>线程都有自己的runloop但是之后主线程的默认被开启）<br><br></code></pre></td></tr></table></figure>

<h6 id="5、NSOperation和GCD的区别"><a href="#5、NSOperation和GCD的区别" class="headerlink" title="5、NSOperation和GCD的区别"></a>5、NSOperation和GCD的区别</h6><ul>
<li>1、GCD</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">- GCD在iOS4.0推出，主要针对多核处理器做了优化的并发计数，是C语言的<br><br>- 将任务[block]添加到度列[串行&#x2F;并发&#x2F;主队列&#x2F;全局队列],并且制定执行任<br>	务的函数[同步&#x2F;异步]<br>	<br>- 线程间通讯dispatch_get_main_queue<br><br>- 提供了一些NSOperation不具备的功能<br>		- 一次性执行<br> 		- 延迟执行<br> 		- 调度组（在op中也可以做到，就是有点麻烦）<br>	<br><br></code></pre></td></tr></table></figure>

<ul>
<li>2、NSOperation</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br>- NSOperation在iOS2.0之后推出，苹果推出GCD之后，对NSOperation底<br>	层重写了一遍<br>- 将操作[异步执行的任务]添加到队列[并发队列]，就会立即异步执行<br>- mainQueue<br>- 提供了一些GCD实现起来比较困难的功能<br>		- 最大并发操作数<br>		- 队列的暂停&#x2F;继续<br>		- 取消所有的操作<br>		- 制定操作之间的依赖关系（GCD用同步实现）<br><br></code></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>iOS基础</category>
      </categories>
      <tags>
        <tag>多线程</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title>NSURLSessionConfiguration配置</title>
    <url>/2016/03/21/networking-concept/</url>
    <content><![CDATA[<p>本文主要介绍了NSURLSessionConfiguration配置，只是简单的写了一个 最常用的设置，后续会陆续补充。</p>
<a id="more"></a>


<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">可以设置全局的网络访问属性-- 对某台服务器所有特殊的设置，统一在config中设置<br><br>最重要的一个属性 应用于身份验证的<br><br>	HTTPAdditionalHeaders“”<br>		 &#x2F;&#x2F; 设置身份验证的数据 - 一旦设置，全局共享的好处！<br>		 <br>    NSString *authStr &#x3D; [self base64Encode:@&quot;admin:<br>    										123456&quot;];<br>    										<br>        authStr &#x3D; [@&quot;BASIC &quot; <br>        				stringByAppendingString:authStr];<br>        				<br>        &#x2F;&#x2F; 设置请求头 身份验证 的字段<br>        <br>&#x2F;&#x2F;        [request setValue:authStr forHTTPHeaderField:@&quot;Authorization&quot;];<br><br>        config.HTTPAdditionalHeaders &#x3D; @&#123;@&quot;Authorization&quot;: <br>        								authStr&#125;;<br><br><br></code></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>iOS基础</category>
      </categories>
      <tags>
        <tag>NSURLSessionConfiguration</tag>
      </tags>
  </entry>
  <entry>
    <title>NSURLRequest 详解</title>
    <url>/2016/03/21/networking/</url>
    <content><![CDATA[<p>本片文章重点介绍了NSURLRequest的配置，作为网络请求的主要载体，NSURLRequest的配置十分重要。本文会对创建请求，发送请求以及这个过程中的参数设置进行详细的解析。</p>
<a id="more"></a>

<h4 id="1、NSURLRequest"><a href="#1、NSURLRequest" class="headerlink" title="1、NSURLRequest"></a>1、NSURLRequest</h4><ul>
<li>1、创建方法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">NSURLRequest *request &#x3D; [NSURLRequest requestWithURL:url <br>					cachePolicy:0 timeoutInterval:2.0];<br><br></code></pre></td></tr></table></figure>

<ul>
<li><p>2、参数介绍</p>
<ul>
<li><p>1、cachePolicy 缓存策略</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"> 默认缓存策略<br> NSURLRequestUseProtocolCachePolicy &#x3D; 0, <br> <br> NSURLRequestReload(刷新)Ignoring(忽略)Local(本<br> 						地)Cache(缓存)Data &#x3D; 1,  <br> 						 <br> 如果有缓存，返回缓存数据，否则加载		<br> NSURLRequestReturnCacheDataElseLoad &#x3D; 2,       <br>   <br>   如果有缓存，返回缓存数据，否则不加载<br>NSURLRequestReturnCacheDataDontLoad &#x3D; 3,       <br>      <br></code></pre></td></tr></table></figure>
</li>
<li><p>2、timeoutInterval 超长时间</p>
</li>
</ul>
</li>
</ul>
<pre><code>    <figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br>超长事件，访问一个服务器，如果在制定时间内服务器没有做<br>出响应，就放弃请求，默认时长是60s<br>		<br>一般在实际开发中，建议设置为15~30s，太短服务器可能来<br>不及做出响应，太长用户等待的事件又太长，影响用户体验<br>		<br>  SDWebImage 默认时长就是 15s<br><br>     AFNetworking 默认时长是 60s<br><br></code></pre></td></tr></table></figure></code></pre>
<ul>
<li>3、发送请求</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">[NSURLConnection sendAsynchronousRequest:request<br> 		queue:[[NSOperationQueue alloc] init]<br> 		 completionHandler:^(NSURLResponse *response, <br> 		 	NSData *data, NSError *connectionError) &#123;<br>      <br>       if (connectionError || data &#x3D;&#x3D; nil) &#123;<br>           NSLog(@&quot;你的网络不给力，请稍候再试！&quot;);<br>           NSLog(@&quot;&#x3D;&#x3D;&#x3D;&gt; %@&quot;, connectionError);<br>           return;<br>       &#125;<br>       <br>       NSString *json &#x3D; [[NSString alloc]<br>       	 initWithData:data <br>       	     encoding:NSUTF8StringEncoding];<br>       	     <br>       NSLog(@&quot;%@&quot;, json);<br>   &#125;];<br><br></code></pre></td></tr></table></figure>
<p>参数介绍</p>
<p> 1、request</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">索要资源的请求队列<br></code></pre></td></tr></table></figure>

<p>2、queue 调度任务的队列</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">指定调度回调块代码在哪个线程上执行<br>-主队列：回调的块代码在主线程上执行<br>-新建队列：就会在其他线程执行回调代码<br><br>选择的原则：<br><br>是否需要对返回的数据做耗时操作，如果直接更新UI可以使用主队列，否则建议新建队列<br><br></code></pre></td></tr></table></figure>

<p>3、回调块代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">在网络请求结束后执行，已经获得了服务器返回的二进制<br><br>回调参数：<br><br>1、response(NSHTTPURLResponse):<br>	-服务器的响应（一般只有在做下载的网络操作，才会使用的 response）<br><br>	URL：                     <br>	服务器返回的 URL，绝大多数是和请求的 URL 是一致的，有的时候会不<br>	一样，&quot;重定向&quot;<br><br>	MIMEType:               <br>	二进制数据的文件类型，服务器告诉客户端，可以使用什么软件，打开二进<br>	制数据<br>	<br>	textEncodingName：<br>	文本编码名称，大多数都是 UTF8<br>	<br>	expectedContentLength:<br>	下载文件的长度！<br>	<br>	suggestedFilename:<br>	服务器建议保存的文件名<br>	<br>	statusCode:<br>	状态码，2XX OK，3XX 重定向，4XX 客户端错误，5XX 服务器错误！<br>	<br>	allHeaderFields:<br>	所有响应头的内容<br>	<br>2、data :<br>	- 数据实体，程序员开发最关注的<br>	<br>	数据的序列化：<br>	NSArray *result &#x3D; [NSJSONSerialization <br>						JSONObjectWithData:data <br>								   options:0 <br>								     error:NULL];<br>	可序列化数据的要求：<br>	  - 顶级节点是一个NSArray或者NSDictionary<br>	  - 所有对象是<br>	  	NSString,NSNumber,NSArray,NSDictionary,NSNull<br>	  - 所有字典的key时NSString<br>	  - NSNumber 不能为空或者无穷大<br>	<br>	<br>3、connectionError<br>	-连接错误 只要是网络开发，就有可能出现错误！在实际开发中，一定要对<br>	错误进行处理！<br>	<br>	错误处理：<br>    if (connectionError || data &#x3D;&#x3D; nil) &#123;<br>        NSLog(@&quot;你的网络不给力，请稍候再试！&quot;);<br>        NSLog(@&quot;&#x3D;&#x3D;&#x3D;&gt; %@&quot;, connectionError);<br>        return;<br>    &#125;<br><br></code></pre></td></tr></table></figure>


<h4 id="2、请求方式以及区别"><a href="#2、请求方式以及区别" class="headerlink" title="2、请求方式以及区别"></a>2、请求方式以及区别</h4><p>1、请求类型的简单介绍</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">GET http:&#x2F;&#x2F;www.x.com&#x2F;product&#x2F;123 <br>语义：获取产品代号是123的商品信息<br><br>POST http:&#x2F;&#x2F;www.x.com&#x2F;product&#x2F;123 <br>语义：新增产品代号是123的商品信息<br><br>PUT  http:&#x2F;&#x2F;www.x.com&#x2F;product&#x2F;123 <br>语义：修改产品代号是123的商品信息<br><br>DELETE http:&#x2F;&#x2F;www.x.com&#x2F;product&#x2F;123 <br>语义：删除产品代号是123的商品信息<br><br></code></pre></td></tr></table></figure>

<p>2、POST和GET在发送网络请求时的区别：</p>
<ul>
<li>1、URL</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br>GET 所有的参数都包含在URL中，URL的格式如下<br>	&lt;1&gt;login.php是负责登录的脚本（可以有很多种）<br>	&lt;2&gt;?表示脚本后面要接参数<br>	&lt;3&gt;参数格式：参数名 &#x3D; 值<br>	&lt;4&gt;如果有多个参数，使用&amp;连接，后续的参数仍按照“值对”方式定义<br>	&lt;5&gt;如果URL字符串中包含中文或者空格等特殊符号，需要对URL字符串添<br>		加百分号转义<br>POST:只是负责登录的脚本，其它参数无需确定<br><br></code></pre></td></tr></table></figure>

<ul>
<li>2、Request</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">GET 因为所有的参数URL中已经包含，request中无需指定任何内容<br>	request的默认方法是GET GET效率最高，GET方法是使用最频繁的网络<br>	方法<br><br>POST：<br>	1、指定HTTPMethod 要想服务器“贴”数据,<br>		request.HTTPMethod &#x3D; &quot;POST&quot;<br>	2、要设置请求体的二进制数据<br>		提示：可以从firebug中直接粘贴，然后替换参数<br>		格式：和GET方法中参数的格式一样，只是没有?<br>	3、connection -将请求发送给服务器，等待服务器返回的响应和数<br>		据实体在网络访问中，这个方法是最单纯的<br><br></code></pre></td></tr></table></figure>

<p><code>GET和POST请求的区别</code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br>1、GET的本质是“得” POST的本质是“给”<br><br>2、GET是从服务器拿数据，效率更高，POST是想服务器发送数据，<br>	也可以获取服务器处理之后的结果，效果不如GET<br><br>3、GET请求能够被缓存（一个指定URL所代表的内容一般不会变）POST请求不<br>	能被缓存<br>4、GET在HTTP协议中没有对GET请求的数据大小限制，不过因为浏览器的不同<br>	一般限制在2-8K之间POST提交数据比较大，大小靠服务器设定值限制，<br>	PHP通常限定2M<br>5、GET请求所有的参数包装在URL中，并且服务器的访问日志会记录，不要传递<br>	敏感信息 POST：URL中只有资源路径，但不包含参数，服务器日志不会记	录参数相对更安全参数被包装成二进制的数据体，格式与GET基本一致，只<br>	是不包含<br>6、GET的参数在资源路径末尾添加?表示追加参数，<br>	参数：变量名&#x3D;变量值不能包含空格或者中文，多个参数使用&amp;连接POST需<br>		要设置请求体<br><br><br></code></pre></td></tr></table></figure>

<p><code>发送请求的URL字符串中，如果包含了中文或者空格等特殊符号，需要对URL字 符串添加“百分号转义”</code></p>
]]></content>
      <categories>
        <category>iOS基础</category>
      </categories>
      <tags>
        <tag>NSURLRequest</tag>
        <tag>cachePolicy</tag>
        <tag>timeoutInterval</tag>
      </tags>
  </entry>
  <entry>
    <title>Runtime之NSObject结构</title>
    <url>/2020/10/24/oc-object-structure/</url>
    <content><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>OC是一门面向对象的语言，而对于面向对象语言来说<code>一切皆对象</code>。相信每个iOS开发者都很清楚在OC中NSObject是绝大多数对象的父类。OC是一门动态语言，而动态的实现则是离不开Runtime。那么OC中的对象在Runtime中又是以一种什么样的形态出现的呢？本篇文章我们来详细介绍OC对象在Runtime中的结构。</p>
<a id="more"></a>

<h3 id="NSObject"><a href="#NSObject" class="headerlink" title="NSObject"></a>NSObject</h3><p>我们先来看下在<code>Runtime</code>中<code>NSObject</code>的结构</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">NSObject</span> &lt;<span class="hljs-title">NSObject</span>&gt; </span>&#123;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> clang diagnostic push</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> clang diagnostic ignored <span class="hljs-meta-string">&quot;-Wobjc-interface-ivars&quot;</span></span><br>    Class isa  OBJC_ISA_AVAILABILITY;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> clang diagnostic pop</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>从代码中我们可以看到，实际上对于一个NSObject对象 首先遵守了<code>&lt;NSObject&gt;</code>协议同时有一个<code>isa</code>指针，这个指针是Class类型的。</p>
<p>那么Class的结构呢？</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> objc_class *Class;<br></code></pre></td></tr></table></figure>

<p>我们可以简单的理解为：Class是一个指向<code>objc_class</code>类型结构体的指针</p>
<p>那么<code>objc_class</code>的结构又是什么样的呢？</p>
<p>对于这个结构首先，我们在<code>runtime.h</code>中找到了下面这个定义</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">struct</span> objc_class &#123;<br>    Class _Nonnull isa  OBJC_ISA_AVAILABILITY;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> !__OBJC2__</span><br>    Class _Nullable super_class                              OBJC2_UNAVAILABLE;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * _Nonnull name                               OBJC2_UNAVAILABLE;<br>    <span class="hljs-keyword">long</span> version                                             OBJC2_UNAVAILABLE;<br>    <span class="hljs-keyword">long</span> info                                                OBJC2_UNAVAILABLE;<br>    <span class="hljs-keyword">long</span> instance_size                                       OBJC2_UNAVAILABLE;<br>    <span class="hljs-keyword">struct</span> objc_ivar_list * _Nullable ivars                  OBJC2_UNAVAILABLE;<br>    <span class="hljs-keyword">struct</span> objc_method_list * _Nullable * _Nullable methodLists                    OBJC2_UNAVAILABLE;<br>    <span class="hljs-keyword">struct</span> objc_cache * _Nonnull cache                       OBJC2_UNAVAILABLE;<br>    <span class="hljs-keyword">struct</span> objc_protocol_list * _Nullable protocols          OBJC2_UNAVAILABLE;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><br>&#125; OBJC2_UNAVAILABLE;<br></code></pre></td></tr></table></figure>

<p>这个定义应该是我们在平时查看objc_class结构的时候最长见到的结构了，但是我们注意后面实际上有<code>OBJC2_UNAVAILABLE</code>这个标识，表示在objc2中已经不可用了。因此这个结构不具有参考价值，我们继续来查找<code>objc_class</code>结构体。</p>
<p>在<code>objc-runtime-new.h</code>文件中我们发现了新的定义：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">/// OC 中对象的结构体</span><br><span class="hljs-keyword">struct</span> objc_class : objc_object &#123;<br>    <span class="hljs-comment">// Class ISA;</span><br>    Class superclass;<br>    cache_t cache;             <span class="hljs-comment">// formerly cache pointer and vtable</span><br>    <span class="hljs-comment">// bits用于存储类名、类版本号、方法列表、协议列表等信息，替代了Objective-C1.0中methodLists、protocols等成员变量。</span><br>    class_data_bits_t bits;    <span class="hljs-comment">// class_rw_t * plus custom rr/alloc flags</span><br>    <span class="hljs-comment">// class_rw_t 表示 class 是readwrite的 class_ro_t 表示class是readonly的</span><br>    class_rw_t *data() &#123; <br>        <span class="hljs-keyword">return</span> bits.data();<br>    &#125;<br>    <span class="hljs-keyword">void</span> setData(class_rw_t *newData) &#123;<br>        bits.setData(newData);<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">// ....省略一些方法</span><br></code></pre></td></tr></table></figure>

<p>从上面的结构中我们可以看到：类实际上也是一个对象(类对象)，主要包括<code>superclass</code>、<code>cache</code>、<code>bits</code>三个属性。下面我们分别来看下这三个属性的意义。</p>
<h4 id="superclass-父类"><a href="#superclass-父类" class="headerlink" title="superclass 父类"></a>superclass 父类</h4><p><code>superclass</code>首先也是一个class类型，表示这个类的父类。</p>
<p><code>superclass</code>在<code>objc_class</code>结构中除了标识这个类对象是哪种类型的之外，还用在了下面几个方法中</p>
<h5 id="isRootClass-根类"><a href="#isRootClass-根类" class="headerlink" title="isRootClass 根类"></a>isRootClass 根类</h5><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">bool</span> isRootClass() &#123;<br>        <span class="hljs-keyword">return</span> superclass == <span class="hljs-literal">nil</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>当superclass为nil时则表明当前的类对象没有父类 同时也就意味着这个类是rootClass。</p>
<h4 id="cache-缓存"><a href="#cache-缓存" class="headerlink" title="cache 缓存"></a>cache 缓存</h4><p>cache即缓存，那么缓存中存放的内容是什么呢？我们先来看下<code>cache_t</code>的结构</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">struct</span> cache_t &#123;<br>    <span class="hljs-comment">// 是一个指向 bucket_t 结构体的哈希表</span><br>    <span class="hljs-keyword">struct</span> bucket_t *_buckets;<br>    <span class="hljs-comment">// 是一个 uint32_t 的指针，表示整个 _buckets 哈希表的长度</span><br>    mask_t _mask;<br>    <span class="hljs-comment">// _occupied 也是一个 uint32_t 的指针，在 _buckets 哈希表中已经缓存的方法数量</span><br><br>public:<br>    <span class="hljs-keyword">struct</span> bucket_t *buckets();<br>    mask_t mask();<br>    mask_t occupied();<br>    <span class="hljs-comment">//.....</span><br>&#125;;<br></code></pre></td></tr></table></figure>
<p><code>cache_t</code>结构中主要包含了一个<code>bucket_t</code>类型的数组<code>_buckets</code>。我们继续看下<code>bucket_t</code>的结构。</p>
<h5 id="bucket-t-方法缓存"><a href="#bucket-t-方法缓存" class="headerlink" title="bucket_t 方法缓存"></a>bucket_t 方法缓存</h5><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">struct</span> bucket_t &#123;<br>private:<br>    <span class="hljs-comment">// IMP-first is better for arm64e ptrauth and no worse for arm64.</span><br>    <span class="hljs-comment">// SEL-first is better for armv7* and i386 and x86_64.</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> __arm64__</span><br>    MethodCacheIMP _imp;<br>    cache_key_t _key;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><br>    <span class="hljs-comment">// unsigned long 的指针，其实是一个被 hash 化的一串数值，就是方法的 sel</span><br>    cache_key_t _key;<br>    <span class="hljs-comment">// 保存着对应的函数地址</span><br>    MethodCacheIMP _imp;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><br>public:<br>    <span class="hljs-keyword">inline</span> cache_key_t key() <span class="hljs-keyword">const</span> &#123; <span class="hljs-keyword">return</span> _key; &#125;<br>    <span class="hljs-keyword">inline</span> IMP imp() <span class="hljs-keyword">const</span> &#123; <span class="hljs-keyword">return</span> (IMP)_imp; &#125;<br>    <span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> setKey(cache_key_t newKey) &#123; _key = newKey; &#125;<br>    <span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> setImp(IMP newImp) &#123; _imp = newImp; &#125;<br><br>    <span class="hljs-keyword">void</span> set(cache_key_t newKey, IMP newImp);<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>每个bucket_t实际上有一个key和imp(暂时不考虑为何在arm64和armv7e i386以及x86之间的顺序区别)，并包含了设置key,imp以及取值的方法。那么这个缓存在什么时间被填充和使用呢？</p>
<p>实际上在oc中每个类的方法调用都维护了一个cache，当A类的a方法被调用时，A类的cache存放了a方法的实现和key，如果下次再调用了a方法，那么直接从缓存中取出执行。如果缓存中没有找到，那么在去类的方法列表中进行查找，如果找到了，那么执行这个方法并将方法塞到缓存中，方便下此调用。</p>
<h4 id="bits"><a href="#bits" class="headerlink" title="bits"></a>bits</h4><p>同样我们首先看下这个属性的类型为<code>class_data_bits_t</code>，我们再看下这个类型的结构</p>
<h5 id="class-data-bits-t"><a href="#class-data-bits-t" class="headerlink" title="class_data_bits_t"></a>class_data_bits_t</h5><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">struct</span> class_data_bits_t &#123;<br><br>    <span class="hljs-comment">// Values are the FAST_ flags above.</span><br>    uintptr_t bits;<br>private:<br>    <span class="hljs-keyword">bool</span> getBit(uintptr_t bit)<br>    &#123;<br>        <span class="hljs-keyword">return</span> bits &amp; bit;<br>    &#125;<br>    <span class="hljs-comment">/// ......省略</span><br>public:<br>    class_rw_t* data() &#123;<br>        <span class="hljs-keyword">return</span> (class_rw_t *)(bits &amp; FAST_DATA_MASK);<br>    &#125;<br>    <span class="hljs-keyword">void</span> setData(class_rw_t *newData)<br>    &#123;<br>        assert(!data()  ||  (newData-&gt;flags &amp; (RW_REALIZING | RW_FUTURE)));<br>        <span class="hljs-comment">// Set during realization or construction only. No locking needed.</span><br>        <span class="hljs-comment">// Use a store-release fence because there may be concurrent</span><br>        <span class="hljs-comment">// readers of data and data&#x27;s contents.</span><br>        uintptr_t newBits = (bits &amp; ~FAST_DATA_MASK) | (uintptr_t)newData;<br>        atomic_thread_fence(memory_order_release);<br>        bits = newBits;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>class_data_bits_t结构体中只有一个64位的指针bits，它相当于 class_rw_t 指针加上 rr/alloc 等标志位。其中class_rw_t指针存在于4~47位（从1开始计）</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gk0r1rmzu2j30xc05iwes.jpg"></p>
<p>is_swift标记位标示是否为swift的类。</p>
<p>class_data_bits_t结构体中，我们看到有一个data的setter和getter方法。</p>
<p>我们先来看下设置方法的实现：</p>
<h6 id="setData-class-rw-t-newData"><a href="#setData-class-rw-t-newData" class="headerlink" title="setData(class_rw_t *newData)"></a>setData(class_rw_t *newData)</h6><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">// (bits &amp; ~FAST_DATA_MASK)现将当前存储的值bits与之前定义好的掩码进行按位与操作 相当于取出标志位 3-46位</span><br><span class="hljs-comment">// 将前一步得到的值与外部传入的值进行按位或操作 设置新的标志位的值</span><br>uintptr_t newBits = (bits &amp; ~FAST_DATA_MASK) | (uintptr_t)newData;<br>atomic_thread_fence(memory_order_release);<br><span class="hljs-comment">// 将操作后的结果保存着唉bits中</span><br>bits = newBits;<br></code></pre></td></tr></table></figure>

<p>带着这个我们在去看getter方法：</p>
<h6 id="class-rw-t-data"><a href="#class-rw-t-data" class="headerlink" title="class_rw_t *data()"></a>class_rw_t *data()</h6><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">class_rw_t* data() &#123;<br>    <span class="hljs-keyword">return</span> (class_rw_t *)(bits &amp; FAST_DATA_MASK);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>先通过与掩码进行按位与操作 获取到所有的标志位 然后返回。</p>
<p>类似的标志位还有：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><br><span class="hljs-comment">// class or superclass has .cxx_construct implementation</span><br><span class="hljs-comment">// 第 18 位的值是否为 1，以此表示该类或者父类是否有 .cxx_construct 函数实现</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> RW_HAS_CXX_CTOR       (1&lt;&lt;18)</span><br><span class="hljs-comment">// class or superclass has .cxx_destruct implementation</span><br><span class="hljs-comment">// 第17位的值是否为 1 一次来表示类或者父类有 .cxx_destruct 函数实现。</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> RW_HAS_CXX_DTOR       (1&lt;&lt;17)</span><br><br><span class="hljs-comment">// class or superclass has default alloc/allocWithZone: implementation</span><br><span class="hljs-comment">// Note this is is stored in the metaclass.</span><br><span class="hljs-comment">// 第 16 位的值是否为 1，以此表示该类或者父类是否有 alloc/allocWithZone 函数的默认实现</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> RW_HAS_DEFAULT_AWZ    (1&lt;&lt;16)</span><br><span class="hljs-comment">// class&#x27;s instances requires raw isa</span><br><span class="hljs-comment">// 第 15 位的值是否为 1，以此表示类实例对象（此处是指类对象，不是使用类构建的实例对象，一定要记得）是否需要原始的 isa。</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> SUPPORT_NONPOINTER_ISA</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> RW_REQUIRES_RAW_ISA   (1&lt;&lt;15)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><br><span class="hljs-comment">// class or superclass has default retain/release/autorelease/retainCount/</span><br><span class="hljs-comment">//   _tryRetain/_isDeallocating/retainWeakReference/allowsWeakReference</span><br><span class="hljs-comment">// 第 14 位的值是否为 1，以此表示该类或者父类是否有如下函数的默认实现</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> RW_HAS_DEFAULT_RR     (1&lt;&lt;14)</span><br><br><span class="hljs-comment">// class is a Swift class from the pre-stable Swift ABI</span><br><span class="hljs-comment">// class 是来自稳定的 Swift ABI 的 Swift 类。(遗留的类)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FAST_IS_SWIFT_LEGACY  (1UL&lt;&lt;0)</span><br><br><span class="hljs-comment">// class is a Swift class from the stable Swift ABI</span><br><span class="hljs-comment">// class 是一个有稳定的 Swift ABI 的 Swift类。</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FAST_IS_SWIFT_STABLE  (1UL&lt;&lt;1)</span><br><span class="hljs-comment">// data pointer</span><br><span class="hljs-comment">// 一个定义好的掩码 二进制第 3-46 位是 1，其他位都是 0</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FAST_DATA_MASK        0xfffffffcUL</span><br><br></code></pre></td></tr></table></figure>

<p>我们可以看到在getter方法中返回的实际上是一个<code>class_rw_t</code>结构类型的指针，那么这个结构体的结构是什么样的呢？</p>
<h5 id="class-rw-t"><a href="#class-rw-t" class="headerlink" title="class_rw_t"></a>class_rw_t</h5><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">struct</span> class_rw_t &#123;<br>    <span class="hljs-comment">// 只读class 结构体</span><br>    <span class="hljs-keyword">const</span> class_ro_t *ro;<br>    <span class="hljs-comment">//方法列表</span><br>    method_array_t methods;<br>    <span class="hljs-comment">//属性列表</span><br>    property_array_t properties;<br>    <span class="hljs-comment">//协议列表</span><br>    protocol_array_t protocols;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这个结构体中我们发现了一个<code>class_ro_t</code>的常量，<code>class_ro_t</code>与<code>class_rw_t</code>的最大区别在于一个是只读的，一个是可读写的，实质上<code>ro</code>就是<code>readonly</code>的简写，<code>rw</code>是<code>readwrite</code>的简写。</p>
<p>对于<code>method_array_t methods</code>、<code>property_array_t properties</code>、 <code>protocol_array_t protocols</code>我们可以简单的从命名上看出分别对应 方法列表、属性列表、协议列表。</p>
<p>我们在进一步看下<code>class_ro_t</code>的结构体：</p>
<h6 id="class-ro-t"><a href="#class-ro-t" class="headerlink" title="class_ro_t"></a>class_ro_t</h6><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">struct</span> class_ro_t &#123;<br>    <span class="hljs-comment">//</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * name;<br>    <span class="hljs-comment">// 方法列表</span><br>    method_list_t * baseMethodList;<br>    <span class="hljs-comment">// 协议列表</span><br>    protocol_list_t * baseProtocols;<br>    <span class="hljs-comment">//成员变量列表</span><br>    <span class="hljs-keyword">const</span> ivar_list_t * ivars;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>结构与<code>class_rw_t</code>类似分别包含了只读的方法列表、协议列表和成员变量列表。</p>
<p>那么<code>class_rw_t</code>和<code>class_ro_t</code>的区别和关系是什么呢？</p>
<ul>
<li><code>class_ro_t</code>存放的是编译期间就确定的；而<code>class_rw_t</code>是在<code>runtime</code>时才确定</li>
<li><code>class_rw_o</code>是 <code>class_rw_t</code>中的一个属性，所以可以说<code>class_rw_t</code>是<code>class_ro_t</code>的超集</li>
<li>在程序运行期间实际上我们访问的方法、属性、协议的列表都是访问<code>class_rw_t</code>中的</li>
</ul>
<p>那么<code>class_rw_t</code>是如何被创建的，他的<code>class_ro_t</code>属性又是如何被赋值的呢？<br>当dyld调用load_images将镜像加载到内存后，然后依次会<code>map_images-&gt;_read_images-&gt;realizeAllClasses-&gt;realizeClass</code>。<br>我们来看下<code>objc-runtime-new.m</code>中<code>realizeClass</code>方法中的一段代码：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">ro = (<span class="hljs-keyword">const</span> class_ro_t *)cls-&gt;data();<br><span class="hljs-comment">//是否已经初始化过，初始化过的哈 则 cls-&gt;rw 已经初始化过</span><br><span class="hljs-keyword">if</span> (ro-&gt;flags &amp; RO_FUTURE) &#123;<br>    rw = cls-&gt;data();<br>    ro = cls-&gt;data()-&gt;ro;<br>    cls-&gt;changeInfo(RW_REALIZED|RW_REALIZING, RW_FUTURE);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 正常情况下 申请class_rw_t空间</span><br>    rw = (class_rw_t *)calloc(<span class="hljs-keyword">sizeof</span>(class_rw_t), <span class="hljs-number">1</span>);<br>    rw-&gt;ro = ro;<span class="hljs-comment">//cls-&gt;rw-&gt;ro 指向现在的ro</span><br>    rw-&gt;flags = RW_REALIZED|RW_REALIZING;<span class="hljs-comment">//realized = 1 and  realizing = 1</span><br>    cls-&gt;setData(rw);<span class="hljs-comment">//赋值</span><br>    &#125;<br></code></pre></td></tr></table></figure>

<p>从上面代码中我们可以看到 <code>cls-&gt;data()</code> 最开始实际上是<code>readonly</code>的，我们在类初始化的时候，创建一个<code>rw</code>，然后将<code>ro</code>的值赋值给<code>rw-&gt;ro</code>,然后将<code>rw</code>的标志位赋值。最后赋值给<code>cls-&gt;rw</code>。</p>
<p>这个过程我们可以通过下图更加详细的区分，首先是编译过程中：</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gk0s0g7k8ij30hk0lujtc.jpg"></p>
<p>在runtime执行了realizeClass之后</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gk0s5oef3ej30ro0imgtj.jpg"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这样我们就把NSObject在runtime中相关的结构体都看了一遍，通过上面的了解我们来重新看下NSObject的结构：</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gk0trf8wngj31j20rcdjc.jpg"></p>
]]></content>
      <categories>
        <category>Runtime</category>
      </categories>
      <tags>
        <tag>NSObject Runtime</tag>
      </tags>
  </entry>
  <entry>
    <title>几种常用的排序算法</title>
    <url>/2016/12/08/paixusuanfa/</url>
    <content><![CDATA[<p>这里总结了一下我们平时常用的集中排序方法，供大家学习参考</p>
<a id="more"></a>
<h4 id="1、插入排序"><a href="#1、插入排序" class="headerlink" title="1、插入排序"></a>1、插入排序</h4><p>每次从无序表中取出第一个元素，把它插入到有序表的合适位置，使有序表仍然有序。</p>
<p><code>直接插入排序算法时间复杂度：O(n^2)；空间复杂度：O(1)。直接插入排序是稳定的排序方法。</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">#include&lt;iostream&gt;<br>using namespace std;<br>int main()<br>&#123;<br>    int a[]&#x3D;&#123;98,76,109,34,67,190,80,12,14,89,1&#125;;<br>    int k&#x3D;sizeof(a)&#x2F;sizeof(a[0]);<br>    int j;<br>    for(int i&#x3D;1;i&lt;k;i++)&#x2F;&#x2F;循环从第2个元素开始<br>    &#123;<br>        if(a[i]&lt;a[i-1])<br>        &#123;<br>            int temp&#x3D;a[i];<br>            for(j&#x3D;i-1;j&gt;&#x3D;0 &amp;&amp; a[j]&gt;temp;j--)<br>            &#123;<br>                a[j+1]&#x3D;a[j];<br>            &#125;<br>            a[j+1]&#x3D;temp;&#x2F;&#x2F;此处就是a[j+1]&#x3D;temp;<br>        &#125;<br>    &#125;<br>    for(int f&#x3D;0;f&lt;k;f++)<br>    &#123;<br>        cout&lt;&lt;a[f]&lt;&lt;&quot;  &quot;;<br>    &#125;<br>    return 0;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="2、冒泡排序"><a href="#2、冒泡排序" class="headerlink" title="2、冒泡排序"></a>2、冒泡排序</h4><p><code>冒泡排序时间复杂度，最好情况：数组已有序O(n)；最坏情况:数组反序O(n^2)，平均时间复杂度：O(n^2)。空间复杂度，冒泡排序是原地排序，空间复杂度为O(1)。冒泡排序算法是稳定的排序算法。</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">void bubble_sort(int a[], int n)<br>&#123;<br>    int i, j, temp;<br>    for (j &#x3D; 0; j &lt; n - 1; j++)<br>        for (i &#x3D; 0; i &lt; n - 1 - j; i++)<br>        &#123;<br>            if(a[i] &gt; a[i + 1])<br>            &#123;<br>                temp &#x3D; a[i];<br>                a[i] &#x3D; a[i + 1];<br>                a[i + 1] &#x3D; temp;<br>            &#125;<br>        &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h4 id="3、直接选择排序"><a href="#3、直接选择排序" class="headerlink" title="3、直接选择排序"></a>3、直接选择排序</h4><p>无序数组a[0…n-1]，第一次从a[0]<del>a[n-1]中选取最小值，与a[0]交换，第二次从a[1]</del>a[n-1]中选取最小值，与a[1]交换，….，第i次从a[i-1]<del>a[n-1]中选取最小值，与a[i-1]交换，…..，第n-1次从a[n-2]</del>a[n-1]中选取最小值，与a[n-2]交换，总共通过n-1次，得到一个按关键字从小到大排列的有序序列·</p>
<p><code>在直接选择排序中，共需要进行n-1次选择和交换，每次选择需要进行 n-i 次比较 (1&lt;=i&lt;=n-1),而每次交换最多需要3次移动，因此，总的比较次数C=(n*n - n)/2，时间复杂度O(n^2)。直接选择排序为原地排序，空间复杂度O(1)。直接选择排序不是稳定的排序算法。</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&#x2F;&#x2F;直接选择排序  <br>void sort(int array[],int size)&#123;  <br>        int i,j,small,temp;  <br>        for(i&#x3D;0;i&lt;size;i++)&#123;  <br>        &#x2F;&#x2F;将i假设为最小的  <br>                small &#x3D; i;  <br>        &#x2F;&#x2F;从i+1开始遍历，找到最小的但是比i大的数的下标  <br>                for(j&#x3D;i+1;j&lt;size;j++)&#123;  <br>                        if(array[j]&lt;array[small])&#123;  <br>                                small &#x3D; j;  <br>                        &#125;  <br>                &#125;  <br>        &#x2F;&#x2F;将i和找到的最小的数交换  <br>                temp &#x3D; array[i];  <br>                array[i] &#x3D; array[small];  <br>                array[small] &#x3D; temp;  <br>  <br>                display(array,size);  <br>        &#125;  <br>&#125;  <br></code></pre></td></tr></table></figure>

<h4 id="4、归并排序"><a href="#4、归并排序" class="headerlink" title="4、归并排序"></a>4、归并排序</h4><p><code>时间复杂度为O(nlogn) 是归并排序算法中最好、最坏和平均的时间性能。空间复杂度O(n)。归并排序比较占用内存，但却是一种效率高且稳定的排序算法算法。</code></p>
<p><img src="http://www.hubwiz.com/course/5718b82208ce8b3d3a1432fa/img/merge.png" alt="icon"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">void Merge(int sourceArr[],int tempArr[], int startIndex, int midIndex, int endIndex)<br>&#123;<br>    int i &#x3D; startIndex, j&#x3D;midIndex+1, k &#x3D; startIndex;<br>    while(i!&#x3D;midIndex+1 &amp;&amp; j!&#x3D;endIndex+1)<br>    &#123;<br>        if(sourceArr[i] &gt; sourceArr[j])<br>            tempArr[k++] &#x3D; sourceArr[j++];<br>        else<br>            tempArr[k++] &#x3D; sourceArr[i++];<br>    &#125;<br>    while(i !&#x3D; midIndex+1)<br>        tempArr[k++] &#x3D; sourceArr[i++];<br>    while(j !&#x3D; endIndex+1)<br>        tempArr[k++] &#x3D; sourceArr[j++];<br>    for(i&#x3D;startIndex; i&lt;&#x3D;endIndex; i++)<br>        sourceArr[i] &#x3D; tempArr[i];<br>&#125;<br> <br>&#x2F;&#x2F;内部使用递归<br>void MergeSort(int sourceArr[], int tempArr[], int startIndex, int endIndex)<br>&#123;<br>    int midIndex;<br>    if(startIndex &lt; endIndex)<br>    &#123;<br>        midIndex &#x3D; (startIndex + endIndex) &#x2F; 2;<br>        MergeSort(sourceArr, tempArr, startIndex, midIndex);<br>        MergeSort(sourceArr, tempArr, midIndex+1, endIndex);<br>        Merge(sourceArr, tempArr, startIndex, midIndex, endIndex);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h4 id="5、快速排序"><a href="#5、快速排序" class="headerlink" title="5、快速排序"></a>5、快速排序</h4><p><code>快速排序算法平均时间复杂度O(nlgn)，最坏O(n^2)。快速排序需要栈空间来实现递归，如果数组按局等方式被分割时，则最大的递归深度为 log n，需要的栈空间为 O(log n)。最坏的情况下在递归的每一级上，数组分割成长度为0的左子数组和长度为 n - 1 的右数组。这种情况下，递归的深度就成为 n，需要的栈空间为 O(n)。快速排序不是稳定排序算法。</code></p>
<p>算法说明：<br><img src="http://www.hubwiz.com/course/5718b82208ce8b3d3a1432fa/img/quicksort.png" alt="icon"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">void sort(int *a, int left, int right)<br>&#123;<br>    if(left &gt;&#x3D; right)&#x2F;*如果左边索引大于或者等于右边的索引就代表已经整理完成一个组了*&#x2F;<br>    &#123;<br>        return ;<br>    &#125;<br>    int i &#x3D; left;<br>    int j &#x3D; right;<br>    int key &#x3D; a[left];<br>     <br>    while(i &lt; j)                               &#x2F;*控制在当组内寻找一遍*&#x2F;<br>    &#123;<br>        while(i &lt; j &amp;&amp; key &lt;&#x3D; a[j])<br>        &#x2F;*而寻找结束的条件就是，1，找到一个小于或者大于key的数（大于或小于取决于你想升<br>        序还是降序）2，没有符合条件1的，并且i与j的大小没有反转*&#x2F; <br>        &#123;<br>            j--;&#x2F;*向前寻找*&#x2F;<br>        &#125;<br>         <br>        a[i] &#x3D; a[j];<br>        &#x2F;*找到一个这样的数后就把它赋给前面的被拿走的i的值（如果第一次循环且key是<br>        a[left]，那么就是给key）*&#x2F;<br>         <br>        while(i &lt; j &amp;&amp; key &gt;&#x3D; a[i])<br>        &#x2F;*这是i在当组内向前寻找，同上，不过注意与key的大小关系停止循环和上面相反，<br>        因为排序思想是把数往两边扔，所以左右两边的数大小与key的关系相反*&#x2F;<br>        &#123;<br>            i++;<br>        &#125;<br>         <br>        a[j] &#x3D; a[i];<br>    &#125;<br>     <br>    a[i] &#x3D; key;&#x2F;*当在当组内找完一遍以后就把中间数key回归*&#x2F;<br>    sort(a, left, i - 1);&#x2F;*最后用同样的方式对分出来的左边的小组进行同上的做法*&#x2F;<br>    sort(a, i + 1, right);&#x2F;*用同样的方式对分出来的右边的小组进行同上的做法*&#x2F;<br>                       &#x2F;*当然最后可能会出现很多分左右，直到每一组的i &#x3D; j 为止*&#x2F;<br>&#125;<br><br></code></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序 冒泡 快排</tag>
      </tags>
  </entry>
  <entry>
    <title>Protobuf 的使用</title>
    <url>/2018/03/31/protobuf-research/</url>
    <content><![CDATA[<p>Google Protocol Buffer(简称Protobuf)是由Google推出的一种轻便高效的结构化数据存储格式，可以用于结构化数据串行化，或者说序列化。它很适合做数据存储或RPC数据交换格式。可用于通讯协议、数据存储等领域的语言无关、平台无关、可扩展的序列化结构数据格式</p>
<a id="more"></a>

<h2 id="Protobuf的安装"><a href="#Protobuf的安装" class="headerlink" title="Protobuf的安装"></a>Protobuf的安装</h2><p>这里推荐使用homebrew安装,如果没有安装,先<a href="https://brew.sh/index_zh-cn.html">安装</a>吧</p>
<h3 id="安装protobuf"><a href="#安装protobuf" class="headerlink" title="安装protobuf"></a>安装protobuf</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">$brew install protobuf<br></code></pre></td></tr></table></figure>

<h3 id="安装Protobuf-Compiler"><a href="#安装Protobuf-Compiler" class="headerlink" title="安装Protobuf Compiler"></a>安装Protobuf Compiler</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">brew install automake <br>brew install libtool <br>brew install protobuf<br></code></pre></td></tr></table></figure>

<h2 id="Protobuf-使用"><a href="#Protobuf-使用" class="headerlink" title="Protobuf 使用"></a>Protobuf 使用</h2><p>安装完成后我们就可以直接使用了！</p>
<p><code>注意</code>:上面只是安装了编译环境,可以帮我们将.proto文件编译成我们需要的.h和.m环境</p>
<h3 id="Protobuf-导入"><a href="#Protobuf-导入" class="headerlink" title="Protobuf 导入"></a>Protobuf 导入</h3><p>下面我们就可以新建一个iOS的工程了,然后使用pod方式管理protobuf</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">pod &#39;Protobuf&#39;, &#39;~&gt; 3.4.0&#39;<br></code></pre></td></tr></table></figure>

<h3 id="编写一个proto文件"><a href="#编写一个proto文件" class="headerlink" title="编写一个proto文件"></a>编写一个proto文件</h3><p>这个proto文件就相当于一个类,不过要使用protobuf的语法来定义</p>
<p>可以简单的这么写：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">syntax = <span class="hljs-string">&quot;proto3&quot;</span>;<br><br>message ChatMessage &#123;<br>    <span class="hljs-built_in">string</span> title = <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">string</span> body = <span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>注意：<br><code>使用proto3的时候不需要在变量前面加上required和optional,默认就是optional</code><br>具体的语法规则我们后面介绍</p>
<h3 id="编译这个proto文件"><a href="#编译这个proto文件" class="headerlink" title="编译这个proto文件"></a>编译这个proto文件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">protoc --plugin&#x3D;&#x2F;usr&#x2F;local&#x2F;bin&#x2F;protoc-gen-objc *.proto --objc_out&#x3D;&quot;.&#x2F;*&quot;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>第一个<em>号的地方是你.proto文件所在的位置,<br>第二个</em>所在的地方是你编译完成之后.h和.m要导出的地方</p>
</blockquote>
<h3 id="将生成的文件添加到项目中"><a href="#将生成的文件添加到项目中" class="headerlink" title="将生成的文件添加到项目中"></a>将生成的文件添加到项目中</h3><p>直接添加之后,编译一下,肯定是会报错的(除非你还活在远古的MRC)。这时候你需要将编译出来的对象文件标记为MRC<br>Target - BuildPhases - Compile Sources</p>
<p><img src="http://og0h689k8.bkt.clouddn.com/18-3-31/6967231.jpg"></p>
<p>然后我们仔细阅读,生成的.h文件会发现中的这一段:</p>
<p><img src="http://og0h689k8.bkt.clouddn.com/18-3-31/92058883.jpg"></p>
<p>因为我们是使用pod管理的因此我们这里使用&lt;&gt;导入,因此在</p>
<p>Target - Build Setting - Preprocessor Macros </p>
<p>在Debug和Release中都添加</p>
<p><img src="http://og0h689k8.bkt.clouddn.com/18-3-31/739274.jpg"></p>
<p>这样我们在编译一下,Done! 这就没什么问题了！ </p>
<p>到目前为止,我们基本上已经完成了Protobuf的所有配置,下面开始使用Protobuf了。</p>
<h2 id="简单的使用"><a href="#简单的使用" class="headerlink" title="简单的使用"></a>简单的使用</h2><p>先导入我们生成的.h文件</p>
<p><code>#import &quot;ProtobufChatmessage.pbobjc.h&quot;</code></p>
<p>简单的创建一个的对象–序列化成data然后在解析这个data。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">ChatMessage *message = [[ChatMessage alloc] init];<br>    message.title = <span class="hljs-string">@&quot;Lee&quot;</span>;<br>    message.body = <span class="hljs-string">@&quot;Hom&quot;</span>;<br>    <br>    <span class="hljs-built_in">NSData</span> *data = [message data];<br>    <br>    <br>    <span class="hljs-built_in">NSError</span> *error = <span class="hljs-literal">nil</span>;<br>    ChatMessage *msg = [ChatMessage parseFromData:data error:&amp;error];<br>    <span class="hljs-keyword">if</span> (error) &#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;parseData Error %@&quot;</span>,error.localizedDescription);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;parseData Success&quot;</span>);<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;ChatMessage:title=%@ body=%@&quot;</span>,msg.title,msg.body);<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>运行结果:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">2018-03-31 10:31:00.854929+0800 ProtobufDemo[5901:690009] parseData Success<br>2018-03-31 10:31:00.855157+0800 ProtobufDemo[5901:690009] ChatMessage:title&#x3D;Lee body&#x3D;Hom<br></code></pre></td></tr></table></figure>

<p>至此,我们已经成功的使用到了Protobuf,最直观的感觉就是直接从二进制的NSData转变成了我们想要的模型 Cool!!</p>
<p>Protocol还有很多高深的内容,网上也有很多关于他的文章,喜欢的可以多看看！</p>
<h2 id="Protobuf-基本语法"><a href="#Protobuf-基本语法" class="headerlink" title="Protobuf  基本语法"></a>Protobuf  基本语法</h2><h3 id="字段格式定义"><a href="#字段格式定义" class="headerlink" title="字段格式定义"></a>字段格式定义</h3><p>在Protobuf中，协议是由一系列的消息组成的。因此最重要的就是定义通信时使用到的消息格式。协议中个消息格式固定了t通信双方才能理解对象的码流。</p>
<p><code>限定修饰符① | 数据类型② | 字段名称③ | = | 字段编码值④ | [字段默认值⑤]</code></p>
<h3 id="限定修饰符"><a href="#限定修饰符" class="headerlink" title="限定修饰符"></a>限定修饰符</h3><p>限定修饰符 主要有required\optional\repeated(required在3.0的时候已经被废除,默认是optional)</p>
<ul>
<li><p>Optional：表示是一个可选字段，可选对于发送方，在发送消息时，可以有选择性的设置或者不设置该字段的值。对于接收方，如果能够识别可选字段就进行相应的处理，如果无法识别，则忽略该字段，消息中的其它字段正常处理。因为optional字段的特性，很多接口在升级版本中都把后来添加的字段都统一的设置为optional字段，这样老的版本无需升级程序也可以正常的与新的软件进行通信，只不过新的字段无法识别而已，因为并不是每个节点都需要新的功能，因此可以做到按需升级和平滑过渡。</p>
</li>
<li><p>Repeated：表示该字段可以包含0~N个元素。其特性和optional一样，但是每一次可以包含多个值。可以看作是在传递一个数组的值</p>
</li>
</ul>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>Protobuf到C++的类型映射</p>
<table>
<thead>
<tr>
<th>proto Type</th>
<th>C++ Type</th>
<th>Notes</th>
</tr>
</thead>
<tbody><tr>
<td>double</td>
<td>double</td>
<td></td>
</tr>
<tr>
<td>float</td>
<td>float</td>
<td></td>
</tr>
<tr>
<td>int32</td>
<td>int32</td>
<td>使用可变长编码方式。编码负数时不够高效——如果你的字段可能含有负数，那么请使用sint32。</td>
</tr>
<tr>
<td>int64</td>
<td>int64</td>
<td>使用可变长编码方式。编码负数时不够高效——如果你的字段可能含有负数，那么请使用sint64</td>
</tr>
<tr>
<td>uint32</td>
<td>uint32</td>
<td>Uses variable-length encoding</td>
</tr>
<tr>
<td>uint64</td>
<td>uint64</td>
<td>Uses variable-length encoding.</td>
</tr>
<tr>
<td>sint32</td>
<td>int32</td>
<td>使用可变长编码方式。有符号的整型值。编码时比通常的int32高效。</td>
</tr>
<tr>
<td>sint64</td>
<td>int64</td>
<td>使用可变长编码方式。有符号的整型值。编码时比通常的int64高效。</td>
</tr>
<tr>
<td>fixed32</td>
<td>uint32</td>
<td>总是4个字节。如果数值总是比总是比228大的话，这个类型会比uint32高效</td>
</tr>
<tr>
<td>fixed64</td>
<td>uint64</td>
<td>总是8个字节。如果数值总是比总是比256大的话，这个类型会比uint64高效。</td>
</tr>
<tr>
<td>sfixed32</td>
<td>int32</td>
<td>总是4个字节</td>
</tr>
<tr>
<td>sfixed64</td>
<td>int64</td>
<td>总是8个字节</td>
</tr>
<tr>
<td>bool</td>
<td>bool</td>
<td></td>
</tr>
<tr>
<td>string</td>
<td>string</td>
<td>一个字符串必须是UTF-8编码或者7-bit ASCII编码的文本。</td>
</tr>
<tr>
<td>bytes</td>
<td>string</td>
<td>可能包含任意顺序的字节数据。</td>
</tr>
</tbody></table>
<h3 id="字段名称"><a href="#字段名称" class="headerlink" title="字段名称"></a>字段名称</h3><p>protobuf建议字段的命名采用以下划线分割的驼峰式。例如 first_name 而不是firstName.</p>
<h3 id="字段编码值"><a href="#字段编码值" class="headerlink" title="字段编码值"></a>字段编码值</h3><p>有了该值，通信双方才能互相识别对方的字段。当然相同的编码值，其限定修饰符和数据类型必须相同。</p>
<p>编码值的取值范围为 1~2^32（4294967296）。</p>
<p>其中 1~15的编码时间和空间效率都是最高的，编码值越大，其编码的时间和空间效率就越低（相对于1-15），当然一般情况下相邻的2个值编码效率的是相同的，除非2个值恰好实在4字节，12字节，20字节等的临界区。比如15和16.</p>
<p>1900~2000编码值为Google protobuf 系统内部保留值，建议不要在自己的项目中使用。</p>
<p>protobuf 还建议把经常要传递的值把其字段编码设置为1-15之间的值。</p>
<p>消息中的字段的编码值无需连续，只要是合法的，并且不能在同一个消息中有字段包含相同的编码值</p>
<h5 id="关于import"><a href="#关于import" class="headerlink" title="关于import"></a>关于import</h5><p>Protobuf接口文件可以像C语言的h文件一个，分离为多个，在需要的时候通过import导入需要对文件。其行为和C语言的#include或者iOS中的的#import的行为大致相同。</p>
<h5 id="关于package"><a href="#关于package" class="headerlink" title="关于package"></a>关于package</h5><p>避免名称冲突，可以给每个文件指定一个package名称，对于java解析为java中的包。对于C++则解析为名称空间。</p>
<h5 id="关于message"><a href="#关于message" class="headerlink" title="关于message"></a>关于message</h5><p>支持嵌套消息，消息可以包含另一个消息作为其字段。也可以在消息内定义一个新的消息。</p>
<h5 id="关于enum"><a href="#关于enum" class="headerlink" title="关于enum"></a>关于enum</h5><p>枚举的定义和C++相同，但是有一些限制。枚举值必须大于等于0的整数。使用分号(;)分隔枚举变量而不是C++语言中的逗号(,)</p>
<h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">1,数据压缩效果好,序列化反序列速度快<br>2,跨平台,生成一次proto文件,多端使用<br></code></pre></td></tr></table></figure>

<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">1,可读性行差(在代码中)<br>2,最增加App包体积(生成的类本身就代码很多,而且需要使用第三方库)<br>3,用的人少(在项目交接时,还需要学习这方面的知识)<br></code></pre></td></tr></table></figure>

<p>本文的Demo,放在<a href="https://github.com/LeeWongSnail/Blog_Demo/tree/master/ProtobufDemo">这里</a></p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="http://blog.devzeng.com/blog/ios-protobuf.html">iOS中使用Protocol Buffers</a></p>
<p><a href="https://www.jianshu.com/p/751aa2b621d5">ProtocolBuffer在iOS中的使用</a></p>
]]></content>
      <categories>
        <category>三方库使用</category>
      </categories>
      <tags>
        <tag>Protobuf Google</tag>
      </tags>
  </entry>
  <entry>
    <title>无线循环的滚动视图方案</title>
    <url>/2019/12/20/recyclescrollview/</url>
    <content><![CDATA[<p>我们近期的项目中有两种场景分别是视频流和直播间,由于项目初期直播间或者视频量较少。因此在用户滑动切换直播间或者视频时需要我们做到可以循环滑动。</p>
<a id="more"></a>

<h2 id="可循环滚动内容方案"><a href="#可循环滚动内容方案" class="headerlink" title="可循环滚动内容方案"></a>可循环滚动内容方案</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>我们近期的项目中有两种场景分别是视频流和直播间,由于项目初期直播间或者视频量较少。因此在用户滑动切换直播间或者视频时需要我们做到可以循环滑动。</p>
<h3 id="框架选择"><a href="#框架选择" class="headerlink" title="框架选择"></a>框架选择</h3><p>遇到这几种场景时我们一般都会想到下面三种方案,对于滑动切换这种场景实际上我们要关注的点是：<br>1、何时确定切换完成<br>2、如果在切换完成时获取当前要展示元素(view+model)时机以及方法<br>3、如何滚动到某个具体位置</p>
<p>下面我们带着上面的两个主要问题,讨论下面三个方案可行性和各自的优缺点。</p>
<h4 id="方案一-UICollectionView"><a href="#方案一-UICollectionView" class="headerlink" title="方案一:UICollectionView"></a>方案一:UICollectionView</h4><h5 id="1、何时确定切换完成？"><a href="#1、何时确定切换完成？" class="headerlink" title="1、何时确定切换完成？"></a>1、何时确定切换完成？</h5><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">- (<span class="hljs-keyword">void</span>)collectionView:(<span class="hljs-built_in">UICollectionView</span> *)collectionView didEndDisplayingCell:(<span class="hljs-built_in">UICollectionViewCell</span> *)cell forItemAtIndexPath:(<span class="hljs-built_in">NSIndexPath</span> *)indexPath;<br></code></pre></td></tr></table></figure>
<p>这个方法会在滚动停止时被调用,当然滚动停止并不意味着切换完成因为存在滚动停止时页面并未切换的场景。<br>因此想要确认切换完成 需要将页面停止时当前的Index与滚动前的Index做对比,进而确认是否完成切换。</p>
<h5 id="2、如果在切换完成时获取当前要展示元素-view-model-时机以及方法？"><a href="#2、如果在切换完成时获取当前要展示元素-view-model-时机以及方法？" class="headerlink" title="2、如果在切换完成时获取当前要展示元素(view+model)时机以及方法？"></a>2、如果在切换完成时获取当前要展示元素(view+model)时机以及方法？</h5><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">- (<span class="hljs-keyword">nullable</span> <span class="hljs-built_in">UICollectionViewCell</span> *)cellForItemAtIndexPath:(<span class="hljs-built_in">NSIndexPath</span> *)indexPath<br></code></pre></td></tr></table></figure>
<p>在页面滚动停止时获取当前展示页面的IndexPath,但是页面滚动停止代理方法返回的是结束展示的view和indexPath所以这里需要做一下转换</p>
<h5 id="3、如何滚动到某个具体位置"><a href="#3、如何滚动到某个具体位置" class="headerlink" title="3、如何滚动到某个具体位置"></a>3、如何滚动到某个具体位置</h5><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">- (<span class="hljs-keyword">void</span>)scrollToItemAtIndexPath:(<span class="hljs-built_in">NSIndexPath</span> *)indexPath atScrollPosition:(<span class="hljs-built_in">UICollectionViewScrollPosition</span>)scrollPosition animated:(<span class="hljs-built_in">BOOL</span>)animated;<br></code></pre></td></tr></table></figure>


<h4 id="方案二-UITableView"><a href="#方案二-UITableView" class="headerlink" title="方案二:UITableView"></a>方案二:UITableView</h4><h5 id="1、何时确定切换完成？-1"><a href="#1、何时确定切换完成？-1" class="headerlink" title="1、何时确定切换完成？"></a>1、何时确定切换完成？</h5><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">- (<span class="hljs-keyword">void</span>)tableView:(<span class="hljs-built_in">UITableView</span> *)tableView didEndDisplayingCell:(<span class="hljs-built_in">UITableViewCell</span> *)cell forRowAtIndexPath:(<span class="hljs-built_in">NSIndexPath</span>*)indexPath API_AVAILABLE(ios(<span class="hljs-number">6.0</span>));<br></code></pre></td></tr></table></figure>

<p>与UICollectionView类似,页面滚动停止时可以拿到完成展示的页面以及IndexPath。</p>
<h5 id="2、如果在切换完成时获取当前要展示元素-view-model-时机以及方法？-1"><a href="#2、如果在切换完成时获取当前要展示元素-view-model-时机以及方法？-1" class="headerlink" title="2、如果在切换完成时获取当前要展示元素(view+model)时机以及方法？"></a>2、如果在切换完成时获取当前要展示元素(view+model)时机以及方法？</h5><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">- (<span class="hljs-keyword">nullable</span> __kindof <span class="hljs-built_in">UITableViewCell</span> *)cellForRowAtIndexPath:(<span class="hljs-built_in">NSIndexPath</span> *)indexPath;   <span class="hljs-comment">// returns nil if cell is not visible or index path is out of range</span><br></code></pre></td></tr></table></figure>
<p>获取视图和模型的方法与UICollectionView的一致。</p>
<h5 id="3、如何滚动到某个具体位置-1"><a href="#3、如何滚动到某个具体位置-1" class="headerlink" title="3、如何滚动到某个具体位置"></a>3、如何滚动到某个具体位置</h5><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">- (<span class="hljs-keyword">void</span>)scrollToRowAtIndexPath:(<span class="hljs-built_in">NSIndexPath</span> *)indexPath atScrollPosition:(<span class="hljs-built_in">UITableViewScrollPosition</span>)scrollPosition animated:(<span class="hljs-built_in">BOOL</span>)animated;<br></code></pre></td></tr></table></figure>
<p>该方法与UICollectionView一致。</p>
<h4 id="方案三-UIScrollView"><a href="#方案三-UIScrollView" class="headerlink" title="方案三:UIScrollView"></a>方案三:UIScrollView</h4><h5 id="1、何时确定切换完成？-2"><a href="#1、何时确定切换完成？-2" class="headerlink" title="1、何时确定切换完成？"></a>1、何时确定切换完成？</h5><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">- (<span class="hljs-keyword">void</span>)scrollViewDidScroll:(<span class="hljs-built_in">UIScrollView</span> *)scrollView;                                               <span class="hljs-comment">// any offset changes</span><br></code></pre></td></tr></table></figure>
<p>该方法的调用时机为页面滚动,调用频率比较高！需要根据页面滚动的contentOffset来判断当前的页码。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">// called on finger up if the user dragged. decelerate is true if it will continue moving afterwards</span><br>- (<span class="hljs-keyword">void</span>)scrollViewDidEndDragging:(<span class="hljs-built_in">UIScrollView</span> *)scrollView willDecelerate:(<span class="hljs-built_in">BOOL</span>)decelerate;<br><br>- (<span class="hljs-keyword">void</span>)scrollViewDidEndDecelerating:(<span class="hljs-built_in">UIScrollView</span> *)scrollView;      <span class="hljs-comment">// called when scroll view grinds to a halt</span><br></code></pre></td></tr></table></figure>

<p>这两个方法表示滚动停止！其调用时机分别是：</p>
<p>1、scrollViewDidEndDragging：</p>
<p>scrollView 结束拖动(松开鼠标停止拖动的那一瞬间调用(水平滚动ScrollView也调用，垂直滚动TableView也调用))</p>
<p>2、scrollViewDidEndDecelerating：</p>
<p> scrollview 减速停止(必须得有快速拖动的动作，scrollView滚动完毕(速度减为0)并且手已经松开的时候调用)</p>
<h5 id="2、如果在切换完成时获取当前要展示元素-view-model-时机以及方法？-2"><a href="#2、如果在切换完成时获取当前要展示元素-view-model-时机以及方法？-2" class="headerlink" title="2、如果在切换完成时获取当前要展示元素(view+model)时机以及方法？"></a>2、如果在切换完成时获取当前要展示元素(view+model)时机以及方法？</h5><p>滚动完成时获取当前处于第几个位置,使用scrollView的contentOffset.y与单个视图的高度做除法来获取当前滚动到的视图的位置</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-built_in">CGFloat</span> screenHeigh = <span class="hljs-keyword">self</span>.view.frame.size.height;<br><span class="hljs-built_in">NSInteger</span> offsety = scrollView.contentOffset.y;<br><span class="hljs-built_in">NSInteger</span> height = screenHeigh;<br><span class="hljs-built_in">CGFloat</span> ratio = offsety % height;<br><span class="hljs-built_in">NSInteger</span> index = offsety/screenHeigh;<br>ULLogInfo(<span class="hljs-string">@&quot;LIVEMANAGER： scrollViewDidScroll=index=%@&quot;</span>,@(index));<br><span class="hljs-keyword">if</span> (index == <span class="hljs-keyword">self</span>.currentIndex) &#123;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;enter_live_room_new %s, %@&quot;</span>, __PRETTY_FUNCTION__, <span class="hljs-string">@&quot;1&quot;</span>);<br><br><span class="hljs-keyword">if</span> (scrollView == <span class="hljs-keyword">self</span>.tableView &amp;&amp; ratio == <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">self</span>.currentIndex = index;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>根据上面的条件可以获取到当前展示的视图的位置</p>
<h5 id="3、如何滚动到某个具体位置-2"><a href="#3、如何滚动到某个具体位置-2" class="headerlink" title="3、如何滚动到某个具体位置"></a>3、如何滚动到某个具体位置</h5><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">- (<span class="hljs-keyword">void</span>)setContentOffset:(<span class="hljs-built_in">CGPoint</span>)contentOffset animated:(<span class="hljs-built_in">BOOL</span>)animated;  <span class="hljs-comment">// animate at constant velocity to new offset</span><br><br></code></pre></td></tr></table></figure>

<h3 id="无限循环方案"><a href="#无限循环方案" class="headerlink" title="无限循环方案"></a>无限循环方案</h3><p>假设目前有下面几个视图 </p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gbc3eho3e8j30y004g3yq.jpg" alt="viewtree"></p>
<p>如果我们要实现无限循环的滚动那么实际上我们有两种方案：</p>
<ul>
<li>1、修改数据源 实现无线循环滚动(缺点较明显)</li>
<li>2、修改滚动视图位置 静默滚动 (详细介绍)</li>
</ul>
<h4 id="修改数据源-实现无线循环滚动"><a href="#修改数据源-实现无线循环滚动" class="headerlink" title="修改数据源 实现无线循环滚动"></a>修改数据源 实现无线循环滚动</h4><p>咱们的滚动视图中,以UITableView为例,因为我们的cell是可复用的所以不用考虑创建大量的view的问题：</p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gbc3oliqj4j31kw06ygn0.jpg"></p>
<p>我们可以对数据源做大量的复制比如在tableView中做分组<br>在</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">- (<span class="hljs-built_in">NSInteger</span>)numberOfSectionsInTableView:(<span class="hljs-built_in">UITableView</span> *)tableView<br></code></pre></td></tr></table></figure>
<p>方法中返回一个固定值 例如1000<br>在</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">- (<span class="hljs-built_in">NSInteger</span>)tableView:(<span class="hljs-built_in">UITableView</span> *)tableView numberOfRowsInSection:(<span class="hljs-built_in">NSInteger</span>)section;<br></code></pre></td></tr></table></figure>
<p>中返回我们视图个数</p>
<p>如此我们页面上展示的就是一个有1000个分组 每个分组中有N个row的TableView</p>
<p>在初始化页面展示完成后静默的将页面滚动到中间的分组位置,这样就可以实现循环滚动的效果！</p>
<p>问题：<br>1、这种方式比较适合每个分组中个数固定的类型 比如banner 但是如果我们在滑动过程中需要动态请求接口来扩充每一个分组中数据的个数 那么这种方式需要频繁操作大量数据源。<br>2、在滚动过程中如果我们遇到了某些数据是不符合业务条件的(比如直播间中被拉黑),我们在进行过滤操作时需要操作所有的分组。<br>优点：<br>在数据量不是太大的情况下,我们不需要对页面做滚动操作。</p>
<h4 id="修改滚动视图位置-静默滚动"><a href="#修改滚动视图位置-静默滚动" class="headerlink" title="修改滚动视图位置 静默滚动"></a>修改滚动视图位置 静默滚动</h4><p>这种方法我们不去操作数据源 保证数据源的稳定,只是在临界条件时需要进行静默滚动操作</p>
<p>通过下面这张图我们来更加详细的描述下</p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gbc404oojrj319w05474q.jpg"></p>
<p>下面我们重点介绍下临界点时的处理逻辑</p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gbc42i2ct1j31b8064t9b.jpg"></p>
<h5 id="1、当页面滚动到A且为向上滚动时"><a href="#1、当页面滚动到A且为向上滚动时" class="headerlink" title="1、当页面滚动到A且为向上滚动时"></a>1、当页面滚动到A且为向上滚动时</h5><p>按照理想的情况 当前情况再次向上滚动我们应该滚动到最末尾的位置。</p>
<p>1、如何判断当前是向上滚动且滚动到了A的位置</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>.currentIndex == <span class="hljs-number">0</span> &amp;&amp; !<span class="hljs-keyword">self</span>.isFirstEntry) &#123;<br>    <span class="hljs-comment">// 滚动到了第一个位置</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>2、如何滚动</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">// 需要滚动到列表的倒数第二个位置</span><br><span class="hljs-built_in">NSInteger</span> rowCount = <span class="hljs-keyword">self</span>.liveListArray.count;<br><span class="hljs-keyword">if</span> (rowCount &gt;= <span class="hljs-number">2</span>) &#123;<br>    <span class="hljs-keyword">self</span>.currentIndex = rowCount<span class="hljs-number">-2</span>;<br>    [<span class="hljs-keyword">self</span>.tableView scrollToRowAtIndexPath:[<span class="hljs-built_in">NSIndexPath</span> indexPathForRow:<span class="hljs-keyword">self</span>.currentIndex inSection:<span class="hljs-number">0</span>] atScrollPosition:<span class="hljs-built_in">UITableViewScrollPositionTop</span> animated:<span class="hljs-literal">NO</span>];<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 如果数组的个数小于2 那么证明只有一个直播间不可以滚动</span><br>    [<span class="hljs-keyword">self</span> canSlideChangeLiveRoom:<span class="hljs-literal">NO</span>];<br>&#125;<br></code></pre></td></tr></table></figure>
<p>注意：判断数组的个数是因为如果只有一个数据 不需要滚动</p>
<h5 id="2、当前页面滚动到E且为向下滚动时"><a href="#2、当前页面滚动到E且为向下滚动时" class="headerlink" title="2、当前页面滚动到E且为向下滚动时"></a>2、当前页面滚动到E且为向下滚动时</h5><p>这种情况的判断比较简单：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>.currentIndex == <span class="hljs-keyword">self</span>.liveListArray.count <span class="hljs-number">-1</span>) &#123;<br>    <span class="hljs-comment">// 滚动到了最后一个</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>滚动到指定位置</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">// 滚动到最后一个位置 此处的数据为补充数据 需要滚动列表</span><br>    <span class="hljs-comment">// 需要滚到第一个位置</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>.liveListArray.count == <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-comment">// 如果当前直播间列表只有一个直播间</span><br>        [<span class="hljs-keyword">self</span> canSlideChangeLiveRoom:<span class="hljs-literal">NO</span>];<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">self</span>.currentIndex = <span class="hljs-number">1</span>;<br>        [<span class="hljs-keyword">self</span>.tableView scrollToRowAtIndexPath:[<span class="hljs-built_in">NSIndexPath</span> indexPathForRow:<span class="hljs-keyword">self</span>.currentIndex inSection:<span class="hljs-number">0</span>] atScrollPosition:<span class="hljs-built_in">UITableViewScrollPositionTop</span> animated:<span class="hljs-literal">NO</span>];<br>    &#125;<br></code></pre></td></tr></table></figure>

<p><code>注意</code>:上面两个方法的调用均是在页面滚动停止之后进行！</p>
<p>通过上面这些操作,我们基本实现了一个可以循环滑动的列表！！ </p>
<p>但是在应用到实际的场景时我们肯定会遇到数据源的增删问题,那么这种情况下我们如何去处理呢？</p>
<h3 id="异常情况处理"><a href="#异常情况处理" class="headerlink" title="异常情况处理"></a>异常情况处理</h3><h4 id="数据源增加"><a href="#数据源增加" class="headerlink" title="数据源增加"></a>数据源增加</h4><p>这种情况通常是我们列表中的数据并不是一成不变的比如分页拉取多条数据,那么在这个时候我们应该如何操作呢？</p>
<p>下面我们通过,分页加载数据时如何处理：</p>
<p>假设我们在滚动到倒数第三个数据(有效数据倒数第二条)时我们预加载下一页的内容。</p>
<p>因为需要通过接口返回数据 所以我们无法确认接口返回数据的时机,所以这里要<code>注意处理数据源的时机和方式</code></p>
<p>假如我们接口返回了2条数据 F G </p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gbc4zx31e9j31m40d0jt6.jpg"></p>
<p>我们在返回数据后因为之前在数组的首尾都添加了占位的数据,因此数据添加后我们依然要重置这两个占位数据<br>同时在每次数据重置时都要确认当前数据的个数。</p>
<p>数组重置方法：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">- (<span class="hljs-built_in">NSArray</span> *)reCombineWithArray:(<span class="hljs-built_in">NSArray</span> *)liveList &#123;<br>    <span class="hljs-built_in">NSMutableArray</span> *listArray = [<span class="hljs-built_in">NSMutableArray</span> arrayWithArray:liveList];<br>    <span class="hljs-comment">// 当前直播间列表中有多个直播间</span><br>    ULDiscovery *firstObject = listArray.firstObject;<br>    ULDiscovery *firstPlacehoder = [ULDiscovery parse:[firstObject toDictionary]];<br>    ULDiscovery * lastObject = listArray.lastObject;<br>    ULDiscovery *lastPlacehoder = [ULDiscovery parse:[lastObject toDictionary]];<br>    [listArray addObject:firstPlacehoder];<br>    [listArray insertObject:lastPlacehoder atIndex:<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">return</span> [listArray <span class="hljs-keyword">copy</span>];<br>&#125;<br></code></pre></td></tr></table></figure>
<p>之所以使用数据copy的方法是因为防止数组中数据对象相同导致在获取index时发生错位！</p>
<p>上面说过 因为数据是接口返回 那么可能存在下面两种情况：</p>
<ul>
<li>接口速度较快 在用户从倒数第二条数据滑动到倒数第一条数据前已经获取到数据了</li>
</ul>
<p>这种情况下我们在滚动之前就已经操作了数据源 因此此时数据中已经包含了新请求的F G 因此在此向下滑动时可以正确的滚动到F和G这两条数据。</p>
<ul>
<li>接口速度较慢 在用户从倒数第二条主句滑动到倒数第一条数据时或者之后才获取到数据</li>
</ul>
<p>这种情况下,我们滚动已经开始或者已经结束了,我们要滚动的位置已经根据之前的数据源(EABCDEA)确定了,当接口数据返回后数据源变成了(GABCDEFGA)我们可以发现除了占位数据外其他数据的index是没有改变的,所以这里不会影响数据返回前滚动的index数据的展示(index和数据还是一一对应的),只是新返回的数据需要再次滑动一遍之前的直播间(ABCDE)之后才有机会展示。</p>
<p>这样 我们就完成了动态添加数据后无限循环滚动视图的实现！</p>
<h4 id="数据源删除"><a href="#数据源删除" class="headerlink" title="数据源删除"></a>数据源删除</h4><p>这种情况通常发生在滚动列表数据源中的某一条数据被用户动态删除,我们在查询列表数据详情时发现该数据状态为已删除时需要将这条数据从列表中删除。</p>
<p>这种情况下我们需要做</p>
<ul>
<li>1、删除这条无效数据</li>
<li>2、重置当前数据源</li>
<li>3、找到下一个要滚动到的视图并进行滚动</li>
<li>4、滚动到指定位置</li>
</ul>
<p>第一步和第二部我们在上面都说过这里不再赘述。我们在着重说一下第三步</p>
<p>下面先介绍找到下一个视图的方法和参数：</p>
<p>liveList：删除完无效数据之后重置的数组<br>index: 已删除的无效数据的index<br>destIndex: 根据滚动方向判断出的下一个要展示的视图的位置<br>scrollDown: 是否为向下滚动</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><br><span class="hljs-comment">///  滚动到下一个直播间的index</span><br><span class="hljs-comment">/// @param aDiscovery aDiscovery description</span><br><span class="hljs-comment">/// @param scrollDown scrollDown description</span><br>- (<span class="hljs-built_in">NSInteger</span>)findNextLiveItems:(<span class="hljs-built_in">NSArray</span> &lt;ULDiscovery *&gt; *)liveList index:(<span class="hljs-built_in">NSInteger</span>)index destIndex:(<span class="hljs-built_in">NSInteger</span>)destIndex scrollDown:(<span class="hljs-built_in">BOOL</span>)scrollDown &#123;<br>    <span class="hljs-keyword">if</span> (scrollDown &amp;&amp; (destIndex &gt;= <span class="hljs-keyword">self</span>.liveListArray.count - <span class="hljs-number">1</span>)) &#123;<br>        <span class="hljs-comment">// 如果是向下滚动且为最后一个直播间向第一个直播间滚动 第一个直播间被拉黑</span><br>        <span class="hljs-comment">// 需要滚动到第一个直播间的下一个直播间</span><br>        <span class="hljs-comment">// 数组正向遍历</span><br>        ULDiscovery *destDis = [liveList ul_safeObjectAtIndex:index];<br>        __block <span class="hljs-built_in">NSInteger</span> disIndex = destIndex;<br>        [liveList enumerateObjectsUsingBlock:^(ULDiscovery * _Nonnull obj, <span class="hljs-built_in">NSUInteger</span> idx, <span class="hljs-built_in">BOOL</span> * _Nonnull stop) &#123;<br>            <span class="hljs-keyword">if</span> (obj.room.roomID == destDis.room.roomID) &#123;<br>                *stop = <span class="hljs-literal">YES</span>;<br>                disIndex = idx;<br>            &#125;<br>        &#125;];<br>        destIndex = disIndex+<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">self</span>.currentIndex = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">self</span>.lastRoomIndex = <span class="hljs-number">-1</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!scrollDown &amp;&amp; destIndex &lt;= <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 如果是向上滚动且为第一个直播间向最后一个直播间滚动 最后一个直播间被拉黑</span><br>        ULDiscovery *destDis = [liveList ul_safeObjectAtIndex:index];<br>        __block <span class="hljs-built_in">NSInteger</span> disIndex = destIndex;<br>        [liveList enumerateObjectsWithOptions:<span class="hljs-built_in">NSEnumerationReverse</span> usingBlock:^(ULDiscovery * _Nonnull obj, <span class="hljs-built_in">NSUInteger</span> idx, <span class="hljs-built_in">BOOL</span> * _Nonnull stop) &#123;<br>            <span class="hljs-keyword">if</span> (obj.room.roomID == destDis.room.roomID) &#123;<br>                disIndex = idx;<br>                *stop = <span class="hljs-literal">YES</span>;<br>            &#125;<br>        &#125;];<br>        destIndex = disIndex<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">self</span>.lastRoomIndex = <span class="hljs-keyword">self</span>.liveListArray.count <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> destIndex;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>滚动到指定位置方法</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">// 滚动到指定位置</span><br>    dispatch_main_async_ulsafe(^&#123;<br>        <span class="hljs-keyword">if</span> (destIndex &gt; <span class="hljs-number">0</span> &amp;&amp; destIndex &lt; <span class="hljs-keyword">self</span>.liveListArray.count) &#123;<br>            [<span class="hljs-keyword">self</span>.tableView scrollToRowAtIndexPath:[<span class="hljs-built_in">NSIndexPath</span> indexPathForRow:destIndex inSection:<span class="hljs-number">0</span>] atScrollPosition:<span class="hljs-built_in">UITableViewScrollPositionTop</span> animated:<span class="hljs-literal">NO</span>];<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            [<span class="hljs-keyword">self</span>.tableView scrollToRowAtIndexPath:[<span class="hljs-built_in">NSIndexPath</span> indexPathForRow:<span class="hljs-number">0</span> inSection:<span class="hljs-number">0</span>] atScrollPosition:<span class="hljs-built_in">UITableViewScrollPositionTop</span> animated:<span class="hljs-literal">NO</span>];<br>        &#125;<br>    &#125;);<br></code></pre></td></tr></table></figure>

<p>这样我们就完成了 删除某条数据后循环滚动方案！！</p>
]]></content>
      <categories>
        <category>UI</category>
      </categories>
      <tags>
        <tag>循环 滚动视图</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS LLDB 打印技巧</title>
    <url>/2015/12/19/something-about-lldb/</url>
    <content><![CDATA[<p>今天在微博上看到<a href="http://www.jianshu.com/users/1f93e3b1f3da/latest_articles">小笨狼</a>分享的一片文章，其中比较详细的介绍了LLDB的使用，顿时感觉原来LLDB控制体可以做那么多事情，下面是我挑选的几个，开发中比较常用的命令</p>
<a id="more"></a>

<h4 id="1、基本语法"><a href="#1、基本语法" class="headerlink" title="1、基本语法"></a>1、基本语法</h4><p>首先还是先看一下最近本的语法，这会让我们会更容易的去理解和记住下面的命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;command&gt; [&lt;subcommand&gt; [&lt;subcommand&gt;...]] <br>&lt;action&gt; [-options [option-value]] <br>[argument [argument...]]<br><br>&#96;&#96;&#96;	<br>参数解析：<br>1、&#96;&lt;command&gt;&#96;和&lt;subcommand&gt;:是LLDB调试命令的名称，命令和子命令是按照层级结构排列的<br>一个命令对象为跟随他的子对象创建一个上下文，子命令又为子命令创建一个上下文<br><br>2、&#96;&lt;action&gt;&#96;:执行命令的操作<br><br>3、&#96;&lt;option&gt;&#96;：命令选项<br><br>4、&#96;&lt;argument&gt;&#96;:命令参数<br><br>5、&#96;[]&#96;:表示命令是可选的，可有可无<br><br>exmp:<br><br></code></pre></td></tr></table></figure>
<p>breakpoint set - n main</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">1、&#96;command&#96;:breakpoint 表示断点命令<br><br>2、&#96;断点命令&#96;:set 表示设置断点<br><br>3、&#96;-n&#96;:表示根据方法name设置断点<br><br>4、&#96;argument&#96;: main 表示方法名为main<br><br>#### 2、唯一匹配原则<br><br>LLDB的命令遵循唯一匹配原则：假如根据前n个字母已经能唯一匹配到某个命令，则只写前n个字母等效于写下完整的命令。<br>e.g:<br><br></code></pre></td></tr></table></figure>
<p>breakpoint set -n main<br>br s -n main</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">下面一行的命令可以唯一匹配到上一行的命令，所以二者是等效的<br><br>&#96;~&#x2F;.lldbinit&#96;<br><br>LLDB有了一个启动时加载的文件~&#x2F;.lldbinit，每次启动都会加载。所以一些初始化的事儿，我们可以写入~&#x2F;.lldbinit中，比如给命令定义别名等。但是由于这时候程序还没有真正运行，也有部分操作无法在里面玩，比如设置断点。<br><br><br>#### 3、LLDB常用命令<br><br>##### 1、expression<br>语法格式<br><br></code></pre></td></tr></table></figure>
<p>expression <cmd-options> – <expr></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">作用：执行一个表达式，并将表达式的返回值输出<br><br>e.g 1：执行一个表达式<br><br></code></pre></td></tr></table></figure>
<p> expression – self.view.backgroundColor = [UIColor redColor]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br>e.g 2:输出返回值<br><br></code></pre></td></tr></table></figure>
<p> (lldb) expression – self.view<br>    (UIView *) $1 = 0x00007fe322c18a10</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&#96;expression 可以简写做e&#96;<br><br>##### 2、p &amp; print &amp; call<br>其实这三个方法都可以看做是expression的别名，只是不再向expression那样可以设置命令选项（一般情况下，我们是不需要去设置命令选项的）<br><br>print:打印出某个东西，可以是变量或者是表达式<br><br>p:可以看做是print的缩写<br><br>call:调用某个方法<br><br>e.g:<br><br></code></pre></td></tr></table></figure>
<p>(lldb) expression – self.view<br>(UIView *) $5 = 0x00007fb2a40344a0<br>(lldb) p self.view<br>(UIView *) $6 = 0x00007fb2a40344a0<br>(lldb) print self.view<br>(UIView *) $7 = 0x00007fb2a40344a0<br>(lldb) call self.view<br>(UIView *) $8 = 0x00007fb2a40344a0<br>(lldb) e self.view<br>(UIView *) $9 = 0x00007fb2a40344a0</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br>##### 3、PO<br>通常我们在控制台打印的时候，一般都是变量值或者是对象<br>如果我们直接<br><br></code></pre></td></tr></table></figure>
<p>expression – self.view<br>(UIView *) $13 = 0x00007fb2a40344a0</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">显然结果并不是我们想要的，所以，我们需要添加命令选项：<br><br></code></pre></td></tr></table></figure>
<p>(lldb) expression -O – self.view</p>
<p>&lt;UIView: 0x7fb2a40344a0; frame = (0 0; 375 667); autoresize = W+H; layer = &lt;CALayer: 0x7fb2a4018c80&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">这里 为了方便使用，LLDB为expression定义了一个别名 po,因此：<br><br></code></pre></td></tr></table></figure>
<p>(lldb) po self.view</p>
<p>&lt;UIView: 0x7fb2a40344a0; frame = (0 0; 375 667); autoresize = W+H; layer = &lt;CALayer: 0x7fb2a4018c80&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">也能达到上面一样的效果<br><br>##### 4、thread backtrace &amp; bt<br>作用：打印线程的堆栈<br><br></code></pre></td></tr></table></figure>
<p>thread backtrace [-c <count>] [-s <frame-index>] [-e <boolean>]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">thread backtrace 后面的都是命令选项<br><br>&#96;-c&#96;: 设置打印堆栈帧的帧数（frame）<br>&#96;-s&#96;: 设置从哪一帧开始打印<br>&#96;-e&#96;: 是否显示额外的回溯<br><br>&#96;实际上，我们在平时的使用中一般都不会添加这些命令选项&#96;<br><br>e.g: crash happens<br><br></code></pre></td></tr></table></figure>
<p>(lldb) thread backtrace</p>
<ul>
<li>thread #1: tid = 0xdd42, 0x000000010afb380b libobjc.A.dylib<code>objc_msgSend + 11, queue = &#39;com.apple.main-thread&#39;, stop reason = EXC_BAD_ACCESS (code=EXC_I386_GPFLT)   frame #0: 0x000000010afb380b libobjc.A.dylib</code>objc_msgSend + 11<ul>
<li>frame #1: 0x000000010aa9f75e TLLDB<code>-[ViewController viewDidLoad](self=0x00007fa270e1f440, _cmd=&quot;viewDidLoad&quot;) + 174 at ViewController.m:23 frame #2: 0x000000010ba67f98 UIKit</code>-[UIViewController loadViewIfRequired] + 1198<br>frame #3: 0x000000010ba682e7 UIKit<code>-[UIViewController view] + 27 frame #4: 0x000000010b93eab0 UIKit</code>-[UIWindow addRootViewControllerViewIfPossible] + 61<br>frame #5: 0x000000010b93f199 UIKit<code>-[UIWindow _setHidden:forced:] + 282 frame #6: 0x000000010b950c2e UIKit</code>-[UIWindow makeKeyAndVisible] + 42</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">这里，我们可以比较清晰的看到 crash 触发的位置，就可以有针对性的进行检查<br><br>&#96;backtrace &#x3D; bt&#96; 可以使用简单的bt来代替backtrace<br><br>##### 5、thread return<br>作用： return 返回，表示不再执行断点下面的代码，直接返回，&#96;可以自己定义要返回的值&#96;<br><br>e.g: <br>![icon](http:&#x2F;&#x2F;upload-images.jianshu.io&#x2F;upload_images&#x2F;1122433-cf22e45902233a0c.png?imageMogr2&#x2F;auto-orient&#x2F;strip%7CimageView2&#x2F;2&#x2F;w&#x2F;1240)<br><br>如果我们不想执行断点后面的代码，同时还想让这个方法的返回值为NO<br><br></code></pre></td></tr></table></figure>
<p>(lldb) thread return NO</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br>##### 6、c &amp; n &amp; s &amp; finish<br><br>![icon](http:&#x2F;&#x2F;upload-images.jianshu.io&#x2F;upload_images&#x2F;1122433-17ba978ac411af3d.png?imageMogr2&#x2F;auto-orient&#x2F;strip%7CimageView2&#x2F;2&#x2F;w&#x2F;1240)<br><br>其实这四个按钮都可以用下面的命令来代替：<br><br>1、&#96;c&#96;&#x2F;&#96;continue&#96;&#x2F;&#96;thread continue&#96;: 这三个命令的效果等同于图片中的第一个按钮，表示继续运行<br><br>2、&#96;n&#96;&#x2F;&#96;next&#96;&#x2F;&#96;thread step-over&#96;:等同于第二个按钮，表示单步执行<br><br>3、&#96;s&#96;&#x2F;&#96;step&#96;&#x2F;&#96;thread step-in&#96;:等同于第三个按钮，表示进入方法内部<br><br>4、&#96;finish&#96;&#x2F;&#96;step-out&#96;:等同于第四个按钮，表示直接走完当前方法，返回到上一层<br><br>###### 7、breakpoint <br>1、breakpoint set 设置断点<br><br></code></pre></td></tr></table></figure>
<p>这个方法的功能比较强大，可以根据方法名设置断点，可以给指定文件中的指定方法设置断点(方法不存在，无法设置断点)，给指定文件的某一行设置断点、设置条件断点、设置单次执行断点。由于这些在实际的开发中用的比较少，所以在这里不再详细说明（需要看的可以在本文最后查看引用的文章）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">2、breakpoint command add 给断点添加命令<br><br>3、breakpoint command list 查看某个断点已有的命令<br><br>4、breakpoint command delete 删除断点<br><br>5、breakpoint list 查看一ing设置断点的位置<br><br>6、breakpoint enable&#x2F;disable 断点暂时失效&#x2F;生效<br><br>7、breakpoint delete 彻底删除所有断点（也可以删除指定行）<br><br><br>###### 8、watchpoint <br>&#96;breakpoint&#96;有一个孪生兄弟&#96;watchpoint&#96;。如果说&#96;breakpoint&#96;是对方法生效的断点，&#96;watchpoint&#96;就是对地址生效的断点<br><br>基本用法和breakpoint 类似，这里不再详细说明<br><br>###### 9、target<br><br>对于target这个命令，我们用得最多的可能就是target modules lookup。由于LLDB给target modules取了个别名image，所以这个命令我们又可以写成image lookup<br><br><br>1、image lookup --address 查找这个地址具体对应的文件位置（具体到行）<br>当我们遇到崩溃（不是停留在main函数中的崩溃）我们可以通过这个方法获取到这个控制器的哪一行出现问题<br>e.g : crash happens<br><br></code></pre></td></tr></table></figure>
<p>2015-12-17 14:51:06.301 TLLDB[25086:246169] <strong>* Terminating app due to uncaught exception ‘NSRangeException’, reason: ‘*</strong> -[__NSArray0 objectAtIndex:]: index 1 beyond bounds for empty NSArray’<br>*** First throw call stack:<br>(<br>    0   CoreFoundation                      0x000000010accde65 __exceptionPreprocess + 165<br>    1   libobjc.A.dylib                     0x000000010a746deb objc_exception_throw + 48<br>    2   CoreFoundation                      0x000000010ac7c395 -[__NSArray0 objectAtIndex:] + 101<br>    3   TLLDB                               0x000000010a1c3e36 -[ViewController viewDidLoad] + 86<br>    4   UIKit                               0x000000010b210f98 -[UIViewController loadViewIfRequired] + 1198<br>    5   UIKit                               0x000000010b2112e7 -[UIViewController view] + 27</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br></code></pre></td></tr></table></figure>
<p>(lldb) image lookup -a 0x000000010a1c3e36<br>      Address: TLLDB[0x0000000100000e36] (TLLDB.__TEXT.__text + 246)<br>      Summary: TLLDB`-[ViewController viewDidLoad] + 86 at ViewController.m:32</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">准确定位，崩溃出现的方法名，及在文件中的行号<br><br>2、image lookup --name <br><br>e.g : <br><br></code></pre></td></tr></table></figure>
<p>某个第三方SDK用了一个我们项目里原有的第三方库，库里面对NSDictionary添加了category。也就是有2个class对NSDictionary添加了名字相同的category，项目中调用自己的category的地方实际走到了第三方SDK里面去了。最大的问题是，这2个同名category方法行为并不一致，导致出现bug<br>现在问题来了，怎么寻找到底是哪个第三方SDK？方法完全包在.a里面</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br></code></pre></td></tr></table></figure>

<p>(lldb) image lookup -n dictionaryWithXMLString:<br>2 matches found in /Users/jiangliancheng/Library/Developer/Xcode/DerivedData/VideoIphone-aivsnqmlwjhxapdlvmdmrubbdxpq/Build/Products/Debug-iphoneos/BaiduIphoneVideo.app/BaiduIphoneVideo:<br>        Address: BaiduIphoneVideo[0x00533a7c] (BaiduIphoneVideo.__TEXT.__text + 5414908)<br>        Summary: BaiduIphoneVideo<code>+[NSDictionary(SAPIXmlDictionary) dictionaryWithXMLString:] at XmlDictionary.m          Module: file = &quot;/Users/jiangliancheng/Library/Developer/Xcode/DerivedData/VideoIphone-aivsnqmlwjhxapdlvmdmrubbdxpq/Build/Products/Debug-iphoneos/BaiduIphoneVideo.app/BaiduIphoneVideo&quot;, arch = &quot;armv7&quot;     CompileUnit: id = &#123;0x00000000&#125;, file = &quot;/Users/jiangliancheng/Development/Work/iOS_ShareLib/SharedLib/Srvcs/BDPassport4iOS/BDPassport4iOS/SAPI/Extensive/ThirdParty/XMLDictionary/XmlDictionary.m&quot;, language = &quot;Objective-C&quot;        Function: id = &#123;0x23500000756&#125;, name = &quot;+[NSDictionary(SAPIXmlDictionary) dictionaryWithXMLString:]&quot;, range = [0x005a6a7c-0x005a6b02)        FuncType: id = &#123;0x23500000756&#125;, decl = XmlDictionary.m:189, clang_type = &quot;NSDictionary *(NSString *)&quot;          Blocks: id = &#123;0x23500000756&#125;, range = [0x005a6a7c-0x005a6b02)       LineEntry: [0x005a6a7c-0x005a6a98): /Users/jiangliancheng/Development/Work/iOS_ShareLib/SharedLib/Srvcs/BDPassport4iOS/BDPassport4iOS/SAPI/Extensive/ThirdParty/XMLDictionary/XmlDictionary.m          Symbol: id = &#123;0x0000f2d5&#125;, range = [0x005a6a7c-0x005a6b04), name=&quot;+[NSDictionary(SAPIXmlDictionary) dictionaryWithXMLString:]&quot;        Variable: id = &#123;0x23500000771&#125;, name = &quot;self&quot;, type = &quot;Class&quot;, location =  [sp+32], decl =         Variable: id = &#123;0x2350000077e&#125;, name = &quot;_cmd&quot;, type = &quot;SEL&quot;, location =  [sp+28], decl =         Variable: id = &#123;0x2350000078b&#125;, name = &quot;string&quot;, type = &quot;NSString *&quot;, location =  [sp+24], decl = XmlDictionary.m:189        Variable: id = &#123;0x23500000799&#125;, name = &quot;data&quot;, type = &quot;NSData *&quot;, location =  [sp+20], decl = XmlDictionary.m:192         Address: BaiduIphoneVideo[0x012ee160] (BaiduIphoneVideo.__TEXT.__text + 19810016)         Summary: BaiduIphoneVideo</code>+[NSDictionary(XMLDictionary) dictionaryWithXMLString:] at XMLDictionary.m<br>         Module: file = “/Users/jiangliancheng/Library/Developer/Xcode/DerivedData/VideoIphone-aivsnqmlwjhxapdlvmdmrubbdxpq/Build/Products/Debug-iphoneos/BaiduIphoneVideo.app/BaiduIphoneVideo”, arch = “armv7”<br>    CompileUnit: id = {0x00000000}, file = “/Users/wingle/Workspace/qqlive4iphone/iphone_4.0_fabu_20150601/Common_Proj/mobileTAD/VIDEO/Library/Third Party/XMLDictionary/XMLDictionary.m”, language = “Objective-C”<br>       Function: id = {0x79900000b02}, name = “+[NSDictionary(XMLDictionary) dictionaryWithXMLString:]”, range = [0x01361160-0x0136119a)<br>       FuncType: id = {0x79900000b02}, decl = XMLDictionary.m:325, clang_type = “NSDictionary *(NSString *)”<br>         Blocks: id = {0x79900000b02}, range = [0x01361160-0x0136119a)<br>      LineEntry: [0x01361160-0x01361164): /Users/wingle/Workspace/qqlive4iphone/iphone_4.0_fabu_20150601/Common_Proj/mobileTAD/VIDEO/Library/Third Party/XMLDictionary/XMLDictionary.m<br>         Symbol: id = {0x0003a1e9}, range = [0x01361160-0x0136119c), name=”+[NSDictionary(XMLDictionary) dictionaryWithXMLString:]”<br>       Variable: id = {0x79900000b1e}, name = “self”, type = “Class”, location =  r0, decl =<br>       Variable: id = {0x79900000b2c}, name = “_cmd”, type = “SEL”, location =  r1, decl =<br>       Variable: id = {0x79900000b3a}, name = “string”, type = “NSString *”, location =  r2, decl = XMLDictionary.m:325<br>       Variable: id = {0x79900000b4a}, name = “data”, type = “NSData *”, location =  r2, decl = XMLDictionary.m:327</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">找到file:<br><br></code></pre></td></tr></table></figure>
<p>CompileUnit: id = {0x00000000}, file = “/Users/jiangliancheng/Development/Work/iOS_ShareLib/SharedLib/Srvcs/BDPassport4iOS/BDPassport4iOS/SAPI/Extensive/ThirdParty/XMLDictionary/XmlDictionary.m”, language = “Objective-C”<br>CompileUnit: id = {0x00000000}, file = “/Users/wingle/Workspace/qqlive4iphone/iphone_4.0_fabu_20150601/Common_Proj/mobileTAD/VIDEO/Library/Third Party/XMLDictionary/XMLDictionary.m”, language = “Objective-C”</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">这样就可以找到了……<br><br>3、imag lookup --type  查看类型可以打印类的属性和成员变量<br><br></code></pre></td></tr></table></figure>
<p>(lldb) image lookup -t Model<br>Best match found in /Users/jiangliancheng/Library/Developer/Xcode/DerivedData/TLLDB-beqoowskwzbttrejseahdoaivpgq/Build/Products/Debug-iphonesimulator/TLLDB.app/TLLDB:<br>id = {0x30000002f}, name = “Model”, byte-size = 32, decl = Modek.h:11, clang_type = “@interface Model : NSObject{<br>    NSString * _bb;<br>    NSString * _cc;<br>    NSString * _name;<br>}<br>@property ( getter = name,setter = setName:,readwrite,nonatomic ) NSString * name;<br>@end<br>“</p>
<pre><code>
4、其他不常用的方法，这里不再多说

### tips:

help &amp; apropos
LLDB的命令其实还有很多，很多命令我也没玩过。就算玩过的命令，我们也非常容易忘记，下次可能就不记得是怎么用的了。还好LLDB给我们提供了2个查找命令的命令:help &amp; apropos

参考文章：
[小笨狼与LLDB的故事](http://www.jianshu.com/p/e89af3e9a8d7)

</code></pre>
]]></content>
      <categories>
        <category>iOS进阶</category>
      </categories>
      <tags>
        <tag>lldb</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之策略模式</title>
    <url>/2016/09/12/stragtery-model/</url>
    <content><![CDATA[<p> 最近买了本设计模式的书Header First 非常喜欢其中的讲解方式。虽然买了有一段时间了但是没有认真的看过。这段时间工作相对没有那么难了，所以抽出点时间看一下这本书，同时，在这里做一下分享，希望可以帮到你！</p>
<a id="more"></a>

<h4 id="1、定义"><a href="#1、定义" class="headerlink" title="1、定义"></a>1、定义</h4><pre><code>策略模式定义了算法族，分别封装起来，让他们之间可以互相替换，此模式让算法的变化独立于使用算法的客户</code></pre>
<h4 id="2、使用场景"><a href="#2、使用场景" class="headerlink" title="2、使用场景"></a>2、使用场景</h4><p>   我们的日常开发中经常碰到一类问题，例如有一个类（Animals),他有几个方法（fly,eat）,某一天我们需要创建一个对象1恰好是要有fly/eat这两个方法,后来我们又创建了另外的一个对象2有eat这个方法。这时候我们最容易想到的肯定是<code>继承</code>。但是如果有一天，我们要给对象1和对象2增加一个sleep方法，显然最简单的方法就是在Animals中加入一个方法sleep。</p>
<p>   后来，产品有要求创建另外的一个对象拥有sleep和eat的对象3，很显然，我们仍然可以通过继承的方式，派生出一个Animals的子类。尽管没有要求对象3有fly这个方法，但是实际上这个方法已经从父类中继承了。</p>
<p>   开始的时候，产品大大说这三个对象的eat方法是一样的，直接打印出一个吃就可以了，但是慢慢地，产品大大们发现，这三个对象不是一个品种呀，所以他们吃的东西肯定也是不一样的。因此他们的eat方法的实现是不一样的。</p>
<p>   我的天呐，这可怎么办，我们之前是直接写在父类中的。所以，我们最直接的方法就是在Animals的所有子类中重写eat这个方法。甚至有些没有eat这个行为的对象，我们为了避免出现问题也实现了这个方法（方法中不做任何操作）。另一方面 这也在考验我们的记忆力，那些对象是继承自Animals的，哪些对象的eat方法对需要做什么。</p>
<p>   这时候才发现：<code>继承害人不浅啊！！！！</code>；</p>
<h4 id="3、思考"><a href="#3、思考" class="headerlink" title="3、思考"></a>3、思考</h4><p>1、以后，产品大大们脑洞大开，可能还会有很多<code>新的对象要加入</code>，他们的行为可能会更加的复杂，我们该如何做？</p>
<p>2、父类中的有些方法，并不是非要让所有的子类都去实现？ 这可能造成大量的<code>代码冗余</code>。</p>
<p>3、如果从代码复用的角度去考虑，如果哪天我们有一个Person类也需要调用eat这个方法，我们该如何<code>复用</code>？</p>
<p>4、新人报道，他是如何知道父类中eat方法到底有<code>多少种类型</code>。挨个查找子类中的方法 Are you Kidding me?</p>
<p>5、如何去动态的改变子类中的这些方法，有一天 我想让他吃肉，第二天我又想让他吃素，怎么<code>动态判断和修改</code>。</p>
<h4 id="4、修改思路"><a href="#4、修改思路" class="headerlink" title="4、修改思路"></a>4、修改思路</h4><p>   考虑到代码的复用，我们最先想到的就是代码的隔离，上面我们采用的方法是面向方法的实现进行编程。子类实现了什么样的方法。我们在去做对应的操作，这就意味着，我们的操作具有了一个前提：我知道他要做什么了。这样就导致了我们的代码<code>毫无复用性可言</code>。</p>
<p>   从这一点考虑，我们首先想到了面向接口编程的方法：将具体的方法和对象隔离，简单点来说就是，如果你想要有eat的功能，那么你就<code>遵守我eat这个协议，实现协议方法</code>。这样就可以从一定程度上降低了对象和方法的耦合性，最起码这两者不再是绑定的关系了。</p>
<p>   但是，仔细考虑一下，我们的代码复用性还是不高，如果我们两个对象要实现的功能是一模一样的，那岂不是我这两个对象同时都要遵守协议实现接口中的方法？ 代码的复用性还是有待提高啊！</p>
<p>   所以，我们考虑<code>将方法的实现彻底的与使用这个方法的类分离开</code>。这样才能进一步增加代码的复用性。同时实现了不同对象的隔离。</p>
<h4 id="5、具体实现"><a href="#5、具体实现" class="headerlink" title="5、具体实现"></a>5、具体实现</h4><p>   首先我们从最上层考虑，对于这些对象，他们都有同一个父类(Animals)，但是这里我们不在这个父类中声明或者实现任何关于eat/sleep/fly这些操作。对于这些动作，我们设置多个接口（这里使用eat举例）。考虑现存的eat方法有几种（eatvg,eatmeat）,我们新建两个类分别为eatvg,eatmeat。这两个类遵守关于eat的协议并且实现eat协议中的eat方法。</p>
<p>   通过上面这一步，我们基本可以把对象和方法做了彻底的分离，那么我们如何在对象中调用其所需要的方法呢？</p>
<p>   1、在父类animals中声明一个变量，表明这个animals的eat方法</p>
<p>   2、在初始化的时候 给父类中的这个方法赋值（eatvb或是eatmeat）</p>
<p>   3、如果需要执行eat的方法可以直接调用初始化的时候给eat赋值的方法</p>
<p>  这样我们通过属性的方式，做了绑定，在做到代码最大限度复用的情况下，解决了继承给我们带来的种种问题。</p>
<p><img src="https://i.niupic.com/images/2016/09/12/g0c0bQ.png" alt="策略模式"></p>
<p><a href="https://github.com/LeeWongSnail/Head-First-DesignPattern">代码放在这里了</a></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>策略模式</tag>
      </tags>
  </entry>
  <entry>
    <title>有用的文章积累</title>
    <url>/2015/10/16/useful-article/</url>
    <content><![CDATA[<p>一些设计各个方面的文章的汇总</p>
<a id="more"></a>

<p>一、内购相关</p>
<p>1、<a href="http://www.jianshu.com/p/86ac7d3b593a">iOS开发内购全套图文教程</a></p>
<p>2、<a href="http://www.jianshu.com/p/690a7c68664e">iOS内购(iap)</a></p>
<p>二、常用的过滤</p>
<p><a href="http://www.jianshu.com/p/b65b0d2e1899">常用的过滤</a></p>
<p>三、第三方登陆苦逼的上线经历</p>
<p><a href="http://www.jianshu.com/p/c382c9413495">4次被拒</a></p>
<p>四、良心App可添加的暖心功能</p>
<p><a href="http://www.cnblogs.com/ludashi/p/4867511.html">支持Spotlight</a></p>
<p>五、支付</p>
<p><a href="http://www.jianshu.com/p/97d38b00e53d">微信、支付宝、银联</a></p>
<p>六、自定义控件</p>
<p><a href="http://www.cocoachina.com/ios/20160331/15808.html">图片轮播器</a></p>
<p>七、运行时</p>
<p><a href="http://tech.glowing.com/cn/objective-c-runtime/">Objective-C Runtime</a></p>
<p>八、架构相关</p>
<p><a href="http://limboy.me/ios/2016/03/10/mgj-components.html">蘑菇街APP组件化</a></p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzA3ODg4MDk0Ng==&mid=403009403&idx=1&sn=d19264fa1d06b9c5a9dfb1d192a0ed8e&scene=0#wechat_redirect">携程移动App架构优化</a></p>
<p><a href="http://reviewcode.cn/article.html?hmsr=toutiao.io&reviewId=20&utm_medium=toutiao.io&utm_source=toutiao.io">叶孤城 组件化浅谈</a></p>
<p><a href="http://blog.cnbang.net/tech/3080/">bang的组件化</a></p>
<p><a href="http://casatwy.com/iOS-Modulization.html">casa taloyum 组件化详解</a></p>
<p>九、性能优化<br><a href="http://ios.jobbole.com/84360/">UITableView性能优化</a><br><a href="http://www.cocoachina.com/cms/wap.php?action=article&id=12237">Instrument使用</a></p>
]]></content>
      <categories>
        <category>收藏文章</category>
      </categories>
      <tags>
        <tag>有用的博客</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS webP.framework制作</title>
    <url>/2020/02/20/webpframework/</url>
    <content><![CDATA[<p>相信目前大部分APP都已经支持了WebP格式的图片,下面我们通过这种图片简单介绍下WebP格式图片的优点。</p>
<a id="more"></a>

<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>WebP 的优势体现在它具有更优的图像数据压缩算法，能带来更小的图片体积，而且拥有肉眼识别无差异的图像质量；同时具备了无损和有损的压缩模式、Alpha 透明以及动画的特性，在 JPEG 和 PNG 上的转化效果都相当优秀、稳定和统一。</p>
<p>下面我们看下官网介绍的对于JPEG格式的图片和Gif图片压缩对比！</p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gbc6ha4mv7j31p80dkgwp.jpg"></p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gbc6hzbo21j30nw0oydkv.jpg"></p>
<p>从上面的图中我们看到webP的压缩效果还是很明显的！</p>
<h3 id="现有方案"><a href="#现有方案" class="headerlink" title="现有方案"></a>现有方案</h3><p>熟悉iOS的开发者都知道图片下载和展示的主要框架有<code>SDWebImage</code>和<code>YYWebImage</code>。当然这两个库也都支持了WebP的图片展示,下面我们先介绍下这两个现有的方案。</p>
<h4 id="SDWebImage"><a href="#SDWebImage" class="headerlink" title="SDWebImage"></a>SDWebImage</h4><p>在github的简介上我们看到<br><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gbc6mz3lpxj31em0fqdkj.jpg"></p>
<p>SD实际上支持多种图片格式的扩展!</p>
<p>如果项目中我们使用了SD那么我们想增加对WebP格式的图片支持,只需要增加</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">pod &#39;SDWebImage&#x2F;WebP&#39;<br></code></pre></td></tr></table></figure>
<p><code>注意</code>： 因为libwebp(0.5.1)是谷歌的库，下载需要翻墙。SD中webP的库默认是0.5.1版本的</p>
<h4 id="YYWebImage"><a href="#YYWebImage" class="headerlink" title="YYWebImage"></a>YYWebImage</h4><p>导入方式与SD类似直接通过pod的方式导入</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">pod <span class="hljs-string">&#x27;YYWebImage&#x27;</span><br>pod <span class="hljs-string">&#x27;YYImage/WebP`</span><br></code></pre></td></tr></table></figure>

<p>一般情况下我们直接使用上面两种方法就可以解决webP的集成使用,但是还存在两个问题：</p>
<ul>
<li>1、webP库的版本控制依赖三方</li>
<li>2、webP库为谷歌的库直接pod集成需要翻墙 成本较高</li>
</ul>
<h3 id="自己制作WebP"><a href="#自己制作WebP" class="headerlink" title="自己制作WebP"></a>自己制作WebP</h3><p>首先我们可以登录谷歌的<a href="https://developers.google.com/speed/webp/docs/using">WebP官网</a></p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gbca27ik2fj319s0tyqha.jpg"></p>
<p>通过上面的图我们可以看到WebP的最新版本已经到了 1.1.0(SDWebImage还是0.5.1)</p>
<p>我们直接去下载并解压</p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gbca48vq3yj30mk0za7dx.jpg"></p>
<p>在文件夹中我们可以看到一个<code>iosbuild.sh</code>文件,我们在终端执行这个shell脚本</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">sh iosbuild.sh<br></code></pre></td></tr></table></figure>
<p>执行完成后你会发现文件夹中多了下面几个文件</p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gbcabyxc1dj30by04cdgg.jpg"></p>
<p>这就是我们需要继承的webP相关的framework</p>
<h4 id="多个framework合成"><a href="#多个framework合成" class="headerlink" title="多个framework合成"></a>多个framework合成</h4><p>我们在查看YYWebImage的时候,YY实际上重写了我们在官网下载的demo中的iosbuild.sh</p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gbcagkifxhj31qk0cugou.jpg"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">!/bin/bash</span><br><span class="hljs-meta">#</span><br><span class="hljs-meta">#</span><span class="bash"> This script generates <span class="hljs-string">&#x27;WebP.framework&#x27;</span> (static library).</span><br><span class="hljs-meta">#</span><span class="bash"> An iOS app can decode WebP images by including <span class="hljs-string">&#x27;WebP.framework&#x27;</span>.</span><br><span class="hljs-meta">#</span><br><span class="hljs-meta">#</span><span class="bash"> 1. Download the latest libwebp <span class="hljs-built_in">source</span> code from</span><br><span class="hljs-meta">#</span><span class="bash">    http://downloads.webmproject.org/releases/webp/index.html</span><br><span class="hljs-meta">#</span><span class="bash"> 2. Use this script instead of the original <span class="hljs-string">&#x27;iosbuild.sh&#x27;</span> to build the WebP.framework.</span><br><span class="hljs-meta">#</span><span class="bash">    It will build all modules, include mux, demux, coder and decoder.</span><br><span class="hljs-meta">#</span><br><span class="hljs-meta">#</span><span class="bash"> Notice: You should use Xcode 7 (or above) to support bitcode.</span><br><br>set -e<br><br><span class="hljs-meta">#</span><span class="bash"> Extract the latest SDK version from the final field of the form: iphoneosX.Y</span><br>readonly SDK=$(xcodebuild -showsdks \<br>  | grep iphoneos | sort | tail -n 1 | awk &#x27;&#123;print substr($NF, 9)&#125;&#x27;<br>)<br><span class="hljs-meta">#</span><span class="bash"> Extract Xcode version.</span><br>readonly XCODE=$(xcodebuild -version | grep Xcode | cut -d &quot; &quot; -f2)<br>if [[ -z &quot;$&#123;XCODE&#125;&quot; ]]; then<br>  echo &quot;Xcode not available&quot;<br>  exit 1<br>fi<br><br>readonly OLDPATH=$&#123;PATH&#125;<br><br><span class="hljs-meta">#</span><span class="bash"> Add iPhoneOS-V6 to the list of platforms below <span class="hljs-keyword">if</span> you need armv6 support.</span><br><span class="hljs-meta">#</span><span class="bash"> Note that iPhoneOS-V6 support is not available with the iOS6 SDK.</span><br>PLATFORMS=&quot;iPhoneSimulator iPhoneSimulator64&quot;<br>PLATFORMS+=&quot; iPhoneOS-V7 iPhoneOS-V7s iPhoneOS-V7-arm64&quot;<br>readonly PLATFORMS<br>readonly SRCDIR=$(dirname $0)<br>readonly TOPDIR=$(pwd)<br>readonly BUILDDIR=&quot;$&#123;TOPDIR&#125;/iosbuild&quot;<br>readonly TARGETDIR=&quot;$&#123;TOPDIR&#125;/WebP.framework&quot;<br>readonly DEVELOPER=$(xcode-select --print-path)<br>readonly PLATFORMSROOT=&quot;$&#123;DEVELOPER&#125;/Platforms&quot;<br>readonly LIPO=$(xcrun -sdk iphoneos$&#123;SDK&#125; -find lipo)<br>LIBLIST=&#x27;&#x27;<br><br>if [[ -z &quot;$&#123;SDK&#125;&quot; ]]; then<br>  echo &quot;iOS SDK not available&quot;<br>  exit 1<br>elif [[ $&#123;SDK&#125; &lt; 6.0 ]]; then<br>  echo &quot;You need iOS SDK version 6.0 or above&quot;<br>  exit 1<br>else<br>  echo &quot;iOS SDK Version $&#123;SDK&#125;&quot;<br>fi<br><br>rm -rf $&#123;BUILDDIR&#125;<br>rm -rf $&#123;TARGETDIR&#125;<br>mkdir -p $&#123;BUILDDIR&#125;<br>mkdir -p $&#123;TARGETDIR&#125;/Headers/<br><br>if [[ ! -e $&#123;SRCDIR&#125;/configure ]]; then<br>  if ! (cd $&#123;SRCDIR&#125; &amp;&amp; sh autogen.sh); then<br>    cat &lt;&lt;EOT<br>Error creating configure script!<br>This script requires the autoconf/automake and libtool to build. MacPorts can<br>be used to obtain these:<br>http://www.macports.org/install.php<br>EOT<br>    exit 1<br>  fi<br>fi<br><br>for PLATFORM in $&#123;PLATFORMS&#125;; do<br>  ARCH2=&quot;&quot;<br>  if [[ &quot;$&#123;PLATFORM&#125;&quot; == &quot;iPhoneOS-V7-arm64&quot; ]]; then<br>    PLATFORM=&quot;iPhoneOS&quot;<br>    ARCH=&quot;aarch64&quot;<br>    ARCH2=&quot;arm64&quot;<br>  elif [[ &quot;$&#123;PLATFORM&#125;&quot; == &quot;iPhoneOS-V7s&quot; ]]; then<br>    PLATFORM=&quot;iPhoneOS&quot;<br>    ARCH=&quot;armv7s&quot;<br>  elif [[ &quot;$&#123;PLATFORM&#125;&quot; == &quot;iPhoneOS-V7&quot; ]]; then<br>    PLATFORM=&quot;iPhoneOS&quot;<br>    ARCH=&quot;armv7&quot;<br>  elif [[ &quot;$&#123;PLATFORM&#125;&quot; == &quot;iPhoneOS-V6&quot; ]]; then<br>    PLATFORM=&quot;iPhoneOS&quot;<br>    ARCH=&quot;armv6&quot;<br>  elif [[ &quot;$&#123;PLATFORM&#125;&quot; == &quot;iPhoneSimulator64&quot; ]]; then<br>    PLATFORM=&quot;iPhoneSimulator&quot;<br>    ARCH=&quot;x86_64&quot;<br>  else<br>    ARCH=&quot;i386&quot;<br>  fi<br><br>  ROOTDIR=&quot;$&#123;BUILDDIR&#125;/$&#123;PLATFORM&#125;-$&#123;SDK&#125;-$&#123;ARCH&#125;&quot;<br>  mkdir -p &quot;$&#123;ROOTDIR&#125;&quot;<br><br>  DEVROOT=&quot;$&#123;DEVELOPER&#125;/Toolchains/XcodeDefault.xctoolchain&quot;<br>  SDKROOT=&quot;$&#123;PLATFORMSROOT&#125;/&quot;<br>  SDKROOT+=&quot;$&#123;PLATFORM&#125;.platform/Developer/SDKs/$&#123;PLATFORM&#125;$&#123;SDK&#125;.sdk/&quot;<br>  CFLAGS=&quot;-arch $&#123;ARCH2:-$&#123;ARCH&#125;&#125; -pipe -isysroot $&#123;SDKROOT&#125; -O3 -DNDEBUG&quot;<br>  CFLAGS+=&quot; -miphoneos-version-min=6.0 -fembed-bitcode&quot;<br><br>  set -x<br>  export PATH=&quot;$&#123;DEVROOT&#125;/usr/bin:$&#123;OLDPATH&#125;&quot;<br><span class="hljs-meta">  $</span><span class="bash">&#123;SRCDIR&#125;/configure --host=<span class="hljs-variable">$&#123;ARCH&#125;</span>-apple-darwin --prefix=<span class="hljs-variable">$&#123;ROOTDIR&#125;</span> \</span><br>    --build=$($&#123;SRCDIR&#125;/config.guess) \<br>    --disable-shared --enable-static \<br>    --enable-libwebpmux \<br>    --enable-libwebpdemux \<br>    --enable-swap-16bit-csp \<br>    CFLAGS=&quot;$&#123;CFLAGS&#125;&quot;<br>  set +x<br><br><span class="hljs-meta">  #</span><span class="bash"> run make only <span class="hljs-keyword">in</span> the src/ directory to create libwebpdecoder.a</span><br>  cd src/<br>  make V=0<br>  make install<br><br>  MAKEPATH=$(pwd)<br>  cd $&#123;ROOTDIR&#125;/lib/<br>  ar x libwebp.a<br>  ar x libwebpmux.a<br>  ar x libwebpdemux.a<br>  ar q webp.a *.o<br><br>  LIBLIST+=&quot; $&#123;ROOTDIR&#125;/lib/webp.a&quot;<br>  cd $&#123;MAKEPATH&#125;<br><br>  make clean<br>  cd ..<br><br>  export PATH=$&#123;OLDPATH&#125;<br>done<br><br>cp -a $&#123;SRCDIR&#125;/src/webp/*.h $&#123;TARGETDIR&#125;/Headers/<br><span class="hljs-meta">$</span><span class="bash">&#123;LIPO&#125; -create <span class="hljs-variable">$&#123;LIBLIST&#125;</span> -output <span class="hljs-variable">$&#123;TARGETDIR&#125;</span>/WebP</span><br><br></code></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>iOS优化</category>
      </categories>
      <tags>
        <tag>webP</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS 控制器 代码结构规范</title>
    <url>/2017/09/01/view%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<p>一个良好的代码风格有助于提高代码的可读性,防止错误发生几率，每个公司可能都有自己的一套规范，这里推荐一种通用的 可读性较高的规范</p>
<a id="more"></a>

<p><a href="https://casatwy.com/iosying-yong-jia-gou-tan-viewceng-de-zu-zhi-he-diao-yong-fang-an.html">iOS应用架构谈 view层的组织和调用方案</a></p>
<p>为了防止控制器过于复杂，指定控制器的规范势在必行,制定一个良好的代码结构可以：</p>
<pre><code>* 1、提高业务方View层的可读性可维护性
* 2、防止业务代码对架构产生腐蚀
* 3、确保传承</code></pre>
<h1 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h1><ul>
<li>1、整体结构</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/225849-4c34758cae04a973.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240/q/100" alt="icon"></p>
<ul>
<li><p>2、细节</p>
<p>  &lt;1&gt; 、视图的创建和加载: 视图的创建可以使用懒加载的方式，视图的加载可以在ViewDidLoad中完成</p>
<p>  &lt;2&gt; 、每一个delegate都把对应的protocol名字带上，delegate方法不要到处乱写，写到一块区域里面去</p>
<p>  &lt;3&gt; 、关于private methods，正常情况下ViewController里面不应该写，这个private methods一般是用于日期换算、图片裁剪啥的这种小功能。这种小功能要么把它写成一个category，要么把他做成一个模块，哪怕这个模块只有一个函数也行。</p>
</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>相信大家各自公司里面也都有一套自己的规范，具体怎么个规范法其实也是根据各位架构师的经验而定，我这边只是建议各位在各自规范的基础上再加上这几点。</p>
]]></content>
      <categories>
        <category>iOS优化</category>
      </categories>
      <tags>
        <tag>代码规范</tag>
      </tags>
  </entry>
  <entry>
    <title>探秘NSProxy</title>
    <url>/2018/06/02/what-s-nsproxy/</url>
    <content><![CDATA[<p>之前一直知道有一个与NSObject平级的类存在,但是日常的开发中好像一直都没有用到过。那么他存在的意义究竟是什么呢？这篇文章我们一起来探秘NSProxy。</p>
<a id="more"></a>

<h3 id="先看代码"><a href="#先看代码" class="headerlink" title="先看代码"></a>先看代码</h3><p>我们先看一下<code>NSProxy</code>这个类的声明</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">NSProxy</span> &lt;<span class="hljs-title">NSObject</span>&gt; </span>&#123;<br>    Class	isa;<br>&#125;<br><br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure>

<p>这个类遵守了<code>&lt;NSObject&gt;</code>这个协议,我们来看一下这个协议究竟都做了什么呢？</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-class"><span class="hljs-keyword">@protocol</span> <span class="hljs-title">NSObject</span></span><br><br>- (<span class="hljs-built_in">BOOL</span>)isEqual:(<span class="hljs-keyword">id</span>)object;<br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">readonly</span>) <span class="hljs-built_in">NSUInteger</span> hash;<br><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">readonly</span>) Class superclass;<br>- (Class)<span class="hljs-keyword">class</span> OBJC_SWIFT_UNAVAILABLE(<span class="hljs-string">&quot;use &#x27;type(of: anObject)&#x27; instead&quot;</span>);<br>- (<span class="hljs-keyword">instancetype</span>)<span class="hljs-keyword">self</span>;<br><br>- (<span class="hljs-keyword">id</span>)performSelector:(SEL)aSelector;<br>- (<span class="hljs-keyword">id</span>)performSelector:(SEL)aSelector withObject:(<span class="hljs-keyword">id</span>)object;<br>- (<span class="hljs-keyword">id</span>)performSelector:(SEL)aSelector withObject:(<span class="hljs-keyword">id</span>)object1 withObject:(<span class="hljs-keyword">id</span>)object2;<br><br>- (<span class="hljs-built_in">BOOL</span>)isProxy;<br><br>- (<span class="hljs-built_in">BOOL</span>)isKindOfClass:(Class)aClass;<br>- (<span class="hljs-built_in">BOOL</span>)isMemberOfClass:(Class)aClass;<br>- (<span class="hljs-built_in">BOOL</span>)conformsToProtocol:(Protocol *)aProtocol;<br><br>- (<span class="hljs-built_in">BOOL</span>)respondsToSelector:(SEL)aSelector;<br><br>- (<span class="hljs-keyword">instancetype</span>)<span class="hljs-keyword">retain</span> OBJC_ARC_UNAVAILABLE;<br>- (<span class="hljs-keyword">oneway</span> <span class="hljs-keyword">void</span>)release OBJC_ARC_UNAVAILABLE;<br>- (<span class="hljs-keyword">instancetype</span>)autorelease OBJC_ARC_UNAVAILABLE;<br>- (<span class="hljs-built_in">NSUInteger</span>)retainCount OBJC_ARC_UNAVAILABLE;<br><br>- (<span class="hljs-keyword">struct</span> _NSZone *)zone OBJC_ARC_UNAVAILABLE;<br><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">readonly</span>, <span class="hljs-keyword">copy</span>) <span class="hljs-built_in">NSString</span> *description;<br><span class="hljs-keyword">@optional</span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">readonly</span>, <span class="hljs-keyword">copy</span>) <span class="hljs-built_in">NSString</span> *debugDescription;<br><br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure>

<p>这个协议主要定义了一些类的一些基本方法。</p>
<p>这样看 感觉跟NSObject没什么太大的区别。我们在进一步看看这个类中的方法。</p>
<h4 id="init方法"><a href="#init方法" class="headerlink" title="init方法"></a>init方法</h4><p>在跟NSObject做了简单对比之后发现,<code>NSProxy</code>没有init方法。我们都知道NSObject在alloc方法内申请内存空间 init方法进行初始化。 从这个角度来看的话NSProxy是没有办法被直接创建和初始化的。</p>
<h4 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h4><p>对于class NSObject而言，接收到消息后先去自身的方法列表里找匹配的selector，如果找不到，会沿着继承体系去superclass的方法列表找；如果还找不到，先后会经过<code>+resolveInstanceMethod:</code>和<code>-forwardingTargetForSelector:</code>处理，处理失败后，才会到<code>-methodSignatureForSelector:</code>/<code>-forwardInvocation:</code>进行最后的挣扎。更详细的叙述，详见NSObject的消息转发机制。</p>
<p>但对于NSProxy，接收unknown selector后，直接回调<code>-methodSignatureForSelector:/-forwardInvocation:</code>，消息转发过程比class NSObject要简单得多。</p>
<h4 id="API-注释"><a href="#API-注释" class="headerlink" title="API 注释"></a>API 注释</h4><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">//一个抽象的超类,为那些以替身的身份存在的对象或者还没存在的对象定义了一套API。</span><br>An abstract superclass defining an API <span class="hljs-keyword">for</span> objects that act as stand-ins <span class="hljs-keyword">for</span><br> other objects or <span class="hljs-keyword">for</span> objects that don’t exist yet.<br><br><span class="hljs-comment">//通常,向NSProxy发送一条消息会被转发给一个对象或者会让NSProxy去加载一个对象.NSProxy的子类可以用来实现透明的消息分发(例如NSDistantObject) 或者对创建昂贵的对象进行懒加载。</span><br><br><span class="hljs-comment">// 这里的意思大概是NSProxy的子类可以用来做消息的分发</span><br>Typically, a message to a proxy is forwarded to the real object or causes the<br> proxy to load (or transform itself into) the real object. Subclasses of <br> <span class="hljs-built_in">NSProxy</span> can be used to implement transparent distributed messaging (<span class="hljs-keyword">for</span><br>  example, <span class="hljs-built_in">NSDistantObject</span>) or <span class="hljs-keyword">for</span> lazy instantiation of objects that are <br>  expensive to create.<br><br><br><span class="hljs-comment">//NSProxy实现了作为根类的一些基本的方法,包括在NSObject协议中定义的。然而，作为一个抽象类他没有提供一个实例化方法，在接收到任何他没有实现的方法时都会抛出异常。</span><br><span class="hljs-built_in">NSProxy</span> implements the basic methods required of a root <span class="hljs-keyword">class</span>, including those<br> defined <span class="hljs-keyword">in</span> the <span class="hljs-built_in">NSObject</span> protocol. However, as an abstract <span class="hljs-keyword">class</span> it doesn’t <br> provide an initialization method, and it raises an exception upon receiving <br> any message it doesn’t respond to. <br><br><span class="hljs-comment">//因此 一个具体的子类必提供一个实例化方法或者创建方法。并且覆盖`forwardInvocation`方法和`methodSignatureForSelector`方法来处理类本身没有实现的方法。</span><br>A concrete subclass must therefore provide an initialization or creation <br>method and override the forwardInvocation: and methodSignatureForSelector: <br>methods to handle messages that it doesn’t implement itself.<br><br><span class="hljs-comment">//子类中`forwardInvocation`的实现中应该做任何需要的来处理invocation,比如通过网络转发这个invocation，或者加载一个的对象并将这个invocation转发给他。</span><br> A subclass’s implementation of forwardInvocation: should <span class="hljs-keyword">do</span> whatever is<br>  needed to process the invocation, such as forwarding the invocation over the<br>   network or loading the real object and passing it the invocation. <br> <br><span class="hljs-comment">//`methodSignatureForSelector`是用来获取给定消息的参数类型；在子类的实现中可以获取这个将要被转发的消息的参数类型。同时应该创建一个相对应的NSMethodSignature对象。</span><br>methodSignatureForSelector: is required to provide argument type information <br><span class="hljs-keyword">for</span> a given message; a subclass’s implementation should be able to determine<br> the argument types <span class="hljs-keyword">for</span> the messages it needs to forward and should construct<br>  an <span class="hljs-built_in">NSMethodSignature</span> object accordingly. See the <span class="hljs-built_in">NSDistantObject</span>, <br>  <span class="hljs-built_in">NSInvocation</span>, and <span class="hljs-built_in">NSMethodSignature</span> <span class="hljs-keyword">class</span> specifications <span class="hljs-keyword">for</span> more <br>  information.<br></code></pre></td></tr></table></figure>

<p>通过上面的这段解释,我们能大概的了解到NSProxy的作用:</p>
<p>因为NSProxy没有init方法,因此所有的操作必须是通过子类实现,而且 因为子类也同样没有init方法,那就决定了NSProxy以及子类都无法直接去相应某一个方法。因此NSProxy的子类一般是讲调用的方法转发给对应的某些对象。因此其扮演的实际上是一个分发者的角色。</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>为了对比他和NSObject的区别 我们这里创建两个类分别继承自NSObject和NSProxy.</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">ProxyObject</span> : <span class="hljs-title">NSProxy</span></span><br>- (<span class="hljs-keyword">instancetype</span>)initWithObject:(<span class="hljs-keyword">id</span>)object;<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure>

<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">NormalObject</span> : <span class="hljs-title">NSObject</span></span><br>- (<span class="hljs-keyword">instancetype</span>)initWithObject:(<span class="hljs-keyword">id</span>)object;<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure>

<p>我们在这两个类中都创建了一个对象.当当前类对象没有实现对应方法的时候,统一转发给这个对象。</p>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><ul>
<li>1、<a href="https://zhangbuhuai.com/nsproxy/">NSProxy</a></li>
<li>2、<a href="https://blog.sunnyxx.com/2014/08/24/objc-duck/">objc与鸭子对象</a></li>
<li>3、<a href="http://www.tanhao.me/code/160702.html/">使用NSProxy和NSObject设计代理类的差异</a></li>
<li>4、<a href="https://www.jianshu.com/p/a7187e014c03">用 NSProxy 实现面向切面编程</a></li>
<li>5、<a href="https://www.jianshu.com/p/8e700673202b">NSProxy——少见却神奇的类</a></li>
</ul>
]]></content>
      <categories>
        <category>iOS优化</category>
      </categories>
      <tags>
        <tag>NSProxy</tag>
      </tags>
  </entry>
  <entry>
    <title>看代码 学习Swift</title>
    <url>/2017/09/14/%E7%9C%8B%E4%BB%A3%E7%A0%81-%E5%AD%A6%E4%B9%A0Swift/</url>
    <content><![CDATA[<p>本篇文章主要是在看 其他人代码的过程中 看到的一些知识点 这里做一下总结</p>
<a id="more"></a>

<h2 id="调用对象的方法"><a href="#调用对象的方法" class="headerlink" title="调用对象的方法"></a>调用对象的方法</h2><p>这里是对Selector写了个分类,让代码看起来更简单</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">extension Selector &#123;<br>  static let endEditing &#x3D; #selector(UIView.endEditing(_:))<br>&#125;<br>    &#x2F;&#x2F; dismiss keyboard<br>    self.view.addGestureRecognizer(UITapGestureRecognizer(target: self.view, action: Selector.endEditing))<br></code></pre></td></tr></table></figure>

<h2 id="方法的参数判断"><a href="#方法的参数判断" class="headerlink" title="方法的参数判断"></a>方法的参数判断</h2><p>对于常见的一些方法为Optional的参数 判断方式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">func getLabelsInfo() -&gt; (name: String?, work: String?, salary: String?) &#123;<br>  guard let name &#x3D; nameTextField.text,<br>    let work &#x3D; workTextField.text,<br>    let salary &#x3D; salaryLabel.text<br>    else &#123;<br>      return (nil, nil, nil)<br>  &#125;<br>  <br>  if name.isEmpty || work.isEmpty || salary.isEmpty &#123;<br>    return (nil, nil, nil)<br>  &#125;<br>  <br>  return (name, work, salary)<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h2 id="对象的判空"><a href="#对象的判空" class="headerlink" title="对象的判空"></a>对象的判空</h2><p>.some 表示对象有值 .none表示对象为空</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">switch tweet &#123;<br>case .some(let tweet):<br>  showAlert(title: &quot;Love Tweet&quot;,<br>            message: tweet.info,<br>            buttonTitle: &quot;OK&quot;)<br>  <br>case .none:<br>  showAlert(title: &quot;Info miss or invalid&quot;,<br>            message: &quot;Please fill out correct personal info&quot;,<br>            buttonTitle: &quot;OK&quot;)<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h2 id="属性声明"><a href="#属性声明" class="headerlink" title="属性声明"></a>属性声明</h2><p>private 私有 类内部私有<br>fileprivate 文件内部私有 一个文件有多个类<br>public 外部可使用 类可以继承 方法可以重载<br>open   外部可使用 类不可以继承 方法不可以重载</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">fileprivate let mainStopwatch: Stopwatch &#x3D; Stopwatch()<br><br></code></pre></td></tr></table></figure>

<h3 id="代理声明"><a href="#代理声明" class="headerlink" title="代理声明"></a>代理声明</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">weak var delegate: PokemonSelectionDelegate?<br><br></code></pre></td></tr></table></figure>

<h3 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">(cell.titleLabel.text, cell.descriptionLabel.text, cell.dateLabel.text) &#x3D; (item.title, item.description, item.pubDate)<br><br></code></pre></td></tr></table></figure>

<h3 id="注册cell"><a href="#注册cell" class="headerlink" title="注册cell"></a>注册cell</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">view.register(FBMeBaseCell.self, forCellReuseIdentifier: FBMeBaseCell.identifier)<br></code></pre></td></tr></table></figure>

<h3 id="UI配置文件"><a href="#UI配置文件" class="headerlink" title="UI配置文件"></a>UI配置文件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">public struct Specs &#123;<br>  public struct Color &#123;<br>    public let tint &#x3D; UIColor(hex: 0x3b5998)<br>    public let red &#x3D; UIColor.red<br>    public let white &#x3D; UIColor.white<br>    public let black &#x3D; UIColor.black<br>    public let gray &#x3D; UIColor.lightGray<br>  &#125;<br>  <br>  public struct FontSize &#123;<br>    public let tiny: CGFloat &#x3D; 10<br>    public let small: CGFloat &#x3D; 12<br>    public let regular: CGFloat &#x3D; 14<br>    public let large: CGFloat &#x3D; 16<br>  &#125;<br>  <br>  public struct Font &#123;<br>    private static let regularName &#x3D; &quot;Helvetica Neue&quot;<br>    private static let boldName &#x3D; &quot;Helvetica Neue Bold&quot;<br>    public let tiny &#x3D; UIFont(name: regularName, size: Specs.fontSize.tiny)<br>    public let small &#x3D; UIFont(name: regularName, size: Specs.fontSize.small)<br>    public let regular &#x3D; UIFont(name: regularName, size: Specs.fontSize.regular)<br>    public let large &#x3D; UIFont(name: regularName, size: Specs.fontSize.large)<br>    public let smallBold &#x3D; UIFont(name: boldName, size: Specs.fontSize.small)<br>    public let regularBold &#x3D; UIFont(name: boldName, size: Specs.fontSize.regular)<br>    public let largeBold &#x3D; UIFont(name: boldName, size: Specs.fontSize.large)<br>  &#125;<br>  <br>  public struct ImageName &#123;<br>    public let friends &#x3D; &quot;fb_friends&quot;<br>    public let events &#x3D; &quot;fb_events&quot;<br>    public let groups &#x3D; &quot;fb_groups&quot;<br>    public let education &#x3D; &quot;fb_education&quot;<br>    public let townHall &#x3D; &quot;fb_town_hall&quot;<br>    public let instantGames &#x3D; &quot;fb_games&quot;<br>    public let settings &#x3D; &quot;fb_settings&quot;<br>    public let privacyShortcuts &#x3D; &quot;fb_privacy_shortcuts&quot;<br>    public let helpSupport &#x3D; &quot;fb_help_and_support&quot;<br>    public let placeholder &#x3D; &quot;fb_placeholder&quot;<br>  &#125;<br>  <br>  public static var color: Color &#123;<br>    return Color()<br>  &#125;<br>  <br>  public static var fontSize: FontSize &#123;<br>    return FontSize()<br>  &#125;<br>  <br>  public static var font: Font &#123;<br>    return Font()<br>  &#125;<br>  <br>  public static var imageName: ImageName &#123;<br>    return ImageName()<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h3 id="16进制颜色"><a href="#16进制颜色" class="headerlink" title="16进制颜色"></a>16进制颜色</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">convenience init(hex: Int) &#123;<br>  self.init(r: (hex &amp; 0xff0000) &gt;&gt; 16, g: (hex &amp; 0xff00) &gt;&gt; 8, b: (hex &amp; 0xff), a: 1)<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="多个判断条件叠加"><a href="#多个判断条件叠加" class="headerlink" title="多个判断条件叠加"></a>多个判断条件叠加</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">guard let index &#x3D; viewController.photoIndex, index !&#x3D; photos.count - 1 else &#123;<br>        return nil<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h3 id="常量的位置"><a href="#常量的位置" class="headerlink" title="常量的位置"></a>常量的位置</h3><p>文件中共用的常量要放到类的外面,否则可能无法在某些类方法或者对象方法中使用</p>
<h3 id="控制器代码结构"><a href="#控制器代码结构" class="headerlink" title="控制器代码结构"></a>控制器代码结构</h3><p><img src="http://og0h689k8.bkt.clouddn.com/17-9-18/45832775.jpg" alt="控制器结构"></p>
]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS 开发中常用的快捷键</title>
    <url>/2018/09/30/xcode-shortcuts/</url>
    <content><![CDATA[<p>在我们日常的开发工作中,我们会经常使用一些快捷键,其中的一些快捷键可以很大程度上提高我们开发效率,所以在此对常用的快捷键进行整理！</p>
<a id="more"></a>


<h3 id="删除一行代码"><a href="#删除一行代码" class="headerlink" title="删除一行代码"></a>删除一行代码</h3><p><code>ctrl+k</code> 删除光标之后的内容<br>如果要删除整行代码 那么需要保证光标在行首 </p>
<p><img src="c" alt="删除一行"></p>
<h3 id="将光标跳转至行首"><a href="#将光标跳转至行首" class="headerlink" title="将光标跳转至行首"></a>将光标跳转至行首</h3><p><code>ctrl+a</code><br><code>cmd+&lt;- cmd+-&gt;</code> 光标跳转至行首或者行尾</p>
<p><img src="https://ws4.sinaimg.cn/large/006tNc79ly1fvrrvlx9wag30su0e6gop.gif" alt="回到行首或者行尾"></p>
<h3 id="查看工程文件"><a href="#查看工程文件" class="headerlink" title="查看工程文件"></a>查看工程文件</h3><p><code>command+1</code></p>
<p><img src="https://ws4.sinaimg.cn/large/006tNc79ly1fvrrym88nbg30nf07ct9a.gif" alt="切换到文件目录"></p>
<h3 id="全局查找"><a href="#全局查找" class="headerlink" title="全局查找"></a>全局查找</h3><p><code>command+3</code></p>
<p><img src="https://ws1.sinaimg.cn/large/006tNc79ly1fvrrtc4a0ag308o0k80vp.gif" alt="全局搜索"></p>
<h3 id="快速跳转到类的特定行"><a href="#快速跳转到类的特定行" class="headerlink" title="快速跳转到类的特定行"></a>快速跳转到类的特定行</h3><p><code>command + L</code></p>
<p><img src="https://ws3.sinaimg.cn/large/006tNc79ly1fvrrtx9pu8g30qu0ct76v.gif" alt="跳转到某一行"></p>
<h3 id="快速查找打开类"><a href="#快速查找打开类" class="headerlink" title="快速查找打开类"></a>快速查找打开类</h3><p><code>command+ shift+ O</code></p>
<p><img src="https://ws1.sinaimg.cn/large/006tNc79ly1fvrrtkugwog30tu0fiaqy.gif" alt="跳到某各类后者某个方法"></p>
<h3 id="快速定位当前类在项目文件中的位置"><a href="#快速定位当前类在项目文件中的位置" class="headerlink" title="快速定位当前类在项目文件中的位置"></a>快速定位当前类在项目文件中的位置</h3><p><code>command + shift + J</code></p>
<p><img src="https://ws4.sinaimg.cn/large/006tNc79ly1fvrrvueioig30tu0fi76j.gif" alt="定位当前类的位置"></p>
<h3 id="类文件”-h”与“-m”之间切换"><a href="#类文件”-h”与“-m”之间切换" class="headerlink" title="类文件”.h”与“.m”之间切换"></a>类文件”.h”与“.m”之间切换</h3><p><code>control+command+↑/control+command+↓</code></p>
<p><img src="https://ws4.sinaimg.cn/large/006tNc79ly1fvrrwrq14cg30tu0figv3.gif" alt=".h和.m之间的切换"></p>
<h3 id="清除工程"><a href="#清除工程" class="headerlink" title="清除工程"></a>清除工程</h3><p><code>Command + Shift + K</code></p>
<p><img src="https://ws3.sinaimg.cn/large/006tNc79ly1fvrrs29nizg30tu0fiqae.gif" alt="cleanproject"></p>
<h3 id="当前类-方法-变量查找"><a href="#当前类-方法-变量查找" class="headerlink" title="当前类 方法/变量查找"></a>当前类 方法/变量查找</h3><p><code>Control+6（键入方法/变量名+Enter跳转）</code></p>
<p><img src="https://ws2.sinaimg.cn/large/006tNc79ly1fvrrwf1gxgg30tu0fi7bf.gif" alt="方法查找"></p>
<h3 id="撤销-反撤销："><a href="#撤销-反撤销：" class="headerlink" title="撤销/反撤销："></a>撤销/反撤销：</h3><p><code>command+z /command +shift +z</code></p>
<p><img src="https://ws3.sinaimg.cn/large/006tNc79ly1fvrrw3xvueg30su0e6aht.gif" alt="撤销和反撤销"></p>
<h2 id="光标操作"><a href="#光标操作" class="headerlink" title="光标操作"></a>光标操作</h2><h3 id="向右一个字符（forward）"><a href="#向右一个字符（forward）" class="headerlink" title="向右一个字符（forward）"></a>向右一个字符（forward）</h3><p><code>control+F</code></p>
<h3 id="向左一个字符（backward）"><a href="#向左一个字符（backward）" class="headerlink" title="向左一个字符（backward）"></a>向左一个字符（backward）</h3><p><code>control+B</code></p>
<p><img src="https://ws1.sinaimg.cn/large/006tNc79ly1fvrsfyof3dg30i406ggma.gif" alt="左边字符"></p>
<h3 id="前一行（previous）"><a href="#前一行（previous）" class="headerlink" title="前一行（previous）"></a>前一行（previous）</h3><p><code>control+P</code></p>
<h3 id="后一行（next）"><a href="#后一行（next）" class="headerlink" title="后一行（next）"></a>后一行（next）</h3><p><code>control+N</code></p>
<p><img src="https://ws3.sinaimg.cn/large/006tNc79ly1fvrrxd231zg30su0e6gpo.gif" alt="上下切换一行代码"></p>
<h3 id="去行首"><a href="#去行首" class="headerlink" title="去行首"></a>去行首</h3><p><code>control+A</code></p>
<p><img src="https://ws3.sinaimg.cn/large/006tNc79ly1fvrrsvsv4lg30h505kt9e.gif" alt="行首或者行尾"></p>
<h3 id="到行尾（end）"><a href="#到行尾（end）" class="headerlink" title="到行尾（end）"></a>到行尾（end）</h3><p><code>control+E</code></p>
<p><img src="https://ws2.sinaimg.cn/large/006tNc79ly1fvrrvc847pg30su0e6gpb.gif" alt="回到行尾"></p>
<h3 id="删除光标右侧字符（delete）"><a href="#删除光标右侧字符（delete）" class="headerlink" title="删除光标右侧字符（delete）"></a>删除光标右侧字符（delete）</h3><p><code>control+D</code></p>
<p><img src="https://ws3.sinaimg.cn/large/006tNc79ly1fvrrsidgh6g30su0e6jvx.gif" alt="deleteright"></p>
<h2 id="整体位移代码"><a href="#整体位移代码" class="headerlink" title="整体位移代码:"></a>整体位移代码:</h2><h3 id="向左位移"><a href="#向左位移" class="headerlink" title="向左位移"></a>向左位移</h3><p><code>选中的代码 + command+[ </code></p>
<h3 id="向右位移"><a href="#向右位移" class="headerlink" title="向右位移"></a>向右位移</h3><p><code>选中的代码 + command+]</code></p>
<p><img src="https://ws2.sinaimg.cn/large/006tNc79ly1fvrruvvuuzg30su0e60x2.gif" alt="Xcode格式规范 缩进修改"></p>
<h3 id="向上位移"><a href="#向上位移" class="headerlink" title="向上位移"></a>向上位移</h3><p><code>选中的代码 + command+option+[ </code></p>
<h3 id="向下位移"><a href="#向下位移" class="headerlink" title="向下位移"></a>向下位移</h3><p><code>选中的代码 + command+option+]</code></p>
<p><img src="https://ws1.sinaimg.cn/large/006tNc79ly1fvrrujmyn7g30su0e6wik.gif" alt="上一行或者下一行"></p>
<h2 id="xcode-整体"><a href="#xcode-整体" class="headerlink" title="xcode 整体"></a>xcode 整体</h2><h3 id="回到上一个-下一个打开的页面"><a href="#回到上一个-下一个打开的页面" class="headerlink" title="回到上一个/下一个打开的页面"></a>回到上一个/下一个打开的页面</h3><p><code>control + command + ← / control + command + →</code></p>
<p><img src="https://ws3.sinaimg.cn/large/006tNc79ly1fvrru6e5f3g30su0e67eu.gif" alt="返回到上一个页面"></p>
<h3 id="新建文件"><a href="#新建文件" class="headerlink" title="新建文件"></a>新建文件</h3><p><code>command + N</code></p>
<p><img src="https://ws3.sinaimg.cn/large/006tNc79ly1fvrsg8i4j6g30tc0f8wjg.gif" alt="新建文件"></p>
<h3 id="创建新工程"><a href="#创建新工程" class="headerlink" title="创建新工程:"></a>创建新工程:</h3><p><code>command + shift + N</code></p>
<p><img src="https://ws1.sinaimg.cn/large/006tNc79ly1fvrsgj63h3g30tc0f8n50.gif" alt="新建项目"></p>
]]></content>
      <categories>
        <category>iOS基础</category>
      </categories>
      <tags>
        <tag>快捷键</tag>
      </tags>
  </entry>
  <entry>
    <title>[转]Swift:利用Enum灵活映射多重类型Data model</title>
    <url>/2017/09/10/%E8%BD%AC-Swift-%E5%88%A9%E7%94%A8Enum%E7%81%B5%E6%B4%BB%E6%98%A0%E5%B0%84%E5%A4%9A%E9%87%8D%E7%B1%BB%E5%9E%8BData-model/</url>
    <content><![CDATA[<p>利用Enum灵活映射多重类型Data model</p>
<a id="more"></a>

<p><a href="http://www.jianshu.com/p/87255dc14331">中文译文</a><br><a href="https://medium.com/swift-programming/swift-typecasing-3cd156c323e#.rfhar1edp">原文</a></p>
<h2 id="一个字段中返回了多种相似的类型"><a href="#一个字段中返回了多种相似的类型" class="headerlink" title="一个字段中返回了多种相似的类型"></a>一个字段中返回了多种相似的类型</h2><p>先来看下项目中我遇到的一个情况，服务端在人物中返回了一组数据。这些人物有几个相同的属性，但是又有各自不同的角色各有的属性。json数据如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&quot;characters&quot; : [<br>    &#123;<br>        type: &quot;hero&quot;,<br>        name: &quot;Jake&quot;,<br>        power: &quot;Shapeshift&quot;<br>    &#125;,<br>    &#123;<br>        type: &quot;hero&quot;,<br>        name: &quot;Finn&quot;,<br>        power: &quot;Grass sword&quot;<br>    &#125;,<br>    &#123;<br>        type: &quot;princess&quot;,<br>        name: &quot;Lumpy Space Princess&quot;,<br>        kingdom: &quot;Lumpy Space&quot;<br>    &#125;,<br>    &#123;<br>        type: &quot;civilian&quot;,<br>        name: &quot;BMO&quot;<br>    &#125;,<br>    &#123;<br>        type: &quot;princess&quot;,<br>        name: &quot;Princess Bubblegum&quot;,<br>        kingdom: &quot;Candy&quot;<br>    &#125;<br>]<br><br></code></pre></td></tr></table></figure>
<p>那么我们可以怎么解析这样的数据呢？</p>
<h2 id="利用类和继承"><a href="#利用类和继承" class="headerlink" title="利用类和继承"></a>利用类和继承</h2><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">class Character &#123;<br>    type: String<br>    name: String<br>&#125;<br>class Hero : Character &#123;<br>    power: String<br>&#125;<br>class Princess : Character &#123;<br>    kingdom: String<br>&#125;<br>class Civilian : Character &#123; <br>&#125;<br>...<br>struct Model &#123;<br>    characters: [Character]<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>这其实就是项目中我原来使用的方案。但是很快就会觉得有点苦逼，因为使用的时候要不断的类型判断，然后类型转换后才能访问到某个具体类型的属性：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&#x2F;&#x2F; Type checking<br>if model.characters[indexPath.row] is Hero &#123;<br>    print(model.characters[indexPath.row].name)<br>&#125;<br>&#x2F;&#x2F; Type checking and Typecasting<br>if let hero &#x3D; model.characters[indexPath.row] as? Hero &#123;<br>    print(hero.power)<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="利用结构体和协议"><a href="#利用结构体和协议" class="headerlink" title="利用结构体和协议"></a>利用结构体和协议</h2><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">protocol Character &#123;<br>    var type: String &#123; get set &#125;<br>    var name: String &#123; get set &#125;<br>&#125;<br>struct Hero : Character &#123;<br>    power: String<br>&#125;<br>struct Princess : Character &#123;<br>    kingdom: String<br>&#125;<br>struct Civilian : Character &#123; <br>&#125;<br>...<br>struct Model &#123;<br>    characters: [Character]<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>这里我们使用了结构体，解析的性能会好一些。但是看起来和前面类的方案差不多。我们并没有利用上protocol的特点，使用的时候我们还是要进行类型判断：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&#x2F;&#x2F; Type checking<br>if model.characters[indexPath.row] is Hero &#123;<br>    print(model.characters[indexPath.row].name)<br>&#125;<br>&#x2F;&#x2F; Type checking and Typecasting<br>if let hero &#x3D; model.characters[indexPath.row] as? Hero &#123;<br>    print(hero.power)<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h2 id="类型转换的潜在问题"><a href="#类型转换的潜在问题" class="headerlink" title="类型转换的潜在问题"></a>类型转换的潜在问题</h2><p>上面的这种类型转换可能引入潜在的问题。如果后台此时增加了一个类型对代码会产生什么样的影响呢？可能想到这种情况提前做了处理，也可能没有处理导致崩溃。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&#123;<br>    type: &quot;king&quot;<br>    name: &quot;Ice King&quot;<br>    power: &quot;Frost&quot;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>当我们在写代码的时候，应该考虑到这样的场景，当有新类型出现时能不能友好的提示哪里需要处理呢？毕竟swift的设计目标之一就是更安全的语言。</p>
<h2 id="另外一种可能：Enum"><a href="#另外一种可能：Enum" class="headerlink" title="另外一种可能：Enum"></a>另外一种可能：Enum</h2><p>我们如何创建一个包含不同类型数据的数组，然后访问他们的属性的时候不用类型转换呢？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">enum Character &#123;<br>    case hero, princess, civilian<br>&#125;<br></code></pre></td></tr></table></figure>

<p>当switch一个枚举时，每种case都需要被照顾到，所以使用enum可以很好的避免一些潜在的问题。但是如果只是这样依然不够好，我们可以更进一步：</p>
<h2 id="Associated-values：关联值"><a href="#Associated-values：关联值" class="headerlink" title="Associated values：关联值"></a>Associated values：关联值</h2><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">enum Character &#123;<br>    case hero(Hero) <br>    case princess(Princess)<br>    case civilian(Civilian)<br>&#125;<br>...<br>switch characters[indexPath.row] &#123;<br>    case .hero(let hero):<br>        print(hero.power)<br>    case .princess(let princess):<br>        print(princess.kingdom)<br>    case .civilian(let civilian):<br>        print(civilian.name)<br>&#125;<br><br><br></code></pre></td></tr></table></figure>

<p>现在使用的时候不再需要类型转换了。并且如果增加一种新类型，只要在enum中增加一个case，你就不会遗漏需要再修改何处的代码，消除了潜在的问题。</p>
<h2 id="Raw-Value"><a href="#Raw-Value" class="headerlink" title="Raw Value"></a>Raw Value</h2><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">enum Character : String &#123; &#x2F;&#x2F; Error: ❌<br>    case hero(Hero) <br>    case princess(Princess)<br>    case civilian(Civilian)<br>&#125;<br></code></pre></td></tr></table></figure>

<p>你可能会发现这个枚举没有实现RawRepresentable协议，这是因为关联值类型的枚举不能同时遵从RawRepresentable协议，他们是互斥的。</p>
<h2 id="如何初始化"><a href="#如何初始化" class="headerlink" title="如何初始化"></a>如何初始化</h2><p>如果实现了RawRepresentable协议，就会自带一个利用raw value 初始化的方法。但是我们现在没有实现这个协议，所以我们需要自定义一个初始化方法。<br>先定义一个内部使用的枚举表示类型：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">enum Character &#123;<br><br>    private enum Type : String &#123;<br>        case hero, princess, civilian<br>        static let key &#x3D; &quot;type&quot;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="Failable-initializers"><a href="#Failable-initializers" class="headerlink" title="Failable initializers"></a>Failable initializers</h2><p>因为传回来的json可能出现映射失败的情况，比如增加的一个新类型，所以这里的初始化方法是可失败的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&#x2F;&#x2F; enum Character<br>init?(json: [String : AnyObject]) &#123;<br>    guard let <br>        string &#x3D; json[Type.key] as? String,<br>        type &#x3D; Type(rawValue: string)<br>        else &#123; return nil &#125;<br>    switch type &#123;<br>        case .hero:<br>            guard let hero &#x3D; Hero(json: json) <br>            else &#123; return nil &#125;<br>            self &#x3D; .hero(hero)<br>        case .princess:<br>            guard let princess &#x3D; Princess(json: json) <br>            else &#123; return nil &#125;<br>            self &#x3D; .princess(princess)      <br>        case .civilian:<br>            guard let civilian &#x3D; Civilian(json: json) <br>            else &#123; return nil &#125;<br>            self &#x3D; .civilian(civilian)<br>    &#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure>

<h2 id="使用枚举解析json"><a href="#使用枚举解析json" class="headerlink" title="使用枚举解析json"></a>使用枚举解析json</h2><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&#x2F;&#x2F; Model initialisation<br>if let characters &#x3D; json[&quot;characters&quot;] as? [[String : AnyObject]] &#123;<br>    self.characters &#x3D; characters.flatMap &#123; Character(json: $0) &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>注意这里使用了flatMap。当一条数据的type不在我们已经定义的范围内时，Character(json: [String : AnyObject])返回一个nil。我们当然希望过滤掉这些无法处理的数据。所以使用flatMap，flatMap过程中会抛弃为nil的值，所以这里使用了flapMap。</p>
<h2 id="完成"><a href="#完成" class="headerlink" title="完成"></a>完成</h2><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">switch model.characters[indexPath.row] &#123;<br>    case .hero(let hero):<br>        print(hero.power)<br><br>    case .princess(let princess):<br>        print(princess.kingdom)<br><br>    case .civilian(let civilian):<br>        print(civilian.name)<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>现在可以像最前面展示的那样使用了。<br>可以告别那些将数组类型声明为 Any, AnyObject或者泛型，继承组合的model，使用时再转换类型的日子了。</p>
<h2 id="One-More-Thing-模式匹配"><a href="#One-More-Thing-模式匹配" class="headerlink" title="One More Thing: 模式匹配"></a>One More Thing: 模式匹配</h2><p>如果只处理枚举中的一种类型，我们会这么写：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">func printPower(character: Character) &#123;<br>    switch character &#123;<br>        case .hero(let hero):<br>            print(hero.power)<br>        default: <br>            break<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>然而我们可以利用swift提供的模式匹配，用这种更优雅的写法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">func printPower(character: Character) &#123;<br>    if case .hero(let hero) &#x3D; character &#123;<br>        print(hero.power)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Swift</category>
      </categories>
  </entry>
  <entry>
    <title>SDWebImage - 缓存管理</title>
    <url>/2016/01/27/SDWebImage-4/</url>
    <content><![CDATA[<p>这篇文章主要是介绍了一下SDWebImage提供的一写关于缓存的其他功能，也提供了清除缓存的方法，这里粗略的介绍一下，希望对大家在以后的文件操作中有一定的帮助。</p>
<a id="more"></a>


<h4 id="磁盘空间的初始化方法"><a href="#磁盘空间的初始化方法" class="headerlink" title="磁盘空间的初始化方法"></a>磁盘空间的初始化方法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">- (id)initWithNamespace:(NSString *)ns &#123;<br>    &#x2F;&#x2F; iOS使用的是沙盒机制，此处makeDiskCachePath就是获取Cache目录，并<br>    	在Cache目录下创建default目录<br>   &#x2F;&#x2F; 比如我的mac上就显示&#x2F;Users&#x2F;poloby&#x2F;Library&#x2F;Developer&#x2F;<br>   CoreSimulator&#x2F;Devices&#x2F;4404872F-4DDD-4AEA-AAD3-71BA1931D4C1&#x2F;<br>   data&#x2F;Containers&#x2F;Data&#x2F;Application&#x2F;9C7E5D14-FBF0-41F1-A533-<br>   E8ACC59FCBAC&#x2F;Library&#x2F;Caches&#x2F;default<br>   &#x2F;&#x2F; 后面详解<br>    NSString *path &#x3D; [self makeDiskCachePath:ns];<br>   &#x2F;&#x2F; 最终的初始化，后面详解<br>return [self initWithNamespace:ns diskCacheDirectory:path];<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>makeDiskCachePath</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">-(NSString *)makeDiskCachePath:(NSString*)fullNamespace&#123;<br>    &#x2F;&#x2F; 获取当前用户应用下的Caches目录<br>    &#x2F;&#x2F; 返回了一个包含用户Caches目录作为第一元素的数组，所以底下用的是<br>    	paths[0]<br>    &#x2F;&#x2F; 即&#x2F;Users&#x2F;poloby&#x2F;Library&#x2F;Developer&#x2F;CoreSimulator&#x2F;Devices&#x2F;<br>    4404872F-4DDD-4AEA-AAD3-71BA1931D4C1&#x2F;data&#x2F;Containers&#x2F;Data&#x2F;<br>    Application&#x2F;9C7E5D14-FBF0-41F1-A533-E8ACC59FCBAC&#x2F;Library&#x2F;<br>    Caches&#x2F;<br>    <br>    NSArray *paths &#x3D; <br>    NSSearchPathForDirectoriesInDomains(NSCachesDirectory, <br>    								NSUserDomainMask, YES);<br>   &#x2F;&#x2F; 在Caches目录下构建一个fullNamespace目录，此处默认是default目录<br>    return [paths[0] <br>    		stringByAppendingPathComponent:fullNamespace];<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>initWithNamespace:diskCacheDirectory:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">(id)initWithNamespace:(NSString *)ns diskCacheDirectory:<br>									(NSString *)directory &#123;<br>									<br>    if ((self &#x3D; [super init])) &#123;<br>        &#x2F;&#x2F; 再给Caches&#x2F;default&#x2F;后面加上fullNamspace<br>        &#x2F;&#x2F; 最终可能获得的diskCachePath可能为<br>        NSString *fullNamespace &#x3D; <br>        [@&quot;com.hackemist.SDWebImageCache.&quot;<br>        							 stringByAppendingString:ns];<br><br>        &#x2F;&#x2F; 初始化kPNGSignatureData为PNG前8字节的标志：&#123;0x89, 0x50,<br>        		 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A&#125;<br>        &#x2F;&#x2F; 用于ImageDataHasPNGPreffix这个C函数中，判断该data是不是PNG<br>        	格式<br>        	<br>        kPNGSignatureData &#x3D; [NSData <br>        			dataWithBytes:kPNGSignatureBytes length:8];<br><br>        &#x2F;&#x2F; 创建名为com.hackemist.SDWebImageCache的IO的串行队列<br>        <br>        _ioQueue &#x3D;<br>         dispatch_queue_create(&quot;com.hackemist.SDWebImageCache&quot;, <br>         							DISPATCH_QUEUE_SERIAL);<br><br>        &#x2F;&#x2F; cache存储的最长时间为60 * 60 * 24 * 7，即一个星期<br>        _maxCacheAge &#x3D; kDefaultCacheMaxCacheAge;<br><br>        &#x2F;&#x2F; 注意此处不是直接使用[[NSCache alloc] init]进行初始化的，而<br>        	是使用了一个AutoPurgeCache<br>        &#x2F;&#x2F; AutoPurgeCache和NSCache不同之处在于，如果AutoPurgeCache收<br>        	到一个内存警告，就会自动释放内存，调用NSCache的<br>        	removeAllObjects<br>        	<br>        _memCache &#x3D; [[AutoPurgeCache alloc] init];<br>        _memCache.name &#x3D; fullNamespace;<br><br>        &#x2F;&#x2F; 初始化disk cache，一般情况下directory，除非你把Caches删除了<br>        if (directory !&#x3D; nil) &#123;<br>            &#x2F;&#x2F; 最终结果是&#x2F;Users&#x2F;poloby&#x2F;Library&#x2F;Developer&#x2F;<br>            CoreSimulator&#x2F;Devices&#x2F;4404872F-4DDD-4AEA-<br>            AAD3-71BA1931D4C1&#x2F;data&#x2F;Containers&#x2F;Data&#x2F;Application&#x2F;<br>            9C7E5D14-FBF0-41F1-A533-E8ACC59FCBAC&#x2F;Library&#x2F;Caches&#x2F;<br>            default&#x2F;com.hackemist.SDWebImageCache.default<br>            <br>            _diskCachePath &#x3D; [directory <br>            	stringByAppendingPathComponent:fullNamespace];<br>        &#125; else &#123;<br>            &#x2F;&#x2F; 如果没有找到Caches目录，或者新建default目录失败。就重新<br>            	使用makeCachePath新建一个缓存目录<br>            NSString *path &#x3D; [self makeDiskCachePath:ns];<br>            _diskCachePath &#x3D; path;<br>        &#125;<br><br>        &#x2F;&#x2F; 默认需要解压缩图片<br>        _shouldDecompressImages &#x3D; YES;<br>       &#x2F;&#x2F; 新建一个NSFileManager也是放在ioQueue中的<br>        dispatch_sync(_ioQueue, ^&#123;<br>            _fileManager &#x3D; [NSFileManager new];<br>        &#125;);<br><br>	#if TARGET_OS_IPHONE<br>        &#x2F;&#x2F; 订阅了app可能发生的时间<br>        &#x2F;&#x2F; 出现内存警告<br>        (UIApplicationDidReceiveMemoryWarningNotification)，调用<br>        	clearMemory<br>        	<br>        [[NSNotificationCenter defaultCenter] addObserver:self<br>                           selector:@selector(clearMemory)                                                   		name:UIApplicationDidReceiveMemoryWarningNotification                           <br>                           object:nil];<br>                           <br>        &#x2F;&#x2F; 程序终止(UIApplicationWillTerminateNotification)，调用<br>        	cleanDisk<br>        	<br>        [[NSNotificationCenter defaultCenter] addObserver:self<br>								selector:@selector(cleanDisk)<br>                name:UIApplicationWillTerminateNotification<br>                               object:nil];<br>        &#x2F;&#x2F; 程序进入后台运行<br>        (UIApplicationDidEnterBackgroundNotification)，调用<br>        backgroundCleanDisk<br>        <br>        &#x2F;&#x2F; backgroundCleanDisk就不赘述了，其实现了在后台注册了<br>        	cleanDiskWithCompletionBlock函数来处理后台的磁盘缓存<br>        	<br>        [[NSNotificationCenter defaultCenter] addObserver:self<br>						selector:@selector(backgroundCleanDisk)<br>				name:UIApplicationDidEnterBackgroundNotification<br>                       object:nil];<br>	#endif<br>    &#125;<br><br>    return self;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h4 id="计算缓存文件的大小"><a href="#计算缓存文件的大小" class="headerlink" title="计算缓存文件的大小"></a>计算缓存文件的大小</h4><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">- (void)calculateSizeWithCompletionBlock:(SDWebImageCalculateSizeBlock)completionBlock &#123;<br>    NSURL *diskCacheURL &#x3D; [NSURL fileURLWithPath:<br>    									self.diskCachePath<br>     									isDirectory:YES];<br><br>    dispatch_async(self.ioQueue, ^&#123;<br>        NSUInteger fileCount &#x3D; 0;<br>        NSUInteger totalSize &#x3D; 0;<br>        <br>   NSDirectoryEnumerator *fileEnumerator &#x3D; <br>        			[_fileManager enumeratorAtURL:diskCacheURL<br>					includingPropertiesForKeys:@[NSFileSize]<br>					options: <br>					 NSDirectoryEnumerationSkipsHiddenFiles<br>					 errorHandler:NULL];<br><br>   for (NSURL *fileURL in fileEnumerator) &#123;<br>       NSNumber *fileSize;<br>       &#x2F;&#x2F;获取单个文件大小的方法<br>       [fileURL getResourceValue:&amp;fileSize <br>       						forKey:NSURLFileSizeKey error:NULL];<br>       totalSize +&#x3D; [fileSize unsignedIntegerValue];<br>       &#x2F;&#x2F;文件个数累加<br>       fileCount +&#x3D; 1;<br>   &#125;<br><br>   if (completionBlock) &#123;<br>       dispatch_async(dispatch_get_main_queue(), ^&#123;<br>          completionBlock(fileCount, totalSize);<br>       &#125;);<br>    &#125;<br>  &#125;);<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h4 id="获取磁盘文件个数"><a href="#获取磁盘文件个数" class="headerlink" title="获取磁盘文件个数"></a>获取磁盘文件个数</h4><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">- (NSUInteger)getDiskCount &#123;<br>    __block NSUInteger count &#x3D; 0;<br>    dispatch_sync(self.ioQueue, ^&#123;<br>        NSDirectoryEnumerator *fileEnumerator &#x3D; [_fileManager enumeratorAtPath:self.diskCachePath];<br>        count &#x3D; [[fileEnumerator allObjects] count];<br>    &#125;);<br>    return count;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h4 id="SDWebImage定期清理缓存"><a href="#SDWebImage定期清理缓存" class="headerlink" title="SDWebImage定期清理缓存"></a>SDWebImage定期清理缓存</h4><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">- (void)cleanDiskWithCompletionBlock:<br>					(SDWebImageNoParamsBlock)completionBlock &#123;<br>  dispatch_async(self.ioQueue, ^&#123;<br>      &#x2F;&#x2F; 这两个变量主要是为了下面生成NSDirectoryEnumerator准备的<br>      &#x2F;&#x2F; 一个是记录遍历的文件目录，一个是记录遍历需要预先获取文件的哪些属性<br>      <br>        NSURL *diskCacheURL &#x3D; [NSURL fileURLWithPath:<br>        									self.diskCachePath<br>        					 				isDirectory:YES];<br>        					 				<br>        NSArray *resourceKeys &#x3D; @[NSURLIsDirectoryKey, <br>        						NSURLContentModificationDateKey,<br>        						 NSURLTotalFileAllocatedSizeKey];<br><br>		<br>        &#x2F;&#x2F; 递归地遍历diskCachePath这个文件夹中的所有目录，此处不是直接使<br>        	用diskCachePath，而是使用其生成的NSURL<br>        &#x2F;&#x2F; 此处使用includingPropertiesForKeys:resourceKeys，这样每<br>        	个file的resourceKeys对应的属性也会在遍历时预先获取到<br>        NSDirectoryEnumerator *fileEnumerator &#x3D;<br>        			 [_fileManager enumeratorAtURL:diskCacheURL<br>        			    includingPropertiesForKeys:resourceKeys<br>        		options:NSDirectoryEnumerationSkipsHiddenFiles<br>				errorHandler:NULL];<br><br><br>        &#x2F;&#x2F; 获取文件的过期时间，SDWebImage中默认是一个星期<br>        &#x2F;&#x2F; 不过这里虽然称*expirationDate为过期时间，但是实质上并不是这<br>        	样。<br>        &#x2F;&#x2F; 其实是这样的，比如在2015&#x2F;12&#x2F;12&#x2F;00:00:00最后一次修改文件，对<br>        	应的过期时间应该是<br>        &#x2F;&#x2F; 2015&#x2F;12&#x2F;19&#x2F;00:00:00，不过现在时间是2015&#x2F;12&#x2F;27&#x2F;00:00:00，<br>        	我先将当前时间减去1个星期，得到<br>        &#x2F;&#x2F; 2015&#x2F;12&#x2F;20&#x2F;00:00:00，这个时间才是我们函数中的<br>        	expirationDate。<br>        &#x2F;&#x2F; 用这个expirationDate和最后一次修改时间modificationDate比较<br>        	看谁更晚就行。<br>        	<br>        NSDate *expirationDate &#x3D; [NSDate<br>        		dateWithTimeIntervalSinceNow:-self.maxCacheAge];<br>        <br>        NSMutableDictionary *cacheFiles &#x3D; <br>        						[NSMutableDictionary dictionary];<br>        						<br>        NSUInteger currentCacheSize &#x3D; 0;<br><br>		&#x2F;&#x2F; 在缓存的目录开始遍历文件.  此次遍历有两个目的:<br>        &#x2F;&#x2F;<br>        &#x2F;&#x2F;  1. 移除过期的文件<br>        &#x2F;&#x2F;  2. 同时存储每个文件的属性（比如该file是否是文件夹、该file所<br>        		需磁盘大小，修改时间）<br>        <br>        NSMutableArray *urlsToDelete &#x3D;<br>        						 [[NSMutableArray alloc] init];<br>        						 <br>        for (NSURL *fileURL in fileEnumerator) &#123;<br>            NSDictionary *resourceValues &#x3D; <br>            	[fileURL resourceValuesForKeys:resourceKeys <br>            							  error:NULL];<br><br>            &#x2F;&#x2F; Skip directories.<br>            if ([resourceValues[NSURLIsDirectoryKey] boolValue]) <br>            &#123;<br>                continue;<br>            &#125;<br><br>            &#x2F;&#x2F; 移除过期文件<br>            &#x2F;&#x2F; 这里判断过期的方式：对比文件的最后一次修改日期和<br>            	expirationDate谁更晚，如果expirationDate更晚，就认为<br>            	该文件已经过期，具体解释见上面<br>            NSDate *modificationDate &#x3D; <br>            	resourceValues[NSURLContentModificationDateKey];<br>            	<br>            if ([[modificationDate laterDate:expirationDate]<br>            				 isEqualToDate:expirationDate]) &#123;<br>                [urlsToDelete addObject:fileURL];<br>                continue;<br>            &#125;<br><br>          	&#x2F;&#x2F; 计算当前已经使用的cache大小，<br>            &#x2F;&#x2F; 并将对应file的属性存到cacheFiles中<br>            NSNumber *totalAllocatedSize &#x3D;<br>            	 resourceValues[NSURLTotalFileAllocatedSizeKey];<br>            <br>            currentCacheSize +&#x3D; [totalAllocatedSize<br>             							unsignedIntegerValue];<br>            [cacheFiles setObject:resourceValues <br>            									forKey:fileURL];<br>        &#125;<br>        <br>        for (NSURL *fileURL in urlsToDelete) &#123;<br>            [_fileManager removeItemAtURL:fileURL error:nil];<br>        &#125;<br>	    &#x2F;&#x2F; 如果我们当前cache的大小已经超过了允许配置的缓存大小，<br>	    	那就删除已经缓存的文件。<br>        &#x2F;&#x2F; 删除策略就是，首先删除修改时间更早的缓存文件<br>         <br>        if (self.maxCacheSize &gt; 0 <br>        	&amp;&amp; currentCacheSize &gt; self.maxCacheSize)<br>        &#123;<br>            &#x2F;&#x2F; 直接将当前cache大小降到允许最大的cache大小的一般<br>            const NSUInteger desiredCacheSize &#x3D; <br>            							self.maxCacheSize &#x2F; 2;<br><br>			&#x2F;&#x2F; 根据文件修改时间来给所有缓存文件排序，按照修改时间越早越在<br>				前的规则排序            		<br>            NSArray *sortedFiles &#x3D; [cacheFiles <br>            	keysSortedByValueWithOptions:NSSortConcurrent<br>				usingComparator:^NSComparisonResult(id obj1, id <br>				obj2) &#123;<br>				 return [obj1[NSURLContentModificationDateKey]<br>				  		compare:<br>				 		obj2[NSURLContentModificationDateKey]];<br>             &#125;];<br><br>            &#x2F;&#x2F; 每次删除file后，就计算此时的cache的大小<br>            &#x2F;&#x2F; 如果此时的cache大小已经降到期望的大小了，就停止删除文件了<br>            for (NSURL *fileURL in sortedFiles) &#123;<br>                if ([_fileManager <br>               		 removeItemAtURL:<br>                	fileURL error:nil])<br>                &#123;<br>                    NSDictionary *resourceValues &#x3D; <br>                    						cacheFiles[fileURL];<br>                    &#x2F;&#x2F; 根据resourceValues获取该文件所需磁盘空间大小<br>                    NSNumber *totalAllocatedSize &#x3D; <br>                resourceValues[NSURLTotalFileAllocatedSizeKey];<br>                	&#x2F;&#x2F; 计算当前cache大小<br>                    currentCacheSize -&#x3D; [totalAllocatedSize <br>                    					  unsignedIntegerValue];<br><br>                    if (currentCacheSize &lt; desiredCacheSize) &#123;<br>                        break;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        if (completionBlock) &#123;<br>            dispatch_async(dispatch_get_main_queue(), ^&#123;<br>                completionBlock();<br>            &#125;);<br>        &#125;<br>    &#125;);<br>&#125;<br><br><br></code></pre></td></tr></table></figure>
<p>总结一下：</p>
<p>清理缓存的时机：</p>
<p>清除磁盘缓存<br>UIApplicationWillTerminateNotification<br>UIApplicationDidEnterBackgroundNotification</p>
<p>清除Cache缓存</p>
<p>UIApplicationDidReceiveMemoryWarningNotification<br>当收到这三个通知的时候回到用对应的清理缓存的方法</p>
<p>清理过程：</p>
<p>1、按照用户设置的maxCacheAge图片被缓存的最长时间</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&#x2F;**<br> * The maximum length of time to keep an image in the cache, in seconds<br> *&#x2F;<br>@property (assign, nonatomic) NSInteger maxCacheAge;<br></code></pre></td></tr></table></figure>
<p>将所有modificationDate时间晚于maxCacheAge时间的文件删除</p>
<p>2、如果经过第一步的删除之后，图片的缓存仍然大于maxCacheSize,那么需要进一步的删除图片文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&#x2F;**<br> * The maximum size of the cache, in bytes.<br> *&#x2F;<br>@property (assign, nonatomic) NSUInteger maxCacheSize;<br><br></code></pre></td></tr></table></figure>
<p>这一步的删除，最终的目的是将最终的缓存大小降低到maxCacheSize的一半，方式也是根据最后的修改时间先将所有的文件排序，然后依次删除，每一次删除都要确认是否当前的缓存大小是否小鱼maxCacheSize的一半</p>
<p>3、清理Cache缓存</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">- (void)clearMemory &#123;<br>    [self.memCache removeAllObjects];<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h4 id="手动清理磁盘图片缓存"><a href="#手动清理磁盘图片缓存" class="headerlink" title="手动清理磁盘图片缓存"></a>手动清理磁盘图片缓存</h4><p>直接清除，磁盘缓存目录下的所有文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">- (void)clearDiskOnCompletion:<br>					 (SDWebImageNoParamsBlock)completion<br>&#123;<br>    dispatch_async(self.ioQueue, ^&#123;<br>    	 &#x2F;&#x2F; 先将存储在diskCachePath中缓存全部移除，然后新建一个空的<br>    	 	diskCachePath<br>        [_fileManager removeItemAtPath:self.diskCachePath <br>        					      error:nil];<br>        					      <br>        [_fileManager createDirectoryAtPath:self.diskCachePath<br>                withIntermediateDirectories:YES<br>                                 attributes:nil<br>                                      error:NULL];<br><br>        if (completion) &#123;<br>            dispatch_async(dispatch_get_main_queue(), ^&#123;<br>                completion();<br>            &#125;);<br>        &#125;<br>    &#125;);<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h4 id="通过cacheKey获取某张图片"><a href="#通过cacheKey获取某张图片" class="headerlink" title="通过cacheKey获取某张图片"></a>通过cacheKey获取某张图片</h4><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">- (UIImage *)imageFromDiskCacheForKey:(NSString *)key &#123;<br><br>    &#x2F;&#x2F; First check the in-memory cache...<br>    UIImage *image &#x3D; [self imageFromMemoryCacheForKey:key];<br>    if (image) &#123;<br>        return image;<br>    &#125;<br><br>    &#x2F;&#x2F; Second check the disk cache...<br>    UIImage *diskImage &#x3D; [self diskImageForKey:key];<br>    if (diskImage &amp;&amp; self.shouldCacheImagesInMemory) &#123;<br>        NSUInteger cost &#x3D; SDCacheCostForImage(diskImage);<br>        [self.memCache setObject:diskImage forKey:key cost:cost];<br>    &#125;<br><br>    return diskImage;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p><code>注意：</code>这里在磁盘中找到这张图片之后，会将这张图片放到缓存中 用来表示他最近使用了</p>
<h4 id="通过搜索全路径获取图片数据-NSData"><a href="#通过搜索全路径获取图片数据-NSData" class="headerlink" title="通过搜索全路径获取图片数据(NSData)"></a>通过搜索全路径获取图片数据(NSData)</h4><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">- (NSData *)diskImageDataBySearchingAllPathsForKey:(NSString *)key &#123;<br>    NSString *defaultPath &#x3D; [self defaultCachePathForKey:key];<br>    NSData *data &#x3D; [NSData dataWithContentsOfFile:defaultPath];<br>    if (data) &#123;<br>        return data;<br>    &#125;<br><br>    &#x2F;&#x2F; fallback because of https:&#x2F;&#x2F;github.com&#x2F;rs&#x2F;SDWebImage&#x2F;<br>    	pull&#x2F;976 that added the extension to the disk file name<br>    &#x2F;&#x2F; checking the key with and without the extension<br>    <br>    data &#x3D; [NSData dataWithContentsOfFile:<br>    			[defaultPath stringByDeletingPathExtension]];<br>    			<br>    if (data) &#123;<br>        return data;<br>    &#125;<br><br>    NSArray *customPaths &#x3D; [self.customPaths copy];<br>    for (NSString *path in customPaths) &#123;<br>        NSString *filePath &#x3D; [self cachePathForKey:key<br>        									 inPath:path];<br>        NSData *imageData &#x3D; [NSData <br>        						dataWithContentsOfFile:filePath];<br>        						<br>        if (imageData) &#123;<br>            return imageData;<br>        &#125;<br><br>        &#x2F;&#x2F; fallback because of https:&#x2F;&#x2F;github.com&#x2F;rs&#x2F;SDWebImage&#x2F;<br>        pull&#x2F;976 that added the extension to the disk file name<br>        &#x2F;&#x2F; checking the key with and without the extension<br>        <br>        imageData &#x3D; [NSData dataWithContentsOfFile:<br>        			[filePath stringByDeletingPathExtension]];<br>        			<br>        if (imageData) &#123;<br>            return imageData;<br>        &#125;<br>    &#125;<br><br>    return nil;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>customPaths:是在搜索完缓存以及磁盘都没有找到的时候，查找一个只读的空间，判断图片是否存在</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&#x2F;**<br> * Add a read-only cache path to search for images pre-cached by SDImageCache<br> * Useful if you want to bundle pre-loaded images with your app<br> *<br> * @param path The path to use for this read-only cache path<br> *&#x2F;<br>- (void)addReadOnlyCachePath:(NSString *)path;<br><br></code></pre></td></tr></table></figure>
<p>当用户调用这个方法设置只读的路径时，会向customPaths中添加路径</p>
<h4 id="获取一张磁盘中缓存的图片（UIImage）"><a href="#获取一张磁盘中缓存的图片（UIImage）" class="headerlink" title="获取一张磁盘中缓存的图片（UIImage）"></a>获取一张磁盘中缓存的图片（UIImage）</h4><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">- (UIImage *)diskImageForKey:(NSString *)key &#123;<br>    NSData *data &#x3D; [self <br>    			diskImageDataBySearchingAllPathsForKey:key];<br>    if (data) &#123;<br>        UIImage *image &#x3D; [UIImage sd_imageWithData:data];<br>        image &#x3D; [self scaledImageForKey:key image:image];<br>        if (self.shouldDecompressImages) &#123;<br>            image &#x3D; [UIImage decodedImageWithImage:image];<br>        &#125;<br>        return image;<br>    &#125;<br>    else &#123;<br>        return nil;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>从磁盘中取出图片要经历的几个过程：</p>
<p>1、取出NSData</p>
<p>2、将NSData转换为UIImage</p>
<p>3、做scale适配</p>
<p>4、图片是否需要解码，如果需要执行解码操作</p>
<p>5、返回这张图片</p>
]]></content>
      <categories>
        <category>源码分析</category>
      </categories>
      <tags>
        <tag>SDWebImage</tag>
        <tag>缓存</tag>
        <tag>磁盘管理</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS内存管理之AutoreleasePool</title>
    <url>/2018/03/20/iOS%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B9%8BAutoreleasePool/</url>
    <content><![CDATA[<p>每个线程（包括主线程），都维护了一个管理 NSAutoreleasePool 的栈。当创先新的 Pool 时，他们会被添加到栈顶。当 Pool 被销毁时，他们会被从栈中移除。<br>autorelease 的对象会被添加到当前线程的栈顶的 Pool 中。当 Pool 被销毁，其中的对象也会被释放。当线程结束时，所有的 Pool 被销毁释放。</p>
<a id="more"></a>

<h2 id="AutoreleasePool"><a href="#AutoreleasePool" class="headerlink" title="AutoreleasePool"></a>AutoreleasePool</h2><p>autorelease 本质上就是延迟调用 release ，那 autoreleased 对象究竟会在什么时候释放呢？为了弄清楚这个问题，我们先来做一个小实验。</p>
<h4 id="先看代码："><a href="#先看代码：" class="headerlink" title="先看代码："></a>先看代码：</h4><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">__<span class="hljs-keyword">weak</span> <span class="hljs-built_in">NSString</span> *string_weak_ = <span class="hljs-literal">nil</span>;<br><br>- (<span class="hljs-keyword">void</span>)viewDidLoad &#123;<br>    [<span class="hljs-keyword">super</span> viewDidLoad];<br><br>    <span class="hljs-comment">// 场景 1</span><br>    <span class="hljs-built_in">NSString</span> *string = [<span class="hljs-built_in">NSString</span> stringWithFormat:<span class="hljs-string">@&quot;leichunfeng&quot;</span>];<br>    string_weak_ = string;<br><br>    <span class="hljs-comment">// 场景 2</span><br><span class="hljs-comment">//    @autoreleasepool &#123;</span><br><span class="hljs-comment">//        NSString *string = [NSString stringWithFormat:@&quot;leichunfeng&quot;];</span><br><span class="hljs-comment">//        string_weak_ = string;</span><br><span class="hljs-comment">//    &#125;</span><br><br>    <span class="hljs-comment">// 场景 3</span><br><span class="hljs-comment">//    NSString *string = nil;</span><br><span class="hljs-comment">//    @autoreleasepool &#123;</span><br><span class="hljs-comment">//        string = [NSString stringWithFormat:@&quot;leichunfeng&quot;];</span><br><span class="hljs-comment">//        string_weak_ = string;</span><br><span class="hljs-comment">//    &#125;</span><br><br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;string: %@&quot;</span>, string_weak_);<br>&#125;<br><br>- (<span class="hljs-keyword">void</span>)viewWillAppear:(<span class="hljs-built_in">BOOL</span>)animated &#123;<br>    [<span class="hljs-keyword">super</span> viewWillAppear:animated];<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;string: %@&quot;</span>, string_weak_);<br>&#125;<br><br>- (<span class="hljs-keyword">void</span>)viewDidAppear:(<span class="hljs-built_in">BOOL</span>)animated &#123;<br>    [<span class="hljs-keyword">super</span> viewDidAppear:animated];<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;string: %@&quot;</span>, string_weak_);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>思考一下 输出结果</p>
<p>———————————–这是分割线———————————</p>
<h5 id="答案："><a href="#答案：" class="headerlink" title="答案："></a>答案：</h5><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">// 场景 1</span><br><span class="hljs-number">2015</span><span class="hljs-number">-05</span><span class="hljs-number">-30</span> <span class="hljs-number">10</span>:<span class="hljs-number">32</span>:<span class="hljs-number">20.837</span> AutoreleasePool[<span class="hljs-number">33876</span>:<span class="hljs-number">1448343</span>] string: leichunfeng<br><span class="hljs-number">2015</span><span class="hljs-number">-05</span><span class="hljs-number">-30</span> <span class="hljs-number">10</span>:<span class="hljs-number">32</span>:<span class="hljs-number">20.838</span> AutoreleasePool[<span class="hljs-number">33876</span>:<span class="hljs-number">1448343</span>] string: leichunfeng<br><span class="hljs-number">2015</span><span class="hljs-number">-05</span><span class="hljs-number">-30</span> <span class="hljs-number">10</span>:<span class="hljs-number">32</span>:<span class="hljs-number">20.845</span> AutoreleasePool[<span class="hljs-number">33876</span>:<span class="hljs-number">1448343</span>] string: (null)<br><br><span class="hljs-comment">// 场景 2</span><br><span class="hljs-number">2015</span><span class="hljs-number">-05</span><span class="hljs-number">-30</span> <span class="hljs-number">10</span>:<span class="hljs-number">32</span>:<span class="hljs-number">50.548</span> AutoreleasePool[<span class="hljs-number">33915</span>:<span class="hljs-number">1448912</span>] string: (null)<br><span class="hljs-number">2015</span><span class="hljs-number">-05</span><span class="hljs-number">-30</span> <span class="hljs-number">10</span>:<span class="hljs-number">32</span>:<span class="hljs-number">50.549</span> AutoreleasePool[<span class="hljs-number">33915</span>:<span class="hljs-number">1448912</span>] string: (null)<br><span class="hljs-number">2015</span><span class="hljs-number">-05</span><span class="hljs-number">-30</span> <span class="hljs-number">10</span>:<span class="hljs-number">32</span>:<span class="hljs-number">50.555</span> AutoreleasePool[<span class="hljs-number">33915</span>:<span class="hljs-number">1448912</span>] string: (null)<br><br><span class="hljs-comment">// 场景 3</span><br><span class="hljs-number">2015</span><span class="hljs-number">-05</span><span class="hljs-number">-30</span> <span class="hljs-number">10</span>:<span class="hljs-number">33</span>:<span class="hljs-number">07.075</span> AutoreleasePool[<span class="hljs-number">33984</span>:<span class="hljs-number">1449418</span>] string: leichunfeng<br><span class="hljs-number">2015</span><span class="hljs-number">-05</span><span class="hljs-number">-30</span> <span class="hljs-number">10</span>:<span class="hljs-number">33</span>:<span class="hljs-number">07.075</span> AutoreleasePool[<span class="hljs-number">33984</span>:<span class="hljs-number">1449418</span>] string: (null)<br><span class="hljs-number">2015</span><span class="hljs-number">-05</span><span class="hljs-number">-30</span> <span class="hljs-number">10</span>:<span class="hljs-number">33</span>:<span class="hljs-number">07.094</span> AutoreleasePool[<span class="hljs-number">33984</span>:<span class="hljs-number">1449418</span>] string: (null)<br></code></pre></td></tr></table></figure>


<h5 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h5><p>3 种场景下，我们都通过 <code>[NSString stringWithFormat:@&quot;leichunfeng&quot;]</code> 创建了一个 <code>autoreleased</code> 对象，这是我们实验的前提。并且，为了能够在 <code>viewWillAppear</code> 和 <code>viewDidAppear</code> 中继续访问这个对象，我们使用了一个全局的 <code>__weak </code>变量 <code>string_weak_</code> 来指向它。因为 <code>__weak</code> 变量有一个特性就是它不会影响所指向对象的生命周期，这里我们正是利用了这个特性。</p>
<h6 id="场景-1："><a href="#场景-1：" class="headerlink" title="场景 1："></a>场景 1：</h6><p>当使用 <code>[NSString stringWithFormat:@&quot;leichunfeng&quot;]</code> 创建一个对象时，这个对象的引用计数为 1 ，并且这个对象被系统自动添加到了当前的 autoreleasepool 中。当使用局部变量 string 指向这个对象时，这个对象的引用计数 +1 ，变成了 <code>2 </code>(这里后面会在看一下)。因为在 ARC 下 <code>NSString *string</code> 本质上就是 <code>__strong NSString *string</code> 。所以在 <code>viewDidLoad</code> 方法返回前，这个对象是一直存在的，且引用计数为 2 。而当 <code>viewDidLoad</code> 方法返回时，局部变量 string 被回收，指向了 nil 。因此，其所指向对象的引用计数 -1 ，变成了 1 。</p>
<p>而在 <code>viewWillAppear</code> 方法中，我们仍然可以打印出这个对象的值，说明这个对象并没有被释放。咦，这不科学吧？不是一直都说当函数返回的时候，函数内部产生的对象就会被释放的吗？前面我们提到了，这个对象是一个 <code>autoreleased</code> 对象，<code>autoreleased</code> 对象是被添加到了当前最近的 <code>autoreleasepool </code>中的，只有当这个 <code>autoreleasepool</code> 自身 <code>drain</code> 的时候，<code>autoreleasepool </code>中的 <code>autoreleased</code> 对象才会被 <code>release </code></p>
<p>另外，我们注意到当在<code>viewDidAppear</code> 中再打印这个对象的时候，对象的值变成了 nil ，说明此时对象已经被释放了。因此，我们可以大胆地猜测一下，这个对象一定是在 viewWillAppear 和 viewDidAppear 方法之间的某个时候被释放了，并且是由于它所在的 autoreleasepool 被 drain 的时候释放的。</p>
<p>####### 下面我们要证明这个问题</p>
<p>在开始前，我先简单地说明一下原理，我们可以通过使用 <code>lldb</code> 的 <code>watchpoint</code> 命令来设置观察点，观察全局变量 <code>string_weak_</code> 的值的变化，<code>string_weak_ </code>变量保存的就是我们创建的 <code>autoreleased</code> 对象的地址。在这里，我们再次利用了 <code>__weak</code> 变量的另外一个特性，就是当它所指向的对象被释放时，<code>__weak</code> 变量的值会被置为 nil 。了解了基本原理后，我们开始验证上面的猜测。</p>
<p>我们先在第 35 行打一个断点，当程序运行到这个断点时，我们通过 lldb 命令<code> watchpoint set v string_weak_</code> 设置观察点，观察 <code>string_weak_</code> 变量的值的变化。如下图所示，我们将在 console 中看到类似的输出，说明我们已经成功地设置了一个观察点：<br><img src="http://blog.leichunfeng.com/images/watchpoint1.jpg" alt="设置一个观察点"></p>
<p>点击继续执行</p>
<p><img src="http://blog.leichunfeng.com/images/watchpoint2.jpg" alt="继续执行"></p>
<p>我们先看 console 中的输出，注意到 string_weak_ 变量的值由 <code>0x00007f9b886567d0</code> 变成了 <code>0x0000000000000000</code> ，也就是 nil.</p>
<p>说明此时它所指向的对象被释放了。另外，我们也可以注意到一个细节，那就是 console 中打印了两次对象的值，说明此时 <code>viewWillAppear</code> 也已经被调用了，而 <code>viewDidAppear</code> 还没有被调用。</p>
<p>接着，我们来看看左侧的线程堆栈。我们看到了一个非常敏感的方法调用 <code>-[NSAutoreleasePool release] </code>，这个方法最终通过调用 <code>AutoreleasePoolPage::pop(void *)</code> 函数来负责对 autoreleasepool 中的 autoreleased 对象执行 release 操作。</p>
<p>结合前面的分析，我们知道在 viewDidLoad 中创建的 autoreleased 对象在方法返回后引用计数为 1 ，所以经过这里的 release 操作后，这个对象的引用计数 -1 ，变成了 0 ，该 autoreleased 对象最终被释放，猜测得证。</p>
<p>另外，我们在代码中并没有手动添加 autoreleasepool ，那这个 autoreleasepool 究竟是哪里来的呢？看完后面的章节你就明白了。</p>
<h6 id="场景-2："><a href="#场景-2：" class="headerlink" title="场景 2："></a>场景 2：</h6><p>当通过 <code>[NSString stringWithFormat:@&quot;leichunfeng&quot;] </code>创建一个对象时，这个对象的引用计数为 1 。而当使用局部变量 string 指向这个对象时，这个对象的引用计数 +1 ，变成了 2 。而出了当前作用域时，局部变量 string 变成了 nil ，所以其所指向对象的引用计数变成 1 。</p>
<p>另外，我们知道当出了 <code>@autoreleasepool &#123;&#125; </code>的作用域时，当前 autoreleasepool 被 <code>drain</code> ，其中的 autoreleased 对象被 release 。所以这个对象的引用计数变成了 0 ，对象最终被释放。</p>
<h6 id="场景-3："><a href="#场景-3：" class="headerlink" title="场景 3："></a>场景 3：</h6><p>当出了 <code>@autoreleasepool &#123;&#125;</code> 的作用域时，其中的 autoreleased 对象被 release ，对象的引用计数变成 1 。当出了局部变量 string 的作用域，即 viewDidLoad 方法返回时，string 指向了 nil ，其所指向对象的引用计数变成 0 ，对象最终被释放。</p>
<p>理解在这 3 种场景下，autoreleased 对象什么时候释放对我们理解 Objective-C 的内存管理机制非常有帮助。其中，场景 1 出现得最多，就是不需要我们手动添加 <code>@autoreleasepool &#123;&#125;</code> 的情况，直接使用系统维护的 autoreleasepool ；场景 2 就是需要我们手动添加 <code>@autoreleasepool &#123;&#125; </code>的情况，手动干预 autoreleased 对象的释放时机；场景 3 是为了区别场景 2 而引入的，在这种场景下并不能达到出了 <code>@autoreleasepool &#123;&#125;</code> 的作用域时 autoreleased 对象被释放的目的。</p>
<h2 id="AutoreleasePoolPage"><a href="#AutoreleasePoolPage" class="headerlink" title="AutoreleasePoolPage"></a>AutoreleasePoolPage</h2><p>细心的读者应该已经有所察觉，我们在上面已经提到了 <code>-[NSAutoreleasePool release]</code> 方法最终是通过调用 <code>AutoreleasePoolPage::pop(void *)</code> 函数来负责对 autoreleasepool 中的 autoreleased 对象执行 release 操作的</p>
<p>那这里的 AutoreleasePoolPage 是什么东西呢？其实，autoreleasepool 是没有单独的内存结构的，它是通过以 <code>AutoreleasePoolPage </code>为结点的<code>双向链表</code>来实现的(分别对应结构中的parent指针和child指针)。我们打开 runtime 的源码工程，在 NSObject.mm 文件的第 438-932 行可以找到 autoreleasepool 的实现源码。通过阅读源码，我们可以知道</p>
<ul>
<li>1、每一个线程的 autoreleasepool 其实就是一个指针的堆栈；</li>
<li>2、每一个指针代表一个需要 release 的对象或者 POOL_SENTINEL（哨兵对象，代表一个 autoreleasepool 的边界）</li>
<li>3、一个 pool token 就是这个 pool 所对应的 <code>POOL_SENTINEL</code> 的内存地址。当这个 pool 被 pop 的时候，所有内存地址在 <code>pool token</code> 之后的对象都会被 release </li>
<li>4、这个堆栈被划分成了一个以 page 为结点的双向链表。pages 会在必要的时候动态地增加或删除</li>
<li>5、<code>Thread-local storage</code>（线程局部存储）指向 <code>hot page</code> ，即最新添加的 autoreleased 对象所在的那个 page</li>
<li>6、AutoreleasePool是按线程一一对应的（结构中的thread指针指向当前线程</li>
<li>7、AutoreleasePoolPage每个对象会开辟<code>4096</code>字节内存（也就是虚拟内存一页的大小），除了上面的实例变量所占空间，剩下的空间全部用来储存autorelease对象的地</li>
<li>8、上面的id *next指针作为游标指向栈顶最新add进来的autorelease对象的下一个位置</li>
</ul>
<p>一个空的 AutoreleasePoolPage 的内存结构如下图所示：</p>
<p><img src="http://blog.leichunfeng.com/images/AutoreleasePoolPage.png" alt="AutoreleasePoolPage内存结构"></p>
<p>字段释义：</p>
<blockquote>
<p><code>magic</code> 用来校验 AutoreleasePoolPage 的结构是否完整；<br><code>next</code> 指向最新添加的 autoreleased 对象的下一个位置，初始化时指向 begin()<br><code>thread</code> 指向当前线程<br><code>parent</code> 指向父结点，第一个结点的 parent 值为 nil<br><code>child</code> 指向子结点，最后一个结点的 child 值为 nil<br><code>depth</code> 代表深度，从 0 开始，往后递增 1<br><code>hiwat</code> 代表 high water mark 。</p>
</blockquote>
<p><code>注意</code>:当 <code>next == begin()</code> 时，表示 AutoreleasePoolPage 为<code>空</code>；当 <code>next == end() </code>时，表示 AutoreleasePoolPage <code>已满</code></p>
<h3 id="Autorelease-Pool-Blocks"><a href="#Autorelease-Pool-Blocks" class="headerlink" title="Autorelease Pool Blocks"></a>Autorelease Pool Blocks</h3><p>我们使用 <code>clang -rewrite-objc</code> 命令将下面的 Objective-C 代码重写成 C++ 代码：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">@autoreleasepool</span> &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>将会得到以下输出结果（只保留了相关代码）：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> __declspec(dllimport) <span class="hljs-keyword">void</span> * objc_autoreleasePoolPush(<span class="hljs-keyword">void</span>);<br><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> __declspec(dllimport) <span class="hljs-keyword">void</span> objc_autoreleasePoolPop(<span class="hljs-keyword">void</span> *);<br><br><span class="hljs-keyword">struct</span> __AtAutoreleasePool &#123;<br>  __AtAutoreleasePool() &#123;atautoreleasepoolobj = objc_autoreleasePoolPush();&#125;<br>  ~__AtAutoreleasePool() &#123;objc_autoreleasePoolPop(atautoreleasepoolobj);&#125;<br>  <span class="hljs-keyword">void</span> * atautoreleasepoolobj;<br>&#125;;<br><br><span class="hljs-comment">/* @autoreleasepool */</span> &#123; __AtAutoreleasePool __autoreleasepool;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>不得不说，苹果对 <code>@autoreleasepool &#123;&#125;</code> 的实现真的是非常巧妙，真正可以称得上是代码的艺术。苹果通过声明一个 <code>__AtAutoreleasePool</code> 类型的局部变量 <code>__autoreleasepool</code> 来实现 <code>@autoreleasepool &#123;&#125;</code> 。当声明 <code>__autoreleasepool</code> 变量时，构造函数 <code>__AtAutoreleasePool()</code> 被调用，即执行 <code>atautoreleasepoolobj = objc_autoreleasePoolPush();</code> ；当出了当前作用域时，析构函数 <code>~__AtAutoreleasePool() </code>被调用，即执行 <code>objc_autoreleasePoolPop(atautoreleasepoolobj);</code> 。也就是说 <code>@autoreleasepool &#123;&#125; </code>的实现代码可以进一步简化如下</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">/* @autoreleasepool */</span> &#123;<br>    <span class="hljs-keyword">void</span> *atautoreleasepoolobj = objc_autoreleasePoolPush();<br>    <span class="hljs-comment">// 用户代码，所有接收到 autorelease 消息的对象会被添加到这个 autoreleasepool 中</span><br>    objc_autoreleasePoolPop(atautoreleasepoolobj);<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="push-操作"><a href="#push-操作" class="headerlink" title="push 操作"></a>push 操作</h3><p>上面提到的 <code>objc_autoreleasePoolPush()</code> 函数本质上就是调用的 AutoreleasePoolPage 的 push 函数</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">void</span> *<br>objc_autoreleasePoolPush(<span class="hljs-keyword">void</span>)<br>&#123;<br>    <span class="hljs-keyword">if</span> (UseGC) <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>;<br>    <span class="hljs-keyword">return</span> AutoreleasePoolPage::push();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>因此，我们接下来看看 AutoreleasePoolPage 的 push 函数的作用和执行过程。一个 push 操作其实就是<code>创建</code>一个新的 autoreleasepool ，对应 AutoreleasePoolPage 的具体实现就是往 AutoreleasePoolPage 中的 <code>next</code> 位置插入一个 <code>POOL_SENTINEL</code> ，并且返回插入的 <code>POOL_SENTINEL</code> 的内存地址。这个地址也就是我们前面提到的 <code>pool token</code> ，在执行 pop 操作的时候作为函数的入参</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> *push()<br>&#123;<br>    <span class="hljs-keyword">id</span> *dest = autoreleaseFast(POOL_SENTINEL);<br>    assert(*dest == POOL_SENTINEL);<br>    <span class="hljs-keyword">return</span> dest;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>push 函数通过调用 <code>autoreleaseFast</code> 函数来执行具体的插入操作。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">id</span> *autoreleaseFast(<span class="hljs-keyword">id</span> obj)<br>&#123;<br>    <span class="hljs-comment">//创建的时候插入一个POOL_SENTINEL表示一个新的自动pool的创建</span><br>    AutoreleasePoolPage *page = hotPage();<br>    <span class="hljs-comment">//下面是将新建的这个pool插入page中</span><br>    <span class="hljs-keyword">if</span> (page &amp;&amp; !page-&gt;full()) &#123;<br>        <span class="hljs-keyword">return</span> page-&gt;add(obj);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (page) &#123;<br>        <span class="hljs-keyword">return</span> autoreleaseFullPage(obj, page);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> autoreleaseNoPage(obj);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>autoreleaseFast 函数在执行一个具体的插入操作时，分别对三种情况进行了不同的处理：</p>
<ul>
<li>1、当前 page 存在且没有满时，直接将对象添加到当前 page 中，即 next 指向的位置；</li>
<li>2、当前 page 存在且已满时，创建一个新的 page ，并将对象添加到新创建的 page 中；</li>
<li>3、当前 page 不存在时，即还没有 page 时，创建第一个 page ，并将对象添加到新创建的 page 中。</li>
</ul>
<p>每调用一次 push 操作就会创建一个新的 autoreleasepool ，即往 <code>AutoreleasePoolPage </code>中插入一个 <code>POOL_SENTINEL</code> ，并且返回插入的 <code>POOL_SENTINEL</code> 的内存地址。</p>
<h3 id="autorelease-操作"><a href="#autorelease-操作" class="headerlink" title="autorelease 操作"></a>autorelease 操作</h3><p>通过 <code>NSObject.mm</code> 源文件，我们可以找到 <code>-autorelease</code> 方法的实现：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">- (<span class="hljs-keyword">id</span>)autorelease &#123;<br>    <span class="hljs-keyword">return</span> ((<span class="hljs-keyword">id</span>)<span class="hljs-keyword">self</span>)-&gt;rootAutorelease();<br>&#125;<br></code></pre></td></tr></table></figure>
<p>通过查看 <code>((id)self)-&gt;rootAutorelease()</code> 的方法调用，我们发现最终调用的就是 AutoreleasePoolPage 的 autorelease 函数。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">__attribute__((noinline,used))<br><span class="hljs-keyword">id</span><br>objc_object::rootAutorelease2()<br>&#123;<br>    assert(!isTaggedPointer());<br>    <span class="hljs-keyword">return</span> AutoreleasePoolPage::autorelease((<span class="hljs-keyword">id</span>)<span class="hljs-keyword">this</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>AutoreleasePoolPage</code> 的 autorelease 函数的实现对我们来说就比较容量理解了，它跟 push 操作的实现非常相似。只不过 push 操作插入的是一个 <code>POOL_SENTINEL </code>，而 autorelease 操作插入的是一个具体的 autoreleased 对象。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">id</span> autorelease(<span class="hljs-keyword">id</span> obj)<br>&#123;<br>    assert(obj);<br>    assert(!obj-&gt;isTaggedPointer());<br>    <span class="hljs-keyword">id</span> *dest __unused = autoreleaseFast(obj);<br>    assert(!dest  ||  *dest == obj);<br>    <span class="hljs-keyword">return</span> obj;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="pop-操作"><a href="#pop-操作" class="headerlink" title="pop 操作"></a>pop 操作</h3><p>同理，前面提到的 <code>objc_autoreleasePoolPop(void *)</code> 函数本质上也是调用的 AutoreleasePoolPage 的 pop 函数。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">void</span><br>objc_autoreleasePoolPop(<span class="hljs-keyword">void</span> *ctxt)<br>&#123;<br>    <span class="hljs-keyword">if</span> (UseGC) <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-comment">// fixme rdar://9167170</span><br>    <span class="hljs-keyword">if</span> (!ctxt) <span class="hljs-keyword">return</span>;<br><br>    AutoreleasePoolPage::pop(ctxt);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>pop 函数的入参就是 push 函数的返回值，也就是 <code>POOL_SENTINEL</code> 的内存地址，即 <code>pool token</code> 。当执行 pop 操作时，内存地址在<code> pool token</code> 之后的所有 autoreleased 对象都会被 release 。直到<code> pool token</code> 所在 page 的<code> next</code> 指向 <code>pool token</code> 为止。</p>
<p>根绝上面的内容我们可以大致猜测 AutoreleasePoolPage类的结构 如下：</p>
<h3 id="AutoreleasePoolPage-类的结构"><a href="#AutoreleasePoolPage-类的结构" class="headerlink" title="AutoreleasePoolPage 类的结构"></a>AutoreleasePoolPage 类的结构</h3><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">objc4/<span class="hljs-built_in">NSObject</span>.mm AutoreleasePoolPage<br><br><span class="hljs-keyword">class</span> AutoreleasePoolPage <br>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> *push() <br>    &#123;<br>        生成或者持有 <span class="hljs-built_in">NSAutoreleasePool</span> 类对象<br>    &#125;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> pop(<span class="hljs-keyword">void</span> *token) <br>    &#123;<br>        废弃 <span class="hljs-built_in">NSAutoreleasePool</span> 类对象<br>        releaseAll();<br>    &#125;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">id</span> autorelease(<span class="hljs-keyword">id</span> obj)<br>    &#123;<br>        相当于 <span class="hljs-built_in">NSAutoreleasePool</span> 类的 addObject 类方法<br>        AutoreleasePoolPage *page = 取得正在使用的 AutoreleasePoolPage 实例;<br>    &#125;<br>    <span class="hljs-keyword">id</span> *add(<span class="hljs-keyword">id</span> obj)<br>    &#123;<br>        将对象追加到内部数组<br>    &#125;<br>    <span class="hljs-keyword">void</span> releaseAll() <br>    &#123;<br>        调用内部数组中对象的 release 方法<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">void</span> *<br>objc_autoreleasePoolPush(<span class="hljs-keyword">void</span>)<br>&#123;<br>    <span class="hljs-keyword">if</span> (UseGC) <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>;<br>    <span class="hljs-keyword">return</span> AutoreleasePoolPage::push();<br>&#125;<br><br><span class="hljs-keyword">void</span><br>objc_autoreleasePoolPop(<span class="hljs-keyword">void</span> *ctxt)<br>&#123;<br>    <span class="hljs-keyword">if</span> (UseGC) <span class="hljs-keyword">return</span>;<br>    AutoreleasePoolPage::pop(ctxt);<br>&#125;<br></code></pre></td></tr></table></figure>


<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>下面是某个线程的 autoreleasepool 堆栈的内存结构图，在这个 autoreleasepool 堆栈中总共有两个 POOL_SENTINEL ，即有两个 autoreleasepool 。该堆栈由三个 AutoreleasePoolPage 结点组成，第一个 AutoreleasePoolPage 结点为 coldPage() ，最后一个 AutoreleasePoolPage 结点为 hotPage() 。其中，前两个结点已经满了，最后一个结点中保存了最新添加的 autoreleased 对象 objr3 的内存地址。</p>
<p><img src="http://blog.leichunfeng.com/images/AutoreleasePoolPage1.png" alt="内存结构图"></p>
<p>此时，如果执行 <code>pop(token1)</code> 操作，那么该 autoreleasepool 堆栈的内存结构将会变成如下图所示</p>
<p><img src="http://blog.leichunfeng.com/images/AutoreleasePoolPage2.png" alt="内存结构图"></p>
<h3 id="Autorelease对象什么时候释放？"><a href="#Autorelease对象什么时候释放？" class="headerlink" title="Autorelease对象什么时候释放？"></a>Autorelease对象什么时候释放？</h3><p>这个问题拿来做面试题，问过很多人，没有几个能答对的。很多答案都是“当前作用域大括号结束时释放”，显然木有正确理解Autorelease机制。<br>在没有手加Autorelease Pool的情况下，Autorelease对象是在当前的runloop迭代结束时释放的，而它能够释放的原因是系统在每个runloop迭代中都加入了自动释放池Push和Pop</p>
<h3 id="嵌套的AutoreleasePool"><a href="#嵌套的AutoreleasePool" class="headerlink" title="嵌套的AutoreleasePool"></a>嵌套的AutoreleasePool</h3><p>知道了上面的原理，嵌套的AutoreleasePool就非常简单了，pop的时候总会释放到上次push的位置为止，多层的pool就是多个哨兵对象而已，就像剥洋葱一样，每次一层，互不影响。</p>
<h3 id="其他Autorelease相关知识点"><a href="#其他Autorelease相关知识点" class="headerlink" title="其他Autorelease相关知识点"></a>其他Autorelease相关知识点</h3><p>使用容器的block版本的枚举器时，内部会自动添加一个AutoreleasePool：</p>
<p>[array enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop) {<br>    // 这里被一个局部@autoreleasepool包围着<br>}];<br>当然，在普通for循环和for in循环中没有，所以，还是新版的block版本枚举器更加方便。for循环中遍历产生大量autorelease变量时，就需要手加局部AutoreleasePool咯。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="http://blog.sunnyxx.com/2014/10/15/behind-autorelease/">黑幕背后的Autorelease</a><br><a href="http://blog.leichunfeng.com/blog/2015/05/31/objective-c-autorelease-pool-implementation-principle/#jtss-tsina">Objective-C Autorelease Pool 的实现原理</a></p>
]]></content>
      <categories>
        <category>iOS优化</category>
      </categories>
      <tags>
        <tag>ARC RetainCount AutoreleasePool AutoreleasePoolPage</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS内存管理基础篇</title>
    <url>/2018/03/22/iOS%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80%E7%AF%87/</url>
    <content><![CDATA[<p>本文是iOS 内存管理的基础篇,从最基本的堆栈开始一步步的了解iOS的内存管理。</p>
<a id="more"></a>

<h2 id="内存管理基础结构"><a href="#内存管理基础结构" class="headerlink" title="内存管理基础结构"></a>内存管理基础结构</h2><h3 id="程序可执行文件的结构"><a href="#程序可执行文件的结构" class="headerlink" title="程序可执行文件的结构"></a>程序可执行文件的结构</h3><p>一个程序的可执行文件在内存中的结果，从大的角度可以分为两个部分：只读部分和可读写部分。只读部分包括程序代码（.text）和程序中的常量（.rodata）。可读写部分（也就是变量）大致可以分成下面几个部分：</p>
<ul>
<li>.data： 初始化了的全局变量和静态变量</li>
<li>.bss： 即 Block Started by Symbol， 未初始化的全局变量和静态变量</li>
<li>heap： 堆，使用 malloc, realloc, 和 free 函数控制的变量，堆在所有的线程，共享库，和动态加载的模块中被共享使用</li>
<li>stack： 栈，函数调用时使用栈来保存函数现场，自动变量（即生命周期限制在某个 scope 的变量）也存放在栈中</li>
</ul>
<p><img src="https://www.processon.com/chart_image/586f3b1fe4b067ce8566dc70.png" alt="架构图"></p>
<p>下面来具体解释一下：</p>
<h3 id="data-和-bss-区"><a href="#data-和-bss-区" class="headerlink" title="data 和 bss 区"></a>data 和 bss 区</h3><p>这两个都是存放全局变量的 他们之间的区别是：<br><code>data区存放的是初始化了的全局变量和静态变量,而bss区存放的是未初始化过得</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//初始化</span><br><span class="hljs-keyword">int</span> val = <span class="hljs-number">3</span>;<br><span class="hljs-keyword">char</span> <span class="hljs-built_in">string</span>[] = <span class="hljs-string">&quot;Hello World&quot;</span>;<br><br><span class="hljs-comment">//未初始化</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> i;<br></code></pre></td></tr></table></figure>

<p>已经初始化的变量最开始会被放在.text中 因为值是卸载代码中的，程序运行起来之后就会被拷贝到.data区或者bss区。</p>
<p><font size="5" color=red>答疑一</font>: 静态变量和全局变量</p>
<p><code>全局变量</code>:在一个代码文件（具体说应该一个 translation unit/compilation unit)）当中，一个变量要么定义在函数中，要么定义在在函数外面。当定义在函数外面时，这个变量就有了全局作用域，成为了全局变量。全局变量不光意味着这个变量可以在整个文件中使用，也意味着这个变量可以在其他文件中使用（这种叫做 external linkage）。当有如下两个文件时</p>
<p>a.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-keyword">int</span> a;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">compute</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    a = <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d\n&quot;</span>, a, compute());<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>b.c</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">int a;<br>int compute(void)<br>&#123;<br>    a &#x3D; 0;<br>    return a;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在 Link 过程中会产生重复定义错误，因为有两个全局的 a 变量，Linker 不知道应该使用哪一个。为了避免这种情况，就需要引入 static</p>
<p><code>静态变量</code>： 指使用 static 关键字修饰的变量，static 关键字对变量的作用域进行了限制，具体的</p>
<p>限制如下：</p>
<ul>
<li>在函数外定义：全局变量，但是只在当前文件中可见（叫做 internal linkage）</li>
<li>在函数内定义：全局变量，但是只在此函数内可见（同时，在多次函数调用中，变量的值不会丢失）<br>（C++）在类中定义：全局变量，但是只在此类中可见</li>
</ul>
<p>对于全局变量来说，为了避免上面提到的重复定义错误，我们可以在一个文件中使用 static，另一个不使用。这样使用 static 的就会使用自己的 a 变量，而没有用 static 的会使用全局的 a 变量。当然，最好两个都使用 static，避免更多可能的命名冲突。</p>
<p><font color='black' size = '6'>注意</font>：’静态’这个中文翻译实在是有些莫名其妙，给人的感觉像是不可改变的，而实际上 static 跟不可改变没有关系，不可改变的变量使用 const 关键字修饰，注意不要混淆。</p>
<p><font color="blue">Bonus 部分</font> —— extern： extern 是 C 语言中另一个关键字，用来指示变量或函数的定义在别的文件中，使用 extern 可以在多个源文件中共享某个变量，例如这里的例子。 extern 跟 static 在含义上是“水火不容”的，一个表示不能在别的地方用，一个表示要去别的地方找。如果同时使用的话，有两种情况，一种是先使用 static，后使用 extern ，即：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> m;<br><span class="hljs-keyword">extern</span> <span class="hljs-keyword">int</span> m;<br></code></pre></td></tr></table></figure>
<p>这种情况，后面的 m 实际上就是前面的 m 。如果反过来：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">extern</span> <span class="hljs-keyword">int</span> m;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> m;<br></code></pre></td></tr></table></figure>
<p>这种情况的行为是未定义的，编译器也会给出警告。</p>
<p><font color='red' size='6'>答疑二</font> 程序在内存和硬盘上不同的存在形式（不懂！！！）</p>
<p>这里我们提到的几个区，是指程序在内存中的存在形式。和程序在硬盘上存储的格式不是完全对应的。程序在硬盘上存储的格式更加复杂，而且是和操作系统有关的，具体可以参考这里。一个比较明显的例子可以帮你区分这个差别：之前我们提到过未定义的全局变量存储在 .bss 区，这个区域不会占用可执行文件的空间（一般只存储这个区域的长度），但是却会占用内存空间。这些变量没有定义，因此可执行文件中不需要存储（也不知道）它们的值，在程序启动过程中，它们的值会被初始化成 0 ，存储在内存中</p>
<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>栈是用于存放本地变量，内部临时变量以及有关上下文的内存区域。程序在调用函数时，操作系统会自动通过压栈和弹栈完成保存函数现场等操作，不需要程序员手动干预。</p>
<p>栈是一块<code>连续的内存区域</code>，栈顶的地址和栈的最大容量是系统预先规定好的。能从栈获得的空间较小。如果申请的空间超过栈的剩余空间时，例如递归深度过深，将提示stackoverflow。</p>
<p>栈是机器系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高</p>
<h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>堆是用于存放除了栈里的东西之外所有其他东西的内存区域，当使用<code>malloc</code>和<code>free</code>时就是在操作堆中的内存。对于堆来说<code>·释放工作由程序员控制</code>，容易产生<code>memory leak</code>。</p>
<p>堆是向高地址扩展的数据结构，<code>是不连续的内存区域</code>。这是由于系统是用<code>链表</code>来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，<code>堆获得的空间比较灵活，也比较大</code>。</p>
<p>对于堆来讲，频繁的<code>new/delete</code>势必会造成内存空间的不连续，从而造成大量的<code>碎片</code>，使程序效率降低。对于栈来讲，则不会存在这个问题，因为栈是先进后出的队列，永远都不可能有一个内存块从栈中间弹出。</p>
<p>堆都是<code>动态分配的</code>，没有静态分配的堆。栈有2种分配方式：静态分配和动态分配。<code>静态分配是编译器完成的，比如局部变量的分配</code>。<code>动态分配由alloca函数进行分配</code>，但是栈的动态分配和堆是不同的，他的动态分配是<code>由编译器进行释放，无需我们手工实现</code>。</p>
<p>计算机底层并没有对堆的支持，堆则是C/C++函数库提供的，同时由于上面提到的碎片问题，都会导致堆的效率比栈要低。</p>
<h3 id="全局区-静态区"><a href="#全局区-静态区" class="headerlink" title="全局区 / 静态区"></a>全局区 / 静态区</h3><p>存储全局变量和静态变量，程序结束后由系统释放</p>
<blockquote>
<p>初始化区 非初始化区分开存放</p>
</blockquote>
<h3 id="文字常量区"><a href="#文字常量区" class="headerlink" title="文字常量区"></a>文字常量区</h3><blockquote>
<p>存储字符串常量，程序结束后由系统释放</p>
</blockquote>
<h3 id="程序代码区"><a href="#程序代码区" class="headerlink" title="程序代码区"></a>程序代码区</h3><blockquote>
<p>存储函数体的二进制代码</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//main.cpp</span><br><span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>; <span class="hljs-comment">// 全局初始化区</span><br><span class="hljs-keyword">char</span> *p1; <span class="hljs-comment">// 全局未初始化区</span><br>main &#123;<br>    <span class="hljs-keyword">int</span> b; <span class="hljs-comment">// 栈</span><br>    <span class="hljs-keyword">char</span> s[] = <span class="hljs-string">&quot;abc&quot;</span>; <span class="hljs-comment">// 栈</span><br>    <span class="hljs-keyword">char</span> *p2; <span class="hljs-comment">// 栈</span><br>    <span class="hljs-keyword">char</span> *p3 = <span class="hljs-string">&quot;123456&quot;</span>; <span class="hljs-comment">// 123456\0在常量区，p3在栈上</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> c =<span class="hljs-number">0</span>； <span class="hljs-comment">// 全局静态初始化区</span><br>    p1 = (<span class="hljs-keyword">char</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">10</span>);<br>    p2 = (<span class="hljs-keyword">char</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">20</span>); <span class="hljs-comment">// 分配得来的10和20字节的区域就在堆区</span><br>    <span class="hljs-built_in">strcpy</span>(p1, <span class="hljs-string">&quot;123456&quot;</span>); <span class="hljs-comment">// 123456\0在常量区，这个函数的作用是将&quot;123456&quot; 这串字符串复制一份放在p1申请的10个字节的堆区域中。</span><br>    <span class="hljs-comment">// p3指向的&quot;123456&quot;与这里的&quot;123456&quot;可能会被编译器优化成一个地址。</span><br>&#125;<br></code></pre></td></tr></table></figure>


<h3 id="结构体-Struct"><a href="#结构体-Struct" class="headerlink" title="结构体(Struct)"></a>结构体(Struct)</h3><h4 id="1、定义"><a href="#1、定义" class="headerlink" title="1、定义"></a>1、定义</h4><blockquote>
<p>struct tag { member-list } variable-list;</p>
</blockquote>
<h4 id="2、成员访问"><a href="#2、成员访问" class="headerlink" title="2、成员访问"></a>2、成员访问</h4><blockquote>
<p>直接访问： 变量名.成员名<br>间接访问： 结构体指针名-&gt;成员名</p>
</blockquote>
<h5 id="3、成员存储"><a href="#3、成员存储" class="headerlink" title="3、成员存储"></a>3、成员存储</h5><blockquote>
<p>获得EXAMPLE类型结构体所占内存大小: int size_example = sizeof( struct EXAMPLE );<br>获得成员b相对于EXAMPLE储存地址的偏移量: int offset_b = offsetof( struct EXAMPLE, b );</p>
</blockquote>
<h3 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h3><ul>
<li><p>虚拟地址：用户编程时将代码（或数据）分成若干个段，每条代码或每个数据的地址由段名称 + 段内相对地址构成，这样的程序地址称为虚拟地址</p>
</li>
<li><p>逻辑地址：虚拟地址中，段内相对地址部分称为逻辑地址</p>
</li>
<li><p>物理地址：实际物理内存中所看到的存储地址称为物理地址</p>
</li>
<li><p>逻辑地址空间：在实际应用中，将虚拟地址和逻辑地址经常不加区分，通称为逻辑地址。逻辑地址的集合称为逻辑地址空间</p>
</li>
<li><p>线性地址空间：CPU地址总线可以访问的所有地址集合称为线性地址空间</p>
</li>
<li><p>物理地址空间：实际存在的可访问的物理内存地址集合称为物理地址空间</p>
</li>
<li><p>MMU(Memery Management Unit内存管理单元)：实现将用户程序的虚拟地址（逻辑地址） → 物理地址映射的CPU中的硬件电路</p>
</li>
<li><p>基地址：在进行地址映射时，经常以段或页为单位并以其最小地址（即起始地址）为基值来进行计算</p>
</li>
<li><p>偏移量：在以段或页为单位进行地址映射时，相对于基地址的地址值<br>虚拟地址先经过分段机制映射到线性地址，然后线性地址通过分页机制映射到物理地址。</p>
</li>
</ul>
<h3 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h3><h4 id="FIFO算法"><a href="#FIFO算法" class="headerlink" title="FIFO算法"></a>FIFO算法</h4><p>先入先出，即淘汰最早调入的页面。</p>
<h4 id="OPT-MIN-算法"><a href="#OPT-MIN-算法" class="headerlink" title="OPT(MIN)算法"></a>OPT(MIN)算法</h4><p>选未来最远将使用的页淘汰，是一种最优的方案，可以证明缺页数最小。<br>可惜，MIN需要知道将来发生的事，只能在理论中存在，实际不可应用。</p>
<h4 id="LRU-Least-Recently-Used-算法"><a href="#LRU-Least-Recently-Used-算法" class="headerlink" title="LRU(Least-Recently-Used)算法"></a>LRU(Least-Recently-Used)算法</h4><p>用过去的历史预测将来，选最近最长时间没有使用的页淘汰(也称最近最少使用)。<br>LRU准确实现：计数器法，页码栈法。<br>由于代价较高，通常不使用准确实现，而是采用近似实现，例如Clock算法。</p>
<p><code>内存抖动现象</code>：页面的频繁更换，导致整个系统效率急剧下降，这个现象称为内存抖动（或颠簸）。抖动一般是内存分配算法不好，内存太小引或者程序的算法不佳引起的</p>
<p><code>Belady现象</code>：对有的页面置换算法，页错误率可能会随着分配帧数增加而增加。<br>FIFO会产生Belady异常。<br>栈式算法无Belady异常，LRU，LFU（最不经常使用），OPT都属于栈式算法。</p>
<h1 id="OC的内存管理"><a href="#OC的内存管理" class="headerlink" title="OC的内存管理"></a>OC的内存管理</h1><h3 id="MRC于ARC-环境设置"><a href="#MRC于ARC-环境设置" class="headerlink" title="MRC于ARC 环境设置"></a>MRC于ARC 环境设置</h3><p><img src="https://blog.devtang.com/images/memory-fno-objc-arc.png" alt="参数配置"></p>
<h2 id="Reference-Counting"><a href="#Reference-Counting" class="headerlink" title="Reference Counting"></a>Reference Counting</h2><table>
<thead>
<tr>
<th>对象操作</th>
<th>Objective-C方法</th>
</tr>
</thead>
<tbody><tr>
<td>生成并持有对象</td>
<td>alloc/new/copy/mutableCopy等方法</td>
</tr>
<tr>
<td>持有对象</td>
<td>retain方法</td>
</tr>
<tr>
<td>释放对象</td>
<td>release方法</td>
</tr>
<tr>
<td>废弃对象</td>
<td>dealloc方法</td>
</tr>
</tbody></table>
<h3 id="alloc-retain-release-dealloc-实现"><a href="#alloc-retain-release-dealloc-实现" class="headerlink" title="alloc/retain/release/dealloc 实现"></a>alloc/retain/release/dealloc 实现</h3><p>在 Xcode 中 设置 Debug -&gt; Debug Workflow -&gt; Always Show Disassenbly 打开。这样在打断点后，可以看到更详细的方法调用。</p>
<h4 id="alloc"><a href="#alloc" class="headerlink" title="alloc"></a>alloc</h4><p>通过设置断点追踪程序的执行，下面列出了执行所调用的方法和函数：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">+alloc<br>+allocWithZone:<br>class_createInstance<br>calloc<br></code></pre></td></tr></table></figure>

<p>下面我们来看这几个跟retainCount相关的方法到底都做了什么！</p>
<h4 id="retainCount"><a href="#retainCount" class="headerlink" title="retainCount"></a>retainCount</h4><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">__CFdoExternRefOperation<br><span class="hljs-built_in">CFBasicHashGetCountOfKey</span><br></code></pre></td></tr></table></figure>

<h4 id="retain"><a href="#retain" class="headerlink" title="retain"></a>retain</h4><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">__CFdoExternRefOperation<br><span class="hljs-built_in">CFBasicHashAddValue</span><br></code></pre></td></tr></table></figure>

<h4 id="release"><a href="#release" class="headerlink" title="release"></a>release</h4><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">__CFdoExternRefOperation<br><span class="hljs-built_in">CFBasicHashRemoveValue</span><br></code></pre></td></tr></table></figure>

<p>很明显 这几个方法都调用了<code>__CFdoExternRefOperation</code>这个方法,下面我们来看一下这个方法的实现：</p>
<p>CFRuntime.c __CFDoExternRefOperation:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">int</span> __CFDoExternRefOperation(uintptr_t op, <span class="hljs-keyword">id</span> obj) &#123;<br>    <span class="hljs-built_in">CFBasicHashRef</span> table = 取得对象的散列表(obj);<br>    <span class="hljs-keyword">int</span> count;<br>    <br>    <span class="hljs-keyword">switch</span> (op) &#123;<br>        <span class="hljs-keyword">case</span> OPERATION_retainCount:<br>        count = <span class="hljs-built_in">CFBasicHashGetCountOfKey</span>(table, obj);<br>        <span class="hljs-keyword">return</span> count;<br>        <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> OPERATION_retain:<br>        count = <span class="hljs-built_in">CFBasicHashAddValue</span>(table, obj);<br>        <span class="hljs-keyword">return</span> obj;<br>        <span class="hljs-keyword">case</span> OPERATION_release:<br>        count = <span class="hljs-built_in">CFBasicHashRemoveValue</span>(table, obj);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span> == count;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>从<code>BasicHash</code>这样的方法名可以看出，其实引用计数表就是散列表。<code>key 为 hash(对象的地址) value为引用计数</code></p>
<h3 id="所有的修饰符"><a href="#所有的修饰符" class="headerlink" title="所有的修饰符"></a>所有的修饰符</h3><h4 id="strong-修饰符"><a href="#strong-修饰符" class="headerlink" title="_strong 修饰符"></a>_strong 修饰符</h4><p>是id类型和对象类型默认的所有权修饰符</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">id</span> obj = [[<span class="hljs-built_in">NSObject</span> alloc] init];<br></code></pre></td></tr></table></figure>

<p>上面的源码与下面的相同</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">id</span> _<span class="hljs-keyword">strong</span> obj = [[<span class="hljs-built_in">NSObject</span> alloc] init];<br></code></pre></td></tr></table></figure>

<h4 id="weak修饰符"><a href="#weak修饰符" class="headerlink" title="_weak修饰符"></a>_weak修饰符</h4><p>_weak修饰符出现是为了避免发生循环引用,循环引用容易发生内存泄漏.所为内存泄漏就是应当废弃的对象在超出其生存周期后继续存在。</p>
<p>即使只有一个对象也有可能发生循环引用</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">id</span> test = [[Test alloc] init];<br>[test setObject:test];<br></code></pre></td></tr></table></figure>

<p>__weak修饰符还有一个优点：在持有某对象的弱引用时,若该对象被废弃则弱引用将自动失效且处于nil被赋值的状态(空弱引用)。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">id</span> __<span class="hljs-keyword">weak</span> obj1 = <span class="hljs-literal">nil</span>;<br>&#123;<br>    <span class="hljs-keyword">id</span> __<span class="hljs-keyword">strong</span> obj0 = [[<span class="hljs-built_in">NSObject</span> alloc] init];<br>    <br>    obj1 = obj0;<br>    <br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;A:%@&quot;</span>,obj1);<br>&#125;<br> <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;A:%@&quot;</span>,obj1);<br></code></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">A:&lt;NSObject:ox753e180&gt;<br>B:null<br></code></pre></td></tr></table></figure>

<h4 id="unsafe-unretained修饰符"><a href="#unsafe-unretained修饰符" class="headerlink" title="_unsafe_unretained修饰符"></a>_unsafe_unretained修饰符</h4><p>是不安全的所有权修饰符，因此：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">id</span> __<span class="hljs-keyword">unsafe_unretained</span> obj = [[<span class="hljs-built_in">NSObject</span> alloc] init];<br></code></pre></td></tr></table></figure>
<p>仍然会提示</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">Assigning retained object to <span class="hljs-keyword">unsafe_unretained</span> variable; object will be released after assignment<br></code></pre></td></tr></table></figure>
<p>这一点跟__weak是一样 因为自己无法持有自己创建的对象 创建完成之后就会被销毁</p>
<h4 id="autoreleasing-修饰符"><a href="#autoreleasing-修饰符" class="headerlink" title="_autoreleasing 修饰符"></a>_autoreleasing 修饰符</h4><p>ARC有效时，要通过将对象赋值给附加了__autoreleaseing修饰符的变量来替代调用autorelease方法，对象赋值给附有__autoreleaseing修饰符的变量等价于在ARC无效时调用对象的autorelease方法，即对象被注册到autoreleasepool中</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-built_in">NSAutoreleasePool</span> *pool = [[<span class="hljs-built_in">NSAutoreleasePool</span> alloc] init];<br>[obj autorelease];<br><br>[pool drain];<br></code></pre></td></tr></table></figure>
<p>等价于</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">@autoreleasepool</span>&#123;<br>    <span class="hljs-keyword">id</span> __autoreleasing obj2;<br>    obj2 = obj;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="MRC-Manual-Reference-Counting"><a href="#MRC-Manual-Reference-Counting" class="headerlink" title="MRC(Manual Reference Counting)"></a>MRC(Manual Reference Counting)</h2><h4 id="dealloc"><a href="#dealloc" class="headerlink" title="dealloc"></a>dealloc</h4><p>[super dealloc];一定在最后一行<br>不能直接调用<br>一旦对象被回收，继续使用会野指针</p>
<h4 id="野指针-amp-空指针"><a href="#野指针-amp-空指针" class="headerlink" title="野指针 &amp; 空指针"></a>野指针 &amp; 空指针</h4><ul>
<li>野指针即一个指针指向了“僵尸对象（不能再使用的对象）”</li>
<li>给野指针发消息报错：EXC_BAD_ACCESS</li>
<li>避免野指针发消息报错，对象释放后，将指针置为空指针<br>  空指针即没有指向任何存储空间（存的nil）<br>  向空指针发送消息没有任何反应</li>
</ul>
<h4 id="MRC-property参数"><a href="#MRC-property参数" class="headerlink" title="MRC @property参数"></a>MRC @property参数</h4><p>成员变量前加上@property，自动生成基本的setter/getter<br>property加上retain，自动生成有内存管理的setter/getter<br>property加上assign，自动生成基本的setter/getter，默认什么都不加就是assign</p>
<h4 id="MRC-循环引用"><a href="#MRC-循环引用" class="headerlink" title="MRC 循环引用"></a>MRC 循环引用</h4><p>当两端互相引用时，应该一端用retain，一端用assign</p>
<h4 id="autoreleasepool"><a href="#autoreleasepool" class="headerlink" title="autoreleasepool"></a>autoreleasepool</h4><ul>
<li>[p autorelease] 给p发送一条autorelease消息，将p放到autoreleasepool，在autoreleasepool释放时做一次release操作</li>
<li>autorelease方法返回对象本身，引用计数不会变化</li>
</ul>
<h4 id="autoreleasepool-注意"><a href="#autoreleasepool-注意" class="headerlink" title="autoreleasepool 注意"></a>autoreleasepool 注意</h4><p>并不是放到autoreleasepool代码中,都会自动加入到自动释放池</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">@autoreleasepool</span> &#123;<br>    <span class="hljs-comment">// 因为没有调用 autorelease 方法,所以对象没有加入到自动释放池</span><br>    Person *p = [[Person alloc] init];<br>    [p run];<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>autorelease是一个方法, 只有在autoreleasepool中调用才有效</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><br><span class="hljs-keyword">@autoreleasepool</span> &#123;<br>&#125;<br><span class="hljs-comment">// 没有与之对应的自动释放池, 只有在自动释放池中调用autorelease才会放到释放池</span><br>Person *p = [[[Person alloc] init] autorelease];<br>[p run];<br><br><span class="hljs-comment">// 正确写法</span><br><span class="hljs-keyword">@autoreleasepool</span> &#123;<br>    Person *p = [[[Person alloc] init] autorelease];<br> &#125;<br><br><span class="hljs-comment">// 正确写法</span><br>Person *p = [[Person alloc] init];<br><span class="hljs-keyword">@autoreleasepool</span> &#123;<br>    [p autorelease];<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h4 id="autoreleasepool-循环"><a href="#autoreleasepool-循环" class="headerlink" title="autoreleasepool 循环"></a>autoreleasepool 循环</h4><ul>
<li>尽量避免对大内存使用autorelease</li>
<li>不要把for循环放在@autoreleasepool之间，会造成内存峰值上升</li>
</ul>
<h4 id="autoreleasepool-错误用法"><a href="#autoreleasepool-错误用法" class="headerlink" title="autoreleasepool 错误用法"></a>autoreleasepool 错误用法</h4><p>不能连续调用autorelease<br>调用autorelease后又调用release</p>
<h2 id="ARC-Automatic-Reference-Counting"><a href="#ARC-Automatic-Reference-Counting" class="headerlink" title="ARC(Automatic Reference Counting)"></a>ARC(Automatic Reference Counting)</h2><p>ARC自动引用计数内存管理，通过编译器（Clang Complier），本质上还是会使用到retain、release等关键字方法，只是不是开发者手动添加，而是编译器在编译过程中添加retain、release等关键字方法到相应的代码行。</p>
<p><img src="https://developer.apple.com/library/content/releasenotes/ObjectiveC/RN-TransitioningToARC/Art/ARC_Illustration.jpg" alt="ARC"></p>
<h3 id="ARC-property"><a href="#ARC-property" class="headerlink" title="ARC @property"></a>ARC @property</h3><ul>
<li>strong : 用于OC对象，相当于MRC中的retain</li>
<li>weak : 用于OC对象，相当于MRC中的assign</li>
<li>assign : 用于基本数据类型，跟MRC中的assign一样</li>
</ul>
<h3 id="ARC-注意"><a href="#ARC-注意" class="headerlink" title="ARC 注意"></a>ARC 注意</h3><p>不能调用release<br>不能调用autorelease<br>不能调用[super dealloc]</p>
<h3 id="NSThread-amp-NSRunLoop-amp-NSAutoreleasePool"><a href="#NSThread-amp-NSRunLoop-amp-NSAutoreleasePool" class="headerlink" title="NSThread &amp; NSRunLoop &amp; NSAutoreleasePool"></a>NSThread &amp; NSRunLoop &amp; NSAutoreleasePool</h3><ul>
<li>1、每个线程（包括主线程）都拥有一个专属的NSRunLoop，并在需要时自动创建</li>
<li>2、主线程的NSRunLoop对象（包括系统级别的其它线程）的每个event loop开始前，自动创建一个autoreleasepool，并在event loop结束时drain</li>
<li>3、每个autoreleasepool对应且只对应一个线程</li>
</ul>
<h3 id="需要手动添加autoreleasepool的情况"><a href="#需要手动添加autoreleasepool的情况" class="headerlink" title="需要手动添加autoreleasepool的情况"></a>需要手动添加autoreleasepool的情况</h3><ul>
<li>编写的程序不是基于UI框架的，比如命令行工具</li>
<li>编写的循环中创建了大量的临时对象</li>
<li>创建了一个辅助线程</li>
</ul>
<h2 id="内存管理的实际应用"><a href="#内存管理的实际应用" class="headerlink" title="内存管理的实际应用"></a>内存管理的实际应用</h2><h3 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h3><ul>
<li>1、YYKit ：解决循环中创建的大量临时对象</li>
<li>2、AFNetworking： 创建了辅助线程</li>
<li>3、XX会 混编时， 标注MRC文件：-fno-objc-arc</li>
</ul>
<h3 id="ARC-实例"><a href="#ARC-实例" class="headerlink" title="ARC 实例"></a>ARC 实例</h3><ul>
<li>1、ARC想要主动释放，最好是提前置为nil</li>
<li>2、ARC下获取引用计数<br>  KVC [obj valueForKey:@”retainCount”]<br>  私有API _objc_rootRetainCount(obj)<br>  CFGetRetainCount((__bridge CFTypeRef)(obj))</li>
</ul>
<h3 id="MRC-实例"><a href="#MRC-实例" class="headerlink" title="MRC 实例"></a>MRC 实例</h3><h4 id="NSString的引用计数是随机值，NSMutableString的引用计数是正常值"><a href="#NSString的引用计数是随机值，NSMutableString的引用计数是正常值" class="headerlink" title="NSString的引用计数是随机值，NSMutableString的引用计数是正常值"></a>NSString的引用计数是随机值，NSMutableString的引用计数是正常值</h4><blockquote>
<p>NSString的class是__NSCFConstantString，字符串常量<br>NSMutableString的class是__NSCFString，有引用计数</p>
</blockquote>
<h4 id="对于字符串常量、NSNumber做常量时"><a href="#对于字符串常量、NSNumber做常量时" class="headerlink" title="对于字符串常量、NSNumber做常量时?"></a>对于字符串常量、NSNumber做常量时?</h4><blockquote>
<p>retain 和 release都不会有影响，因为系统不会回收，也不会对其做引用计数</p>
</blockquote>
<h4 id="stringWithFormat创建的string"><a href="#stringWithFormat创建的string" class="headerlink" title="stringWithFormat创建的string?"></a>stringWithFormat创建的string?</h4><blockquote>
<p>为变量，所以会有引用计数<br>现在返回的已经是常量，见后面的例子</p>
</blockquote>
<h4 id="stringWithString创建的string"><a href="#stringWithString创建的string" class="headerlink" title="stringWithString创建的string?"></a>stringWithString创建的string?</h4><blockquote>
<p>取决于它后面的string对象，如果是常量则不做计数，如果是变量则做计数</p>
</blockquote>
<h4 id="除了alloc-new-copy-mutableCopy-retain显示增加retainCount以外还有哪些看不到的能够增加引用计数的操作？"><a href="#除了alloc-new-copy-mutableCopy-retain显示增加retainCount以外还有哪些看不到的能够增加引用计数的操作？" class="headerlink" title="除了alloc new copy mutableCopy retain显示增加retainCount以外还有哪些看不到的能够增加引用计数的操作？"></a>除了alloc new copy mutableCopy retain显示增加retainCount以外还有哪些看不到的能够增加引用计数的操作？</h4><blockquote>
<p>容器类array、dic addObject；release时，里面的成员都会release一次，和autorelease pool一致<br>addsubview, 因为view有栈(subviews)，加入栈中retainCount+1<br>navcontroller的push, 因为nav有栈(viewcontrollers)，加入栈中retainCount+1<br>performSelector 调用时target和info都会加1，结束时减1</p>
</blockquote>
<h4 id="苹果不推荐使用retainCount方法，因为他对程序本身没有作用，retainCount可能永远不会反回0，有时候系统会优化对象的释放行为，在保留计数还是1的时候就释放了。"><a href="#苹果不推荐使用retainCount方法，因为他对程序本身没有作用，retainCount可能永远不会反回0，有时候系统会优化对象的释放行为，在保留计数还是1的时候就释放了。" class="headerlink" title="苹果不推荐使用retainCount方法，因为他对程序本身没有作用，retainCount可能永远不会反回0，有时候系统会优化对象的释放行为，在保留计数还是1的时候就释放了。"></a>苹果不推荐使用retainCount方法，因为他对程序本身没有作用，retainCount可能永远不会反回0，有时候系统会优化对象的释放行为，在保留计数还是1的时候就释放了。</h4><h4 id="retainCount-关于NSString和NSMutableString的例子"><a href="#retainCount-关于NSString和NSMutableString的例子" class="headerlink" title="retainCount 关于NSString和NSMutableString的例子"></a>retainCount 关于NSString和NSMutableString的例子</h4><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">// 1</span><br>   <span class="hljs-built_in">NSMutableString</span> *str = [[<span class="hljs-built_in">NSMutableString</span> alloc] init];<br>   <span class="hljs-built_in">NSMutableString</span> *str2 = [[<span class="hljs-built_in">NSMutableString</span> alloc] init];<br>   <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%ld, %ld&quot;</span>, [str retainCount], [str2 retainCount]);<span class="hljs-comment">//1,1</span><br>   <br>   str2 = [str <span class="hljs-keyword">copy</span>];         <span class="hljs-comment">//copy返回一个不可变对象属于常量</span><br>   <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%ld, %ld&quot;</span>, [str retainCount], [str2 retainCount]);<span class="hljs-comment">//1,-1</span><br></code></pre></td></tr></table></figure>

<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">// 2</span><br><span class="hljs-built_in">NSString</span> *str = [[<span class="hljs-built_in">NSString</span> alloc] init];<br><span class="hljs-built_in">NSString</span> *str2 = [[<span class="hljs-built_in">NSString</span> alloc] init];<br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%ld, %ld&quot;</span>, [str retainCount], [str2 retainCount]); <span class="hljs-comment">//-1,-1</span><br><br>str2 = [str <span class="hljs-keyword">copy</span>];<br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%ld, %ld&quot;</span>, [str retainCount], [str2 retainCount]);<span class="hljs-comment">//-1,-1</span><br></code></pre></td></tr></table></figure>

<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">// 3</span><br><span class="hljs-built_in">NSString</span> *str = [[<span class="hljs-built_in">NSString</span> alloc] initWithFormat:<span class="hljs-string">@&quot;abc%@&quot;</span>, <span class="hljs-string">@&quot;hehe&quot;</span>];<br><span class="hljs-built_in">NSString</span> *str2 = [[<span class="hljs-built_in">NSString</span> alloc] initWithFormat:<span class="hljs-string">@&quot;bbc%@&quot;</span>, <span class="hljs-string">@&quot;hehe&quot;</span>];<br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%ld, %ld&quot;</span>, [str retainCount], [str2 retainCount]); <span class="hljs-comment">//-1,-1</span><br><br>str2 = [str mutableCopy];<br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%ld, %ld&quot;</span>, [str retainCount], [str2 retainCount]);<span class="hljs-comment">//-1,1</span><br></code></pre></td></tr></table></figure>

<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://hit-alibaba.github.io/interview/basic/arch/Memory-Management.html">阿里面试基础</a><br><a href="http://zhoulingyu.com/2017/02/15/Advanced-iOS-Study-objc-Memory-2/"></a><br><a href="http://yolynn.com/2015/07/20/ios_arc_mrc/">内存管理基础到进阶</a></p>
]]></content>
      <categories>
        <category>iOS进阶</category>
      </categories>
      <tags>
        <tag>堆 栈 RetainCount</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS面试笔记 （上）</title>
    <url>/2015/07/23/interview-note/</url>
    <content><![CDATA[<p>本文是 看了github上 《招聘一个靠谱的iOS程序员》提供的面试题之后做的一些总结，内容大多为其中的一些摘抄。</p>
<a id="more"></a>

<h3 id="1、枚举的定义"><a href="#1、枚举的定义" class="headerlink" title="1、枚举的定义"></a>1、枚举的定义</h3><pre><code>NS_ENUM和NS_OPTIONS本质是一样的，仅仅从字面上来区分其用途。NS_ENUM是通用情况，NS_OPTIONS一般用来定义具有位移操作或特点的情况（bitmask)。
typedef NS_ENUM(NSInteger, UIViewAnimationTransition) &#123;  
UIViewAnimationTransitionNone,//默认从0开始  
UIViewAnimationTransitionFlipFromLeft,  
UIViewAnimationTransitionFlipFromRight,  
UIViewAnimationTransitionCurlUp,  
UIViewAnimationTransitionCurlDown,  
&#125;;  

typedef NS_OPTIONS(NSUInteger, UIViewAutoresizing) &#123;  
    UIViewAutoresizingNone                 = 0,  
    UIViewAutoresizingFlexibleLeftMargin   = 1 &lt;&lt; 0,  
    UIViewAutoresizingFlexibleWidth        = 1 &lt;&lt; 1,  
    UIViewAutoresizingFlexibleRightMargin  = 1 &lt;&lt; 2,  
    UIViewAutoresizingFlexibleTopMargin    = 1 &lt;&lt; 3,  
    UIViewAutoresizingFlexibleHeight       = 1 &lt;&lt; 4,  
    UIViewAutoresizingFlexibleBottomMargin = 1 &lt;&lt; 5  
&#125;;</code></pre>
<h3 id="2、方法名中间的连词"><a href="#2、方法名中间的连词" class="headerlink" title="2、方法名中间的连词"></a>2、方法名中间的连词</h3><pre><code>//错误，不要使用&quot;and&quot;来连接参数
- (int)runModalForDirectory:(NSString *)path andFile:    (NSString *)name andTypes:(NSArray *)fileTypes;
//错误，不要使用&quot;and&quot;来阐明有多个参数
- (instancetype)initWithName:(CGFloat)width andAge:    (CGFloat)height;
//正确，使用&quot;and&quot;来表示两个相对独立的操作
- (BOOL)openFile:(NSString *)fullPath withApplication:    (NSString *)appName andDeactivate:(BOOL)flag;</code></pre>
<h3 id="3、编程规范的问题"><a href="#3、编程规范的问题" class="headerlink" title="3、编程规范的问题"></a>3、编程规范的问题</h3><pre><code>在-和(void)之间应该有一个空格
enum 中驼峰命名法和下划线命名法混用错误：枚举类型的命名规则和函数的    命名规则相同：命名时使用驼峰命名法，勿使用下划线命名法。
enum 左括号前加一个空格，或者将左括号换到下一行
enum 右括号后加一个空格
UserModel :NSObject 应为UserModel : NSObject，也就是:右侧少    了一个空格。
@interface 与 @property 属性声明中间应当间隔一行。
两个方法定义之间不需要换行，有时为了区分方法的功能也可间隔一行，但示    例代码中间隔了两行。
-(id)initUserModelWithUserName: (NSString*)name withAge:    (int)age;方法中方法名与参数之间多了空格。而且 - 与 (id) 之间少了    空格。
-(id)initUserModelWithUserName: (NSString*)name withAge:    (int)age;方法中方法名与参数之间多了空格：(NSString*)name 前多了    空格。
-(id)initUserModelWithUserName: (NSString*)name withAge:    (int)age; 方法中 (NSString*)name,应为 (NSString *)name，少    了空格。</code></pre>
<h3 id="4、什么情况使用-weak-关键字，相比-assign-有什么不同？"><a href="#4、什么情况使用-weak-关键字，相比-assign-有什么不同？" class="headerlink" title="4、什么情况使用 weak 关键字，相比 assign 有什么不同？"></a>4、什么情况使用 weak 关键字，相比 assign 有什么不同？</h3><pre><code>什么情况使用 weak 关键字？

在 ARC 中,在有可能出现循环引用的时候,往往要通过让其中一端使用 weak     来解决,比如: delegate 代理属性

自身已经对它进行一次强引用,没有必要再强引用一次,此时也会使用 weak,    自定义 IBOutlet 控件属性一般也使用 weak；当然，也可以使用    strong。在下文也有论述：《IBOutlet连出来的视图属性为什么可以被设    置成weak?》

不同点：
weak 此特质表明该属性定义了一种非拥有关系 (nonowning     relationship)。为这种属性设置新值时，设置方法既不保留新值，也不释    放旧值。此特质同assign类似， 然而在属性所指的对象遭到摧毁时，属性值    也会清空(nil out)。 而 assign 的“设置方法”只会执行针对纯量类    型” (scalar type，例如 CGFloat 或 NSlnteger 等)的简赋值操    。
assigin 可以用非 OC 对象,而 weak 必须用于 OC 对象</code></pre>
<h3 id="5、怎么用-copy-关键字？"><a href="#5、怎么用-copy-关键字？" class="headerlink" title="5、怎么用 copy 关键字？"></a>5、怎么用 copy 关键字？</h3><pre><code>1、block使用copy
    block 使用 copy 是从 MRC 遗留下来的“传统”,在 MRC 中,方法内部的 block 是在栈区的,使用 copy 可以把它放到堆区.在 ARC 中写不写都行对于 block 使用 copy 还是 strong 效果是一样的
使用copy的意义：
    编译器自动对 block 进行了 copy 操作。如果不写 copy ，该类的调用者有可能会忘记或者根本不知道“编译器会自动对 block 进行了 copy 操作”，他们有可能会在调用之前自行拷贝属性值。这种操作多余而低效。</code></pre>
<p><img src="https://camo.githubusercontent.com/8a5fa34435801cc4c2715d8880f3abd45be6a6c5/687474703a2f2f692e696d6775722e636f6d2f566c564b6c384c2e706e67" alt="Mou icon"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">下面做下解释： copy 此特质所表达的所属关系与 strong 类似。然而设置方法并不保留新值，而是将其“拷贝” (copy)。 当属性类型为 NSString 时，经常用此特质来保护其封装性，因为传递给设置方法的新值有可能指向一个 NSMutableString 类的实例。这个类是 NSString 的子类，表示一种可修改其值的字符串，此时若是不拷贝字符串，那么设置完属性之后，字符串的值就可能会在对象不知情的情况下遭人更改。所以，这时就要拷贝一份“不可变” (immutable)的字符串，确保对象中的字符串值不会无意间变动。只要实现属性所用的对象是“可变的” (mutable)，就应该在设置新属性值时拷贝一份。<br>用 @property 声明 NSString、NSArray、NSDictionary 经常使用 copy 关键字，是因为他们有对应的可变类型：NSMutableString、NSMutableArray、NSMutableDictionary，他们之间可能进行赋值操作，为确保对象中的字符串值不会无意间变动，应该在设置新属性值时拷贝一份。<br></code></pre></td></tr></table></figure>
<h3 id="6、这个写法会出什么问题：-property-copy-NSMutableArray-array"><a href="#6、这个写法会出什么问题：-property-copy-NSMutableArray-array" class="headerlink" title="6、这个写法会出什么问题： @property (copy) NSMutableArray *array;"></a>6、这个写法会出什么问题： @property (copy) NSMutableArray *array;</h3><pre><code>两个问题：1、添加,删除,修改数组内的元素的时候,程序会因为找不到对应的方法而崩溃.因为 copy 就是复制一个不可变 NSArray 的对象；2、使用了 atomic 属性会严重影响性能 ；
1、NSMutableArray *array = [NSMutableArray                                 arrayWithObjects:@1,@2,nil];
    self.mutableArray = array;
    [self.mutableArray removeObjectAtIndex:0];
    执行会崩溃
2、该属性使用了同步锁，会在创建时生成一些额外的代码用于帮助编写多线程程序，这会带来性能问题，通过声明 nonatomic 可以节省这些虽然很小但是不必要额外开销</code></pre>
<h3 id="7、-property-的本质是什么？ivar、getter、setter-是如何生成并添加到这个类中的"><a href="#7、-property-的本质是什么？ivar、getter、setter-是如何生成并添加到这个类中的" class="headerlink" title="7、@property 的本质是什么？ivar、getter、setter 是如何生成并添加到这个类中的"></a>7、@property 的本质是什么？ivar、getter、setter 是如何生成并添加到这个类中的</h3><pre><code>@property 的本质是什么？
@property = ivar + getter + setter;
下面解释下：
“属性” (property)有两大概念：ivar（实例变量）、存取方法（access method ＝ getter + setter）。
ivar、getter、setter 是如何生成并添加到这个类中的?
“自动合成”( autosynthesis)

完成属性定义后，编译器会自动编写访问这些属性所需的方法，此过程叫做“自动合成”(autosynthesis)。需要强调的是，这个过程由编译 器在编译期执行，所以编辑器里看不到这些“合成方法”(synthesized method)的源代码。除了生成方法代码 getter、setter 之外，编译器还要自动向类中添加适当类型的实例变量，并且在属性名前面加下划线，以此作为实例变量的名字。在前例中，会生成两个实例变量，其名称分别为 _firstName 与 _lastName。也可以在类的实现代码里通过 @synthesize 语法来指定实例变量的名字.
@implementation Person
@synthesize firstName = _myFirstName;
@synthesize lastName = _myLastName;
@end
我为了搞清属性是怎么实现的,曾经反编译过相关的代码,他大致生成了五个东西

OBJC_IVAR_$类名$属性名称 ：该属性的“偏移量” (offset)，这个偏移    量是“硬编码” (hardcode)，表示该变量距离存放对象的内存区域的起始地    址有多远。
setter 与 getter 方法对应的实现函数
ivar_list ：成员变量列表
method_list ：方法列表
prop_list ：属性列表
也就是说我们每次在增加一个属性,系统都会在 ivar_list 中添加一个成员变量的描述,在 method_list 中增加 setter 与 getter 方法的描述,在属性列表中增加一个属性的描述,然后计算该属性在对象中的偏移量,然后给出 setter 与 getter 方法对应的实现,在 setter 方法中从偏移量的位置开始赋值,在 getter 方法中从偏移量开始取值,为了能够读取正确字节数,系统对象偏移量的指针类型进行了类型强转.</code></pre>
<h3 id="8-protocol-和-category-中如何使用-property"><a href="#8-protocol-和-category-中如何使用-property" class="headerlink" title="8 @protocol 和 category 中如何使用 @property"></a>8 @protocol 和 category 中如何使用 @property</h3><pre><code>1、在 protocol 中使用 property 只会生成 setter 和 getter 方法声明,我们使用属性的目的,是希望遵守我协议的对象能实现该属性
2、category 使用 @property 也是只会生成 setter 和 getter 方法的声明,如果我们真的需要给 category 增加属性的实现,需要借助于运行时的两个函数：

objc_setAssociatedObject
objc_getAssociatedObject</code></pre>
<h3 id="10-property中有哪些属性关键字？-property-后面可以有哪些修饰符？"><a href="#10-property中有哪些属性关键字？-property-后面可以有哪些修饰符？" class="headerlink" title="10  @property中有哪些属性关键字？ @property 后面可以有哪些修饰符？"></a>10  @property中有哪些属性关键字？ @property 后面可以有哪些修饰符？</h3><pre><code>1、原子性--- nonatomic 特质
2、读/写权限---readwrite(读写)、readonly (只读)
3、内存管理语义---assign、strong、 weak、unsafe_unretained、copy
4、方法名---getter=&lt;name&gt; 、setter=&lt;name&gt;

        getter=&lt;name&gt;的样式：

  @property (nonatomic, getter=isOn) BOOL on;

  setter=&lt;name&gt;一般用在特殊的情境下，比如：
      在数据反序列化、转模型的过程中，服务器返回的字段如果以 init 开头，所以你需要定义一个 init 开头的属性，但默认生成的 setter 与 getter 方法也会以 init 开头，而编译器会把所有以 init 开头的方法当成初始化方法，而初始化方法只能返回 self 类型，因此编译器会报错。
      避免方法：
      @property(nonatomic, strong, getter=p_initBy, setter=setP_initBy:)NSString *initBy;</code></pre>
<h3 id="11、weak属性需要在dealloc中置nil么？"><a href="#11、weak属性需要在dealloc中置nil么？" class="headerlink" title="11、weak属性需要在dealloc中置nil么？"></a>11、weak属性需要在dealloc中置nil么？</h3><pre><code>不需要
在ARC环境无论是强指针还是弱指针都无需在 dealloc 设置为 nil ， ARC 会自动帮我们处理
在属性所指的对象遭到摧毁时，属性值也会清空(nil out)。</code></pre>
<h3 id="12、-synthesize和-dynamic分别有什么作用？"><a href="#12、-synthesize和-dynamic分别有什么作用？" class="headerlink" title="12、 @synthesize和@dynamic分别有什么作用？"></a>12、 @synthesize和@dynamic分别有什么作用？</h3><pre><code>@property有两个对应的词，一个是 @synthesize，一个是 @dynamic。如果 @synthesize和 @dynamic都没写，那么默认的就是@syntheszie var = _var;
@synthesize 的语义是如果你没有手动实现 setter 方法和 getter 方法，那么编译器会自动为你加上这两个方法。
@dynamic 告诉编译器：属性的 setter 与 getter 方法由用户自己实现，不自动生成。（当然对于 readonly 的属性只需提供 getter 即可）。假如一个属性被声明为 @dynamic var，然后你没有提供 @setter方法和 @getter 方法，编译的时候没问题，但是当程序运行到 instance.var = someVar，由于缺 setter 方法会导致程序崩溃；或者当运行到 someVar = var 时，由于缺 getter 方法同样会导致崩溃。编译时没问题，运行时才执行相应的方法，这就是所谓的动态绑定。</code></pre>
<h3 id="13、ARC下，不显式指定任何属性关键字时，默认的关键字都有哪些"><a href="#13、ARC下，不显式指定任何属性关键字时，默认的关键字都有哪些" class="headerlink" title="13、ARC下，不显式指定任何属性关键字时，默认的关键字都有哪些"></a>13、ARC下，不显式指定任何属性关键字时，默认的关键字都有哪些</h3><pre><code>1、对应基本数据类型默认关键字是

atomic,readwrite,assign

2、对于普通的 Objective-C 对象

atomic,readwrite,strong</code></pre>
<h3 id="14、用-property声明的NSString（或NSArray，NSDictionary）经常使用copy关键字，为什么？如果改用strong关键字，可能造成什么问题"><a href="#14、用-property声明的NSString（或NSArray，NSDictionary）经常使用copy关键字，为什么？如果改用strong关键字，可能造成什么问题" class="headerlink" title="14、用@property声明的NSString（或NSArray，NSDictionary）经常使用copy关键字，为什么？如果改用strong关键字，可能造成什么问题"></a>14、用@property声明的NSString（或NSArray，NSDictionary）经常使用copy关键字，为什么？如果改用strong关键字，可能造成什么问题</h3><pre><code>1、因为父类指针可以指向子类对象,使用 copy 的目的是为了让本对象的属性不受外界影响,使用 copy 无论给我传入是一个可变对象还是不可对象,我本身持有的就是一个不可变的副本.
2、如果我们使用是 strong ,那么这个属性就有可能指向一个可变对象,如果这个可变对象在外部被修改了,那么会影响该属性.
对非集合类对象的copy操作：
[immutableObject copy] // 浅复制
[immutableObject mutableCopy] //深复制
[mutableObject copy] //深复制
[mutableObject mutableCopy] //深复制
集合类对象的copy与mutableCopy：
[immutableObject copy] // 浅复制
[immutableObject mutableCopy] //单层深复制
[mutableObject copy] //单层深复制
[mutableObject mutableCopy] //单层深复制
在集合类对象中，对 immutable 对象进行 copy，是指针复制， mutableCopy 是内容复制；对 mutable 对象进行 copy 和 mutableCopy 都是内容复制。但是：集合对象的内容复制仅限于对象本身，对象元素仍然是指针复制</code></pre>
<h3 id="15、-synthesize合成实例变量的规则是什么？假如property名为foo，存在一个名为-foo的实例变量，那么还会自动合成新变量么？"><a href="#15、-synthesize合成实例变量的规则是什么？假如property名为foo，存在一个名为-foo的实例变量，那么还会自动合成新变量么？" class="headerlink" title="15、@synthesize合成实例变量的规则是什么？假如property名为foo，存在一个名为_foo的实例变量，那么还会自动合成新变量么？"></a>15、@synthesize合成实例变量的规则是什么？假如property名为foo，存在一个名为_foo的实例变量，那么还会自动合成新变量么？</h3><p>.h</p>
<pre><code>@interface CYLPerson : NSObject 
@property NSString *firstName; 
@property NSString *lastName; 
@end</code></pre>
<p>在上例中，会生成两个实例变量，其名称分别为 _firstName 与 _lastName。也可以在类的实现代码里通过 @synthesize 语法来指定实例变量的名字:<br>.m</p>
<pre><code>@implementation CYLPerson 
@synthesize firstName = _myFirstName; 
@synthesize lastName = _myLastName; 
@end</code></pre>
<p>上述语法会将生成的实例变量命名为 _myFirstName 与 _myLastName ，而不再使用默认的名字</p>
<p>@synthesize 合成实例变量的规则:</p>
<pre><code>如果指定了成员变量的名称,会生成一个指定的名称的成员变量,
如果这个成员已经存在了就不再生成了.
如果是 @synthesize foo; 还会生成一个名称为foo的成员变量，也就是说：如果没有指定成员变量的名称会自动生成一个属性同名的成员变量
如果是 @synthesize foo = _foo; 就不会生成成员变量了.</code></pre>
<p>假如 property 名为 foo，存在一个名为 _foo 的实例变量，那么还会自动合成新变量么？</p>
<pre><code>不会，</code></pre>
<p><img src="https://camo.githubusercontent.com/8e11101c9fe0b3defc7fbd144c0dca9fdf0471d0/687474703a2f2f692e696d6775722e636f6d2f743238676534572e706e67" alt="icon"></p>
<h3 id="16、在有了自动合成属性实例变量之后，-synthesize还有哪些使用场景？"><a href="#16、在有了自动合成属性实例变量之后，-synthesize还有哪些使用场景？" class="headerlink" title="16、在有了自动合成属性实例变量之后，@synthesize还有哪些使用场景？"></a>16、在有了自动合成属性实例变量之后，@synthesize还有哪些使用场景？</h3><pre><code>不会autosynthesis的场景：
    同时重写了 setter 和 getter 时
    重写了只读属性的 getter 时
    使用了 @dynamic 时
    在 @protocol 中定义的所有属性
    在 category 中定义的所有属性
    重载的属性
        当你在子类中重载了父类中的属性，你必须 使用 @synthesize             来手动合成ivar。
        在子类中重写父类的属性时，编译的时候会提示问题！！！</code></pre>
<p><img src="https://camo.githubusercontent.com/a569a90281598d8cc74156fe5f0e3a6ddbf8fc6b/687474703a2f2f692e696d6775722e636f6d2f6641454748496f2e706e67" alt="icon"></p>
<pre><code>当你同时重写了 setter 和 getter 时，系统就不会生成 ivar（实例变量/成员变量）。这时候有两种选择
要么如第14行：手动创建 ivar
要么如第17行：使用@synthesize foo = _foo; ，关联 @property 与 ivar。</code></pre>
<h3 id="17、objc中向一个nil对象发送消息将会发生什么"><a href="#17、objc中向一个nil对象发送消息将会发生什么" class="headerlink" title="17、objc中向一个nil对象发送消息将会发生什么"></a>17、objc中向一个nil对象发送消息将会发生什么</h3><pre><code>在 Objective-C 中向 nil 发送消息是完全有效的——只是在运行时不会有任何作用:
1、如果一个方法返回值是一个对象，那么发送给nil的消息将返回0(nil)
2、如果方法返回值为指针类型，其指针大小为小于或者等于sizeof(void*)，float，double，long double 或者 long long 的整型标量，发送给 nil 的消息将返回0
3、如果方法返回值为结构体,发送给 nil 的消息将返回0。结构体中各个字段的值将都是0。
4、如果方法的返回值不是上述提到的几种情况，那么发送给 nil 的消息的返回值将是未定义的。
原因：
objc是动态语言，每个方法在运行时会被动态转为消息发送，即：objc_msgSend(receiver, selector)。

objc在向一个对象发送消息时，runtime库会根据对象的isa指针找到该对象实际所属的类，然后在该类中的方法列表以及其父类方法列表中寻找方法运行，然后在发送消息的时候，objc_msgSend方法不会返回值，所谓的返回内容都是具体调用时执行的。 那么，回到本题，如果向一个nil对象发送消息，首先在寻找对象的isa指针时就是0地址返回了，所以不会出现任何错误。</code></pre>
<h3 id="18、objc中向一个对象发送消息-obj-foo-和objc-msgSend-函数之间有什么关系？"><a href="#18、objc中向一个对象发送消息-obj-foo-和objc-msgSend-函数之间有什么关系？" class="headerlink" title="18、objc中向一个对象发送消息[obj foo]和objc_msgSend()函数之间有什么关系？"></a>18、objc中向一个对象发送消息[obj foo]和objc_msgSend()函数之间有什么关系？</h3><pre><code>该方法编译之后就是objc_msgSend()函数调用
[obj foo];在objc动态编译时，会被转意为：objc_msgSend(obj,     @selector(foo));。
    int main(int argc, char * argv[]) &#123;
    @autoreleasepool &#123;
        CYLTest *test = [[CYLTest alloc] init];
        [test performSelector:(@selector(iOSinit))];
        return 0;
    &#125;
&#125;
具体实现：</code></pre>
<p><img src="https://camo.githubusercontent.com/bf346edc21ab4b3387906602249b357d250ab1c2/687474703a2f2f692e696d6775722e636f6d2f6541483559576e2e706e67" alt="icon"></p>
<h3 id="12、-什么时候会报unrecognized-selector的异常？"><a href="#12、-什么时候会报unrecognized-selector的异常？" class="headerlink" title="12、 什么时候会报unrecognized selector的异常？"></a>12、 什么时候会报unrecognized selector的异常？</h3><pre><code>当调用该对象上某个方法,而该对象上没有实现这个方法的时候， 可以通过“消息转发”进行解决。
objc是动态语言，每个方法在运行时会被动态转为消息发送，即：objc_msgSend(receiver, selector)。
objc在向一个对象发送消息时，runtime库会根据对象的isa指针找到该对象实际所属的类，然后在该类中的方法列表以及其父类方法列表中寻找方法运行，如果，在最顶层的父类中依然找不到相应的方法时，程序在运行时会挂掉并抛出异常unrecognized selector sent to XXX 。但是在这之前，objc的运行时会给出三次拯救程序崩溃的机会：</code></pre>
<p>1、Method resolution</p>
<pre><code>objc运行时会调用+resolveInstanceMethod:或者 +resolveClassMethod:，让你有机会提供一个函数实现。如果你添加了函数，那运行时系统就会重新启动一次消息发送的过程，否则 ，运行时就会移到下一步，消息转发（Message Forwarding）。</code></pre>
<p>2、Fast forwarding</p>
<pre><code>如果目标对象实现了-forwardingTargetForSelector:，Runtime 这时就会调用这个方法，给你把这个消息转发给其他对象的机会。 只要这个方法返回的不是nil和self，整个消息发送的过程就会被重启，当然发送的对象会变成你返回的那个对象。否则，就会继续Normal Fowarding。 这里叫Fast，只是为了区别下一步的转发机制。因为这一步不会创建任何新的对象，但下一步转发会创建一个NSInvocation对象，所以相对更快点。</code></pre>
<p>3、Normal forwarding</p>
<pre><code>这一步是Runtime最后一次给你挽救的机会。首先它会发送-methodSignatureForSelector:消息获得函数的参数和返回值类型。如果-methodSignatureForSelector:返回nil，Runtime则会发出-doesNotRecognizeSelector:消息，程序这时也就挂掉了。如果返回了一个函数签名，Runtime就会创建一个NSInvocation对象并发送-forwardInvocation:消息给目标对象。</code></pre>
<h3 id="13、一个objc对象如何进行内存布局？（考虑有父类的情况）"><a href="#13、一个objc对象如何进行内存布局？（考虑有父类的情况）" class="headerlink" title="13、一个objc对象如何进行内存布局？（考虑有父类的情况）"></a>13、一个objc对象如何进行内存布局？（考虑有父类的情况）</h3><pre><code>所有父类的成员变量和自己的成员变量都会存放在该对象所对应的存储空间中.
每一个对象内部都有一个isa指针,指向他的类对象,类对象中存放着本对象的
    对象方法列表（对象能够接收的消息列表，保存在它所对应的类对象中）
    成员变量的列表,
    属性列表,
它内部也有一个isa指针指向元对象(meta class),元对象内部存放的是类方法列表,类对象内部还有一个superclass的指针,指向他的父类对象</code></pre>
<p><img src="https://camo.githubusercontent.com/cdc02fffae7a70aa00cbb6c0f3675d00728cdaad/687474703a2f2f692e696d6775722e636f6d2f7736747a46787a2e706e67" alt="icon"></p>
<h3 id="14、一个objc对象的isa的指针指向什么？有什么作用？"><a href="#14、一个objc对象的isa的指针指向什么？有什么作用？" class="headerlink" title="14、一个objc对象的isa的指针指向什么？有什么作用？"></a>14、一个objc对象的isa的指针指向什么？有什么作用？</h3><pre><code>指向他的类对象,从而可以找到对象上的方法</code></pre>
<h3 id="15、下面的代码输出什么？"><a href="#15、下面的代码输出什么？" class="headerlink" title="15、下面的代码输出什么？"></a>15、下面的代码输出什么？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">@implementation Son : Father<br>    - (id)init<br>    &#123;<br>        self &#x3D; [super init];<br>        if (self) &#123;<br>            NSLog(@&quot;%@&quot;, NSStringFromClass([self class]));<br>            NSLog(@&quot;%@&quot;, NSStringFromClass([super class]));<br>        &#125;<br>        return self;<br>    &#125;<br>    @end<br></code></pre></td></tr></table></figure>
<pre><code>都输出 Son

这个题目主要是考察关于 Objective-C 中对 self 和 super 的理解。
我们都知道：self 是类的隐藏参数，指向当前调用方法的这个类的实例。那 super 呢？

很多人会想当然的认为“ super 和 self 类似，应该是指向父类的指针吧！”。这是很普遍的一个误区。其实 super 是一个 Magic Keyword， 它本质是一个编译器标示符，和 self 是指向的同一个消息接受者！他们两个的不同点在于：super 会告诉编译器，调用 class 这个方法时，要去父类的方法，而不是本类里的。

上面的例子不管调用[self class]还是[super class]，接受消息的对象都是当前 Son ＊xxx 这个对象。

当使用 self 调用方法时，会从当前类的方法列表中开始找，如果没有，就从父类中再找；而当使用 super 时，则从父类的方法列表中开始找。然后调用父类的这个方法。

这也就是为什么说“不推荐在 init 方法中使用点语法”，如果想访问实例变量 iVar 应该使用下划线（ _iVar ），而非点语法（ self.iVar ）</code></pre>
<h3 id="16、runtime如何通过selector找到对应的IMP地址？（分别考虑类方法和实例方法"><a href="#16、runtime如何通过selector找到对应的IMP地址？（分别考虑类方法和实例方法" class="headerlink" title="16、runtime如何通过selector找到对应的IMP地址？（分别考虑类方法和实例方法"></a>16、runtime如何通过selector找到对应的IMP地址？（分别考虑类方法和实例方法</h3><pre><code>每一个类对象中都一个方法列表,方法列表中记录着方法的名称,方法实现,以及参数类型,其实selector本质就是方法名称,通过这个方法名称就可以在方法列表中找到对应的方法实现.</code></pre>
<h3 id="17、-使用runtime-Associate方法关联的对象，需要在主对象dealloc的时候释放么"><a href="#17、-使用runtime-Associate方法关联的对象，需要在主对象dealloc的时候释放么" class="headerlink" title="17、. 使用runtime Associate方法关联的对象，需要在主对象dealloc的时候释放么"></a>17、. 使用runtime Associate方法关联的对象，需要在主对象dealloc的时候释放么</h3><pre><code>无论在MRC下还是ARC下均不需要。</code></pre>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&#x2F;&#x2F; 对象的内存销毁时间表<br>&#x2F;&#x2F; http:&#x2F;&#x2F;weibo.com&#x2F;luohanchenyilong&#x2F; (微博@iOS程序犭袁)<br>&#x2F;&#x2F; https:&#x2F;&#x2F;github.com&#x2F;ChenYilong<br>&#x2F;&#x2F; 根据 WWDC 2011, Session 322 (36分22秒)中发布的内存销毁时间表 <br><br> 1. 调用 -release ：引用计数变为零<br>     * 对象正在被销毁，生命周期即将结束.<br>     * 不能再有新的 __weak 弱引用， 否则将指向 nil.<br>     * 调用 [self dealloc] <br> 2. 父类 调用 -dealloc<br>     * 继承关系中最底层的父类 在调用 -dealloc<br>     * 如果是 MRC 代码 则会手动释放实例变量们（iVars）<br>     * 继承关系中每一层的父类 都在调用 -dealloc<br> 3. NSObject 调 -dealloc<br>     * 只做一件事：调用 Objective-C runtime 中的 object_dispose() 方法<br> 4. 调用 object_dispose()<br>     * 为 C++ 的实例变量们（iVars）调用 destructors <br>     * 为 ARC 状态下的 实例变量们（iVars） 调用 -release <br>     * 解除所有使用 runtime Associate方法关联的对象<br>     * 解除所有 __weak 引用<br>     * 调用 free()<br></code></pre></td></tr></table></figure>

<h3 id="18、-objc中的类方法和实例方法有什么本质区别和联系？"><a href="#18、-objc中的类方法和实例方法有什么本质区别和联系？" class="headerlink" title="18、 objc中的类方法和实例方法有什么本质区别和联系？"></a>18、 objc中的类方法和实例方法有什么本质区别和联系？</h3><pre><code>类方法：

类方法是属于类对象的
类方法只能通过类对象调用
类方法中的self是类对象
类方法可以调用其他的类方法
类方法中不能访问成员变量
类方法中不定直接调用对象方法

实例方法：
实例方法是属于实例对象的
实例方法只能通过实例对象调用
实例方法中的self是实例对象
实例方法中可以访问成员变量
实例方法中直接调用实例方法
实例方法中也可以调用类方法(通过类名)</code></pre>
<h3 id="9-runtime-如何实现-weak-属性"><a href="#9-runtime-如何实现-weak-属性" class="headerlink" title="9  runtime 如何实现 weak 属性"></a>9  runtime 如何实现 weak 属性</h3><pre><code>weak属性的特点：
weak 此特质表明该属性定义了一种“非拥有关系” (nonowning relationship)。为这种属性设置新值时，设置方法既不保留新值，也不释放旧值。此特质同 assign 类似， 然而在属性所指的对象遭到摧毁时，属性值也会清空(nil out)。</code></pre>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>靠谱的iOS程序员</tag>
      </tags>
  </entry>
  <entry>
    <title>基于响应者链条的事件传递方式</title>
    <url>/2020/07/02/responsechainevent/</url>
    <content><![CDATA[<p>随着业务越来越负责，APP中的页面也变得越来越负责，层级变的越来越深，不论项目是MVC还是MVVM架构，我们都倾向于将事件的处理放到控制器中。随着层级越来越复杂，事件处理方法越来越多，为此我们的解决方案一般都是将部分处理事件放到viewmodel中或者给控制器添加分类。但这些方法都不能避免事件一层层的传递。那么有没有更好的方法呢？</p>
<a id="more"></a>

<p>随着业务越来越负责，APP中的页面也变得越来越负责，层级变的越来越深，不论项目是MVC还是MVVM架构，我们都倾向于将事件的处理放到控制器中。随着层级越来越复杂，事件处理方法越来越多，为此我们的解决方案一般都是将部分处理事件放到viewmodel中或者给控制器添加分类。但这些方法都不能避免事件一层层的传递。那么有没有更好的方法呢？</p>
<p>我们都知道屏幕上的某个按钮被点击之后，系统会先寻找最佳响应者然后在将事件交给最佳响应者去处理。这里我们可以看到其实每个事件的处理，系统也是在通过某些方法去找到一个最佳的响应者，那么我们是否可以利用这个过程呢？</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggn0pu39ooj31080lywgd.jpg" alt="响应者链条"></p>
<p>响应者链的链路是: </p>
<p>subview -&gt; view –&gt; (viewController) –&gt; parentView –&gt; … –&gt; UIWindow –&gt; UIApplication</p>
<p>有没有感觉 这个其实跟我们的事件传递是一样的，我们在处理事件的时候也是想将子视图中的某些响应事件一层一层的传到控制器中，最终在控制器中处理这个事件。</p>
<h2 id="现有的传递方式和弊端"><a href="#现有的传递方式和弊端" class="headerlink" title="现有的传递方式和弊端"></a>现有的传递方式和弊端</h2><p>目前我们事件传递的方式主要有：</p>
<ul>
<li>代理</li>
<li>block</li>
<li>通知</li>
<li>KVO</li>
<li>直接property传值</li>
</ul>
<p>很明显，除了通知其他几种一对一的传递方式，在层次比较深的场景下我们都需要做大量的事件传递，这就导致我们创建了大量的作用相似的block或者代理。</p>
<p>那么到底有没有更好的方法呢？</p>
<p>首先我们再次明确下，我们的目的: <code>优化复杂场景下事件传递方式，简化事件传递时的代码。</code></p>
<p>下面 我们通过下面的例子来具体分析下：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ggn1cvmukhj30je0km0td.jpg" alt="示例"></p>
<p>下面是上图展示视图的层级结构：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ggn1f8szz9j30v00u0jth.jpg" alt="层次结构"></p>
<p>上面的示例中我们有两个按钮，这两个按钮的点击事件我们都需要像外部传递。</p>
<p>下面先来看下传统的方式我们是如何向外部传递的(以delegate为例):</p>
<h3 id="声明协议"><a href="#声明协议" class="headerlink" title="声明协议"></a>声明协议</h3><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-class"><span class="hljs-keyword">@protocol</span> <span class="hljs-title">LWCyanViewDelegate</span> &lt;<span class="hljs-title">NSObject</span>&gt;</span><br><br><span class="hljs-comment">/// 按钮的点击事件</span><br><span class="hljs-comment">/// @param cyanView cyanView description</span><br>- (<span class="hljs-keyword">void</span>)cyanViewButtonDidClick:(LWCyanView *_Nullable)cyanView;<br><br><span class="hljs-keyword">@end</span><br><br></code></pre></td></tr></table></figure>

<h3 id="代理调用"><a href="#代理调用" class="headerlink" title="代理调用"></a>代理调用</h3><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><br>- (<span class="hljs-keyword">void</span>)buttonDidClick &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>.delegate &amp;&amp; [<span class="hljs-keyword">self</span>.delegate respondsToSelector:<span class="hljs-keyword">@selector</span>(cyanViewButtonDidClick:)]) &#123;<br>        [<span class="hljs-keyword">self</span>.delegate cyanViewButtonDidClick:<span class="hljs-keyword">self</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="设置代理"><a href="#设置代理" class="headerlink" title="设置代理"></a>设置代理</h3><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">weak</span>) <span class="hljs-keyword">id</span> &lt;LWCyanViewDelegate&gt; delegate;<br></code></pre></td></tr></table></figure>

<p>按照上面的步骤 我们要在示例中的<br>[purpleView] -&gt; [LWGreenView] -&gt; [LWBlueView] -&gt; [subController.view] -&gt; [ViewController.view] 中每层都要实现上面的三个步骤。</p>
<p>这种实现过于复杂，而我们想要做的只是响应按钮的点击事件。</p>
<p>导致的问题：</p>
<p>由于这种方式需要层层传递，所以有些偷懒的同事就直接将事件的处理放到了view视图里，这样我们就不用传递事件了。但是这将导致更加严重的问题:视图复用。如果这个视图我们需要在其他位置复用，但是点击的响应事件我们不在是之前的那个，这样我们应该如何修改？</p>
<p>还有些同事，不希望层层的实现和调用方法，因此选择将最外层的控制器作为代理 一层层的向内传递。但是这种做法同样存在一些问题，比如控制器遵守了某些层次较深的子视图的协议，但是这些视图实际上并不是直接加载当前控制器视图上的，而且当我们重用这个控制器的某些子视图时 我们不知道要处理那些事件，相反我们必须传递一个代理，但是起初我们是并不知道这个代理需要实现那些方法的。</p>
<p>同时，因为代理的方法如果是<code>required</code>的方法但是未实现时，还会导致方法调用的崩溃。</p>
<p>针对上面使用代理进行事件传递存在的问题,我们希望比较好的事件传递方式应该具备:</p>
<ul>
<li>省略层层的协议声明、代理方法调用、代理的设置</li>
<li>在最外部的控制器中我们可以知道我们需要处理那些方法，以及如何处理</li>
<li>如果外部方法不存在，内部调用时不会导致崩溃</li>
</ul>
<h2 id="如何利用响应者链条进行事件传递"><a href="#如何利用响应者链条进行事件传递" class="headerlink" title="如何利用响应者链条进行事件传递"></a>如何利用响应者链条进行事件传递</h2><h3 id="查找最佳响应者"><a href="#查找最佳响应者" class="headerlink" title="查找最佳响应者"></a>查找最佳响应者</h3><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ggn2npr3bpj312o0sa406.jpg"></p>
<p>查找最佳响应者的过程如上图，而其中最主要依赖的方法是</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-number">1</span>：- (<span class="hljs-keyword">nullable</span> <span class="hljs-built_in">UIView</span> *)hitTest:(<span class="hljs-built_in">CGPoint</span>)point withEvent:(<span class="hljs-keyword">nullable</span> <span class="hljs-built_in">UIEvent</span> *)event;<br><br><span class="hljs-number">2</span>: - (<span class="hljs-built_in">BOOL</span>)pointInside:(<span class="hljs-built_in">CGPoint</span>)point withEvent:(<span class="hljs-keyword">nullable</span> <span class="hljs-built_in">UIEvent</span> *)event;<br></code></pre></td></tr></table></figure>

<p>通过上面方法的递归调用 我们就可以找到某个事件的最佳响应者。</p>
<h3 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h3><p>Application 已经找到了第一响应者对象，接下来 UIWindow 会将封装好的 <code>UIEvent</code> 对象，直接交给第一响应者，让其处理</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ggn2npkq8fj315a0oojt8.jpg"></p>
<p>但是 如果第一响应者选择不处理这个事件，那么这个事件会根据响应者联调一次向上寻找下一个最佳响应者。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ggn2tyyrc4j310n0lhwfu.jpg"></p>
<p>具体过程如上图的左边部分：</p>
<p>当第一响应者不能处理 <code>UIEvent</code> 的时候，事件会被转发给下一个响应者(next Responder)，下一个响应者不能处理，则继续传递给 next Responder ，以此类推下去，便形成了响应者链。<code>UIResponder</code> 的属性 <code>nextResponder</code> 是建立响应者链的桥梁:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">@property</span>(<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">readonly</span>, <span class="hljs-keyword">nullable</span>) <span class="hljs-built_in">UIResponder</span> *nextResponder;<br></code></pre></td></tr></table></figure>

<p>既然当最佳响应者选择不处理某个事件时，系统会自动向上查找下一个最佳响应者。那么我们是否可以利用这个机制来帮我们实现自定义的方法的数据传递。</p>
<p>当A按钮被点击时，我们调用某个方法(方法参数可以确定是A按钮被点击)，如果这个方法没有实现，我们就去调用下一个响应者的这个方法，如果仍未实现那么继续向下查找，直到找到这个方法为止，如果到了<code>UIApplication</code>仍未能处理这个方法，那么直接丢弃。</p>
<p>但是有一个明显的问题，我们的时间传递依赖<code>UIResponder</code>，那如果某些控件不继承自<code>UIResponder</code>呢？</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">Responder objects—that is, instances of <br><span class="hljs-built_in">UIResponder</span>—constitute the event-handling <br>backbone of a <span class="hljs-built_in">UIKit</span> app. Many key objects are also responders, including the <br><span class="hljs-built_in">UIApplication</span> object, <span class="hljs-built_in">UIViewController</span> objects, and all <span class="hljs-built_in">UIView</span> objects (which<br> includes <span class="hljs-built_in">UIWindow</span>). As events occur, <span class="hljs-built_in">UIKit</span> dispatches them to your app<span class="hljs-string">&#x27;s </span><br><span class="hljs-string"> responder objects for handling.</span><br></code></pre></td></tr></table></figure>

<p>从上面的介绍中，我们可以看出我们平时使用的类基本都是继承<code>UIResponder</code>，他是仅次于NSObject的基类存在。</p>
<p>既然不用考虑某些控件可能不继承自UIResponder的问题，那么该如何实现呢？</p>
<h2 id="如何实现利用响应者链条实现事件传递"><a href="#如何实现利用响应者链条实现事件传递" class="headerlink" title="如何实现利用响应者链条实现事件传递"></a>如何实现利用响应者链条实现事件传递</h2><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>因为上面我们说了要利用响应者链条，那么我们先给<code>UIResponder</code>做一个分类</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-built_in">UIResponder</span>+LW.h<br>- (<span class="hljs-keyword">void</span>)routerEventWithName:(<span class="hljs-built_in">NSString</span> *)eventName userInfo:(<span class="hljs-built_in">NSDictionary</span> *)userInfo;<br><br></code></pre></td></tr></table></figure>

<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-built_in">UIResponder</span>+LW..m<br>- (<span class="hljs-keyword">void</span>)routerEventWithName:(<span class="hljs-built_in">NSString</span> *)eventName userInfo:(<span class="hljs-built_in">NSDictionary</span> *)userInfo<br>&#123;<br>    [[<span class="hljs-keyword">self</span> nextResponder] routerEventWithName:eventName userInfo:userInfo];<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这样我们在按钮响应事件时调用分类中的方法</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">- (<span class="hljs-keyword">void</span>)buttonDidClick &#123;<br>    [<span class="hljs-keyword">self</span> routerEventWithName:<span class="hljs-string">@&quot;:LWButton DidClick&quot;</span> userInfo:@&#123;<span class="hljs-string">@&quot;test&quot;</span>:<span class="hljs-string">@&quot;test&quot;</span>&#125;];<br>&#125;<br></code></pre></td></tr></table></figure>

<p>那么这个方法就会顺着相应者链条依次调用，那么到了控制器中我们该如何处理呢？</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">- (<span class="hljs-keyword">void</span>)routerEventWithName:(<span class="hljs-built_in">NSString</span> *)eventName userInfo:(<span class="hljs-built_in">NSDictionary</span> *)userInfo &#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;event name %@  info%@&quot;</span>,eventName,userInfo);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们只需要实现这个方法，同时保证不再继续调用下一个响应者的这个方法。就表示这里已经将对应事件处理完成。不需要外部的响应者继续处理。</p>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>对于复杂的页面来说，我们要处理的事件肯定会非常多，不同的事件需要处理的方式也不同。那么在最终控制器里的<code>routerEventWithName</code>方法中 我们可能会写大量的<code>if/else</code>。</p>
<p>大量的<code>if/else</code>虽然逻辑比较清晰，但是维护起来非常复杂，那么该如何解决这个问题呢？</p>
<p>其实对于了解设计模式的人来说，有一种设计模式叫做策略模式，这种模式是专门用来解决类似问题的。下面我们来具体看下改怎么实现。</p>
<p>首先，对于策略模式我们要确定的是策略。我们可以根据类型进行区分，这个类型最好可以一对多，这样策略模式作用才能最大的提现。</p>
<p>例如我们可以根据视图作为策略进行区分。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggnacf0cmtj30jg090mxa.jpg"></p>
<p>上图父视图中有两个子视图，每个子视图都有4个事件需要处理。<br>这里我们有两种方式指定策略</p>
<p>1、以视图作为区分策略</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">if</span> (A || B || C || D)<br>    <span class="hljs-keyword">return</span> Strategy1<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (F || G || H || I ) <br>    <span class="hljs-keyword">return</span> Strategy2<br></code></pre></td></tr></table></figure>

<p>2、根据预定规范的方法名</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">if</span> ([eventName hasPrefix:A])<br>    <span class="hljs-keyword">return</span> Strategy1<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ([eventName hasPrefix:B]) <br>    <span class="hljs-keyword">return</span> Strategy2<br></code></pre></td></tr></table></figure>

<p>实际应用<br>普通视图方法解耦 （一对一）<br>假设我们有6个事件需要处理，那么我们首先需要维护6个事件名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">kULAViewEventA,kULAViewEventB,kULAViewEventC,kULAViewEventD<br>kULBViewEventF,kULBViewEventG,kULBViewEventH,kULBViewEventI<br></code></pre></td></tr></table></figure>

<p>其次我们需要维护一个映射表或者条件转换方法</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">- (<span class="hljs-built_in">NSDictionary</span> &lt;<span class="hljs-built_in">NSString</span> *, <span class="hljs-built_in">NSInvocation</span> *&gt; *)eventStrategy<br>&#123;<br>    <span class="hljs-keyword">if</span> (_eventStrategy == <span class="hljs-literal">nil</span>) &#123;<br>        _eventStrategy = @&#123;<br>                               kULAViewEventA:[<span class="hljs-keyword">self</span> createInvocationWithSelector:<span class="hljs-keyword">@selector</span>(aViewEventA:)],<br>                               kULAViewEventB:[<span class="hljs-keyword">self</span> createInvocationWithSelector:<span class="hljs-keyword">@selector</span>(aViewEventB:)],<br>                               kULAViewEventC:[<span class="hljs-keyword">self</span> createInvocationWithSelector:<span class="hljs-keyword">@selector</span>(aViewEventC:)],<br>                               kULAViewEventD:[<span class="hljs-keyword">self</span> createInvocationWithSelector:<span class="hljs-keyword">@selector</span>(aViewEventD:)],<br>                               kULBViewEventF:[<span class="hljs-keyword">self</span> createInvocationWithSelector:<span class="hljs-keyword">@selector</span>(bViewEventA:)],<br>                               kULBViewEventG:[<span class="hljs-keyword">self</span> createInvocationWithSelector:<span class="hljs-keyword">@selector</span>(bViewEventB:)],<br>                               kULBViewEventH:[<span class="hljs-keyword">self</span> createInvocationWithSelector:<span class="hljs-keyword">@selector</span>(bViewEventC:)],<br>                               kULBViewEventI:[<span class="hljs-keyword">self</span> createInvocationWithSelector:<span class="hljs-keyword">@selector</span>(bViewEventD:)]<br>                               &#125;;<br>    &#125;<br>    <span class="hljs-keyword">return</span> _eventStrategy;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面这个方法，我们可以在调用的时候通过下面的方法完成转换 然后进行方法的执行</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">- (<span class="hljs-keyword">void</span>)routerEventWithName:(<span class="hljs-built_in">NSString</span> *)eventName userInfo:(<span class="hljs-built_in">NSDictionary</span> *)userInfo<br>&#123;<br><br>    <span class="hljs-built_in">NSInvocation</span> *invocation = <span class="hljs-keyword">self</span>.eventStrategy[eventName];<br>    [invocation setArgument:&amp;userInfo atIndex:<span class="hljs-number">2</span>];<br>    [invocation invoke];<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这样我们我们就可以将大量的<code>if/else</code>转换为上面的几句代码实现，但是不可否认的是，这个过程中我们需要维护一个<code>映射表</code>，所以我们每次添加方法的时候都需要添加一个对应的事件名。这里实际上是有可以继续优化的，如果大家有好的方法可以给我留言。</p>
<h3 id="schema处理（一对多）"><a href="#schema处理（一对多）" class="headerlink" title="schema处理（一对多）"></a>schema处理（一对多）</h3><p>每个APP可能都维护了大量的scheme跳转路径，比如 <code>a://b/c?id=1</code>这个scheme，我们通过这个scheme就知道我们应该跳转到b业务c页面参数为id=1。但是我们在处理scheme的位置可能会有大量的判断。而且这些判断的位置都集中在一起，也给我们组件化造成了一定的困扰。</p>
<p>下面我们就尝试使用策略模式进行优化 我们先看下之前的逻辑</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">- (<span class="hljs-built_in">BOOL</span>)handleOpenScheme:(<span class="hljs-built_in">NSString</span> *)scheme<br><span class="hljs-keyword">if</span>([scheme hasPrefix:<span class="hljs-string">@&quot;http&quot;</span>]) &#123;<br>    <span class="hljs-comment">// 跳转到网页</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ([scheme hasPrefix:<span class="hljs-string">@&quot;projectName&quot;</span>]) &#123;<br>    <span class="hljs-comment">// 项目自身的scheme</span><br>    <span class="hljs-keyword">if</span>([scheme isEqualToString:<span class="hljs-string">@&quot;APage&quot;</span>]) &#123;<br>        <span class="hljs-comment">// 跳转到A页面</span><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>([scheme isEqualToString:<span class="hljs-string">@&quot;BPage&quot;</span>]) &#123;<br>        <span class="hljs-comment">// 跳转到B页面</span><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>([scheme isEqualToString:<span class="hljs-string">@&quot;CPage&quot;</span>]) &#123;<br>        <span class="hljs-comment">// 跳转到C页面</span><br>    &#125;<br>    .....<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 暂不支持的方法</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>从上面的代码我们可以看出 基本上APP有多少个页面这里就会有多少个if/else。随着我们项目组件化的进程我们也需要将这些跳转方法分散到各个模块当中。</p>
<p>假设我们的项目中目前有四大模块：</p>
<ul>
<li>小说模块</li>
<li>直播间模块</li>
<li>广播剧模块</li>
<li>个人主页模块</li>
</ul>
<p>那么我们先声明一个协议，协议中是处理跳转的方法</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-class"><span class="hljs-keyword">@protocol</span> <span class="hljs-title">ULHandleSchemeDelegate</span> &lt;<span class="hljs-title">NSObject</span>&gt;</span><br><br>- (<span class="hljs-built_in">BOOL</span>)handleScheme:(<span class="hljs-built_in">NSString</span> *)scheme;<br><br><span class="hljs-keyword">@end</span><br><br></code></pre></td></tr></table></figure>
<p>我们实现四个实体类：<code>NovelSchemeHandler</code>、<code>LiveSchemeHandler</code>、<code>DramaSchemeHandler</code>、<code>UserProfileSchemeHandler</code></p>
<p>这四个类都遵守了<code>ULHandleSchemeDelegate</code>这个协议并实现了方法。</p>
<p>下面我们来重新实现下之前的方法</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">- (<span class="hljs-built_in">BOOL</span>)handleOpenScheme:(<span class="hljs-built_in">NSString</span> *)scheme<br>    <span class="hljs-built_in">NSURL</span> *url = [<span class="hljs-built_in">NSURL</span> URLWithString:scheme];<br>    <span class="hljs-keyword">if</span>([scheme hasPrefix:<span class="hljs-string">@&quot;http&quot;</span>]) &#123;<br>        <span class="hljs-comment">// 跳转到网页</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> ([url isEqualToString:<span class="hljs-string">@&quot;Live&quot;</span>]) &#123;<br>            <span class="hljs-comment">// 直播模块处理 请忽略这里直接创建对应模块实例的方式</span><br>            <span class="hljs-keyword">return</span> [[LiveSchemeHandler new] handleScheme:scheme];<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ([url.host isEqualToString:<span class="hljs-string">@&quot;Novel&quot;</span>]) &#123;<br>            <span class="hljs-comment">// 小说模块 请忽略这里直接创建对应模块实例的方式</span><br>            <span class="hljs-keyword">return</span> [[NovelSchemeHandler new] handleScheme:scheme];<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ([url.host isEqualToString:<span class="hljs-string">@&quot;Drama&quot;</span>]) &#123;<br>            <span class="hljs-comment">// 话剧模块 请忽略这里直接创建对应模块实例的方式</span><br>            <span class="hljs-keyword">return</span> [[DramaSchemeHandler new] handleScheme:scheme];<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ([url.host isEqualToString:<span class="hljs-string">@&quot;Novel&quot;</span>]) &#123;<br>            <span class="hljs-comment">// 个人主页 请忽略这里直接创建对应模块实例的方式</span><br>            <span class="hljs-keyword">return</span> [[UserProfileSchemeHandler new] handleScheme:scheme];<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 暂不支持的方法</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>通过这中方式进行修改后，scheme的跳转变的更加清晰也更加容易维护了。当然我们还可以进行进一步的维护，添加一个映射方法</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">- (<span class="hljs-keyword">id</span> &lt;ULHandleSchemeDelegate&gt; )schemeHandlerForScheme:(<span class="hljs-built_in">NSString</span> *)scheme &#123;<br>    <span class="hljs-keyword">if</span> ([url isEqualToString:<span class="hljs-string">@&quot;Live&quot;</span>]) &#123;<br>        <span class="hljs-comment">// 直播模块处理</span><br>        <span class="hljs-keyword">return</span> [LiveSchemeHandler new];<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ([url.host isEqualToString:<span class="hljs-string">@&quot;Novel&quot;</span>]) &#123;<br>        <span class="hljs-comment">// 小说模块</span><br>        <span class="hljs-keyword">return</span> [NovelSchemeHandler new];<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ([url.host isEqualToString:<span class="hljs-string">@&quot;Drama&quot;</span>]) &#123;<br>        <span class="hljs-comment">// 话剧模块</span><br>        <span class="hljs-keyword">return</span> [DramaSchemeHandler new];<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ([url.host isEqualToString:<span class="hljs-string">@&quot;Novel&quot;</span>]) &#123;<br>        <span class="hljs-comment">// 个人主页</span><br>        <span class="hljs-keyword">return</span> [UserProfileSchemeHandler new];<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 暂不支持的方法</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这样上面的<code>handleOpenScheme</code>方法可进一步简化为：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">- (<span class="hljs-built_in">BOOL</span>)handleOpenScheme:(<span class="hljs-built_in">NSString</span> *)scheme<br>    <span class="hljs-built_in">NSURL</span> *url = [<span class="hljs-built_in">NSURL</span> URLWithString:scheme];<br>    <span class="hljs-keyword">if</span>([scheme hasPrefix:<span class="hljs-string">@&quot;http&quot;</span>]) &#123;<br>        <span class="hljs-comment">// 跳转到网页</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">id</span> &lt;ULHandleSchemeDelegate&gt; handler = [<span class="hljs-keyword">self</span> schemeHandlerForScheme:scheme];<br>        [handler handleScheme:scheme];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>通过上面的方法我们可以将包含大量<code>if/else</code>语句的方法进行精简，而且根据自己的业务模块指定更好的策略，能达到更好的效果。</p>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>对于基于相应者链条的事件传递，其实还有其他的应用场景</p>
<p>控件id 我们埋点的时候有时候希望可以在埋点中携带控件的唯一id，而这个id我们通常是根据路径获取的。我们对分类中的方法稍加改造</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">- (<span class="hljs-keyword">void</span>)routerEventWithName:(<span class="hljs-built_in">NSString</span> *)eventName userInfo:(<span class="hljs-built_in">NSDictionary</span> *)userInfo<br>&#123;<br>    <span class="hljs-built_in">NSString</span> *newName = [<span class="hljs-built_in">NSString</span> stringWithFormat:<span class="hljs-string">@&quot;%@--%@&quot;</span>,<span class="hljs-built_in">NSStringFromClass</span>(<span class="hljs-keyword">self</span>.class),eventName];<br>    [[<span class="hljs-keyword">self</span> nextResponder] routerEventWithName:newName userInfo:userInfo];<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这样当我们处理点击事件的时候是否就可以获取到被点击这个控件在当前页面的id了呢？而这个过程当中是否有其他信息可以通过事件传递携带呢？大家可以根据自己的业务进行发挥！！！</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇文章我们主要介绍了一种新的基于响应者链条的事件传递机制，同时针对这种问题存在的弊端，我们使用策略模式进行简化，让这种方式更具有实用价值，当然对于视图的点击事件这种方法还存在下面两个问题</p>
<p>1、需要维护事件名称<br>2、需要维护不同事件名称与对应处理方法的映射表<br>不过在scheme处理的例子中，这种方式还是有很明显的效果的。</p>
<p>参考文档</p>
<p><a href="https://juejin.im/post/5e77135e6fb9a07ca714dbc4#heading-23">调试iOS用户交互事件响应流程</a></p>
<p><a href="https://www.xiaobotalk.com/2020/03/responder-chain/">iOS 响应者链与事件处理</a></p>
<p><a href="https://casatwy.com/responder_chain_communication.html">一种基于ResponderChain的对象交互方式</a></p>
<p><a href="https://juejin.im/post/5e77135e6fb9a07ca714dbc4#heading-23">调试iOS用户交互事件响应流程</a></p>
]]></content>
      <categories>
        <category>组件化</category>
      </categories>
      <tags>
        <tag>ResponseChain</tag>
      </tags>
  </entry>
  <entry>
    <title>retain和release实现探究</title>
    <url>/2020/08/02/retaincount/</url>
    <content><![CDATA[<p>前面一篇文章，我们讲到了系统为了优化数字字符串等类型的数据存储新增了一种<code>NSTaggedPointer</code>类型，同时我们还发现，<code>isa</code>指针在经过优化后，提供了19个bit位用来存储引用计数的个数。但是如果超出了这个限制呢？</p>
<a id="more"></a>

<h3 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h3><p>其实在绝大多数情况下，仅用优化的isa_t来记录对象的引用计数就足够了，但是当对象被引用次数超过 2^19 限制时，就轮到SideTable出场了。</p>
<p>首先，我们先看下超出限制之后，系统是如何将引用计数转移的</p>
<h3 id="retian"><a href="#retian" class="headerlink" title="retian"></a>retian</h3><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">// 等价于直接使用对象调用retain方法</span><br><span class="hljs-keyword">inline</span> <span class="hljs-keyword">id</span> <br>objc_object::<span class="hljs-keyword">retain</span>()<br>&#123;<br>    <span class="hljs-comment">// 如果是TaggedPointer类型 不涉及引用计数</span><br>    ASSERT(!isTaggedPointer());<br>    <span class="hljs-comment">// fastpath 表示if中的条件是一个大概率事件</span><br>    <span class="hljs-comment">// 如果当前对象没有自定义（override）retain 方法</span><br>    <span class="hljs-keyword">if</span> (fastpath(!ISA()-&gt;hasCustomRR())) &#123;<br>        <span class="hljs-keyword">return</span> rootRetain();<br>    &#125;<br>    <span class="hljs-comment">// 如果有自定义的retain方法</span><br>    <span class="hljs-comment">// 通过发消息的方式调用自定义的 retain 方法</span><br>    <span class="hljs-keyword">return</span> ((<span class="hljs-keyword">id</span>(*)(objc_object *, SEL))objc_msgSend)(<span class="hljs-keyword">this</span>, <span class="hljs-keyword">@selector</span>(<span class="hljs-keyword">retain</span>));<br>&#125;<br></code></pre></td></tr></table></figure>

<p>接下来我们主要看下 引用计数+1的主要负责函数rootRetain</p>
<h4 id="rootRetain"><a href="#rootRetain" class="headerlink" title="rootRetain"></a>rootRetain</h4><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">ALWAYS_INLINE <span class="hljs-keyword">id</span> <br>objc_object::rootRetain(<span class="hljs-keyword">bool</span> tryRetain, <span class="hljs-keyword">bool</span> handleOverflow)<br>&#123;<br>    <span class="hljs-comment">// 如果如果是taggedPointer直接返回不需要引用计数</span><br>    <span class="hljs-keyword">if</span> (isTaggedPointer()) <span class="hljs-keyword">return</span> (<span class="hljs-keyword">id</span>)<span class="hljs-keyword">this</span>;<br>    <span class="hljs-comment">// 默认不使用sideTable</span><br>    <span class="hljs-keyword">bool</span> sideTableLocked = <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">// 是否需要将引用计数转到sidetable</span><br>    <span class="hljs-keyword">bool</span> transcribeToSideTable = <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-comment">// 记录新旧两个isa指针</span><br>    isa_t oldisa;<br>    isa_t newisa;<br><br>    <span class="hljs-keyword">do</span> &#123;<br>        transcribeToSideTable = <span class="hljs-literal">false</span>;<br>        <span class="hljs-comment">//// 通过 LoadExclusive 方法加载 isa 的值，加锁</span><br>        oldisa = LoadExclusive(&amp;isa.bits);<br>        <span class="hljs-comment">// 此时 newisa = oldisa</span><br>        newisa = oldisa;<br>        <span class="hljs-comment">// slowpath表示if中的条件是小概率事件</span><br>        <span class="hljs-comment">// 如果newisa(此时和oldisa相等) 如果没有采用isa优化</span><br>        <span class="hljs-keyword">if</span> (slowpath(!newisa.nonpointer)) &#123;<br>            <span class="hljs-comment">// 解锁</span><br>            ClearExclusive(&amp;isa.bits);<br>            <span class="hljs-comment">//rawISA() = (Class)isa.bits</span><br>            <span class="hljs-comment">// 如果当前对象的 isa 指向的类对象是元类（也就是说当前对象不是实例对象，而是类对象），直接返回</span><br>            <span class="hljs-keyword">if</span> (rawISA()-&gt;isMetaClass()) <span class="hljs-keyword">return</span> (<span class="hljs-keyword">id</span>)<span class="hljs-keyword">this</span>;<br>            <span class="hljs-comment">// 如果不需要retain对象(引用计数+1) 且sideTable是锁上的</span><br>            <span class="hljs-keyword">if</span> (!tryRetain &amp;&amp; sideTableLocked)<br>                <span class="hljs-comment">// sidetable解锁</span><br>                sidetable_unlock();<br>            <span class="hljs-keyword">if</span> (tryRetain)<br>                <span class="hljs-comment">// sidetable_tryRetain 尝试对引用计数器进行+1的操作 返回+1操作是否成功</span><br>                <span class="hljs-keyword">return</span> sidetable_tryRetain() ? (<span class="hljs-keyword">id</span>)<span class="hljs-keyword">this</span> : <span class="hljs-literal">nil</span>;<br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-comment">// 将sidetable中保存的引用计数+1同时返回引用计数</span><br>                <span class="hljs-keyword">return</span> sidetable_retain();<br>        &#125;<br>        <span class="hljs-comment">// 如果需要尝试 +1 但是当前对象正在销毁中</span><br>        <span class="hljs-keyword">if</span> (slowpath(tryRetain &amp;&amp; newisa.deallocating)) &#123;<br>            <span class="hljs-comment">// 解锁</span><br>            ClearExclusive(&amp;isa.bits);<br>            <span class="hljs-comment">// 如果不需要去尝试 +1 并且 SideTables 表锁住了，就将其解锁</span><br>            <span class="hljs-comment">// 这里的条件 应该永远都不会被满足</span><br>            <span class="hljs-keyword">if</span> (!tryRetain &amp;&amp; sideTableLocked)<br>                sidetable_unlock();<br>            <span class="hljs-comment">// 如果对象正在被释放 执行retain是无效的</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>;<br>        &#125;<br>        <span class="hljs-comment">// 引用计数是否溢出标志位</span><br>        uintptr_t carry;<br>        <span class="hljs-comment">//为 isa 中的 extra_rc 位 +1 ，并保存引用计数</span><br>        newisa.bits = addc(newisa.bits, RC_ONE, <span class="hljs-number">0</span>, &amp;carry);  <span class="hljs-comment">// extra_rc++</span><br>        <span class="hljs-comment">// 如果 isa中的extra_rc 溢出</span><br>        <span class="hljs-keyword">if</span> (slowpath(carry)) &#123;<br>            <span class="hljs-comment">// newisa.extra_rc++ 溢出</span><br>            <span class="hljs-comment">// 是否需要处理溢出 这个变量是rootRetain函数外部传入的参数 是否需要处理溢出时的情况</span><br>            <span class="hljs-keyword">if</span> (!handleOverflow) &#123;<br>                <span class="hljs-comment">//解锁</span><br>                ClearExclusive(&amp;isa.bits);<br>                <span class="hljs-comment">// rootRetain_overflow 方法实际上就是递归调用了当前方法只是将handleOverflow</span><br>                <span class="hljs-comment">// 置为yes</span><br>                <span class="hljs-keyword">return</span> rootRetain_overflow(tryRetain);<br>            &#125;<br>            <span class="hljs-comment">// 保留isa中extra_rc一半的值 将另一半转移到sidetable中</span><br>            <span class="hljs-comment">// 如果不需要尝试 +1 并且 sidetable 表未加锁，就将其加锁</span><br>            <span class="hljs-keyword">if</span> (!tryRetain &amp;&amp; !sideTableLocked) sidetable_lock();<br>            <span class="hljs-comment">// sidetable加锁</span><br>            sideTableLocked = <span class="hljs-literal">true</span>;<br>            <span class="hljs-comment">// 需要将引用计数转移到sidetable</span><br>            transcribeToSideTable = <span class="hljs-literal">true</span>;<br>            <span class="hljs-comment">// 将newisa中的引用计数置为之前的一半 # define RC_HALF  (1ULL&lt;&lt;18)</span><br>            newisa.extra_rc = RC_HALF;<br>            <span class="hljs-comment">// isa中是否使用sidetable存储retiancount的标志位置为1</span><br>            newisa.has_sidetable_rc = <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-comment">//while循环开始 直到 isa.bits 中的值被成功更新成 newisa.bits</span><br>        <span class="hljs-comment">// StoreExclusive(uintptr_t *dst, uintptr_t oldvalue, uintptr_t value)</span><br>        <span class="hljs-comment">// 将更新后的newisa的值更新到isabit中</span><br>    &#125; <span class="hljs-keyword">while</span> (slowpath(!StoreExclusive(&amp;isa.bits, oldisa.bits, newisa.bits)));<br><br>    <span class="hljs-comment">// 如果需要转移引用计数到sidetable中</span><br>    <span class="hljs-keyword">if</span> (slowpath(transcribeToSideTable)) &#123;<br>        <span class="hljs-comment">// 将溢出的引用计数加到 sidetable 中</span><br>        sidetable_addExtraRC_nolock(RC_HALF);<br>    &#125;<br>    <span class="hljs-comment">// 如果不需要去尝试 +1 并且 SideTables 表锁住了，就将其解锁</span><br>    <span class="hljs-keyword">if</span> (slowpath(!tryRetain &amp;&amp; sideTableLocked)) sidetable_unlock();<br>    <span class="hljs-comment">// 返回当前对象 引用计数已完成+1操作</span><br>    <span class="hljs-keyword">return</span> (<span class="hljs-keyword">id</span>)<span class="hljs-keyword">this</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>当<code>tryRetain</code>标志位为1时，我们会先尝试调用<code>sidetable_tryRetain</code>方法，我们先看下这个方法:</p>
<h5 id="sidetable-tryRetain"><a href="#sidetable-tryRetain" class="headerlink" title="sidetable_tryRetain"></a>sidetable_tryRetain</h5><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">//尝试将 SideTable 表中的引用计数 +1</span><br><span class="hljs-keyword">bool</span><br>objc_object::sidetable_tryRetain()<br>&#123;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> SUPPORT_NONPOINTER_ISA</span><br>    ASSERT(!isa.nonpointer);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>    <span class="hljs-comment">// 根据对象地址获取到引用计数器所在的sideTable</span><br>    SideTable&amp; table = SideTables()[<span class="hljs-keyword">this</span>];<br><br>    <span class="hljs-comment">// NO SPINLOCK HERE</span><br>    <span class="hljs-comment">// _objc_rootTryRetain() is called exclusively by _objc_loadWeak(), </span><br>    <span class="hljs-comment">// which already acquired the lock on our behalf.</span><br><br>    <span class="hljs-comment">// fixme can&#x27;t do this efficiently with os_lock_handoff_s</span><br>    <span class="hljs-comment">// if (table.slock == 0) &#123;</span><br>    <span class="hljs-comment">//     _objc_fatal(&quot;Do not call -_tryRetain.&quot;);</span><br>    <span class="hljs-comment">// &#125;</span><br><br>    <span class="hljs-keyword">bool</span> result = <span class="hljs-literal">true</span>;<br>    <span class="hljs-comment">// try_emplace 如果给定的key在容器中不存在，原位构造一个元素 如果在容器中则返回</span><br>    <span class="hljs-comment">// try_emplace 有两个返回值 第一个返回值是一个遍历器 第二个返回值表示 key value 在map中是否已存在</span><br>    auto it = table.refcnts.try_emplace(<span class="hljs-keyword">this</span>, SIDE_TABLE_RC_ONE);<br>    <span class="hljs-comment">// 获取引用计数(含两个标志位)</span><br>    auto &amp;refcnt = it.first-&gt;second;<br><br>    <span class="hljs-keyword">if</span> (it.second) &#123;<br>        <span class="hljs-comment">//如果这个对象对应的实体第一次插入到sidetable中</span><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (refcnt &amp; SIDE_TABLE_DEALLOCATING) &#123;<br>        <span class="hljs-comment">// 如果当前对象处于正在被销毁状态SIDE_TABLE_DEALLOCATING标志位为1</span><br>        result = <span class="hljs-literal">false</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (! (refcnt &amp; SIDE_TABLE_RC_PINNED)) &#123;<br>        <span class="hljs-comment">// 引用计数没有溢出 + 1</span><br>        refcnt += SIDE_TABLE_RC_ONE;<br>    &#125;<br>    <span class="hljs-comment">// 返回值为引用计数是否成功+1</span><br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>当前的对象没有处于正在被销毁的状态时，我们会将sidetable中的引用计数+1。</p>
<p>如果<code>tryRetain</code>标志位为0,那么我们直接调用<code>sidetable_retain</code>方法对引用计数器进行+1操作，<code>sidetable_retain</code>方法如下：</p>
<h5 id="sidetable-retain"><a href="#sidetable-retain" class="headerlink" title="sidetable_retain"></a>sidetable_retain</h5><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">// 将 SideTable 表中的引用计数 +1</span><br><span class="hljs-keyword">id</span><br>objc_object::sidetable_retain()<br>&#123;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> SUPPORT_NONPOINTER_ISA</span><br>    ASSERT(!isa.nonpointer);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>    <span class="hljs-comment">// 根据对象获取 存储引用计数的sidetable</span><br>    SideTable&amp; table = SideTables()[<span class="hljs-keyword">this</span>];<br>    <br>    table.lock();<br>    <span class="hljs-comment">// 获取sidetable中存储的引用计数值</span><br>    size_t&amp; refcntStorage = table.refcnts[<span class="hljs-keyword">this</span>];<br>    <span class="hljs-comment">// 如果引用计数值没有溢出</span><br>    <span class="hljs-keyword">if</span> (! (refcntStorage &amp; SIDE_TABLE_RC_PINNED)) &#123;<br>        <span class="hljs-comment">// 引用计数值+SIDE_TABLE_RC_ONE</span><br>        <span class="hljs-comment">// #define SIDE_TABLE_RC_ONE            (1UL&lt;&lt;2)</span><br>        <span class="hljs-comment">// SIDE_TABLE_RC_ONE = 4 为什么这里会+4我们下面会介绍</span><br>        refcntStorage += SIDE_TABLE_RC_ONE;<br>    &#125;<br>    table.unlock();<br><br>    <span class="hljs-keyword">return</span> (<span class="hljs-keyword">id</span>)<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>通过上面这个方法，我们对引用计数器完成了+1(实际上是+4)的操作，那么这里为什么会+4呢？<br>那是因为对于<code>table.refcnts</code>,实际上并不完全是表示引用计数的值，refcnts的最后两位有特殊的标示意义：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SIDE_TABLE_WEAKLY_REFERENCED (1UL&lt;&lt;0)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SIDE_TABLE_DEALLOCATING      (1UL&lt;&lt;1) </span><br></code></pre></td></tr></table></figure>

<ul>
<li>倒数第一位标记当前对象是否被weak指针指向(1:有weak指针指向);</li>
<li>倒数第二位标记当前对象是否正在销毁状态(1:处在正在销毁状态); </li>
</ul>
<p>因此，我们每次执行retain方法时，虽然每次都是+4，但是对于引用计数真实的值来说就是+1,64位环境下只有62位是保存溢出的引用计数的.</p>
<p>紧接如果对象没有采用isa优化且对象没有正在销毁，我们通过调用<code>addc</code>方法实现引用计数器+1的操作，这个方法会给我们一个标志值<code>carry</code>,表示进行+1操作后，引用计数是否溢出。</p>
<p>如果发生溢出，但是此时我们不需要处理溢出:</p>
<p>那么我们会直接调用<code>rootRetain_overflow</code>方法，我们先来看下这个方法：</p>
<h5 id="rootRetain-overflow"><a href="#rootRetain-overflow" class="headerlink" title="rootRetain_overflow"></a>rootRetain_overflow</h5><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">NEVER_INLINE <span class="hljs-keyword">id</span> <br>objc_object::rootRetain_overflow(<span class="hljs-keyword">bool</span> tryRetain)<br>&#123;<br>    <span class="hljs-keyword">return</span> rootRetain(tryRetain, <span class="hljs-literal">true</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>很明显 这个方法实际是递归调用了<code>rootRetain</code>方法，只是<code>handleOverflow</code>参数值被置为<code>yes</code>。而对于retain操作来说实际上是走出了刚才<code>if (!handleOverflow)</code>判断。那么我们继续往下看。</p>
<p>如果发生溢出，且我么需要处理溢出时：<br>我们需要先设置标志位：</p>
<ul>
<li>sideTableLocked = true;</li>
<li>transcribeToSideTable = true;</li>
<li>newisa.extra_rc = RC_HALF;</li>
<li>newisa.has_sidetable_rc = true;</li>
</ul>
<p>同时将<code>newisa</code>的值更新到<code>isa</code>中，保存成功后，while循环结束。</p>
<p>紧接着我们调用<code>sidetable_addExtraRC_nolock</code>方法，下面我们再来看下这个方法:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">if</span> (slowpath(transcribeToSideTable)) &#123;<br> <span class="hljs-comment">//拷贝 平外一半的 引用计数到 side table</span><br>    sidetable_addExtraRC_nolock(RC_HALF);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>RC_HALF</code>的定义如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">#define RC_HALF  (1ULL&lt;&lt;18)<br></code></pre></td></tr></table></figure>

<p>我们都知道<code>NSTaggedPointer</code>预留了19个bit位用来存放引用计数，<code>RC_HALF</code>的值刚好为 2^19 次方的一半。</p>
<p>我们下面来看下<code>sidetable_addExtraRC_nolock</code>如何实现的</p>
<h5 id="sidetable-addExtraRC-nolock"><a href="#sidetable-addExtraRC-nolock" class="headerlink" title="sidetable_addExtraRC_nolock"></a>sidetable_addExtraRC_nolock</h5><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><br><span class="hljs-comment">// Move some retain counts to the side table from the isa field.</span><br><span class="hljs-comment">// Returns true if the object is now pinned.</span><br><span class="hljs-comment">// 将isa中的引用计数移动到sidetable中 当引用计数达到最大值(溢出)是返回true</span><br><span class="hljs-keyword">bool</span> <br>objc_object::sidetable_addExtraRC_nolock(size_t delta_rc)<br>&#123;<br>    ASSERT(isa.nonpointer);<br>    <span class="hljs-comment">// 根据对象地址获取到存放引用计数对应的sidetable</span><br>    SideTable&amp; table = SideTables()[<span class="hljs-keyword">this</span>];<br>    <span class="hljs-comment">// 从table.refcnts中获取当前对象的引用计数</span><br>    size_t&amp; refcntStorage = table.refcnts[<span class="hljs-keyword">this</span>];<br>    <span class="hljs-comment">// 声明一个局部变量存储旧的引用计数</span><br>    size_t oldRefcnt = refcntStorage;<br>    <span class="hljs-comment">// isa-side bits should not be set here</span><br>    <span class="hljs-comment">// 如果就的引用计数&gt;0或sidetable正在销毁</span><br>    <span class="hljs-comment">// 如果引用计数&gt;0或当前对象再被其他对象弱引用</span><br>    ASSERT((oldRefcnt &amp; SIDE_TABLE_DEALLOCATING) == <span class="hljs-number">0</span>);<br>    ASSERT((oldRefcnt &amp; SIDE_TABLE_WEAKLY_REFERENCED) == <span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// #define SIDE_TABLE_RC_PINNED         (1UL&lt;&lt;(WORD_BITS-1))</span><br>    <span class="hljs-comment">// oldRefcnt &amp; SIDE_TABLE_RC_PINNED = 1 就是 oldRefcnt = 2147483648 （32位情况）</span><br>    <span class="hljs-comment">// 这时候 引用计数已经超过了三十二位所能表达的最大值 直接返回true</span><br>    <span class="hljs-keyword">if</span> (oldRefcnt &amp; SIDE_TABLE_RC_PINNED) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-comment">// 溢出标志位</span><br>    uintptr_t carry;<br>    <span class="hljs-comment">// 对oldRefcnt执行+delta_rc操作</span><br>    size_t newRefcnt = <br>        addc(oldRefcnt, delta_rc &lt;&lt; SIDE_TABLE_RC_SHIFT, <span class="hljs-number">0</span>, &amp;carry);<br>    <span class="hljs-comment">// 如果引用计数溢出 设置标识为已满</span><br>    <span class="hljs-keyword">if</span> (carry) &#123;<br>        <span class="hljs-comment">// 如果是32位的情况 SIDE_TABLE_RC_PINNED = 1&lt;&lt; (32-1)</span><br>        <span class="hljs-comment">// int的最大值 SIDE_TABLE_RC_PINNED = 2147483648</span><br>        <span class="hljs-comment">//  SIDE_TABLE_FLAG_MASK = 3</span><br>        <span class="hljs-comment">// refcntStorage = 2147483648 | (oldRefcnt &amp; 3)</span><br>        <span class="hljs-comment">// 如果溢出，直接把refcntStorage 设置成最大值</span><br>        refcntStorage =<br>            SIDE_TABLE_RC_PINNED | (oldRefcnt &amp; SIDE_TABLE_FLAG_MASK);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 如果没有溢出 那么直接将新的引用计数赋值给refcntStorage</span><br>        refcntStorage = newRefcnt;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>


<p>向右偏移两位的原因是,RefcountMap refcnts的最后两位有特殊的标示意义：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SIDE_TABLE_WEAKLY_REFERENCED (1UL&lt;&lt;0)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SIDE_TABLE_DEALLOCATING      (1UL&lt;&lt;1) </span><br></code></pre></td></tr></table></figure>

<ul>
<li>倒数第一位标记当前对象是否被weak指针指向(1:有weak指针指向);</li>
<li>倒数第二位标记当前对象是否正在销毁状态(1:处在正在销毁状态); </li>
</ul>
<p>所以,64位环境下只有62位是保存溢出的引用计数的.</p>
<p>通过上面的介绍我们了解到了引用计数是如何在sidetable中存储的(retian方法)。那么引用计数-1的操作又是怎么实现的呢？</p>
<h3 id="release"><a href="#release" class="headerlink" title="release"></a>release</h3><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">// Equivalent to calling [this release], with shortcuts if there is no override</span><br><span class="hljs-comment">// 等价于直接使用对象调用release方法</span><br><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span><br>objc_object::release()<br>&#123;<br>    ASSERT(!isTaggedPointer());<br>    <span class="hljs-comment">// 如果没有自定义的release方法 就直接调用rootRelease</span><br>    <span class="hljs-keyword">if</span> (fastpath(!ISA()-&gt;hasCustomRR())) &#123;<br>        rootRelease();<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// 如果有自定义的release方法那么调用对象的release方法</span><br>    ((<span class="hljs-keyword">void</span>(*)(objc_object *, SEL))objc_msgSend)(<span class="hljs-keyword">this</span>, <span class="hljs-keyword">@selector</span>(release));<br>&#125;<br></code></pre></td></tr></table></figure>

<p>从上面的代码我们看到，在没有自定义release方法时，系统默认是调用的<code>rootRelease</code>方法，下面我们来看下这个方法。</p>
<h4 id="rootRelease"><a href="#rootRelease" class="headerlink" title="rootRelease"></a>rootRelease</h4><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">ALWAYS_INLINE <span class="hljs-keyword">bool</span> <br>objc_object::rootRelease()<br>&#123;<br>    <span class="hljs-comment">// 调用了私有函数 rootRelease 去实现</span><br>    <span class="hljs-keyword">return</span> rootRelease(<span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>上面这个方法实际上调用了同名函数(两个默认参数),下面我们进一步看下带有两个参数的<code>rootRelease</code>方法:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">// 真正的release方法</span><br><span class="hljs-comment">// 两个参数分别是 是否需要调用dealloc函数，是否需要处理 向下溢出的问题</span><br>ALWAYS_INLINE <span class="hljs-keyword">bool</span> <br>objc_object::rootRelease(<span class="hljs-keyword">bool</span> performDealloc, <span class="hljs-keyword">bool</span> handleUnderflow)<br>&#123;<br>    <span class="hljs-comment">// 如果是TaggedPointer 不需要进行release操作</span><br>    <span class="hljs-keyword">if</span> (isTaggedPointer()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">// 局部变量sideTable是否上锁 默认false</span><br>    <span class="hljs-keyword">bool</span> sideTableLocked = <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-comment">// 两个局部变量用来记录这个对象的isa指针</span><br>    isa_t oldisa;<br>    isa_t newisa;<br><br> retry:<br>    <span class="hljs-keyword">do</span> &#123;<br>        <span class="hljs-comment">// 加载这个isa指针</span><br>        oldisa = LoadExclusive(&amp;isa.bits);<br>        newisa = oldisa;<br>        <span class="hljs-comment">// 如果没有进行nonpointer优化</span><br>        <span class="hljs-keyword">if</span> (slowpath(!newisa.nonpointer)) &#123;<br>            ClearExclusive(&amp;isa.bits);<br>            <span class="hljs-comment">// 如果是类对象直接返回false 不需要释放</span><br>            <span class="hljs-keyword">if</span> (rawISA()-&gt;isMetaClass()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-comment">// 如果sideTableLocked 则解锁 这里默认是false</span><br>            <span class="hljs-keyword">if</span> (sideTableLocked)<br>                sidetable_unlock();<br>            <span class="hljs-comment">// 调用sidetable_release 进行引用计数-1操作</span><br>            <span class="hljs-keyword">return</span> sidetable_release(performDealloc);<br>        &#125;<br><br>        <span class="hljs-comment">// 溢出标记位</span><br>        uintptr_t carry;<br>        <span class="hljs-comment">// newisa 对象的extra_rc 进行-1操作</span><br>        newisa.bits = subc(newisa.bits, RC_ONE, <span class="hljs-number">0</span>, &amp;carry);  <span class="hljs-comment">// extra_rc--</span><br>        <span class="hljs-comment">// 如果-1操作后 向下溢出了 结果为负数</span><br>        <span class="hljs-keyword">if</span> (slowpath(carry)) &#123;<br>            <span class="hljs-comment">// don&#x27;t ClearExclusive()</span><br>            <span class="hljs-comment">// 调用underflow 进行向下溢出的处理</span><br>            <span class="hljs-keyword">goto</span> underflow;<br>        &#125;<br>        <span class="hljs-comment">//  开启循环，直到 isa.bits 中的值被成功更新成 newisa.bits</span><br>    &#125; <span class="hljs-keyword">while</span> (slowpath(!StoreReleaseExclusive(&amp;isa.bits, <br>                                             oldisa.bits, newisa.bits)));<br><br>    <span class="hljs-comment">//走到这说明引用计数的 -1 操作已完成</span><br>    <span class="hljs-keyword">if</span> (slowpath(sideTableLocked)) sidetable_unlock();<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br> underflow:<br>    <span class="hljs-comment">//newisa的extra_rc在执行-1操作后导致了向下溢出</span><br>    <span class="hljs-comment">// 放弃对newisa的修改 使用之前的oldisa</span><br>    newisa = oldisa;<br><br>    <span class="hljs-comment">// 如果 isa 的 has_sidetable_rc 标志位标识引用计数已溢出</span><br>    <span class="hljs-comment">// has_sidetable_rc 用于标识是否当前的引用计数过大，无法在isa中存储，</span><br>    <span class="hljs-comment">// 而需要借用sidetable来存储。（这种情况大多不会发生）</span><br>    <span class="hljs-keyword">if</span> (slowpath(newisa.has_sidetable_rc)) &#123;<br>        <span class="hljs-comment">// 是否需要处理下溢</span><br>        <span class="hljs-keyword">if</span> (!handleUnderflow) &#123;<br>            <span class="hljs-comment">// 清除原 isa 中的数据的原子独占</span><br>            ClearExclusive(&amp;isa.bits);<br>            <span class="hljs-comment">// 如果不需要处理下溢 直接调用 rootRelease_underflow方法</span><br>            <span class="hljs-keyword">return</span> rootRelease_underflow(performDealloc);<br>        &#125;<br><br>        <span class="hljs-comment">// 如果sidetable是上锁状态</span><br>        <span class="hljs-keyword">if</span> (!sideTableLocked) &#123;<br>            <span class="hljs-comment">// 解除清除原 isa 中的数据的原子独占</span><br>            ClearExclusive(&amp;isa.bits);<br>            <span class="hljs-comment">// sidetable 上锁</span><br>            sidetable_lock();<br>            sideTableLocked = <span class="hljs-literal">true</span>;<br>            <span class="hljs-comment">// 跳转到 retry 重新开始，避免 isa 从 nonpointer 类型转换成原始类型导致的问题</span><br>            <span class="hljs-keyword">goto</span> retry;<br>        &#125;<br><br>        <span class="hljs-comment">// sidetable_subExtraRC_nolock 放回要从sidetable移动到isa的extra_rc的值</span><br>        <span class="hljs-comment">// 默认是获取extra_rc可存储的长度一半的值</span><br>        size_t borrowed = sidetable_subExtraRC_nolock(RC_HALF);<br><br>        <span class="hljs-comment">// To avoid races, has_sidetable_rc must remain set </span><br>        <span class="hljs-comment">// even if the side table count is now zero.</span><br>        <span class="hljs-comment">//  为了避免冲突 has_sidetable_rc 标志位必须保留1的状态 及时sidetable中的个数为0</span><br>        <span class="hljs-keyword">if</span> (borrowed &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 将newisa中引用计数值extra_rc 设置为borrowed - 1</span><br>            <span class="hljs-comment">// -1 是因为 本身这次是release操作</span><br>            newisa.extra_rc = borrowed - <span class="hljs-number">1</span>;<br>            <span class="hljs-comment">// 然后将修改同步到isa中</span><br>            <span class="hljs-keyword">bool</span> stored = StoreReleaseExclusive(&amp;isa.bits, <br>                                                oldisa.bits, newisa.bits);<br>            <span class="hljs-comment">// 如果保存失败</span><br>            <span class="hljs-keyword">if</span> (!stored) &#123;<br>                <span class="hljs-comment">// Inline update failed. </span><br>                <span class="hljs-comment">// Try it again right now. This prevents livelock on LL/SC </span><br>                <span class="hljs-comment">// architectures where the side table access itself may have </span><br>                <span class="hljs-comment">// dropped the reservation.</span><br>                <span class="hljs-comment">// 从新装载isa</span><br>                isa_t oldisa2 = LoadExclusive(&amp;isa.bits);<br>                isa_t newisa2 = oldisa2;<br>                <span class="hljs-comment">// 如果newisa2是nonpointer类型</span><br>                <span class="hljs-keyword">if</span> (newisa2.nonpointer) &#123;<br>                    <span class="hljs-comment">// 下溢出标志位</span><br>                    uintptr_t overflow;<br>                    <span class="hljs-comment">// 将从 SideTables 表中获取的引用计数保存到 newisa2 的 extra_rc 标志位中</span><br>                    newisa2.bits = <br>                        addc(newisa2.bits, RC_ONE * (borrowed<span class="hljs-number">-1</span>), <span class="hljs-number">0</span>, &amp;overflow);<br>                    <span class="hljs-comment">//</span><br>                    <span class="hljs-keyword">if</span> (!overflow) &#123;<br>                        <span class="hljs-comment">// 如果没有溢出再次将 isa.bits 中的值更新为 newisa2.bits</span><br>                        stored = StoreReleaseExclusive(&amp;isa.bits, oldisa2.bits, <br>                                                       newisa2.bits);<br>                    &#125;<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-comment">// 如果重试之后依然失败</span><br>            <span class="hljs-keyword">if</span> (!stored) &#123;<br>                <span class="hljs-comment">// 将从sidetable中取出的引用计数borrowed 重新加到sidetable中</span><br>                sidetable_addExtraRC_nolock(borrowed);<br>                <span class="hljs-comment">// 重新尝试</span><br>                <span class="hljs-keyword">goto</span> retry;<br>            &#125;<br><br>            <span class="hljs-comment">// Decrement successful after borrowing from side table.</span><br>            <span class="hljs-comment">// This decrement cannot be the deallocating decrement - the side </span><br>            <span class="hljs-comment">// table lock and has_sidetable_rc bit ensure that if everyone </span><br>            <span class="hljs-comment">// else tried to -release while we worked, the last one would block.</span><br>            <span class="hljs-comment">// 完成对 SideTables 表中数据的操作后，为其解锁</span><br>            sidetable_unlock();<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 在从Side table拿出一部分引用计数之后 Side table为空</span><br>            <span class="hljs-comment">// Side table is empty after all. Fall-through to the dealloc path.</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 如果当前的对象正在被释放</span><br>    <span class="hljs-keyword">if</span> (slowpath(newisa.deallocating)) &#123;<br>        ClearExclusive(&amp;isa.bits);<br>        <span class="hljs-comment">// 如果sideTableLocked被锁 那么解锁</span><br>        <span class="hljs-keyword">if</span> (sideTableLocked) sidetable_unlock();<br>        <span class="hljs-comment">// 兑现被过度释放</span><br>        <span class="hljs-keyword">return</span> overrelease_error();<br>        <span class="hljs-comment">// does not actually return</span><br>    &#125;<br>    <span class="hljs-comment">// 将对象被释放的标志位置为true</span><br>    newisa.deallocating = <span class="hljs-literal">true</span>;<br>    <span class="hljs-comment">// 将newisa同步到isa中 如果失败 进行重试</span><br>    <span class="hljs-keyword">if</span> (!StoreExclusive(&amp;isa.bits, oldisa.bits, newisa.bits))<br>        <span class="hljs-keyword">goto</span> retry;<br><br>    <span class="hljs-comment">// 如果sideTableLocked= true</span><br>    <span class="hljs-keyword">if</span> (slowpath(sideTableLocked))<br>        <span class="hljs-comment">// Side table解锁</span><br>        sidetable_unlock();<br><br>    __c11_atomic_thread_fence(__ATOMIC_ACQUIRE);<br><br>    <span class="hljs-comment">// 如果需要执行dealloc方法 那么调用该对象的dealloc方法</span><br>    <span class="hljs-keyword">if</span> (performDealloc) &#123;<br>        ((<span class="hljs-keyword">void</span>(*)(objc_object *, SEL))objc_msgSend)(<span class="hljs-keyword">this</span>, <span class="hljs-keyword">@selector</span>(dealloc));<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>这个方法还是有点长的，我们看到主要是由两个内部方法<code>retry</code>,<code>underflow</code>组成，下面我们来一步步的整理下引用计数-1操作的具体步骤</p>
<h4 id="retry"><a href="#retry" class="headerlink" title="retry"></a>retry</h4><h5 id="sidetable-release"><a href="#sidetable-release" class="headerlink" title="sidetable_release"></a>sidetable_release</h5><p>如果这个对象没有<code>nonpointer</code>优化，且不是一个类对象，那么我们直接通过对sidetable进行-1操作</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">// 将 SideTable 表中的引用计数 -1</span><br>uintptr_t<br>objc_object::sidetable_release(<span class="hljs-keyword">bool</span> performDealloc)<br>&#123;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> SUPPORT_NONPOINTER_ISA</span><br>    ASSERT(!isa.nonpointer);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>    <span class="hljs-comment">// 根据对象地址获取SideTable</span><br>    SideTable&amp; table = SideTables()[<span class="hljs-keyword">this</span>];<br>    <span class="hljs-comment">// 是否需要执行dealloc方法 默认是false</span><br>    <span class="hljs-keyword">bool</span> do_dealloc = <span class="hljs-literal">false</span>;<br><br>    table.lock();<br>    <span class="hljs-comment">// 获取当前对象的销毁状态 方法的返回值有2个</span><br>    <span class="hljs-comment">// 引用计数和当前对象是否已存在与map中</span><br>    auto it = table.refcnts.try_emplace(<span class="hljs-keyword">this</span>, SIDE_TABLE_DEALLOCATING);<br>    auto &amp;refcnt = it.first-&gt;second;<br>    <span class="hljs-comment">// 如果当前对象之前不存在与map中</span><br>    <span class="hljs-keyword">if</span> (it.second) &#123;<br>        do_dealloc = <span class="hljs-literal">true</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (refcnt &lt; SIDE_TABLE_DEALLOCATING) &#123;<br>        <span class="hljs-comment">// 如果引用计数的值小于 SIDE_TABLE_DEALLOCATING = 2(0010)</span><br>        <span class="hljs-comment">// refcnt 低两位分别是SIDE_TABLE_WEAKLY_REFERENCED 0  SIDE_TABLE_DEALLOCATING 1</span><br>        <span class="hljs-comment">// 这个对象需要被销毁</span><br>        do_dealloc = <span class="hljs-literal">true</span>;<br>        refcnt |= SIDE_TABLE_DEALLOCATING;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (! (refcnt &amp; SIDE_TABLE_RC_PINNED)) &#123;<br>        <span class="hljs-comment">// 如果引用计数有值且未溢出那么-1</span><br>        refcnt -= SIDE_TABLE_RC_ONE;<br>    &#125;<br>    table.unlock();<br>    <span class="hljs-comment">// 如果需要执行dealloc 那么就调用这个对象的dealloc</span><br>    <span class="hljs-keyword">if</span> (do_dealloc  &amp;&amp;  performDealloc) &#123;<br>        ((<span class="hljs-keyword">void</span>(*)(objc_object *, SEL))objc_msgSend)(<span class="hljs-keyword">this</span>, <span class="hljs-keyword">@selector</span>(dealloc));<br>    &#125;<br>    <span class="hljs-keyword">return</span> do_dealloc;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>相反，如果该对象做了nonpointer优化，那么我们直接对extra_rc进行-1操作，即</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">// newisa 对象的extra_rc 进行-1操作</span><br>newisa.bits = subc(newisa.bits, RC_ONE, <span class="hljs-number">0</span>, &amp;carry);  <span class="hljs-comment">// extra_rc--</span><br><span class="hljs-comment">// 如果-1操作后 向下溢出了 结果为负数</span><br><span class="hljs-keyword">if</span> (slowpath(carry)) &#123;<br>    <span class="hljs-comment">// don&#x27;t ClearExclusive()</span><br>    <span class="hljs-comment">// 调用underflow 进行向下溢出的处理</span><br>    <span class="hljs-keyword">goto</span> underflow;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>将extra_rc计数-1，如果发现-1操作之后，extra_rc的个数为0，那么就出现了向下溢出，我们需要将sideTable中的部分引用计数拿到extra_rc中记录。如果没有向下溢出，那么我们就直接将修改后的newisa同步到isa中即完成了release操作。</p>
<h4 id="underflow"><a href="#underflow" class="headerlink" title="underflow"></a>underflow</h4><p>如果在将extra_rc进行-1操作时，出现了向下溢出的问题，那么我们需要将sideTable中的引用计数移动到extra_rc中存储。</p>
<p>下面我们来分析下具体过程</p>
<p>先判断<code>has_sidetable_rc</code>是否有sidetable引用计数,如果有我们要确认是否需要处理向下溢出，如果不需要处理向下溢出，那么我们直接调用<code>rootRelease_underflow</code>方法，</p>
<h5 id="rootRelease-underflow"><a href="#rootRelease-underflow" class="headerlink" title="rootRelease_underflow"></a>rootRelease_underflow</h5><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">NEVER_INLINE uintptr_t<br>objc_object::rootRelease_underflow(<span class="hljs-keyword">bool</span> performDealloc)<br>&#123;<br>    <span class="hljs-keyword">return</span> rootRelease(performDealloc, <span class="hljs-literal">true</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>很明显这个方法实际上与retain操作时处理溢出逻辑相同，将<code>rootRelease</code>方法中的<code>handleUnderflow</code>参数置为true,要处理向下溢出。</p>
<p>下面我们再来看下，需要处理向下溢出时,如果当前的sidetable处于未上锁的状态时，将sidetable上锁然后进行重试，如果sidetable未已经上锁了，那么我们会执行下面这句代码:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">size_t</span> borrowed = sidetable_subExtraRC_nolock(RC_HALF);<br></code></pre></td></tr></table></figure>
<p>sidetable_subExtraRC_nolock 返回要从sidetable移动到isa的extra_rc的值，默认是获取extra_rc可存储的长度一半的值。</p>
<p>如果此时从sidetable中拿到的值 &gt; 0,那么我们要将这部分值放到isa的extra_rc中进行存储，如果取到的borrowed的值为0，那么说明sidetable中的引用计数为0，那么我们直接释放该对象即可。</p>
<h5 id="StoreReleaseExclusive"><a href="#StoreReleaseExclusive" class="headerlink" title="StoreReleaseExclusive"></a>StoreReleaseExclusive</h5><p>上面说到如果从sidetable中获取到的值borrowed大于0，那么我们直接将<code>newisa.extra_rc</code>设置为<code>borrowed - 1</code>即可。</p>
<p>然后我们在调用<code>StoreReleaseExclusive</code>方法将<code>newisa</code>同步到<code>isa</code>中。</p>
<p>如果这里<code>StoreReleaseExclusive</code>方法保存失败了，那么我们需要重新调用<code>LoadExclusive</code>重新声明两个变量<code>newisa2</code>,<code>oldisa2</code>。通过<code>addc</code>方法将<code>extra_rc</code>置为<code>borrowed-1</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">newisa2.bits = addc(newisa2.bits, RC_ONE * (borrowed<span class="hljs-number">-1</span>), <span class="hljs-number">0</span>, &amp;overflow);<br></code></pre></td></tr></table></figure>
<p>然后再次调用<code>StoreReleaseExclusive</code>方法将<code>newisa2</code>的改动同步到<code>isa</code>中。</p>
<p>如果<code>StoreReleaseExclusive</code>方法依然保存失败，那么我们就把从sidetable中获取的<code>borrowed</code>重新加到sideTable中。然后调用retry方法。</p>
<p>经过<code>StoreReleaseExclusive</code>这一步，引用计数更新操作完成。但是如果此时的引用计数为0我们改如何操作呢？</p>
<p>如果引用计数更新成功，那么我们需要先判断，当前对象是否正在被释放，如果正在被释放 那么调用过度释放方法<code>overrelease_error</code></p>
<h5 id="overrelease-error"><a href="#overrelease-error" class="headerlink" title="overrelease_error"></a>overrelease_error</h5><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">NEVER_INLINE uintptr_t<br>objc_object::overrelease_error()<br>&#123;<br>    _objc_inform_now_and_on_crash(<span class="hljs-string">&quot;%s object %p overreleased while already deallocating; break on objc_overrelease_during_dealloc_error to debug&quot;</span>, object_getClassName((<span class="hljs-keyword">id</span>)<span class="hljs-keyword">this</span>), <span class="hljs-keyword">this</span>);<br>    objc_overrelease_during_dealloc_error();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// allow rootRelease() to tail-call this</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>这个方法主要是定义了crash信息，当一个用户正在被释放时，再次调用release方法时会导致crash，具体crash信息如上述代码。</p>
<p>如果当前对象没有被正在释放，那么我们将当前对象正在被释放标志位置为true <code>newisa.deallocating = true;</code> 同时将状态的更新同步到<code>isa</code>中。如果同步失败，那么会重复走一次retry。</p>
<p>更新状态成功后，对sidetable的操作也结束了，我们就可以将sidetable解锁(sidetable_unlock),如果需要执行dealloc方法，那么我们调用dealloc方法进行对象释放通知。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>至此我们就看完了objc对于retain和release以及其对引用计数的操作，以及在retain操作时当extra_rc空间不足时，引用计数是如何从extra_rc转移到sidetable中和release操作时引用计数是如何从sidetable转移到extra_rc中的。希望看了这篇文章可以帮你更好的了解引用计数的实现。</p>
]]></content>
      <categories>
        <category>Runtime</category>
      </categories>
      <tags>
        <tag>Runtime Retain Release</tag>
      </tags>
  </entry>
  <entry>
    <title>Runtime之方法交换</title>
    <url>/2020/10/25/runtime-methodswizzle/</url>
    <content><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>前面几篇文章我们介绍了Runtime中NSObject的数据结构，下面我们来介绍下Runtime在平时开发过程中的常用方法以及实现原理。</p>
<a id="more"></a>

<h3 id="方法交换"><a href="#方法交换" class="headerlink" title="方法交换"></a>方法交换</h3><p>方法交换可以说是我们在开发中比较常用的方法，尤其是在一些需要埋点或者统计的位置，我们可以通过Hook系统的某些方法，通过在这些方法中添加自己代码的方式实现在不入侵业务的情况下实现功能。</p>
<p>首先我们来看下方法交换的实现，下面这段代码使我们在网上随便找了一份方法交换的代码实现：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">+ (<span class="hljs-built_in">BOOL</span>)swizzleMethod:(Class)<span class="hljs-keyword">class</span> orgSel:(SEL)origSel swizzSel:(SEL)altSel &#123;<br>    Method origMethod = class_getInstanceMethod(<span class="hljs-keyword">class</span>, origSel);<br>    Method altMethod = class_getInstanceMethod(<span class="hljs-keyword">class</span>, altSel);<br>    <span class="hljs-keyword">if</span> (!origMethod || !altMethod) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NO</span>;<br>    &#125;<br>    <span class="hljs-built_in">BOOL</span> didAddMethod = class_addMethod(<span class="hljs-keyword">class</span>,origSel,<br>                                        method_getImplementation(altMethod),<br>                                        method_getTypeEncoding(altMethod));<br>    <br>    <span class="hljs-keyword">if</span> (didAddMethod) &#123;<br>        class_replaceMethod(<span class="hljs-keyword">class</span>,altSel,<br>                            method_getImplementation(origMethod),<br>                            method_getTypeEncoding(origMethod));<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        method_exchangeImplementations(origMethod, altMethod);<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">YES</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这个方法是交换class类中<code>origSel</code>方法和<code>swizzSel</code>方法。我们先来分析这个方法的实现步骤：</p>
<ul>
<li><code>swizzleMethod</code>方法的三个参数分别为class交换方法的类 <code>origSel</code> 原方法 <code>altSel</code>要替换的方法</li>
<li><code>class_getInstanceMethod</code>通过<code>runtime</code>的这个方法获取方法Method结构体</li>
<li>给class添加<code>origSel</code>方法 方法的实现是<code>altSel</code>的实现</li>
<li>如果第三步添加成功 则替换<code>class</code>中<code>altSel</code>方法实现为<code>origSel</code></li>
<li>如果第三步添加失败 则交换<code>origMethod</code>和<code>altMethod</code>方法的实现</li>
</ul>
<p>下面我们先针对上面的实现提出几个自己的问题，然后带着这些问题去研究为什么需要这么实现，这么实现是否有其他的问题。</p>
<p>问题一：<code>class_getInstanceMethod</code>到底是从哪里获取方法实现？如果是父类方法可以获取到吗？<br>问题二：交换方法之前为何要调用<code>class_addMethod</code>方法先去添加方法？<br>问题三：为何根据添加方法<code>class_addMethod</code>的返回值去判断下一步的操作？<br>问题四：<code>method_exchangeImplementations</code>和<code>class_replaceMethod</code>的区别是什么？<br>问题五：大多数方法都是交换一个类中的两个方法，是否可以交换两个不同类的方法呢？方法名相同可以交换吗？</p>
<p>下面我们带着这些问题来看方法交换的具体实现：</p>
<h4 id="class-getInstanceMethod"><a href="#class-getInstanceMethod" class="headerlink" title="class_getInstanceMethod"></a>class_getInstanceMethod</h4><p>我们先来看下方法的实现：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">// 获取cls类中对象方法sel的实现</span><br>Method class_getInstanceMethod(Class cls, SEL sel)<br>&#123;<br>    <span class="hljs-keyword">if</span> (!cls  ||  !sel) <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>;<br>    <span class="hljs-comment">// Search method lists, try method resolver, etc.</span><br>    <span class="hljs-comment">// 搜索方法列表 这个方法是有返回值的 但是在这里并没有用到返回值</span><br>    lookUpImpOrNil(cls, sel, <span class="hljs-literal">nil</span>, <br>                   <span class="hljs-literal">NO</span><span class="hljs-comment">/*initialize*/</span>, <span class="hljs-literal">NO</span><span class="hljs-comment">/*cache*/</span>, <span class="hljs-literal">YES</span><span class="hljs-comment">/*resolver*/</span>);<br>    <span class="hljs-comment">// 递归获取cls的sel方法</span><br>    <span class="hljs-keyword">return</span> _class_getMethod(cls, sel);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>从这个方法的实现中我们看到在正式调用<code>_class_getMethod</code>方法获取实例方法前，还调用了lookUpImpOrNil方法，这个方法又是做什么的呢？关于这个问题，我们在后面消息转发模块会进一步介绍，这里暂时略过。</p>
<p>我们来看下递归查找方法的实现：</p>
<h5 id="getMethod-nolock"><a href="#getMethod-nolock" class="headerlink" title="getMethod_nolock"></a>getMethod_nolock</h5><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">// 无锁情况下过去cls类的实例方法sel</span><br><span class="hljs-keyword">static</span> method_t *<br>getMethod_nolock(Class cls, SEL sel)<br>&#123;<br>    method_t *m = <span class="hljs-literal">nil</span>;<br><br>    runtimeLock.assertLocked();<br>    <span class="hljs-comment">// 类是否被实例化 每个被实例化的类实际上是有一个标志位</span><br>    assert(cls-&gt;isRealized());<br>    <span class="hljs-comment">// 这里通过while循环的方式不断的查找当前类-&gt;父类-&gt;...的方法查找这个方法 直到找到方法或者是找到cls-&gt;superclass=nil</span><br>    <span class="hljs-keyword">while</span> (cls  &amp;&amp;  ((m = getMethodNoSuper_nolock(cls, sel))) == <span class="hljs-literal">nil</span>) &#123;<br>        cls = cls-&gt;superclass;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> m;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>看到这个实现后，我们的第一个问题的答案就显而易见了。<code>class_getInstanceMethod</code>方法在获取实例方法时会递归遍历所有的父类来查找<code>sel</code>对应的方法，并通过<code>getMethodNoSuper_nolock</code>方法获取方法的<code>method_t</code>结构。</p>
<p>那么<code>getMethodNoSuper_nolock</code>是如何在<code>methodlist</code>中查找对应的方法的呢？</p>
<h5 id="getMethodNoSuper-nolock"><a href="#getMethodNoSuper-nolock" class="headerlink" title="getMethodNoSuper_nolock"></a>getMethodNoSuper_nolock</h5><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">/ 在类的方法列表中查找对应的方法实现<br><span class="hljs-keyword">static</span> method_t *<br>getMethodNoSuper_nolock(Class cls, SEL sel)<br>&#123;<br>    runtimeLock.assertLocked();<br><br>    assert(cls-&gt;isRealized());<br><br>    <span class="hljs-comment">// 方法列表的遍历</span><br>    <span class="hljs-keyword">for</span> (auto mlists = cls-&gt;data()-&gt;methods.beginLists(),<br>              end = cls-&gt;data()-&gt;methods.endLists(); <br>         mlists != end;<br>         ++mlists)<br>    &#123;<br>        <span class="hljs-comment">// 在mlists中查找sel</span><br>        method_t *m = search_method_list(*mlists, sel);<br>        <span class="hljs-keyword">if</span> (m) <span class="hljs-keyword">return</span> m;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们先忽略for循环里的逻辑，我们先看下<code>search_method_list</code>这个方法：</p>
<h5 id="search-method-list"><a href="#search-method-list" class="headerlink" title="search_method_list"></a>search_method_list</h5><p>这个方法的实现 主要实现是<code>findMethodInSortedMethodList</code>方法实现，我们直接看下这个方法</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">// 在list中查找方法为key的</span><br><span class="hljs-keyword">static</span> method_t *findMethodInSortedMethodList(SEL key, <span class="hljs-keyword">const</span> method_list_t *list)<br>&#123;<br>    assert(list);<br><br>    <span class="hljs-keyword">const</span> method_t * <span class="hljs-keyword">const</span> first = &amp;list-&gt;first;<br>    <span class="hljs-keyword">const</span> method_t *base = first;<br>    <span class="hljs-comment">// 标志位</span><br>    <span class="hljs-keyword">const</span> method_t *probe;<br>    <span class="hljs-comment">// 要查找的方法的名称</span><br>    uintptr_t keyValue = (uintptr_t)key;<br>    <span class="hljs-comment">// 方法列表中方法的个数</span><br>    uint32_t count;<br>    <span class="hljs-comment">// 遍历方法列表 每次遍历count &gt;&gt;= 1 count每次遍历/2</span><br>    <span class="hljs-keyword">for</span> (count = list-&gt;count; count != <span class="hljs-number">0</span>; count &gt;&gt;= <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-comment">// base为列表中第一个 count&gt;&gt;1 = count /2 即表示列表中间的位置index</span><br>        probe = base + (count &gt;&gt; <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// 中间位置的方法的方法名</span><br>        uintptr_t probeValue = (uintptr_t)probe-&gt;name;<br>        <span class="hljs-comment">// 方法名对比 如果刚好中间位置的方法的方法名等于要查找的方法名</span><br>        <span class="hljs-keyword">if</span> (keyValue == probeValue) &#123;<br>            <span class="hljs-comment">// `probe` is a match.</span><br>            <span class="hljs-comment">// Rewind looking for the *first* occurrence of this value.</span><br>            <span class="hljs-comment">// This is required for correct category overrides.</span><br>            <span class="hljs-comment">// 即使查找到了对应的方法 也要向前查找 找到在方法列表中靠前的方法实现</span><br>            <span class="hljs-comment">// 方法列表中是可能存在同名方法的 比如分类重写了方法实现 那么肯定会找到分类的实现返回</span><br>            <span class="hljs-keyword">while</span> (probe &gt; first &amp;&amp; keyValue == (uintptr_t)probe[<span class="hljs-number">-1</span>].name) &#123;<br>                probe--;<br>            &#125;<br>            <span class="hljs-comment">// 返回方法列表中对应方法实现</span><br>            <span class="hljs-keyword">return</span> (method_t *)probe;<br>        &#125;<br>        <span class="hljs-comment">// 如果要查找的方法大于中间位置的方法</span><br>        <span class="hljs-keyword">if</span> (keyValue &gt; probeValue) &#123;<br>            <span class="hljs-comment">// 从中间位置作为base 查找 base-count之间的方法 此处为二分查找 这也侧面验证了method_list_t是一个有序列表</span><br>            base = probe + <span class="hljs-number">1</span>;<br>            count--;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>通过方法的注释我们可以清晰的看到这个方法的功能是：在方法列表中查找传入的方法，查找方法为二分查找，比较方法是否相等的条件为判断方法名是否相同。当然这里还存在一个如果方法列表中包含多个同名函数我们会向前查找，找到方法列表中第一个与要查找方法同名的方法。</p>
<h4 id="class-addMethod"><a href="#class-addMethod" class="headerlink" title="class_addMethod"></a>class_addMethod</h4><p>顾名思义，这个方法的作用是在类中添加一个方法，我们先来看下方法实现：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">class_addMethod(Class cls, SEL name, IMP imp, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *types)<br>&#123;<br>    <span class="hljs-keyword">if</span> (!cls) <span class="hljs-keyword">return</span> <span class="hljs-literal">NO</span>;<br><br>    mutex_locker_t lock(runtimeLock);<br>    <span class="hljs-keyword">return</span> ! addMethod(cls, name, imp, types ?: <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-literal">NO</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>class_addMethod</code>中主要是调用了<code>addMethod</code>静态方法，该方法的返回值是要添加的方法的实现。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">// 像cls类中添加名为name实现为imp编码为types的方法</span><br><span class="hljs-comment">// replace 表示是否需要替换方法实现</span><br><span class="hljs-keyword">static</span> IMP <br>addMethod(Class cls, SEL name, IMP imp, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *types, <span class="hljs-keyword">bool</span> replace)<br>&#123;<br>    IMP result = <span class="hljs-literal">nil</span>;<br><br>    runtimeLock.assertLocked();<br><br>    checkIsKnownClass(cls);<br>    <br>    assert(types);<br>    assert(cls-&gt;isRealized());<span class="hljs-comment">//</span><br><br>    method_t *m;<br>    <span class="hljs-comment">// 先从cls中获取名为name的方法实现 如果可以找到方法</span><br>    <span class="hljs-keyword">if</span> ((m = getMethodNoSuper_nolock(cls, name))) &#123;<br>        <span class="hljs-comment">// already exists</span><br>        <span class="hljs-comment">// 类中已有该方法 判断是否需要替换方法实现</span><br>        <span class="hljs-keyword">if</span> (!replace) &#123;<br>            <span class="hljs-comment">// 不需要替换直接返回该方法的实现</span><br>            result = m-&gt;imp;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 需要替换则调用_method_setImplementation方法替换方法实现</span><br>            result = _method_setImplementation(cls, m, imp);<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// fixme optimize</span><br>        <span class="hljs-comment">// 如果当前类的方法列表中不包含名为name的方法</span><br>        <span class="hljs-comment">// 新创建一个method_list_t结构体 并赋值</span><br>        method_list_t *newlist;<br>        newlist = (method_list_t *)calloc(<span class="hljs-keyword">sizeof</span>(*newlist), <span class="hljs-number">1</span>);<br>        newlist-&gt;entsizeAndFlags = <br>            (uint32_t)<span class="hljs-keyword">sizeof</span>(method_t) | fixed_up_method_list;<br>        newlist-&gt;count = <span class="hljs-number">1</span>;<br>        newlist-&gt;first.name = name;<br>        newlist-&gt;first.types = strdupIfMutable(types);<br>        newlist-&gt;first.imp = imp;<br>        <span class="hljs-comment">// 将新建的newlist添加到已有的方法列表中</span><br>        prepareMethodLists(cls, &amp;newlist, <span class="hljs-number">1</span>, <span class="hljs-literal">NO</span>, <span class="hljs-literal">NO</span>);<br>        cls-&gt;data()-&gt;methods.attachLists(&amp;newlist, <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// 刷新缓存</span><br>        flushCaches(cls);<br><br>        result = <span class="hljs-literal">nil</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>addMethod</code>方法主要的实现为：</p>
<p>先从cls中获取名为name的方法实现 如果可以找到方法，判断是否需要替换方法实现 如果需要则替换 如果不需要直接返回，如果找不到新创建一个<code>method_list_t</code>结构体 并赋值，将新建的<code>newlist</code>添加到已有的方法列表中，刷新缓存 并返回nil。</p>
<p>因此这个方法的返回值表示：</p>
<p>如果返回值不为空则表示这个方法本来就存在于方法列表中，如果返回值为nil则表示这个方法不存在与方法列表中。而<code>class_addMethod</code>则是对<code>addMethod</code>方法的返回值进行取反，因此<code>class_addMethod</code>的返回值如果为true则表示方法不存在与方法列表中(然后添加到了方法列表中)，返回值为false则表示方法之前就在方法列表中，不需要添加。</p>
<p>看完这部分问题二和问题三的答案也比较明显了：实际上<code>class_addMethod</code>的调用实际上是为了确认</p>
<ul>
<li>要替换的方法是否已经在方法列表中(方法是否已经实现)</li>
<li>如果不在方法列表中，那么需要先将方法添加到方法列表中</li>
</ul>
<p>如果方法没有在方法列表中，那么我们要完成方法交换需要调用<code>class_replaceMethod</code>方法，如果方法列表中已经有了该方法那么我们直接调用<code>method_exchangeImplementations</code>来实现方法的交换。</p>
<h4 id="class-replaceMethod"><a href="#class-replaceMethod" class="headerlink" title="class_replaceMethod"></a>class_replaceMethod</h4><p>我们先来看下这个方法的实现：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">IMP <br>class_replaceMethod(Class cls, SEL name, IMP imp, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *types)<br>&#123;<br>    <span class="hljs-keyword">if</span> (!cls) <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>;<br><br>    mutex_locker_t lock(runtimeLock);<br>    <span class="hljs-comment">// 这个方法的实现实际上也是调用了addMethod方法 注意这里replace参数为yes</span><br>    <span class="hljs-keyword">return</span> addMethod(cls, name, imp, types ?: <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-literal">YES</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>第一眼看到这个方法的实现时，我也是一脸懵逼，说好的替换方法呢 为何只是调用了<code>addMethod</code>？</p>
<p>首先 我们要务必再次明确调用这个方法的前提是：这个类中并没有要交换的方法。虽然我们在前一步中添加了实现，但是如果我们要实现方法交换肯定是要存在两个方法的，因此带着这个疑问我们再次看下方法交换的代码实现：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-built_in">BOOL</span> didAddMethod = class_addMethod(<span class="hljs-keyword">class</span>,origSel,<br>                                        method_getImplementation(altMethod),<br>                                        method_getTypeEncoding(altMethod));<br>    <br>    <span class="hljs-keyword">if</span> (didAddMethod) &#123;<br>        class_replaceMethod(<span class="hljs-keyword">class</span>,altSel,<br>                            method_getImplementation(origMethod),<br>                            method_getTypeEncoding(origMethod));<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>在调用class_addMethod我们传递的参数是：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>方法名</th>
<th>参数</th>
</tr>
</thead>
<tbody><tr>
<td>class_addMethod</td>
<td>origSel 原始方法名</td>
<td>新自定义方法的方法实现和方法参数编码</td>
</tr>
<tr>
<td>class_replaceMethod</td>
<td>altSel 新定义的方法名</td>
<td>原始方法的方法实现和方法编码</td>
</tr>
</tbody></table>
<h4 id="method-exchangeImplementations"><a href="#method-exchangeImplementations" class="headerlink" title="method_exchangeImplementations"></a>method_exchangeImplementations</h4><p>下面我们在来看下这个方法的实现：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">// 方法交换实现 m1 和 m2 分别表示要交换的两个方法</span><br><span class="hljs-keyword">void</span> method_exchangeImplementations(Method m1, Method m2)<br>&#123;<br>    <span class="hljs-keyword">if</span> (!m1  ||  !m2) <span class="hljs-keyword">return</span>;<br><br>    mutex_locker_t lock(runtimeLock);<br><br>    <span class="hljs-comment">// 方法交换仅仅是交换了两个方法的imp指针</span><br>    IMP m1_imp = m1-&gt;imp;<br>    m1-&gt;imp = m2-&gt;imp;<br>    m2-&gt;imp = m1_imp;<br><br><br>    <span class="hljs-comment">// RR/AWZ updates are slow because class is unknown</span><br>    <span class="hljs-comment">// Cache updates are slow because class is unknown</span><br>    <span class="hljs-comment">// fixme build list of classes whose Methods are known externally?</span><br>    <span class="hljs-comment">// 更新缓存</span><br>    flushCaches(<span class="hljs-literal">nil</span>);<br>    <span class="hljs-comment">// 更新两个方法的自定义 方法  rr 表示retain/release等方法 awz 表示allocwithzone方法</span><br>    updateCustomRR_AWZ(<span class="hljs-literal">nil</span>, m1);<br>    updateCustomRR_AWZ(<span class="hljs-literal">nil</span>, m2);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>交换方法的实现就更简单了：直接交换<code>Method</code>结构体中的<code>imp</code>指针，<code>imp</code>指针又是指向了方法的实现。因此这里就完成了两个方法的交换。</p>
<p>上面我们就看完了方法交换的整个流程，我们仍有几个问题没想通</p>
<h6 id="问题一："><a href="#问题一：" class="headerlink" title="问题一："></a>问题一：</h6><p>大多数方法都是交换一个类中的两个方法，是否可以交换两个不同类的方法呢？方法名相同可以交换吗？</p>
<p>我封装了下面这个方法 用来交换两个类的两个方法</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><br><br>+ (<span class="hljs-built_in">BOOL</span>)swizzleMethod:(Class)originClass swizzCls:(Class)swizzClass orgSel:(SEL)origSel swizzSel:(SEL)swizzSel &#123;<br>    Method origMethod = class_getInstanceMethod(originClass, origSel);<br>    Method altMethod = class_getInstanceMethod(swizzClass, swizzSel);<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;swizzleMethod origMethod %@&quot;</span>,<span class="hljs-built_in">NSStringFromSelector</span>(method_getName(origMethod)));<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;swizzleMethod altMethod %@&quot;</span>,<span class="hljs-built_in">NSStringFromSelector</span>(method_getName(altMethod)));<br><br>    <span class="hljs-built_in">BOOL</span> didAddMethod = class_addMethod(originClass,origSel,<br>                                        method_getImplementation(altMethod),<br>                                        method_getTypeEncoding(altMethod));<br><br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;swizzleMethod didAddMethod %@&quot;</span>,@(didAddMethod));<br>    <span class="hljs-keyword">if</span> (didAddMethod) &#123;<br>        class_replaceMethod(swizzClass,swizzSel,<br>                            method_getImplementation(origMethod),<br>                            method_getTypeEncoding(origMethod));<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        method_exchangeImplementations(origMethod, altMethod);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">YES</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>方法交换：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">[<span class="hljs-keyword">self</span> swizzleMethod:[Person <span class="hljs-keyword">class</span>] swizzCls:[Tiger <span class="hljs-keyword">class</span>] orgSel:<span class="hljs-keyword">@selector</span>(speak) swizzSel:<span class="hljs-keyword">@selector</span>(yall)];<br></code></pre></td></tr></table></figure>
<p>这里我们交换了<code>Person</code>类的<code>speak</code>方法和<code>Tiger</code>类的<code>yall</code>方法，然后分别调用这两个方法</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">Tiger.m<br>- (<span class="hljs-keyword">void</span>)yall &#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;Tiger -- yall&quot;</span>);<br>&#125;<br>-------<br>Person.m<br>- (<span class="hljs-keyword">void</span>)speak &#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;Person speak&quot;</span>);<br>&#125;<br><br>ViewController.m<br>- (<span class="hljs-keyword">void</span>)testExchangeTwoClsTwoMethod &#123;<br>    Person *p = [[Person alloc] init];<br>    [p speak];<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;-----&quot;</span>);<br>    Tiger *t = [[Tiger alloc] init];<br>    [t yall];<br>&#125;<br></code></pre></td></tr></table></figure>
<p>打印结果为：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-number">2020</span><span class="hljs-number">-10</span><span class="hljs-number">-25</span> <span class="hljs-number">20</span>:<span class="hljs-number">05</span>:<span class="hljs-number">24.400998</span>+<span class="hljs-number">0800</span> MethodSwizzlzeDemo[<span class="hljs-number">27125</span>:<span class="hljs-number">11429192</span>] swizzleMethod didAddMethod <span class="hljs-number">0</span><br><span class="hljs-number">2020</span><span class="hljs-number">-10</span><span class="hljs-number">-25</span> <span class="hljs-number">20</span>:<span class="hljs-number">05</span>:<span class="hljs-number">24.455871</span>+<span class="hljs-number">0800</span> MethodSwizzlzeDemo[<span class="hljs-number">27125</span>:<span class="hljs-number">11429192</span>] Tiger -- yall<br><span class="hljs-number">2020</span><span class="hljs-number">-10</span><span class="hljs-number">-25</span> <span class="hljs-number">20</span>:<span class="hljs-number">05</span>:<span class="hljs-number">24.456007</span>+<span class="hljs-number">0800</span> MethodSwizzlzeDemo[<span class="hljs-number">27125</span>:<span class="hljs-number">11429192</span>] -----<br><span class="hljs-number">2020</span><span class="hljs-number">-10</span><span class="hljs-number">-25</span> <span class="hljs-number">20</span>:<span class="hljs-number">05</span>:<span class="hljs-number">24.456143</span>+<span class="hljs-number">0800</span> MethodSwizzlzeDemo[<span class="hljs-number">27125</span>:<span class="hljs-number">11429192</span>] Person speak<br></code></pre></td></tr></table></figure>
<p>从调用结果可以看出我们的方法交换是成功的。因此 这可以证明我们是可以交换两个类的两个方法的。</p>
<h6 id="问题二："><a href="#问题二：" class="headerlink" title="问题二："></a>问题二：</h6><p>我们是否可以交换一个不存在的方法？会有什么效果？</p>
<p>方法交换调用：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">[<span class="hljs-keyword">self</span> swizzleMethod:[Person <span class="hljs-keyword">class</span>] swizzCls:[Tiger <span class="hljs-keyword">class</span>] orgSel:<span class="hljs-keyword">@selector</span>(speak) swizzSel:<span class="hljs-keyword">@selector</span>(speak)];<br></code></pre></td></tr></table></figure>
<p>我们的Tiger类并没有speak方法,我们看下控制台输出</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-number">2020</span><span class="hljs-number">-10</span><span class="hljs-number">-25</span> <span class="hljs-number">20</span>:<span class="hljs-number">08</span>:<span class="hljs-number">34.567600</span>+<span class="hljs-number">0800</span> MethodSwizzlzeDemo[<span class="hljs-number">27181</span>:<span class="hljs-number">11431963</span>] swizzleMethod origMethod speak<br><span class="hljs-number">2020</span><span class="hljs-number">-10</span><span class="hljs-number">-25</span> <span class="hljs-number">20</span>:<span class="hljs-number">08</span>:<span class="hljs-number">34.568215</span>+<span class="hljs-number">0800</span> MethodSwizzlzeDemo[<span class="hljs-number">27181</span>:<span class="hljs-number">11431963</span>] swizzleMethod altMethod (null)<br><span class="hljs-number">2020</span><span class="hljs-number">-10</span><span class="hljs-number">-25</span> <span class="hljs-number">20</span>:<span class="hljs-number">08</span>:<span class="hljs-number">34.568399</span>+<span class="hljs-number">0800</span> MethodSwizzlzeDemo[<span class="hljs-number">27181</span>:<span class="hljs-number">11431963</span>] swizzleMethod didAddMethod <span class="hljs-number">0</span><br><span class="hljs-number">2020</span><span class="hljs-number">-10</span><span class="hljs-number">-25</span> <span class="hljs-number">20</span>:<span class="hljs-number">08</span>:<span class="hljs-number">34.614912</span>+<span class="hljs-number">0800</span> MethodSwizzlzeDemo[<span class="hljs-number">27181</span>:<span class="hljs-number">11431963</span>] Person speak<br><span class="hljs-number">2020</span><span class="hljs-number">-10</span><span class="hljs-number">-25</span> <span class="hljs-number">20</span>:<span class="hljs-number">08</span>:<span class="hljs-number">34.615029</span>+<span class="hljs-number">0800</span> MethodSwizzlzeDemo[<span class="hljs-number">27181</span>:<span class="hljs-number">11431963</span>] -----<br><span class="hljs-number">2020</span><span class="hljs-number">-10</span><span class="hljs-number">-25</span> <span class="hljs-number">20</span>:<span class="hljs-number">08</span>:<span class="hljs-number">34.615114</span>+<span class="hljs-number">0800</span> MethodSwizzlzeDemo[<span class="hljs-number">27181</span>:<span class="hljs-number">11431963</span>] Tiger -- yall<br></code></pre></td></tr></table></figure>
<p>由上面控制台输出结果我们看出，方法交换实际并未成功，且在方法交换是打印<code>altMethod</code>结果为null。因此如果去交换一个并不存在的方法是不可能实现的。</p>
<p>但是如果我们换成另外一种写法：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">[<span class="hljs-keyword">self</span> swizzleMethod:[Tiger <span class="hljs-keyword">class</span>] swizzCls:[Person <span class="hljs-keyword">class</span>] orgSel:<span class="hljs-keyword">@selector</span>(speak) swizzSel:<span class="hljs-keyword">@selector</span>(speak)];<br><br></code></pre></td></tr></table></figure>
<p>我们再看下输出结果：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-number">2020</span><span class="hljs-number">-10</span><span class="hljs-number">-26</span> <span class="hljs-number">22</span>:<span class="hljs-number">29</span>:<span class="hljs-number">43.179796</span>+<span class="hljs-number">0800</span> MethodSwizzlzeDemo[<span class="hljs-number">1853</span>:<span class="hljs-number">33972</span>] swizzleMethod origMethod (null)<br><span class="hljs-number">2020</span><span class="hljs-number">-10</span><span class="hljs-number">-26</span> <span class="hljs-number">22</span>:<span class="hljs-number">29</span>:<span class="hljs-number">43.180534</span>+<span class="hljs-number">0800</span> MethodSwizzlzeDemo[<span class="hljs-number">1853</span>:<span class="hljs-number">33972</span>] swizzleMethod altMethod speak<br><span class="hljs-number">2020</span><span class="hljs-number">-10</span><span class="hljs-number">-26</span> <span class="hljs-number">22</span>:<span class="hljs-number">29</span>:<span class="hljs-number">43.180695</span>+<span class="hljs-number">0800</span> MethodSwizzlzeDemo[<span class="hljs-number">1853</span>:<span class="hljs-number">33972</span>] swizzleMethod didAddMethod <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>
<p>从日志我们看到，方法添加成功！也就是说 我们可以交换一个不存在的方法，因为在方法交换时我们在利用运行时方法在类里添加了对应方法。那么我们看下是否可以成功调用呢？</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">- (<span class="hljs-keyword">void</span>)testExchangeTwoClsTwoMethod &#123;<br>    Person *p = [[Person alloc] init];<br>    [p speak];<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;-----&quot;</span>);<br>    Tiger *t = [[Tiger alloc] init];<br>    [t performSelector:<span class="hljs-keyword">@selector</span>(speak)];<br>&#125;<br></code></pre></td></tr></table></figure>

<p>打印结果：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-number">2020</span><span class="hljs-number">-10</span><span class="hljs-number">-26</span> <span class="hljs-number">22</span>:<span class="hljs-number">35</span>:<span class="hljs-number">40.918735</span>+<span class="hljs-number">0800</span> MethodSwizzlzeDemo[<span class="hljs-number">1957</span>:<span class="hljs-number">39109</span>] swizzleMethod origMethod (null)<br><span class="hljs-number">2020</span><span class="hljs-number">-10</span><span class="hljs-number">-26</span> <span class="hljs-number">22</span>:<span class="hljs-number">35</span>:<span class="hljs-number">40.919307</span>+<span class="hljs-number">0800</span> MethodSwizzlzeDemo[<span class="hljs-number">1957</span>:<span class="hljs-number">39109</span>] swizzleMethod altMethod speak<br><span class="hljs-number">2020</span><span class="hljs-number">-10</span><span class="hljs-number">-26</span> <span class="hljs-number">22</span>:<span class="hljs-number">35</span>:<span class="hljs-number">40.919464</span>+<span class="hljs-number">0800</span> MethodSwizzlzeDemo[<span class="hljs-number">1957</span>:<span class="hljs-number">39109</span>] swizzleMethod didAddMethod <span class="hljs-number">1</span><br><span class="hljs-number">2020</span><span class="hljs-number">-10</span><span class="hljs-number">-26</span> <span class="hljs-number">22</span>:<span class="hljs-number">36</span>:<span class="hljs-number">15.806909</span>+<span class="hljs-number">0800</span> MethodSwizzlzeDemo[<span class="hljs-number">1957</span>:<span class="hljs-number">39109</span>] Person speak<br><span class="hljs-number">2020</span><span class="hljs-number">-10</span><span class="hljs-number">-26</span> <span class="hljs-number">22</span>:<span class="hljs-number">36</span>:<span class="hljs-number">15.807017</span>+<span class="hljs-number">0800</span> MethodSwizzlzeDemo[<span class="hljs-number">1957</span>:<span class="hljs-number">39109</span>] -----<br><span class="hljs-number">2020</span><span class="hljs-number">-10</span><span class="hljs-number">-26</span> <span class="hljs-number">22</span>:<span class="hljs-number">36</span>:<span class="hljs-number">15.807117</span>+<span class="hljs-number">0800</span> MethodSwizzlzeDemo[<span class="hljs-number">1957</span>:<span class="hljs-number">39109</span>] Person speak<br></code></pre></td></tr></table></figure>
<p>从结果我们看出，调用<code>tiger</code>的<code>speak</code>方法时打印出了<code>Person speak</code>,这说明为Tiger动态增加了一个方法方法实现和<code>Person</code>相同，然后在去替换<code>Person</code>类的<code>speak</code>时因为<code>originMethod</code>为<code>null</code>因此替换不成功，因此这个方法相当于给<code>Tiger</code>增加了一个<code>speak</code>方法。</p>
<h6 id="问题三："><a href="#问题三：" class="headerlink" title="问题三："></a>问题三：</h6><p>仔细看下下面这段代码：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">[<span class="hljs-keyword">self</span> swizzleMethod:[Tiger <span class="hljs-keyword">class</span>] swizzCls:[Person <span class="hljs-keyword">class</span>] orgSel:<span class="hljs-keyword">@selector</span>(walk) swizzSel:<span class="hljs-keyword">@selector</span>(speak)];<br><br></code></pre></td></tr></table></figure>
<p><code>Tiger</code>继承自<code>Animal</code>,<code>walk</code>是<code>Animal</code>对象中的一个实例方法：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">Animal</span> : <span class="hljs-title">NSObject</span></span><br><br>- (<span class="hljs-keyword">void</span>)walk;<br><br>- (<span class="hljs-keyword">void</span>)eat;<br><br><span class="hljs-keyword">@end</span><br><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">Tiger</span> : <span class="hljs-title">Animal</span></span><br><br>- (<span class="hljs-keyword">void</span>)yall;<br><br><span class="hljs-keyword">@end</span><br><br></code></pre></td></tr></table></figure>

<p>但是当我断点调试时，却发现</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gk34f6r9ykj31p50u0qqm.jpg"></p>
<p>从图中我们看到：<code>altMethod</code>和<code>origMethod</code>这两个方法是可以获取到的，但是<code>didAddMethod</code>的值返回了YES。这说明我们在<code>Tiger</code>的方法列表中并没有找到<code>walk</code>方法。但是使用<code>class_getInstanceMethod</code>方法获取到的方法是有值的，这是怎么回事呢？</p>
<p>当我们仔细查看<code>class_addMethod</code>方法实现时我们发现了一处代码：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">if</span> ((m = getMethodNoSuper_nolock(cls, name))) &#123;<br>    <span class="hljs-comment">// 找到该类中对应的方法</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>   <span class="hljs-comment">// 没有找到对应的方法</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们在对比<code>class_getInstanceMethod</code>方法获取方法的位置实现：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">// 这里通过while循环的方式不断的查找当前类-&gt;父类-&gt;...的方法查找这个方法 直到找到方法或者是找到cls-&gt;superclass=nil</span><br><span class="hljs-keyword">while</span> (cls  &amp;&amp;  ((m = getMethodNoSuper_nolock(cls, sel))) == <span class="hljs-literal">nil</span>) &#123;<br>    cls = cls-&gt;superclass;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>经过代码的对比我们很容易发现，在<code>class_addMethod</code>方法中我们只是查找了当前类的方法列表，而在<code>class_getInstanceMethod</code>方法中我们会递归查询当前类以及其父类的方法列表。</p>
<p>因此在Tiger类中找不到walk方法是正常的。</p>
<h4 id="类方法的方法交换"><a href="#类方法的方法交换" class="headerlink" title="类方法的方法交换"></a>类方法的方法交换</h4><p>跟交换对象方法相同，我们先来看下这个方法：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">+ (<span class="hljs-built_in">BOOL</span>)swizzleMethod:(Class)<span class="hljs-keyword">class</span> orgSel:(SEL)origSel swizzSel:(SEL)altSel &#123;<br>    <span class="hljs-comment">// 获取方法改为class_getClassMethod方法</span><br>    Method origMethod = class_getClassMethod(<span class="hljs-keyword">class</span>, origSel);<br>    Method altMethod = class_getClassMethod(<span class="hljs-keyword">class</span>, altSel);<br>    <br>    <br>    <span class="hljs-built_in">BOOL</span> didAddMethod = class_addMethod(<span class="hljs-keyword">class</span>,origSel,<br>                                        method_getImplementation(altMethod),<br>                                        method_getTypeEncoding(altMethod));<br>    <br>    <span class="hljs-keyword">if</span> (didAddMethod) &#123;<br>      <span class="hljs-comment">// 方法已经添加</span><br>        class_replaceMethod(<span class="hljs-keyword">class</span>,altSel,<br>                            method_getImplementation(origMethod),<br>                            method_getTypeEncoding(origMethod));<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        method_exchangeImplementations(origMethod, altMethod);<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">YES</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>从上面的代码我们看到，交换类方法和交换对象方法相比我们只是修改了获取方法结构的方法为<code>class_getClassMethod</code>。</p>
<p>下面我们看下这个方法的实现：</p>
<h5 id="class-getClassMethod"><a href="#class-getClassMethod" class="headerlink" title="class_getClassMethod"></a>class_getClassMethod</h5><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">// 获取指定类的类方法</span><br>Method class_getClassMethod(Class cls, SEL sel)<br>&#123;<br>    <span class="hljs-keyword">if</span> (!cls  ||  !sel) <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>;<br><br>    <span class="hljs-comment">// 获取类的元类的方法</span><br>    <span class="hljs-keyword">return</span> class_getInstanceMethod(cls-&gt;getMeta(), sel);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>其实内部实现很简单，获取类的元类对应的实例方法。</p>
<p>下面我们看下方法调用和最终结果：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">+ (<span class="hljs-keyword">void</span>)load &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-built_in">dispatch_once_t</span> onceToken;<br>    <span class="hljs-built_in">dispatch_once</span>(&amp;onceToken, ^&#123;<br>        [<span class="hljs-keyword">self</span> swizzleClassMethod:[<span class="hljs-keyword">self</span> <span class="hljs-keyword">class</span>] orgSel:<span class="hljs-keyword">@selector</span>(classMethod1) swizzSel:<span class="hljs-keyword">@selector</span>(classMethod2)];<br>    &#125;);<br>&#125;<br><br>+ (<span class="hljs-keyword">void</span>)classMethod1 &#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;classMethod1&quot;</span>);<br>&#125;<br><br>+ (<span class="hljs-keyword">void</span>)classMethod2 &#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;classMethod2&quot;</span>);<br>&#125;<br><br>- (<span class="hljs-keyword">void</span>)viewDidLoad &#123;<br>    [<span class="hljs-keyword">super</span> viewDidLoad];<br>    [ViewController classMethod1];<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;-------------------------&quot;</span>);<br>    [ViewController classMethod2];<br>&#125;<br></code></pre></td></tr></table></figure>
<p>我们来看下打印结果：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-number">2020</span><span class="hljs-number">-10</span><span class="hljs-number">-27</span> <span class="hljs-number">22</span>:<span class="hljs-number">42</span>:<span class="hljs-number">20.314694</span>+<span class="hljs-number">0800</span> MethodSwizzlzeDemo[<span class="hljs-number">4950</span>:<span class="hljs-number">153595</span>] swizzleClassMethod didAddMethod <span class="hljs-number">1</span><br><span class="hljs-number">2020</span><span class="hljs-number">-10</span><span class="hljs-number">-27</span> <span class="hljs-number">22</span>:<span class="hljs-number">42</span>:<span class="hljs-number">20.360568</span>+<span class="hljs-number">0800</span> MethodSwizzlzeDemo[<span class="hljs-number">4950</span>:<span class="hljs-number">153595</span>] classMethod1<br><span class="hljs-number">2020</span><span class="hljs-number">-10</span><span class="hljs-number">-27</span> <span class="hljs-number">22</span>:<span class="hljs-number">42</span>:<span class="hljs-number">20.360679</span>+<span class="hljs-number">0800</span> MethodSwizzlzeDemo[<span class="hljs-number">4950</span>:<span class="hljs-number">153595</span>] -------------------------<br><span class="hljs-number">2020</span><span class="hljs-number">-10</span><span class="hljs-number">-27</span> <span class="hljs-number">22</span>:<span class="hljs-number">42</span>:<span class="hljs-number">20.360790</span>+<span class="hljs-number">0800</span> MethodSwizzlzeDemo[<span class="hljs-number">4950</span>:<span class="hljs-number">153595</span>] classMethod2<br></code></pre></td></tr></table></figure>
<p>从结果我们看到，我们的交换方法并不成功。而且我们发现<code>didAddMethod</code>标记为1，也就是说在<code>class</code>中并未找到类方法<code>origSel</code>。很明显问题出在了<code>class_addMethod</code>方法里。上面我们已经分析了这个方法，他的实现实际上是从类中非递归的在方法列表中查找方法。</p>
<p>但是我们都知道类方法实际上是存放在元类中的，这一点在<code>class_getClassMethod</code>的实现中我们也能得到验证</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">class_getInstanceMethod(cls-&gt;getMeta(), sel);<br></code></pre></td></tr></table></figure>
<p>那么我们这里在方法添加时也应该从元类的方法列表中查找对应的类方法，那么如何获取这个类的元类呢，我们知道每个类对象中都有一个isa指针指向了他的元类。因此我们可以通过下面这个方法获取。</p>
<h5 id="object-getClass"><a href="#object-getClass" class="headerlink" title="object_getClass"></a>object_getClass</h5><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">Class object_getClass(<span class="hljs-keyword">id</span> obj)<br>&#123;<br>    <span class="hljs-keyword">if</span> (obj) <span class="hljs-keyword">return</span> obj-&gt;getIsa();<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> Nil;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>利用上面这个方法我们对方法交换函数进行修改</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">+ (<span class="hljs-built_in">BOOL</span>)swizzleMethod:(Class)<span class="hljs-keyword">class</span> orgSel:(SEL)origSel swizzSel:(SEL)altSel &#123;<br>    <span class="hljs-comment">// 获取方法改为class_getClassMethod方法</span><br>    Method origMethod = class_getClassMethod(<span class="hljs-keyword">class</span>, origSel);<br>    Method altMethod = class_getClassMethod(<span class="hljs-keyword">class</span>, altSel);<br>    <br>    <span class="hljs-comment">// 这里改为object_getClass</span><br>    <span class="hljs-built_in">BOOL</span> didAddMethod = class_addMethod(object_getClass(<span class="hljs-keyword">class</span>),origSel,<br>                                        method_getImplementation(altMethod),<br>                                        method_getTypeEncoding(altMethod));<br>    <br>    <span class="hljs-keyword">if</span> (didAddMethod) &#123;<br>      <span class="hljs-comment">// 方法已经添加</span><br>        class_replaceMethod(<span class="hljs-keyword">class</span>,altSel,<br>                            method_getImplementation(origMethod),<br>                            method_getTypeEncoding(origMethod));<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        method_exchangeImplementations(origMethod, altMethod);<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">YES</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们再来看下输出结果：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-number">2020</span><span class="hljs-number">-10</span><span class="hljs-number">-27</span> <span class="hljs-number">22</span>:<span class="hljs-number">56</span>:<span class="hljs-number">35.223362</span>+<span class="hljs-number">0800</span> MethodSwizzlzeDemo[<span class="hljs-number">5144</span>:<span class="hljs-number">163474</span>] swizzleClassMethod didAddMethod <span class="hljs-number">0</span><br><span class="hljs-number">2020</span><span class="hljs-number">-10</span><span class="hljs-number">-27</span> <span class="hljs-number">22</span>:<span class="hljs-number">56</span>:<span class="hljs-number">35.267136</span>+<span class="hljs-number">0800</span> MethodSwizzlzeDemo[<span class="hljs-number">5144</span>:<span class="hljs-number">163474</span>] classMethod2<br><span class="hljs-number">2020</span><span class="hljs-number">-10</span><span class="hljs-number">-27</span> <span class="hljs-number">22</span>:<span class="hljs-number">56</span>:<span class="hljs-number">35.267236</span>+<span class="hljs-number">0800</span> MethodSwizzlzeDemo[<span class="hljs-number">5144</span>:<span class="hljs-number">163474</span>] -------------------------<br><span class="hljs-number">2020</span><span class="hljs-number">-10</span><span class="hljs-number">-27</span> <span class="hljs-number">22</span>:<span class="hljs-number">56</span>:<span class="hljs-number">35.267320</span>+<span class="hljs-number">0800</span> MethodSwizzlzeDemo[<span class="hljs-number">5144</span>:<span class="hljs-number">163474</span>] classMethod1<br></code></pre></td></tr></table></figure>

<p>我们发现这里方法交换是成功的了！这样也就完成了类方法的交换</p>
<h3 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h3><p><a href="https://github.com/LeeWongSnail/Blog_Demo/tree/master/MethodSwizzlzeDemo">demo代码地址</a></p>
]]></content>
      <categories>
        <category>Runtime</category>
      </categories>
      <tags>
        <tag>Runtime ExchangeImplementations</tag>
      </tags>
  </entry>
  <entry>
    <title>Runtime之对象的一生</title>
    <url>/2020/11/29/runtime-objectlifetime/</url>
    <content><![CDATA[<p>在所有的面向对象语言中，万物皆对象。Objective-C也不例外，这篇文章我们从Runtime的源码去分析一个对象从创建到销毁的整个过程中都做了哪些操作，同时也加深我们对内存管理的理解。</p>
<a id="more"></a>

<h2 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h2><p>我们平时开发中创建一个对象的方式一般有三种</p>
<ul>
<li>alloc init </li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-built_in">NSString</span> *str = [[<span class="hljs-built_in">NSString</span> alloc] init];<br></code></pre></td></tr></table></figure>

<ul>
<li>new</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-built_in">NSString</span> *str = [<span class="hljs-built_in">NSString</span> new];<br></code></pre></td></tr></table></figure>

<ul>
<li>类方法构建</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-built_in">NSMutableString</span> *str = [<span class="hljs-built_in">NSMutableString</span> string];<br></code></pre></td></tr></table></figure>

<p>那么在这个过程中系统都做了哪些操作呢？这三种不同的创建方式又会有什么区别呢？下面我们对上述的几个关键词一一介绍然后在分析下这几种创建对象方式的区别。</p>
<h3 id="alloc"><a href="#alloc" class="headerlink" title="alloc"></a>alloc</h3><p>我们先来看下alloc方法在Runtime中的实现</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">+ (<span class="hljs-keyword">id</span>)alloc &#123;<br>    <span class="hljs-keyword">return</span> _objc_rootAlloc(<span class="hljs-keyword">self</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们在进一步看下_objc_rootAlloc方法的实现：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">id</span><br>_objc_rootAlloc(Class cls)<br>&#123;<br>    <span class="hljs-keyword">return</span> callAlloc(cls, <span class="hljs-literal">false</span><span class="hljs-comment">/*checkNil*/</span>, <span class="hljs-literal">true</span><span class="hljs-comment">/*allocWithZone*/</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们继续跟进方法实现:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">// ALWAYS_INLINE 强制内联函数 所有加了__attribute__((always_inline))的函数再</span><br><span class="hljs-comment">// 把被调用时不会被编译成函数调用而是直接扩展到调用函数体内</span><br><span class="hljs-keyword">static</span> ALWAYS_INLINE <span class="hljs-keyword">id</span><br>callAlloc(Class cls, <span class="hljs-keyword">bool</span> checkNil, <span class="hljs-keyword">bool</span> allocWithZone=<span class="hljs-literal">false</span>)<br>&#123;<br>    <span class="hljs-comment">// slowpath 表示if条件为0的可能性较大 利于编译器优化指令跳转</span><br>    <span class="hljs-comment">// 如果需要检查nil 且cls 为nil 那么直接返回nil</span><br>    <span class="hljs-comment">// 因此 如果cls不存在使用alloc方法创建时可能返回nil</span><br>    <span class="hljs-keyword">if</span> (slowpath(checkNil &amp;&amp; !cls)) <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> __OBJC2__</span><br>    <span class="hljs-comment">// fastpath 表示if条件中为1的可能性较大</span><br>    <span class="hljs-comment">// 如果类没有自定义的allocwithzone方法</span><br>    <span class="hljs-keyword">if</span> (fastpath(!cls-&gt;ISA()-&gt;hasCustomAWZ())) &#123;<br>        <span class="hljs-comment">// cls 是否可以快速创建</span><br>        <span class="hljs-keyword">if</span> (fastpath(cls-&gt;canAllocFast())) &#123;<br>            <span class="hljs-comment">// No ctors, raw isa, etc. Go straight to the metal.</span><br>            <span class="hljs-comment">// cls是否有c++销毁方法 dtor = destructor</span><br>            <span class="hljs-keyword">bool</span> dtor = cls-&gt;hasCxxDtor();<br>            <span class="hljs-comment">// calloc 在内存中动态地分配 1 个长度为  cls-&gt;bits.fastInstanceSize() 的连续空间</span><br>            <span class="hljs-keyword">id</span> obj = (<span class="hljs-keyword">id</span>)calloc(<span class="hljs-number">1</span>, cls-&gt;bits.fastInstanceSize());<br>            <span class="hljs-comment">// 如果obj为空 类初始化失败 报错 attempt to allocate object of class &#x27;%s&#x27; failed</span><br>            <span class="hljs-keyword">if</span> (slowpath(!obj)) <span class="hljs-keyword">return</span> callBadAllocHandler(cls);<br>            <span class="hljs-comment">// 调用初始化对象isa方法</span><br>            obj-&gt;initInstanceIsa(cls, dtor);<br>            <span class="hljs-keyword">return</span> obj;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// Has ctor or raw isa or something. Use the slower path.</span><br>            <span class="hljs-comment">// 调用class_createInstance创建对象</span><br>            <span class="hljs-keyword">id</span> obj = class_createInstance(cls, <span class="hljs-number">0</span>);<br>            <span class="hljs-comment">// 如果对象为空 那么直接报错</span><br>            <span class="hljs-keyword">if</span> (slowpath(!obj)) <span class="hljs-keyword">return</span> callBadAllocHandler(cls);<br>            <span class="hljs-keyword">return</span> obj;<br>        &#125;<br>    &#125;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><br>    <span class="hljs-comment">// No shortcuts available.</span><br>    <span class="hljs-comment">// alloc 方法会进一步调用allocwithzone方法</span><br>    <span class="hljs-keyword">if</span> (allocWithZone) <span class="hljs-keyword">return</span> [cls allocWithZone:<span class="hljs-literal">nil</span>];<br>    <span class="hljs-comment">// 正常情况不会走到这里 想到与一个递归？</span><br>    <span class="hljs-keyword">return</span> [cls alloc];<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们将这个方法的流程通过下图来更好的了解下：</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gl55393ycbj31hr0u0dlg.jpg"></p>
<p><code>注意</code>:图中深色背景区域为<code>OBJC2</code>下会走的的位置，基本上目前都会做到这里</p>
<p><del>为了更好的了解这个方法的实现我们进一步看下这个方法中调用的几个方法：</del></p>
<p>写完这个方法后，<strong>发现在最新的Runtime(781)源码中这个方法变成了:</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">static</span> ALWAYS_INLINE <span class="hljs-keyword">id</span><br>callAlloc(Class cls, <span class="hljs-keyword">bool</span> checkNil, <span class="hljs-keyword">bool</span> allocWithZone=<span class="hljs-literal">false</span>)<br>&#123;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> __OBJC2__</span><br>    <span class="hljs-keyword">if</span> (slowpath(checkNil &amp;&amp; !cls)) <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>;<br>    <span class="hljs-comment">// 是否有自定义的allocWithZone方法</span><br>    <span class="hljs-keyword">if</span> (fastpath(!cls-&gt;ISA()-&gt;hasCustomAWZ())) &#123;<br>        <span class="hljs-comment">// 直接调用_objc_rootAllocWithZone</span><br>        <span class="hljs-keyword">return</span> _objc_rootAllocWithZone(cls, <span class="hljs-literal">nil</span>);<br>    &#125;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><br>    <span class="hljs-comment">// No shortcuts available.</span><br>    <span class="hljs-comment">// 是否需要调用allocWithZone _objc_rootAlloc方法调用时这个参数为yes</span><br>    <span class="hljs-keyword">if</span> (allocWithZone) &#123;<br>        <span class="hljs-keyword">return</span> ((<span class="hljs-keyword">id</span>(*)(<span class="hljs-keyword">id</span>, SEL, <span class="hljs-keyword">struct</span> _NSZone *))objc_msgSend)(cls, <span class="hljs-keyword">@selector</span>(allocWithZone:), <span class="hljs-literal">nil</span>);<br>    &#125;<br>    <span class="hljs-comment">// 调用alloc方法</span><br>    <span class="hljs-keyword">return</span> ((<span class="hljs-keyword">id</span>(*)(<span class="hljs-keyword">id</span>, SEL))objc_msgSend)(cls, <span class="hljs-keyword">@selector</span>(alloc));<br>&#125;<br></code></pre></td></tr></table></figure>


<p>实际上在<code>OBJC2</code>中这个方法的改变并不大，下面我们看下上面这两种实现用到的主要方法的实现，</p>
<h4 id="objc-rootAllocWithZone"><a href="#objc-rootAllocWithZone" class="headerlink" title="objc_rootAllocWithZone"></a>objc_rootAllocWithZone</h4><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">//allocWithZone的根方法</span><br><span class="hljs-keyword">id</span><br>_objc_rootAllocWithZone(Class cls, malloc_zone_t *zone)<br>&#123;<br>    <span class="hljs-keyword">id</span> obj;<br>    <span class="hljs-comment">// 如果zone未空 那么直接调用class_createInstance方法 与之前750的实现一致</span><br>    <span class="hljs-keyword">if</span> (fastpath(!zone)) &#123;<br>        obj = class_createInstance(cls, <span class="hljs-number">0</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 如果返回的zone有值 那么调用class_createInstanceFromZone传入</span><br>        obj = class_createInstanceFromZone(cls, <span class="hljs-number">0</span>, zone);<br>    &#125;<br>    <span class="hljs-comment">// 如果创建的obj为空</span><br>    <span class="hljs-keyword">if</span> (slowpath(!obj)) obj = _objc_callBadAllocHandler(cls);<br>    <span class="hljs-keyword">return</span> obj;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这个方法实际上只是做了一层简单的包装，我们重点关注<code>class_createInstance</code>和<code>class_createInstanceFromZone</code>方法。</p>
<h4 id="class-createInstance"><a href="#class-createInstance" class="headerlink" title="class_createInstance"></a>class_createInstance</h4><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">id</span><br>class_createInstance(Class cls, size_t extraBytes)<br>&#123;<br>    <span class="hljs-keyword">if</span> (!cls) <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>;<br>    <span class="hljs-keyword">return</span> _class_createInstanceFromZone(cls, extraBytes, <span class="hljs-literal">nil</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们继续看<code>_class_createInstanceFromZone</code>方法(即<code>_objc_rootAllocWithZone</code>方法中<code>zone</code>不为空时调用的方法)：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">NEVER_INLINE<br><span class="hljs-keyword">id</span><br>_objc_rootAllocWithZone(Class cls, malloc_zone_t *zone __unused)<br>&#123;<br>    <span class="hljs-comment">// allocWithZone under __OBJC2__ ignores the zone parameter</span><br>    <span class="hljs-keyword">return</span> _class_createInstanceFromZone(cls, <span class="hljs-number">0</span>, <span class="hljs-literal">nil</span>,<br>                                         OBJECT_CONSTRUCT_CALL_BADALLOC);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>继续深入<code>_objc_rootAllocWithZone</code>方法：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">// 创建对象</span><br><span class="hljs-comment">// cls 创建对象的类型</span><br><span class="hljs-comment">// extraBytes 额外字节 正常alloc方法这个值为0</span><br><span class="hljs-comment">// zone construct_flags outAllocatedSize</span><br><span class="hljs-keyword">static</span> ALWAYS_INLINE <span class="hljs-keyword">id</span><br>_class_createInstanceFromZone(Class cls, size_t extraBytes, <span class="hljs-keyword">void</span> *zone,<br>                              <span class="hljs-keyword">int</span> construct_flags = OBJECT_CONSTRUCT_NONE,<br>                              <span class="hljs-keyword">bool</span> cxxConstruct = <span class="hljs-literal">true</span>,<br>                              size_t *outAllocatedSize = <span class="hljs-literal">nil</span>)<br>&#123;<br>    ASSERT(cls-&gt;isRealized());<br><br>    <span class="hljs-comment">// Read class&#x27;s info bits all at once for performance</span><br>    <span class="hljs-comment">// 是否有自定义的创建方法</span><br>    <span class="hljs-keyword">bool</span> hasCxxCtor = cxxConstruct &amp;&amp; cls-&gt;hasCxxCtor();<br>    <span class="hljs-comment">// 是否有自定义的销毁方法</span><br>    <span class="hljs-keyword">bool</span> hasCxxDtor = cls-&gt;hasCxxDtor();<br>    <span class="hljs-comment">// canAllocNonpointer:class&#x27;s instances requires raw isa</span><br>    <span class="hljs-comment">// #define FAST_CACHE_REQUIRES_RAW_ISA   (1&lt;&lt;13)</span><br>    <span class="hljs-comment">// 是否是 isa_t 类型的 isa</span><br>    <span class="hljs-keyword">bool</span> fast = cls-&gt;canAllocNonpointer();<br><br>    size_t size;<br>    <span class="hljs-comment">// 增加额外字节</span><br>    size = cls-&gt;instanceSize(extraBytes);<br>    <span class="hljs-keyword">if</span> (outAllocatedSize) *outAllocatedSize = size;<br><br>    <span class="hljs-keyword">id</span> obj;<br>    <span class="hljs-comment">// 新创建一个obj 并指向一块新创建的内存空间</span><br>    <span class="hljs-keyword">if</span> (zone) &#123;<br>        obj = (<span class="hljs-keyword">id</span>)malloc_zone_calloc((malloc_zone_t *)zone, <span class="hljs-number">1</span>, size);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        obj = (<span class="hljs-keyword">id</span>)calloc(<span class="hljs-number">1</span>, size);<br>    &#125;<br>    <span class="hljs-comment">// 如果对象创建失败 obj = nil</span><br>    <span class="hljs-keyword">if</span> (slowpath(!obj)) &#123;<br>        <span class="hljs-keyword">if</span> (construct_flags &amp; OBJECT_CONSTRUCT_CALL_BADALLOC) &#123;<br>            <span class="hljs-keyword">return</span> _objc_callBadAllocHandler(cls);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// isa如果是isa_t类型</span><br>    <span class="hljs-keyword">if</span> (!zone &amp;&amp; fast) &#123;<br>        obj-&gt;initInstanceIsa(cls, hasCxxDtor);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// Use raw pointer isa on the assumption that they might be</span><br>        <span class="hljs-comment">// doing something weird with the zone or RR.</span><br>        <span class="hljs-comment">// isa是cls类型</span><br>        obj-&gt;initIsa(cls);<br>    &#125;<br>    <span class="hljs-comment">// 如果没有自定义构建方法</span><br>    <span class="hljs-keyword">if</span> (fastpath(!hasCxxCtor)) &#123;<br>        <span class="hljs-keyword">return</span> obj;<br>    &#125;<br>    <span class="hljs-comment">// 自定义构建方法调用</span><br>    construct_flags |= OBJECT_CONSTRUCT_FREE_ONFAILURE;<br>    <span class="hljs-keyword">return</span> object_cxxConstructFromClass(obj, cls, construct_flags);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们在看下这个方法中用到的几个方法：</p>
<h4 id="hasCxxDtor"><a href="#hasCxxDtor" class="headerlink" title="hasCxxDtor"></a>hasCxxDtor</h4><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">bool</span> hasCxxDtor() &#123;<br>    <span class="hljs-comment">// addSubclass() propagates this flag from the superclass.</span><br>    assert(isRealized());<br>    <span class="hljs-keyword">return</span> bits.hasCxxDtor();<br>&#125;<br><br><span class="hljs-keyword">bool</span> hasCxxDtor() &#123;<br>    <span class="hljs-keyword">return</span> data()-&gt;flags &amp; RW_HAS_CXX_DTOR;<br>&#125;<br><br><span class="hljs-comment">// class or superclass has .cxx_destruct implementation</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> RW_HAS_CXX_DTOR       (1&lt;&lt;17)</span><br></code></pre></td></tr></table></figure>

<p>从上述代码中，我们可以看到<code>hasCxxDtor</code>表示<code>cls</code>或者<code>supercls</code>是否有销毁<code>(cxx_destruct)</code>方法。</p>
<h4 id="canAllocNonpointer"><a href="#canAllocNonpointer" class="headerlink" title="canAllocNonpointer"></a>canAllocNonpointer</h4><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-built_in">BOOL</span> canAllocNonpointer() &#123;<br>    ASSERT(!isFuture());<br>    <span class="hljs-keyword">return</span> !instancesRequireRawIsa();<br>&#125;<br><br><span class="hljs-built_in">BOOL</span> instancesRequireRawIsa() &#123;<br>    <span class="hljs-keyword">return</span> cache.getBit(FAST_CACHE_REQUIRES_RAW_ISA);<br>&#125;<br><br><span class="hljs-comment">// class&#x27;s instances requires raw isa</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FAST_CACHE_REQUIRES_RAW_ISA   (1&lt;&lt;13)</span><br></code></pre></td></tr></table></figure>

<h4 id="initInstanceIsa"><a href="#initInstanceIsa" class="headerlink" title="initInstanceIsa"></a>initInstanceIsa</h4><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <br>objc_object::initInstanceIsa(Class cls, <span class="hljs-keyword">bool</span> hasCxxDtor)<br>&#123;<br>    assert(!cls-&gt;instancesRequireRawIsa());<br>    assert(hasCxxDtor == cls-&gt;hasCxxDtor());<br>    <span class="hljs-comment">// 相当于也是包装了一层</span><br>    initIsa(cls, <span class="hljs-literal">true</span>, hasCxxDtor);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>initInstanceIsa</code>主要是调用<code>initIsa</code>方法，我们在进一步看下这个方法的实现：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <br>objc_object::initIsa(Class cls, <span class="hljs-keyword">bool</span> nonpointer, <span class="hljs-keyword">bool</span> hasCxxDtor) <br>&#123; <br>    ASSERT(!isTaggedPointer()); <br>    <span class="hljs-comment">// 如果是非isa_t类型 直接返回 这个cls即可 因为isa中只有一个指针指向isa</span><br>    <span class="hljs-keyword">if</span> (!nonpointer) &#123;<br>        isa = isa_t((uintptr_t)cls);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        ASSERT(!DisableNonpointerIsa);<br>        ASSERT(!cls-&gt;instancesRequireRawIsa());<br>        <span class="hljs-comment">// 创建 isa_t 类型临时变量</span><br>        isa_t newisa(<span class="hljs-number">0</span>);<br><br>        <span class="hljs-comment">// 配置 magic 表示当前对象已经创建</span><br>        <span class="hljs-comment">// 配置 nonpointer 表示当前对象的 isa 为 isa_t 类型的</span><br>        newisa.bits = ISA_MAGIC_VALUE;<br>        <span class="hljs-comment">// isa.magic is part of ISA_MAGIC_VALUE</span><br>        <span class="hljs-comment">// isa.nonpointer is part of ISA_MAGIC_VALUE</span><br>        <span class="hljs-comment">// 配置 has_cxx_dtor 表示当前对象是否有 C++ 的析构器</span><br>        newisa.has_cxx_dtor = hasCxxDtor;<br>        <span class="hljs-comment">// 配置 shiftcls 指向类对象，右移了 3 位是因为类的指针是按照字节（8bits）对齐的，</span><br>        <span class="hljs-comment">// 其指针后三位都是没有意义的 0，因此可以右移 3 位进行消除，以减小无意义的内存占用。</span><br>        newisa.shiftcls = (uintptr_t)cls &gt;&gt; <span class="hljs-number">3</span>;<br>        <br>        <span class="hljs-comment">// 将临时变量赋值给结构体成员</span><br>        isa = newisa;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>从上面我们看出如果是<code>isa_t</code>类型，我们主要设置<code>ISA</code>的<code>bits</code>、<code>has_cxx_dtor</code>、<code>shiftcls</code>三个属性。</p>
<h4 id="hasCustomAWZ"><a href="#hasCustomAWZ" class="headerlink" title="hasCustomAWZ"></a>hasCustomAWZ</h4><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">    <span class="hljs-keyword">bool</span> hasCustomAWZ() &#123;<br>        <span class="hljs-keyword">return</span> ! bits.hasDefaultAWZ();<br>    &#125;<br>    <br>    <span class="hljs-keyword">bool</span> hasDefaultAWZ() &#123;<br>        <span class="hljs-keyword">return</span> data()-&gt;flags &amp; RW_HAS_DEFAULT_AWZ;<br>    &#125;<br>    <br><span class="hljs-comment">// class or superclass has default alloc/allocWithZone: implementation</span><br><span class="hljs-comment">// Note this is is stored in the metaclass.</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> RW_HAS_DEFAULT_AWZ    (1&lt;&lt;16)</span><br></code></pre></td></tr></table></figure>

<p><code>RW_HAS_DEFAULT_AWZ</code>这个标志位表明是<code>cls</code>或者<code>superclass</code>是否有默认的<code>alloc/allocWithZone</code>方法实现，<code>hasCustomAWZ</code>的意思是是否有自定义的<code>AWZ(allocWithZone)</code>方法,在我们前面的<a href="http://www.leewong.cn/2020/10/24/oc-object-structure/">NSObject结构</a>这篇文章中我们介绍过下面这张图</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gk0s5oef3ej30ro0imgtj.jpg"></p>
<p>在图中我们看到<code>NSObject</code>结构中有一个<code>uint32_t</code>类型的<code>flags</code>,而<code>hasDefaultAWZ</code>方法就是从我们的<code>NSObject</code>结构中通过按位与的方法获取到这个值。</p>
<h4 id="object-cxxConstructFromClass"><a href="#object-cxxConstructFromClass" class="headerlink" title="object_cxxConstructFromClass"></a>object_cxxConstructFromClass</h4><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">// 递归调用对象的C++构造方法，从基类到子类的构造方法</span><br><span class="hljs-keyword">id</span> <br>object_cxxConstructFromClass(<span class="hljs-keyword">id</span> obj, Class cls, <span class="hljs-keyword">int</span> flags)<br>&#123;<br>    ASSERT(cls-&gt;hasCxxCtor());  <span class="hljs-comment">// required for performance, not correctness</span><br><br>    <span class="hljs-keyword">id</span> (*ctor)(<span class="hljs-keyword">id</span>);<br>    Class supercls;<br><br>    supercls = cls-&gt;superclass;<br><br>    <span class="hljs-comment">// Call superclasses&#x27; ctors first, if any.</span><br>    <span class="hljs-comment">// 如果父类有C++构造方法</span><br>    <span class="hljs-keyword">if</span> (supercls  &amp;&amp;  supercls-&gt;hasCxxCtor()) &#123;<br>        <span class="hljs-comment">// 调用父类构造方法</span><br>        <span class="hljs-keyword">bool</span> ok = object_cxxConstructFromClass(obj, supercls, flags);<br>        <span class="hljs-comment">// 父类构造方法失败 返回nil</span><br>        <span class="hljs-keyword">if</span> (slowpath(!ok)) <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>;  <span class="hljs-comment">// some superclass&#x27;s ctor failed - give up</span><br>    &#125;<br><br>    <span class="hljs-comment">// Find this class&#x27;s ctor, if any.</span><br>    <span class="hljs-comment">// 父类构造方法调用完成后调用当前类的SEL_cxx_construct方法</span><br>    ctor = (<span class="hljs-keyword">id</span>(*)(<span class="hljs-keyword">id</span>))lookupMethodInClassAndLoadCache(cls, SEL_cxx_construct);<br>    <span class="hljs-comment">// 如果当前类的构造为转发方法 那么直接返回 表示没有对应实现</span><br>    <span class="hljs-keyword">if</span> (ctor == (<span class="hljs-keyword">id</span>(*)(<span class="hljs-keyword">id</span>))_objc_msgForward_impcache) <span class="hljs-keyword">return</span> obj;  <span class="hljs-comment">// no ctor - ok</span><br>    <br>    <span class="hljs-comment">// Call this class&#x27;s ctor.</span><br>    <span class="hljs-keyword">if</span> (PrintCxxCtors) &#123;<br>        _objc_inform(<span class="hljs-string">&quot;CXX: calling C++ constructors for class %s&quot;</span>, <br>                     cls-&gt;nameForLogging());<br>    &#125;<br>    <span class="hljs-comment">// 调用构造方法 传入参数obj</span><br>    <span class="hljs-keyword">if</span> (fastpath((*ctor)(obj))) <span class="hljs-keyword">return</span> obj;  <span class="hljs-comment">// ctor called and succeeded - ok</span><br><br>    supercls = cls-&gt;superclass; <span class="hljs-comment">// this reload avoids a spill on the stack</span><br><br>    <span class="hljs-comment">// This class&#x27;s ctor was called and failed.</span><br>    <span class="hljs-comment">// Call superclasses&#x27;s dtors to clean up.</span><br>    <span class="hljs-keyword">if</span> (supercls) object_cxxDestructFromClass(obj, supercls);<br>    <span class="hljs-keyword">if</span> (flags &amp; OBJECT_CONSTRUCT_FREE_ONFAILURE) free(obj);<br>    <span class="hljs-keyword">if</span> (flags &amp; OBJECT_CONSTRUCT_CALL_BADALLOC) &#123;<br>        <span class="hljs-keyword">return</span> _objc_callBadAllocHandler(cls);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>;<br>&#125;<br></code></pre></td></tr></table></figure>


<h4 id="allocWithZone"><a href="#allocWithZone" class="headerlink" title="allocWithZone"></a>allocWithZone</h4><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">// Replaced by ObjectAlloc</span><br>+ (<span class="hljs-keyword">id</span>)allocWithZone:(<span class="hljs-keyword">struct</span> _NSZone *)zone &#123;<br>    <span class="hljs-keyword">return</span> _objc_rootAllocWithZone(<span class="hljs-keyword">self</span>, (malloc_zone_t *)zone);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这里实际上又回到了上面的<code>_objc_rootAllocWithZone</code>方法，与<code>OBJC2</code>的区别只是是否做了<code>cls</code>为nil的判断以及是否有自定义的<code>allocWithZone</code>的方法。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">if</span> (slowpath(checkNil &amp;&amp; !cls)) <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>;<br><span class="hljs-comment">// 是否有自定义的allocWithZone方法</span><br><span class="hljs-keyword">if</span> (fastpath(!cls-&gt;ISA()-&gt;hasCustomAWZ())) &#123;<br>    <span class="hljs-comment">// 直接调用_objc_rootAllocWithZone</span><br>    <span class="hljs-keyword">return</span> _objc_rootAllocWithZone(cls, <span class="hljs-literal">nil</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>alloc</code>方法调用完成之后，我们实际上已经开辟了对应的内存空间初始化好了<code>ISA</code>的部分信息，下面我们来看下<code>init</code>方法。</p>
<h2 id="init"><a href="#init" class="headerlink" title="init"></a>init</h2><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">- (<span class="hljs-keyword">id</span>)init &#123;<br>    <span class="hljs-keyword">return</span> _objc_rootInit(<span class="hljs-keyword">self</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">id</span><br>_objc_rootInit(<span class="hljs-keyword">id</span> obj)<br>&#123;<br>    <span class="hljs-comment">// In practice, it will be hard to rely on this function.</span><br>    <span class="hljs-comment">// Many classes do not properly chain -init calls.</span><br>    <span class="hljs-keyword">return</span> obj;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>从这里我们看到<code>init</code>方法实际上并没有实现什么只是将我们在<code>alloc</code>方法创建好的对象返回了。</p>
<h2 id="new"><a href="#new" class="headerlink" title="new"></a>new</h2><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">+ (<span class="hljs-keyword">id</span>)new &#123;<br>    <span class="hljs-keyword">return</span> [callAlloc(<span class="hljs-keyword">self</span>, <span class="hljs-literal">false</span><span class="hljs-comment">/*checkNil*/</span>) init];<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们看到这个方法实际上就是调用了<code>callAlloc</code>方法然后<code>callAlloc</code>返回的对象在调用<code>init</code>方法。</p>
<p>至此对象创建的几种方式我们就分析完成了。</p>
<p>对象创建流程如下(主要是alloc方法)：</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gl58rskmkaj30u00xojzw.jpg"></p>
<h2 id="对象赋值"><a href="#对象赋值" class="headerlink" title="对象赋值"></a>对象赋值</h2><p>看完了对象的初始化，我们在平时常用的就是给对象赋值和拷贝，比如</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">Person *person = [[Person alloc] init];<br>Person *personCpy = [person <span class="hljs-keyword">copy</span>];<br></code></pre></td></tr></table></figure>

<p>下面我们主要从上面这两个方面来看下在这个过程中<code>Runtime</code>都做了什么：</p>
<h3 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h3><p>我们都知道，对于一个对象的引用我们有弱引用和强引用两种，分别用<code>__weak</code>和<code>__strong</code>来修饰，如果我们不做显示说明那么默认是<code>__strong</code>。</p>
<p>我们在Runtime中去查找修饰变量的类型时发现了下面这个枚举:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">/*</span><br><span class="hljs-comment">  &quot;Unknown&quot; includes non-object ivars and non-ARC non-__weak ivars</span><br><span class="hljs-comment">  &quot;Strong&quot; includes ARC __strong ivars</span><br><span class="hljs-comment">  &quot;Weak&quot; includes ARC and new MRC __weak ivars</span><br><span class="hljs-comment">  &quot;Unretained&quot; includes ARC __unsafe_unretained and old GC+MRC __weak ivars</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">enum</span> &#123;<br>    objc_ivar_memoryUnknown,     <span class="hljs-comment">// unknown / unknown</span><br>    objc_ivar_memoryStrong,      <span class="hljs-comment">// direct access / objc_storeStrong</span><br>    objc_ivar_memoryWeak,        <span class="hljs-comment">// objc_loadWeak[Retained] / objc_storeWeak</span><br>    objc_ivar_memoryUnretained   <span class="hljs-comment">// direct access / direct access</span><br>&#125; objc_ivar_memory_management_t;<br></code></pre></td></tr></table></figure>

<p>下面我们来详细的了解下这其中的区别：</p>
<h3 id="strong"><a href="#strong" class="headerlink" title="__strong"></a>__strong</h3><p>上面看到的</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">Person *stu = [[Person alloc] init];<br></code></pre></td></tr></table></figure>

<p>实际上可以翻译成：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">__<span class="hljs-keyword">strong</span> Person *stu = [[Person alloc] init];<br></code></pre></td></tr></table></figure>

<p>那么<code>__strong</code>都做了什么呢？我们直接去看下<code>objc_storeStrong</code>方法都做了什么：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">void</span><br>objc_storeStrong(<span class="hljs-keyword">id</span> *location, <span class="hljs-keyword">id</span> obj)<br>&#123;<br>    <span class="hljs-keyword">id</span> prev = *location;<br>    <span class="hljs-comment">// 先判断之前的值和要新赋值的对象地址是否相同</span><br>    <span class="hljs-keyword">if</span> (obj == prev) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// 执行retain操作 保留新值</span><br>    objc_retain(obj);<br>    *location = obj;<br>    <span class="hljs-comment">// 释放旧值</span><br>    objc_release(prev);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这个方法的主要操作让我们很容易联想到<code>MRC</code>下<code>setter</code>方法的书写方式，保留新值，释放旧值。我们在进一步看下<code>objc_retain</code>和<code>objc_release</code>的实现。</p>
<h4 id="objc-retain"><a href="#objc-retain" class="headerlink" title="objc_retain"></a>objc_retain</h4><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">__attribute__((aligned(<span class="hljs-number">16</span>), flatten, noinline))<br><span class="hljs-keyword">id</span> <br>objc_retain(<span class="hljs-keyword">id</span> obj)<br>&#123;<br>    <span class="hljs-comment">// 如果为nil 直接返回nil</span><br>    <span class="hljs-keyword">if</span> (!obj) <span class="hljs-keyword">return</span> obj;<br>    <span class="hljs-comment">// 如果是taggedPointer 直接返回</span><br>    <span class="hljs-keyword">if</span> (obj-&gt;isTaggedPointer()) <span class="hljs-keyword">return</span> obj;<br>    <span class="hljs-comment">// 调用retain方法</span><br>    <span class="hljs-keyword">return</span> obj-&gt;<span class="hljs-keyword">retain</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这个方法里 判断了如果要被<code>retain</code>的对象为<code>nil</code>或者是<code>TaggedPointer</code>类型那么直接返回否则调用<code>retain</code>方法。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">// 等价于直接使用对象调用retain方法</span><br><span class="hljs-keyword">inline</span> <span class="hljs-keyword">id</span> <br>objc_object::<span class="hljs-keyword">retain</span>()<br>&#123;<br>    <span class="hljs-comment">// 如果是TaggedPointer类型 不涉及引用计数</span><br>    ASSERT(!isTaggedPointer());<br>    <span class="hljs-comment">// fastpath 表示if中的条件是一个大概率事件</span><br>    <span class="hljs-comment">// 如果当前对象没有自定义（override）retain 方法</span><br>    <span class="hljs-keyword">if</span> (fastpath(!ISA()-&gt;hasCustomRR())) &#123;<br>        <span class="hljs-keyword">return</span> rootRetain();<br>    &#125;<br>    <span class="hljs-comment">// 如果有自定义的retain方法</span><br>    <span class="hljs-comment">// 通过发消息的方式调用自定义的 retain 方法</span><br>    <span class="hljs-keyword">return</span> ((<span class="hljs-keyword">id</span>(*)(objc_object *, SEL))objc_msgSend)(<span class="hljs-keyword">this</span>, <span class="hljs-keyword">@selector</span>(<span class="hljs-keyword">retain</span>));<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这个方法实际上最后调用了<code>rootRetain</code>，对于这个方法我们在<br><a href="http://www.leewong.cn/2020/08/02/retaincount/">retain和release实现探究</a>这篇文章中详细的介绍过。这里我们就不做进一步的介绍了。我们只需要知道在这个方法中我们<code>newisa.nonpointer</code>判断需要增加哪里的引用计数：</p>
<ul>
<li>如果<code>newisa.nonpointer = 0</code> 则没有进行<code>runtime</code>优化，在<code>sidetable</code>中找到这个对象对应的节点更新将<code>SideTable</code>该对象对应的节点的<code>refcntStorage</code>值 + 1</li>
<li>如果<code>newisa.nonpointer = 1</code> 则进行了<code>runtime</code>优化，那么直接在<code>newisa.extra_rc</code>上做引用计数<code>+1</code>同时需要判断<code>newisa.extra_rc</code>是否溢出，如果溢出则需要将一半的引用计数放到<code>sidetable</code>的<code>refcntStorage</code>中同时将<code>newisa.has_sidetable_rc</code>置为true。</li>
</ul>
<p>从上面可以看出<code>objc_retain</code>的操作实际是：<strong>将新对象的引用计数+1，将旧对象的引用计数-1</strong>。</p>
<h3 id="weak"><a href="#weak" class="headerlink" title="__weak"></a>__weak</h3><p>当我们用<code>__weak</code>去修饰一个变量时根据上面的介绍我们实际上是调用<code>objc_storeWeak</code>方法，我们直接看下这个方法的实现。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">// location weak指针自身的地址</span><br><span class="hljs-comment">// newObj weak指针指向的新对象的地址</span><br><span class="hljs-keyword">id</span><br>objc_storeWeak(<span class="hljs-keyword">id</span> *location, <span class="hljs-keyword">id</span> newObj)<br>&#123;<br>    <span class="hljs-keyword">return</span> storeWeak&lt;DoHaveOld, DoHaveNew, DoCrashIfDeallocating&gt;<br>        (location, (objc_object *)newObj);<br></code></pre></td></tr></table></figure>

<p>这个方法内部实际调用了<code>storeWeak</code>方法，这个方法与<code>rootRetain</code>一起，我们在<a href="http://www.leewong.cn/2020/08/02/retaincount/">retain和release实现探究</a>这里都有详细的讲解这里不再赘述。</p>
<p>我们大概描述下<code>storeWeak</code>操作做了哪些事情：</p>
<ul>
<li>根据对象地址从<code>SideTable</code>中取出对应的节点，如果之前没有 则创建一个新的</li>
<li>调用<code>weak_unregister_no_lock</code>，将<code>weak pointer</code>的地址从旧对象的<code>weak_entry_t</code>中移除，同时判断是否<code>weak_entry_t</code>为空,则将<code>weak_entry_t</code>从<code>weaktable</code>中移除。</li>
<li>调用<code>weak_register_no_lock</code>方法，将<code>weak pointer</code>的地址(location)记录到对象对应的<code>weak_entry_t</code>中，并将对象的isa指针中的<code>weakly_referenced</code>标志位置为1，表明这个对象被弱引用了</li>
</ul>
<h3 id="retaincount"><a href="#retaincount" class="headerlink" title="retaincount"></a>retaincount</h3><p>我们上面创建或者给一个strong类型的指针赋值，实际上都是对引用计数的+1操作，那么我们看下这个引用计数是如何保存的呢？</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">- (<span class="hljs-built_in">NSUInteger</span>)retainCount &#123;<br>    <span class="hljs-keyword">return</span> _objc_rootRetainCount(<span class="hljs-keyword">self</span>);<br>&#125;<br><br>uintptr_t<br>_objc_rootRetainCount(<span class="hljs-keyword">id</span> obj)<br>&#123;<br>    ASSERT(obj);<br><br>    <span class="hljs-keyword">return</span> obj-&gt;rootRetainCount();<br>&#125;<br><br></code></pre></td></tr></table></figure>

<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">// 获取引用高技术</span><br><span class="hljs-keyword">inline</span> uintptr_t <br>objc_object::rootRetainCount()<br>&#123;<br>    <span class="hljs-comment">//isTaggedPointer 不需要引用计数</span><br>    <span class="hljs-keyword">if</span> (isTaggedPointer()) <span class="hljs-keyword">return</span> (uintptr_t)<span class="hljs-keyword">this</span>;<br><br>    sidetable_lock();<br>    isa_t bits = LoadExclusive(&amp;isa.bits);<br>    ClearExclusive(&amp;isa.bits);<br>    <span class="hljs-comment">// 如果是nonpointer</span><br>    <span class="hljs-keyword">if</span> (bits.nonpointer) &#123;<br>        <span class="hljs-comment">// 先从extra_rc取出部分引用计数</span><br>        uintptr_t rc = <span class="hljs-number">1</span> + bits.extra_rc;<br>        <span class="hljs-comment">// sidetable中是否有额外的引用计数</span><br>        <span class="hljs-keyword">if</span> (bits.has_sidetable_rc) &#123;<br>            <span class="hljs-comment">// 从sidetable中获取引用计数</span><br>            rc += sidetable_getExtraRC_nolock();<br>        &#125;<br>        sidetable_unlock();<br>        <span class="hljs-keyword">return</span> rc;<br>    &#125;<br><br>    sidetable_unlock();<br>    <span class="hljs-comment">// 如果不是nonpointer 直接从sidetable中获取引用计数</span><br>    <span class="hljs-keyword">return</span> sidetable_retainCount();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果对象是<code>TaggedPointer</code> 直接返回这个对象(<code>TaggedPointer</code>不需要引用计数)，否则</p>
<ul>
<li><code>bits.nonpointer = 1</code> 则先从<code>bits.extra_rc</code>获取部分引用计数 然后判断<code>sidetable</code>中是否有额外的引用计数 如果有 二者相加</li>
<li><code>bits.nonpointer = 0</code> 则直接从<code>sidetable</code>中获取引用计数</li>
</ul>
<h2 id="对象的销毁"><a href="#对象的销毁" class="headerlink" title="对象的销毁"></a>对象的销毁</h2><p>对象常用的销毁方法实际上就是<code>release</code>和<code>autorelease</code>两种。我们来看下这两种的具体实现：</p>
<h3 id="release"><a href="#release" class="headerlink" title="release"></a>release</h3><p>在查看源码前，我们知道<code>release</code>的主要功能是：<strong>引用计数-1</strong>，我们来看下具体实现</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">- (<span class="hljs-keyword">oneway</span> <span class="hljs-keyword">void</span>)release &#123;<br>    _objc_rootRelease(<span class="hljs-keyword">self</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们看下_objc_rootRelease的实现：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">NEVER_INLINE <span class="hljs-keyword">void</span><br>_objc_rootRelease(<span class="hljs-keyword">id</span> obj)<br>&#123;<br>    ASSERT(obj);<br><br>    obj-&gt;rootRelease();<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>rootRelease</code>方法我们在<a href="http://www.leewong.cn/2020/08/02/retaincount/">retain和release实现探究</a>中也有详细介绍。</p>
<p>我们简单的说下<code>rootRelease</code>这个方法：</p>
<ul>
<li>如果<code>newisa.nonpointer = 0</code> 则调用<code>sidetable_release</code>方法，这个方法会判断<code>sidetable</code>中<code>refcnt</code>是否小于<code>SIDE_TABLE_DEALLOCATING</code> 如果小于则表示这个对象要被释放，则调用<code>dealloc</code>方法。如果不小于则直接执行<code>refcnt -= SIDE_TABLE_RC_ONE</code>;即<code>refcnt-1</code>操作。</li>
<li>如果<code>newisa.nonpointer = 1</code> 则 对<code>newisa.extra_rc</code>进行-1操作，然后判断<code>newisa.extra_rc</code>是否有向下溢出，并执行对应操作。</li>
</ul>
<h3 id="autorelease"><a href="#autorelease" class="headerlink" title="autorelease"></a>autorelease</h3><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">- (<span class="hljs-keyword">id</span>)autorelease &#123;<br>    <span class="hljs-keyword">return</span> _objc_rootAutorelease(<span class="hljs-keyword">self</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">__attribute__((noinline,used))<br><span class="hljs-keyword">id</span> <br>objc_object::rootAutorelease2()<br>&#123;<br>    ASSERT(!isTaggedPointer());<br>    <span class="hljs-keyword">return</span> AutoreleasePoolPage::autorelease((<span class="hljs-keyword">id</span>)<span class="hljs-keyword">this</span>);<br>&#125;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">id</span> autorelease(<span class="hljs-keyword">id</span> obj)<br>    &#123;<br>        ASSERT(obj);<br>        ASSERT(!obj-&gt;isTaggedPointer());<br>        <span class="hljs-keyword">id</span> *dest __unused = autoreleaseFast(obj);<br>        ASSERT(!dest  ||  dest == EMPTY_POOL_PLACEHOLDER  ||  *dest == obj);<br>        <span class="hljs-keyword">return</span> obj;<br>    &#125;<br>    <br><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">id</span> *autoreleaseFast(<span class="hljs-keyword">id</span> obj)<br>    &#123;<br>        AutoreleasePoolPage *page = hotPage();<br>        <span class="hljs-keyword">if</span> (page &amp;&amp; !page-&gt;full()) &#123;<br>            <span class="hljs-keyword">return</span> page-&gt;add(obj);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (page) &#123;<br>            <span class="hljs-keyword">return</span> autoreleaseFullPage(obj, page);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> autoreleaseNoPage(obj);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>我们看到<code>autorelease</code>实际上最终是调用了<code>AutoreleasePoolPage</code>的<code>autorelease</code>方法，<code>AutoreleasePoolPage</code>我们在<a href="http://www.leewong.cn/2018/03/20/iOS%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B9%8BAutoreleasePool/">iOS内存管理之AutoreleasePool</a>中有详细介绍，这里我们也不再赘述。</p>
<p>我们简单的回忆下<code>AutoreleasePoolPage</code>几个重要方法：</p>
<ul>
<li><p>push</p>
<p>  1、首先取出当前的<code>hotPage</code>，所谓<code>hotPage</code>，就是在<code>autoreleasePage</code>链表中正在使用的<code>autoreleasePage</code>节点。<br>  2、如果有<code>hotPage</code>，且<code>hotPage</code>还没满，这将obj加入到page中。<br>  3、如果有<code>hotPage</code>，但是已经满了，则进入<code>page full</code>逻辑（autoreleaseFullPage）<br>  4、如果没有<code>hotPage</code>，进入no page逻辑<code>autoreleaseNoPage</code>。</p>
</li>
<li><p>pop(void pop(void *token))</p>
<p>当<code>autoreleasepool</code>需要被释放时，会调用<code>Pop</code>方法。而Pop方法需要接受一个<code>void *token</code>参数，来告诉池子，需要一直释放到token对应的那个page</p>
</li>
</ul>
<p>通过上面的介绍，我们知道<code>AutoreleasePoolPage</code>实际上就是一个存放待释放对象的缓存池。push为追加对象，pop为释放对象。</p>
<h3 id="dealloc"><a href="#dealloc" class="headerlink" title="dealloc"></a>dealloc</h3><p>在上面我们介绍<code>release</code>时，我们发现在对对象的引用计数进行-1操作时，如果判断对象引用计数为0，会主动调用<code>dealloc</code>,那么我们看下这个方法的实现</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">- (<span class="hljs-keyword">void</span>)dealloc &#123;<br>    _objc_rootDealloc(<span class="hljs-keyword">self</span>);<br>&#125;<br><br>_objc_rootDealloc(<span class="hljs-keyword">id</span> obj)<br>&#123;<br>    ASSERT(obj);<br><br>    obj-&gt;rootDealloc();<br>&#125;<br><br><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span><br>objc_object::rootDealloc()<br>&#123;<br>    <span class="hljs-keyword">if</span> (isTaggedPointer()) <span class="hljs-keyword">return</span>;  <span class="hljs-comment">// fixme necessary?</span><br><br>    <span class="hljs-keyword">if</span> (fastpath(isa.nonpointer  &amp;&amp;  <br>                 !isa.weakly_referenced  &amp;&amp;  <br>                 !isa.has_assoc  &amp;&amp;  <br>                 !isa.has_cxx_dtor  &amp;&amp;  <br>                 !isa.has_sidetable_rc))<br>    &#123;<br>        assert(!sidetable_present());<br>        free(<span class="hljs-keyword">this</span>);<br>    &#125; <br>    <span class="hljs-keyword">else</span> &#123;<br>        object_dispose((<span class="hljs-keyword">id</span>)<span class="hljs-keyword">this</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们看到这个方法主要逻辑为：</p>
<ul>
<li>如果对象<code>isa.nonpointer=1</code>且没有弱指针指向他，且没有关联对象，没有自定义销毁方法，<code>sidetable</code>的<code>retainCount = 0</code> 则直接释放</li>
<li>如果对象<code>isa.nonpointer=0</code> 则需要调用<code>object_dispose</code>方法</li>
</ul>
<p>我们在看下<code>object_dispose</code>方法的实现：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">static</span> <span class="hljs-keyword">id</span> <br>_object_dispose(<span class="hljs-keyword">id</span> anObject) <br>&#123;<br>    <span class="hljs-keyword">if</span> (anObject==<span class="hljs-literal">nil</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>;<br>    <span class="hljs-comment">// 调用objc_destructInstance</span><br>    objc_destructInstance(anObject);<br>    <span class="hljs-comment">// isa指针为_objc_getFreedObjectClass类型</span><br>    anObject-&gt;initIsa(_objc_getFreedObjectClass ()); <br>    <span class="hljs-comment">// 释放对象</span><br>    free(anObject);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们进一步看下<code>_object_dispose</code>中的这几个方法</p>
<h4 id="objc-destructInstance"><a href="#objc-destructInstance" class="headerlink" title="objc_destructInstance"></a>objc_destructInstance</h4><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">// 对象的析构方法</span><br><span class="hljs-keyword">void</span> *objc_destructInstance(<span class="hljs-keyword">id</span> obj) <br>&#123;<br>    <span class="hljs-keyword">if</span> (obj) &#123;<br>        <span class="hljs-comment">// 获取到isa</span><br>        Class isa = obj-&gt;getIsa();<br>        <span class="hljs-comment">// 是否有c++析构方法 有则执行</span><br>        <span class="hljs-keyword">if</span> (isa-&gt;hasCxxDtor()) &#123;<br>            object_cxxDestruct(obj);<br>        &#125;<br>        <span class="hljs-comment">// 是否有关联对象 有则移除</span><br>        <span class="hljs-keyword">if</span> (isa-&gt;instancesHaveAssociatedObjects()) &#123;<br>            _object_remove_assocations(obj);<br>        &#125;<br>        <span class="hljs-comment">// 调用objc_clear_deallocating方法</span><br>        objc_clear_deallocating(obj);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> obj;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="initIsa"><a href="#initIsa" class="headerlink" title="initIsa"></a>initIsa</h4><p>这个方法我们在上面介绍过了 这里主要看下参数<code>_objc_getFreedObjectClass ()</code>,我们看下系统给的解释</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">/***********************************************************************</span><br><span class="hljs-comment">* _class_getFreedObjectClass.  Return a pointer to the dummy freed</span><br><span class="hljs-comment">* object class.  Freed objects get their isa pointers replaced with</span><br><span class="hljs-comment">* a pointer to the freedObjectClass, so that we can catch usages of</span><br><span class="hljs-comment">* the freed object.</span><br><span class="hljs-comment">**********************************************************************/</span><br><span class="hljs-keyword">static</span> Class _class_getFreedObjectClass(<span class="hljs-keyword">void</span>)<br>&#123;<br>    <span class="hljs-keyword">return</span> (Class)freedObjectClass;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>我们可以简单的理解为，对于一个已释放的对象他的isa指针指向了<code>freedObjectClass</code>类型，系统以此作为已释放对象的标记。</p>
<p>我们在源码中搜索的时候还发现：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">if</span> (anObject-&gt;ISA() == _objc_getFreedObjectClass ())<br>       __objc_error(anObject, <span class="hljs-string">&quot;reallocating freed object&quot;</span>);<br><br></code></pre></td></tr></table></figure>
<p>重新分配已释放对象的空间，这也作证了我们上面描述的。</p>
<h4 id="objc-clear-deallocating"><a href="#objc-clear-deallocating" class="headerlink" title="objc_clear_deallocating"></a>objc_clear_deallocating</h4><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <br>objc_object::clearDeallocating()<br>&#123;<br>    <span class="hljs-keyword">if</span> (slowpath(!isa.nonpointer)) &#123;<br>        <span class="hljs-comment">// Slow path for raw pointer isa.</span><br>        sidetable_clearDeallocating();<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (slowpath(isa.weakly_referenced  ||  isa.has_sidetable_rc)) &#123;<br>        <span class="hljs-comment">// Slow path for non-pointer isa with weak refs and/or side table data.</span><br>        clearDeallocating_slow();<br>    &#125;<br><br>    assert(!sidetable_present());<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这个方法也是根据<code>isa.nonpointer</code>判断：</p>
<ul>
<li>如果<code>isa.nonpointer = 0</code> 调用s<code>idetable_clearDeallocating</code> 执行<code>sidetable</code>相关的释放</li>
<li>如果<code>isa.nonpointer = 1</code> 调用<code>clearDeallocating_slow</code> 进行释放</li>
</ul>
<h4 id="sidetable-clearDeallocating"><a href="#sidetable-clearDeallocating" class="headerlink" title="sidetable_clearDeallocating"></a>sidetable_clearDeallocating</h4><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">void</span> <br>objc_object::sidetable_clearDeallocating()<br>&#123;<br>    SideTable&amp; table = SideTables()[<span class="hljs-keyword">this</span>];<br><br>    <span class="hljs-comment">// clear any weak table items</span><br>    <span class="hljs-comment">// clear extra retain count and deallocating bit</span><br>    <span class="hljs-comment">// (fixme warn or abort if extra retain count == 0 ?)</span><br>    table.lock();<br>    RefcountMap::iterator it = table.refcnts.find(<span class="hljs-keyword">this</span>);<br>    <span class="hljs-keyword">if</span> (it != table.refcnts.end()) &#123;<br>        <span class="hljs-keyword">if</span> (it-&gt;second &amp; SIDE_TABLE_WEAKLY_REFERENCED) &#123;<br>            weak_clear_no_lock(&amp;table.weak_table, (<span class="hljs-keyword">id</span>)<span class="hljs-keyword">this</span>);<br>        &#125;<br>        table.refcnts.erase(it);<br>    &#125;<br>    table.unlock();<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>根据<code>this</code>取出对象对应的<code>sidetable</code> 如果有弱引用指针指向这个对象 则这里进行置nil 调用的是<code>weak_clear_no_lock</code>方法</li>
<li>调用<code>erase</code>方法将<code>table.refcnts</code>置为空</li>
</ul>
<h4 id="clearDeallocating-slow"><a href="#clearDeallocating-slow" class="headerlink" title="clearDeallocating_slow"></a>clearDeallocating_slow</h4><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">NEVER_INLINE <span class="hljs-keyword">void</span><br>objc_object::clearDeallocating_slow()<br>&#123;<br>    ASSERT(isa.nonpointer  &amp;&amp;  (isa.weakly_referenced || isa.has_sidetable_rc));<br><br>    SideTable&amp; table = SideTables()[<span class="hljs-keyword">this</span>];<br>    table.lock();<br>    <span class="hljs-keyword">if</span> (isa.weakly_referenced) &#123;<br>        weak_clear_no_lock(&amp;table.weak_table, (<span class="hljs-keyword">id</span>)<span class="hljs-keyword">this</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (isa.has_sidetable_rc) &#123;<br>        table.refcnts.erase(<span class="hljs-keyword">this</span>);<br>    &#125;<br>    table.unlock();<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>实际上这个方法和<code>sidetable_clearDeallocating</code>方法的实现高度相似，只是标志位一个是从<code>it-&gt;second</code>通过按位与方法判断一个是直接从isa中获取。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇文章我们从对象的创建以及赋值销毁等方面分析了Runtime的实现，尤其是对于引用计数器的操作。让我们对内存管理有了更清晰的认识。</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://blog.csdn.net/u013378438/article/details/86508575">OC对象从创建到销毁</a><br><a href="https://halfrost.com/objc_life/">Objc 对象的今生今世</a></p>
]]></content>
      <categories>
        <category>Runtime</category>
      </categories>
      <tags>
        <tag>Runtime Retain Release</tag>
      </tags>
  </entry>
  <entry>
    <title>内存管理之Tagged pointer</title>
    <url>/2020/08/08/tagpointer/</url>
    <content><![CDATA[<p>iOS开发者对<code>引用计数</code>这个名词肯定不陌生,引用计数是苹果为了方便开发者管理内存而引入的一个概念,当引用计数为0时，对象就会被释放。但是，真的是所有对象都是这样吗？</p>
<a id="more"></a>

<h3 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h3><p>iOS将虚拟内存按照地址由低到高划分为如下五个区：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghjbitqd60j30cn09ljrw.jpg"></p>
<p>在程序运行时，代码区，常量区以及全局静态区的大小是固定的，会变化的只有栈和堆的大小。而栈的内存是有操作系统自动释放的，我们平常说所的iOS内存引用计数，其实是就堆上的对象来说的。</p>
<h3 id="如何引入tagged-pointer"><a href="#如何引入tagged-pointer" class="headerlink" title="如何引入tagged pointer"></a>如何引入tagged pointer</h3><p>自2013年苹果推出iphone5s之后，iOS的寻址空间扩大到了64位。我们可以用63位来表示一个数字(一位做符号位)。那么这个数字的范围是2^63 ,很明显我们一般不会用到这么大的数字，那么在我们定义一个数字时<code>NSNumber *num = @100</code>,实际上内存中浪费了很多的内存空间。</p>
<p>当然苹果肯定也认识到了这个问题，于是就引入了<code>tagged pointer</code>,<code>tagged pointer</code>是一种特殊的“指针”，其特殊在于，其实它存储的并不是地址，而是真实的数据和一些附加的信息。</p>
<p>我们可以在WWDC2013的《Session 404 Advanced in Objective-C》视频中，看到苹果对于Tagged Pointer特点的介绍：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghjdbgf38nj31el0u0afd.jpg"></p>
<ul>
<li>Tagged Pointer专门用来存储小的对象，例如NSNumber, NSDate, NSString。</li>
<li>Tagged Pointer指针的值不再是地址了，而是真正的值。所以，实际上它不再是一个对象了，它只是一个披着对象皮的普通变量而已。所以，它的内存并不存储在堆中，也不需要malloc和free。</li>
<li>在内存读取上有着3倍的效率，创建时比以前快106倍。</li>
</ul>
<h3 id="NSTaggedPointer"><a href="#NSTaggedPointer" class="headerlink" title="NSTaggedPointer"></a>NSTaggedPointer</h3><p>我们先看下下面这段代码：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-built_in">NSMutableString</span> *mutableStr = [<span class="hljs-built_in">NSMutableString</span> string];<br><span class="hljs-built_in">NSString</span> *immutable = <span class="hljs-literal">nil</span>;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> _OBJC_TAG_MASK (1UL&lt;&lt;63)</span><br><span class="hljs-keyword">char</span> c = <span class="hljs-string">&#x27;a&#x27;</span>;<br><span class="hljs-keyword">do</span> &#123;<br>    [mutableStr appendFormat:<span class="hljs-string">@&quot;%c&quot;</span>, c++];<br>    immutable = [mutableStr <span class="hljs-keyword">copy</span>];<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%p %@ %@&quot;</span>, immutable, immutable, immutable.class);<br>&#125;<span class="hljs-keyword">while</span>(((uintptr_t)immutable &amp; _OBJC_TAG_MASK) == _OBJC_TAG_MASK);<br></code></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs log">2020-08-08 14:15:54.480862+0800 TaggedPointerDemo[55468:2078125] 0xdc5050684e86e57c a NSTaggedPointerString<br>2020-08-08 14:15:54.481719+0800 TaggedPointerDemo[55468:2078125] 0xdc5050684e80c57f ab NSTaggedPointerString<br>2020-08-08 14:15:54.482480+0800 TaggedPointerDemo[55468:2078125] 0xdc50506848b0c57e abc NSTaggedPointerString<br>2020-08-08 14:15:54.483342+0800 TaggedPointerDemo[55468:2078125] 0xdc50506e08b0c579 abcd NSTaggedPointerString<br>2020-08-08 14:15:54.483950+0800 TaggedPointerDemo[55468:2078125] 0xdc50563e08b0c578 abcde NSTaggedPointerString<br>2020-08-08 14:15:54.484246+0800 TaggedPointerDemo[55468:2078125] 0xdc56363e08b0c57b abcdef NSTaggedPointerString<br>2020-08-08 14:15:54.484800+0800 TaggedPointerDemo[55468:2078125] 0xda26363e08b0c57a abcdefg NSTaggedPointerString<br>2020-08-08 14:15:54.485200+0800 TaggedPointerDemo[55468:2078125] 0xdc527050ee978a35 abcdefgh NSTaggedPointerString<br>2020-08-08 14:15:54.485644+0800 TaggedPointerDemo[55468:2078125] 0xdcd85e404adcb774 abcdefghi NSTaggedPointerString<br>2020-08-08 14:15:54.486003+0800 TaggedPointerDemo[55468:2078125] 0x28334c2c0 abcdefghij __NSCFString<br></code></pre></td></tr></table></figure>
<p>上图我们可以看到，当字符串的长度为10个以内时，字符串的类型都是<code>NSTaggedPointerString</code>类型，当超过10个时，字符串的类型才是<code>__NSCFString</code></p>
<p>打印结果分析：</p>
<h4 id="NSTaggedPointer标志位"><a href="#NSTaggedPointer标志位" class="headerlink" title="NSTaggedPointer标志位"></a>NSTaggedPointer标志位</h4><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">bool</span> <br>_objc_isTaggedPointer(<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> * _Nullable ptr)<br>&#123;<br>    <span class="hljs-keyword">return</span> ((uintptr_t)ptr &amp; _OBJC_TAG_MASK) == _OBJC_TAG_MASK;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>上面这个方法我们看到，判断一个对象类型是否为<code>NSTaggedPointerString</code>类型实际上是讲对象的地址与<code>_OBJC_TAG_MASK</code>进行按位与操作,结果在跟<code>_OBJC_TAG_MASK</code>进行对比,我们在看下<code>_OBJC_TAG_MASK</code>的定义:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> OBJC_MSB_TAGGED_POINTERS</span><br><span class="hljs-meta">#   <span class="hljs-meta-keyword">define</span> _OBJC_TAG_MASK (1UL&lt;&lt;63)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><br><span class="hljs-meta">#   <span class="hljs-meta-keyword">define</span> _OBJC_TAG_MASK 1UL</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br></code></pre></td></tr></table></figure>
<p>我们都知道一个对象地址为64位二进制，它表明如果64位数据中，最高位是1的话，则表明当前是一个<code>tagged pointer</code>类型。</p>
<p>那么我们在看下上面打印出的地址，所有<code>NSTaggedPointerString</code>地址都是<code>0xd</code>开头，d转换为二进制<code>1110</code>，根据上面的结论，我们看到首位为1表示为<code>NSTaggedPointerString</code>类型。在这里得到验证。</p>
<p><code>注意</code>:<code>TaggedPointer</code>类型在iOS和MacOS中标志位是不同的iOS为最高位而MacOS为最低位</p>
<h4 id="对象类型"><a href="#对象类型" class="headerlink" title="对象类型"></a>对象类型</h4><p>正常情况下一个对象的类型，是通过这个对象的ISA指针来判断的，那么对于<code>NSTaggedPointer</code>类型我们如何通过地址判断对应数据是什么类型的呢？</p>
<h5 id="objc4-723之前"><a href="#objc4-723之前" class="headerlink" title="objc4-723之前"></a>objc4-723之前</h5><p>在objc4-723之前，我们可以通过与判断<code>TaggedPointer</code>标志位一样根据地址来判断，而类型的标志位就是对象地址的61-63位,比如对象地址为<code>0xa</code>开头，那么转换成二进制位<code>1010</code>,那么去掉最高位标志位后，剩余为<code>010</code>,即10进制中的2。</p>
<p>接着我们看下runtime源码objc-internal.h中有关于标志位的定义如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> __has_feature(objc_fixed_enum)  ||  __cplusplus &gt;= 201103L</span><br><span class="hljs-keyword">enum</span> objc_tag_index_t : uint16_t<br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><br><span class="hljs-keyword">typedef</span> uint16_t objc_tag_index_t;<br><span class="hljs-keyword">enum</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>&#123;<br>    <span class="hljs-comment">// 60-bit payloads</span><br>    OBJC_TAG_NSAtom            = <span class="hljs-number">0</span>, <br>    OBJC_TAG_1                 = <span class="hljs-number">1</span>, <br>    OBJC_TAG_NSString          = <span class="hljs-number">2</span>, <br>    OBJC_TAG_NSNumber          = <span class="hljs-number">3</span>, <br>    OBJC_TAG_NSIndexPath       = <span class="hljs-number">4</span>, <br>    OBJC_TAG_NSManagedObjectID = <span class="hljs-number">5</span>, <br>    OBJC_TAG_NSDate            = <span class="hljs-number">6</span>,<br><br>    <span class="hljs-comment">// 60-bit reserved</span><br>    OBJC_TAG_RESERVED_7        = <span class="hljs-number">7</span>, <br><br>    <span class="hljs-comment">// 52-bit payloads</span><br>    OBJC_TAG_Photos_1          = <span class="hljs-number">8</span>,<br>    OBJC_TAG_Photos_2          = <span class="hljs-number">9</span>,<br>    OBJC_TAG_Photos_3          = <span class="hljs-number">10</span>,<br>    OBJC_TAG_Photos_4          = <span class="hljs-number">11</span>,<br>    OBJC_TAG_XPC_1             = <span class="hljs-number">12</span>,<br>    OBJC_TAG_XPC_2             = <span class="hljs-number">13</span>,<br>    OBJC_TAG_XPC_3             = <span class="hljs-number">14</span>,<br>    OBJC_TAG_XPC_4             = <span class="hljs-number">15</span>,<br><br>    OBJC_TAG_First60BitPayload = <span class="hljs-number">0</span>, <br>    OBJC_TAG_Last60BitPayload  = <span class="hljs-number">6</span>, <br>    OBJC_TAG_First52BitPayload = <span class="hljs-number">8</span>, <br>    OBJC_TAG_Last52BitPayload  = <span class="hljs-number">263</span>, <br><br>    OBJC_TAG_RESERVED_264      = <span class="hljs-number">264</span><br>&#125;;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> __has_feature(objc_fixed_enum)  &amp;&amp;  !defined(__cplusplus)</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">enum</span> objc_tag_index_t objc_tag_index_t;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br></code></pre></td></tr></table></figure>
<p>那么我们知道2表示的<code>OBJC_TAG_NSString</code>即字符串类型。因为目前已经无法验证这种情况了 所以我们不做其他类型验证。</p>
<h5 id="objc4-750之后"><a href="#objc4-750之后" class="headerlink" title="objc4-750之后"></a>objc4-750之后</h5><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">// Returns a pointer to the class&#x27;s storage in the tagged class arrays.</span><br><span class="hljs-comment">// Assumes the tag is a valid basic tag.</span><br><span class="hljs-keyword">static</span> Class *<br>classSlotForBasicTagIndex(objc_tag_index_t tag)<br>&#123;<br>    uintptr_t tagObfuscator = ((objc_debug_taggedpointer_obfuscator<br>                                &gt;&gt; _OBJC_TAG_INDEX_SHIFT)<br>                               &amp; _OBJC_TAG_INDEX_MASK);<br>    uintptr_t obfuscatedTag = tag ^ tagObfuscator;<br>    <span class="hljs-comment">// Array index in objc_tag_classes includes the tagged bit itself</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> SUPPORT_MSB_TAGGED_POINTERS <span class="hljs-comment">////高位优先</span></span><br>    <span class="hljs-keyword">return</span> &amp;objc_tag_classes[<span class="hljs-number">0x8</span> | obfuscatedTag];<br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><br>    <span class="hljs-keyword">return</span> &amp;objc_tag_classes[(obfuscatedTag &lt;&lt; <span class="hljs-number">1</span>) | <span class="hljs-number">1</span>];<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>classSlotForBasicTagIndex() 函数的主要功能就是根据指定索引 tag 从数组objc_tag_classes中获取类指针,而下标的计算方法发是根据外部传递的索引tag。比如字符串 tag = 2。当然这并不是简单的从数组中获取某条数据。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"> uint16_t <span class="hljs-built_in">NSString_Tag</span> = <span class="hljs-number">2</span>;<br>uint16_t <span class="hljs-built_in">NSNumber_Tag</span> = <span class="hljs-number">3</span>;<br><span class="hljs-comment">// 3 = 0011</span><br><span class="hljs-comment">// _OBJC_TAG_INDEX_MASK = 0x7 = 0111</span><br>        uintptr_t string_tagObfuscator = ((objc_debug_taggedpointer_obfuscator<br>                                           &gt;&gt; _OBJC_TAG_INDEX_SHIFT)<br>                                          &amp; _OBJC_TAG_INDEX_MASK);<br><br>        uintptr_t number_tagObfuscator = ((objc_debug_taggedpointer_obfuscator<br>                                           &gt;&gt; _OBJC_TAG_INDEX_SHIFT)<br>                                          &amp; _OBJC_TAG_INDEX_MASK);<br><br><span class="hljs-comment">// 异或操作 相同返回0 不同返回1</span><br><span class="hljs-comment">// 2 ^ 3 = 0010 ^ 0011 = 0001</span><br><span class="hljs-comment">// 3^ 3 = 0011 ^ 0011 = 0000</span><br>        uintptr_t string_obfuscatedTag = <span class="hljs-built_in">NSString_Tag</span> ^ string_tagObfuscator;<br>        uintptr_t number_obfuscatedTag = <span class="hljs-built_in">NSNumber_Tag</span> ^ number_tagObfuscator;<br><br><span class="hljs-comment">// 按位或</span><br><span class="hljs-comment">// 1000 | 0001 = 1001 = 9</span><br><span class="hljs-comment">// 1000 | 0000 = 1000 = 8</span><br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%@&quot;</span>, objc_tag_classes[<span class="hljs-number">0x8</span> | string_obfuscatedTag]);<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%@&quot;</span>, objc_tag_classes[<span class="hljs-number">0x8</span> | number_obfuscatedTag]);<br></code></pre></td></tr></table></figure>

<p>控制台输出为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs log">TaggedPointer[89420:3027642] NSTaggedPointerString<br>TaggedPointer[89420:3027642] __NSCFNumber<br></code></pre></td></tr></table></figure>

<p>当我们多次运行时,我们发现实际上每次获取到的<code>string_tagObfuscator</code>和<code>number_obfuscatedTag</code>都不一样，但是每次从<code>objc_tag_classes</code>中取出的类型均是一致的，因此实际上每次运行objc_tag_classes中的内容也是不断变化的。</p>
<p>如果你想进一步的了解可以参考<a href="https://jinxuebin.cn/2019/06/Objective-C%E4%B8%AD%E7%9A%84%E4%BC%AA%E6%8C%87%E9%92%88/">Objective-C中伪指针Tagged Pointer</a></p>
<h4 id="NSCFNumber"><a href="#NSCFNumber" class="headerlink" title="NSCFNumber"></a>NSCFNumber</h4><p>下面我们在看下NSNumber类型</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-built_in">NSNumber</span> *number1 = @(<span class="hljs-number">0x1</span>);<br><span class="hljs-built_in">NSNumber</span> *number2 = @(<span class="hljs-number">0x20</span>);<br><span class="hljs-built_in">NSNumber</span> *number3 = @(<span class="hljs-number">0x3F</span>);<br><span class="hljs-built_in">NSNumber</span> *numberFFFF = @(<span class="hljs-number">0xFFFFFFFFFFEFE</span>);<br><span class="hljs-built_in">NSNumber</span> *maxNum = @(MAXFLOAT);<br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;number1 pointer is %p class is %@&quot;</span>, number1, number1.class);<br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;number2 pointer is %p class is %@&quot;</span>, number2, number2.class);<br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;number3 pointer is %p class is %@&quot;</span>, number3, number3.class);<br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;numberffff pointer is %p class is %@&quot;</span>, numberFFFF, numberFFFF.class);<br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;maxNum pointer is %p class is %@&quot;</span>, maxNum, maxNum.class);<br></code></pre></td></tr></table></figure>

<p>我们在看下打印结果:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs log">TaggedPointerDemo[59218:2167895] number1 pointer is 0xf7cb914ffb51479a class is __NSCFNumber<br>TaggedPointerDemo[59218:2167895] number2 pointer is 0xf7cb914ffb51458a class is __NSCFNumber<br>TaggedPointerDemo[59218:2167895] number3 pointer is 0xf7cb914ffb51447a class is __NSCFNumber<br>TaggedPointerDemo[59218:2167895] numberffff pointer is 0xf7346eb004aea86b class is __NSCFNumber<br>TaggedPointerDemo[59218:2167895] maxNum pointer is 0x28172a0c0 class is __NSCFNumber<br></code></pre></td></tr></table></figure>

<p>我们发现对于NSNumber，我们打印出来的数据类型均为<code>__NSCFNumber</code>,但是我们发现对于<code>MAXFLOAT</code>打印出的地址显然与其他几项不符，上面几个NSNumber的地址以<code>0xf</code>开头，根据字符串地址的经验我们可以看出<code>f = 1111</code>,首位标记位为1，表示这个数据类型属于<code>TaggedPointer</code>。而MAXFLOAT不是。</p>
<h4 id="获取TaggedPointer的值"><a href="#获取TaggedPointer的值" class="headerlink" title="获取TaggedPointer的值"></a>获取TaggedPointer的值</h4><h5 id="objc4-723之前-1"><a href="#objc4-723之前-1" class="headerlink" title="objc4-723之前"></a>objc4-723之前</h5><p>字符串：<br><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghki3kum3kj30cw04ljss.jpg"></p>
<p>从上图的地址中我们就可以看出,从低位到高位分别表示的就是字符串的值(在ASCII码表中的值)</p>
<p>数字:<br><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghki3v25qqj30fa02iq3q.jpg"></p>
<p>对于数字来说从地址中也是直接读出存储的值，如上图。</p>
<h5 id="objc4-750之后-1"><a href="#objc4-750之后-1" class="headerlink" title="objc4-750之后"></a>objc4-750之后</h5><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> uintptr_t<br>_objc_decodeTaggedPointer(<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> * _Nullable ptr)<br>&#123;<br>    <span class="hljs-keyword">return</span> (uintptr_t)ptr ^ objc_debug_taggedpointer_obfuscator;<br>&#125;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> uintptr_t<br>_objc_getTaggedPointerValue(<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> * _Nullable ptr) <br>&#123;<br>    <span class="hljs-comment">// assert(_objc_isTaggedPointer(ptr));</span><br>    uintptr_t value = _objc_decodeTaggedPointer(ptr);<br>    uintptr_t basicTag = (value &gt;&gt; _OBJC_TAG_INDEX_SHIFT) &amp; _OBJC_TAG_INDEX_MASK;<br>    <span class="hljs-keyword">if</span> (basicTag == _OBJC_TAG_INDEX_MASK) &#123;<br>        <span class="hljs-keyword">return</span> (value &lt;&lt; _OBJC_TAG_EXT_PAYLOAD_LSHIFT) &gt;&gt; _OBJC_TAG_EXT_PAYLOAD_RSHIFT;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> (value &lt;&lt; _OBJC_TAG_PAYLOAD_LSHIFT) &gt;&gt; _OBJC_TAG_PAYLOAD_RSHIFT;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> intptr_t<br>_objc_getTaggedPointerSignedValue(<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> * _Nullable ptr) <br>&#123;<br>    <span class="hljs-comment">// assert(_objc_isTaggedPointer(ptr));</span><br>    uintptr_t value = _objc_decodeTaggedPointer(ptr);<br>    uintptr_t basicTag = (value &gt;&gt; _OBJC_TAG_INDEX_SHIFT) &amp; _OBJC_TAG_INDEX_MASK;<br>    <span class="hljs-keyword">if</span> (basicTag == _OBJC_TAG_INDEX_MASK) &#123;<br>        <span class="hljs-keyword">return</span> ((intptr_t)value &lt;&lt; _OBJC_TAG_EXT_PAYLOAD_LSHIFT) &gt;&gt; _OBJC_TAG_EXT_PAYLOAD_RSHIFT;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> ((intptr_t)value &lt;&lt; _OBJC_TAG_PAYLOAD_LSHIFT) &gt;&gt; _OBJC_TAG_PAYLOAD_RSHIFT;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>示例代码：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-built_in">NSString</span> *str1 = [<span class="hljs-built_in">NSString</span> stringWithFormat:<span class="hljs-string">@&quot;1&quot;</span>];<br>      <span class="hljs-built_in">NSString</span> *str11 = [<span class="hljs-built_in">NSString</span> stringWithFormat:<span class="hljs-string">@&quot;11&quot;</span>];<br>      <span class="hljs-built_in">NSString</span> *str2 = [<span class="hljs-built_in">NSString</span> stringWithFormat:<span class="hljs-string">@&quot;2&quot;</span>];<br>      <span class="hljs-built_in">NSString</span> *str22 = [<span class="hljs-built_in">NSString</span> stringWithFormat:<span class="hljs-string">@&quot;22&quot;</span>];<br><br><br>      <span class="hljs-comment">// 0x31 1 0x32 1</span><br>      uintptr_t value1 = objc_getTaggedPointerValue((__bridge <span class="hljs-keyword">void</span> *)str1);<br>      uintptr_t value2 = objc_getTaggedPointerValue((__bridge <span class="hljs-keyword">void</span> *)str2);<br>      uintptr_t value11 = objc_getTaggedPointerValue((__bridge <span class="hljs-keyword">void</span> *)str11);<br>      uintptr_t value22 = objc_getTaggedPointerValue((__bridge <span class="hljs-keyword">void</span> *)str22);<br>      <span class="hljs-comment">// 以16进制形式输出</span><br>      <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%lx&quot;</span>, value1);<br>      <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%lx&quot;</span>, value11);<br>      <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%lx&quot;</span>, value2);<br>      <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%lx&quot;</span>, value22);<br></code></pre></td></tr></table></figure>
<p>控制台输出:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs log">TaggedPointer[89535:3033433] 311<br>TaggedPointer[89535:3033433] 31312<br>TaggedPointer[89535:3033433] 321<br>TaggedPointer[89535:3033433] 32322<br></code></pre></td></tr></table></figure>

<p>即 “1” = 0x31 1,最后一位表示长度，在ASCII码表中31表示的就是字符1。而且从字符串“11”的结果我们也可以验证上面的说法。</p>
<h3 id="isa-指针-NONPOINTER-ISA"><a href="#isa-指针-NONPOINTER-ISA" class="headerlink" title="isa 指针(NONPOINTER_ISA)"></a>isa 指针(NONPOINTER_ISA)</h3><p>上面我们说了，对于一个对象的存储，苹果做了优化，那么对于ISA指针呢？</p>
<p>对象的isa指针，用来表明对象所属的类类型。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">union</span> isa_t &#123;<br>    isa_t() &#123; &#125;<br>    isa_t(uintptr_t value) : bits(value) &#123; &#125;<br><br>    Class cls;<br>    uintptr_t bits;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> defined(ISA_BITFIELD)</span><br>    <span class="hljs-keyword">struct</span> &#123;<br>        ISA_BITFIELD;  <span class="hljs-comment">// defined in isa.h</span><br>    &#125;;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>&#125;;<br><br></code></pre></td></tr></table></figure>

<p>同时结合下图，我们可以更清晰的了解isa指针的作用以及类对象的概念。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghjtmvzlxwj30w20j9tas.jpg"></p>
<p>从图中可以看出，我们所谓的isa指针，最后实际上落脚于isa_t的联合类型。那么何为联合类型呢？<br><code>联合类型是C语言中的一种类型，是一种n选1的关系,联合的作用在于，用更少的空间，表示了更多的可能的类型，虽然这些类型是不能够共存的</code>。比如isa_t 中包含有<code>cls</code>，<code>bits</code>， <code>struct</code>三个变量，它们的内存空间是重叠的。在实际使用时，仅能够使用它们中的一种，你把它当做cls，就不能当bits访问，你把它当bits，就不能用cls来访问。</p>
<p>对于<code>isa_t</code>联合类型，主要包含了两个构造函数<code>isa_t()</code>,<code>isa_t(uintptr_t value)</code>和三个变量<code>cls</code>,<code>bits</code>,<code>struct</code>,而<code>uintptr_t</code>的定义为<code>typedef unsigned long</code>。         </p>
<p>当isa_t作为Class cls使用时，这符合了我们之前一贯的认知：isa是一个指向对象所属Class类型的指针。然而，仅让一个64位的指针表示一个类型，显然不划算。</p>
<p>因此，绝大多数情况下，苹果采用了优化的<code>isa策略</code>，即，<code>isa_t</code>类型并不等同而<code>Class cls</code>, 而是<code>struct</code>。</p>
<h4 id="struct"><a href="#struct" class="headerlink" title="struct"></a>struct</h4><p>下面我们先来看下struct的结构体</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">// ISA_BITFIELD定义如下</span><br><span class="hljs-meta"># <span class="hljs-meta-keyword">if</span> __arm64__</span><br><span class="hljs-meta">#   <span class="hljs-meta-keyword">define</span> ISA_MASK        0x0000000ffffffff8ULL</span><br><span class="hljs-meta">#   <span class="hljs-meta-keyword">define</span> ISA_MAGIC_MASK  0x000003f000000001ULL</span><br><span class="hljs-meta">#   <span class="hljs-meta-keyword">define</span> ISA_MAGIC_VALUE 0x000001a000000001ULL</span><br><span class="hljs-meta">#   <span class="hljs-meta-keyword">define</span> ISA_BITFIELD                                                      \</span><br>      uintptr_t nonpointer        : <span class="hljs-number">1</span>;                                       \<br>      uintptr_t has_assoc         : <span class="hljs-number">1</span>;                                       \<br>      uintptr_t has_cxx_dtor      : <span class="hljs-number">1</span>;                                       \<br>      uintptr_t shiftcls          : <span class="hljs-number">33</span>; <span class="hljs-comment">/*MACH_VM_MAX_ADDRESS 0x1000000000*/</span> \<br>      uintptr_t magic             : <span class="hljs-number">6</span>;                                       \<br>      uintptr_t weakly_referenced : <span class="hljs-number">1</span>;                                       \<br>      uintptr_t deallocating      : <span class="hljs-number">1</span>;                                       \<br>      uintptr_t has_sidetable_rc  : <span class="hljs-number">1</span>;                                       \<br>      uintptr_t extra_rc          : <span class="hljs-number">19</span><br><span class="hljs-meta">#   <span class="hljs-meta-keyword">define</span> RC_ONE   (1ULL&lt;&lt;45)</span><br><span class="hljs-meta">#   <span class="hljs-meta-keyword">define</span> RC_HALF  (1ULL&lt;&lt;18)</span><br></code></pre></td></tr></table></figure>

<p>注意:<code>成员后面的：表明了该成员占用几个bit</code><br>而每个成员的意义如下表</p>
<h4 id="标志位说明"><a href="#标志位说明" class="headerlink" title="标志位说明"></a>标志位说明</h4><table>
<thead>
<tr>
<th>成员</th>
<th>bit位</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>nonpointer</td>
<td>1bit</td>
<td>标志位。1(奇数)表示开启了isa优化，0(偶数)表示没有启用isa优化。所以，我们可以通过判断isa是否为奇数来判断对象是否启用了isa优化</td>
</tr>
<tr>
<td>has_assoc</td>
<td>1bit</td>
<td>标志位。表明对象是否有关联对象。没有关联对象的对象释放的更快。</td>
</tr>
<tr>
<td>has_cxx_dtor</td>
<td>1bit</td>
<td>标志位。表明对象是否有C++或ARC析构函数。没有析构函数的对象释放的更快</td>
</tr>
<tr>
<td>shiftcls</td>
<td>33bit</td>
<td>类指针的非零位。</td>
</tr>
<tr>
<td>magic</td>
<td>6bit</td>
<td>固定为0x1a，用于在调试时区分对象是否已经初始化。</td>
</tr>
<tr>
<td>weakly_referenced</td>
<td>1bit</td>
<td>标志位。用于表示该对象是否被别的对象弱引用。没有被弱引用的对象释放的更快。</td>
</tr>
<tr>
<td>deallocating</td>
<td>1bit</td>
<td>标志位。用于表示该对象是否正在被释放。</td>
</tr>
<tr>
<td>has_sidetable_rc</td>
<td>1bit</td>
<td>标志位。用于标识是否当前的引用计数过大，无法在isa中存储，而需要借用sidetable来存储。（这种情况大多不会发生）</td>
</tr>
<tr>
<td>extra_rc</td>
<td>19bit</td>
<td>对象的引用计数减1。比如，一个object对象的引用计数为7，则此时extra_rc的值为6。</td>
</tr>
</tbody></table>
<p>从上表我们发现，<code>extra_rc</code>和<code>has_sidetable_rc</code>是和引用计数相关的标志位，当extra_rc 不够用时，还会借助sidetable来存储计数值，这时，has_sidetable_rc会被标志为1。</p>
<p>接下来我们来验证下，这些标志位是否真的如表中介绍那样。</p>
<h4 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h4><p>我们先来看下面这段代码</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">- (<span class="hljs-keyword">void</span>)testisa &#123;<br>    <span class="hljs-built_in">NSObject</span> *obj = [[<span class="hljs-built_in">NSObject</span> alloc] init];<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;1. obj isa_t = %p&quot;</span>, *(<span class="hljs-keyword">void</span> **)(__bridge <span class="hljs-keyword">void</span>*)obj);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>控制台输出结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs log">TaggedPointerDemo[59983:2185591] 1. obj isa_t &#x3D; 0x1a1f335beb1<br></code></pre></td></tr></table></figure>
<p>我们将地址<code>0x1a1f335beb1</code>转换过后：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghkfjfbyu0j30fe0dogmb.jpg"></p>
<p>我们看到这时候 对象是<code>nonpointer</code>开启了isa优化，且当前的引用计数器为 extra_rc = 0 + 1 = 1;</p>
<p>下面我们接着测试</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-built_in">NSObject</span> *obj = [[<span class="hljs-built_in">NSObject</span> alloc] init];<br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;1. obj isa_t = %p&quot;</span>, *(<span class="hljs-keyword">void</span> **)(__bridge <span class="hljs-keyword">void</span>*)obj);<br>_obj1 = obj;<br><span class="hljs-built_in">NSObject</span> *tmpObj = obj;<br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;2. obj isa_t = %p&quot;</span>, *(<span class="hljs-keyword">void</span> **)(__bridge <span class="hljs-keyword">void</span>*)obj);<br></code></pre></td></tr></table></figure>
<p>控制台输出为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">TaggedPointerDemo[63235:2266690] 1. obj isa_t &#x3D; 0x1a1f335beb1<br>TaggedPointerDemo[63235:2266690] 2. obj isa_t &#x3D; 0x41a1f335beb1<br></code></pre></td></tr></table></figure>
<p>我们将地址<code>0x41a1f335beb1</code>转换过后：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghkfvyc4tkj30fe0dot9f.jpg"></p>
<p>我们看到这时候，我们将obj强引用之后，又实用了一个局部变量对其进行引用，所以这时的引用计数应该为2，当然从图中我们也可以验证这一点。</p>
<h4 id="weakly-referenced"><a href="#weakly-referenced" class="headerlink" title="weakly_referenced"></a>weakly_referenced</h4><p>我们这次添加一个弱引用来验证</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"> _weakRefObj = _obj1;<br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;3. obj isa_t = %p&quot;</span>, *(<span class="hljs-keyword">void</span> **)(__bridge <span class="hljs-keyword">void</span>*)_obj1);<br></code></pre></td></tr></table></figure>

<p>控制台输出为</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">TaggedPointerDemo[<span class="hljs-number">63235</span>:<span class="hljs-number">2266690</span>] <span class="hljs-number">3.</span> obj isa_t = <span class="hljs-number">0x45a1f335beb1</span><br></code></pre></td></tr></table></figure>

<p>这时候我们仅仅通过地址进行判断 当添加了<code>_obj2 = _obj1</code>后，地址变为<code>0x61a1f335beb1</code>与之前地址<code>0x41a1f335beb1</code>对比</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghkfxt2qagj30fe0doq3n.jpg"></p>
<p>上图我们可以看到<code>weakly_referenced</code>标志位被置为1.表示这个对象有被弱引用。</p>
<h4 id="has-assoc"><a href="#has-assoc" class="headerlink" title="has_assoc"></a>has_assoc</h4><p>然后我们在添加一个关联属性</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-built_in">NSObject</span> *attachObj = [[<span class="hljs-built_in">NSObject</span> alloc] init];<br>objc_setAssociatedObject(_obj1, <span class="hljs-string">&quot;attachKey&quot;</span>, attachObj, OBJC_ASSOCIATION_RETAIN_NONATOMIC);<br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;4. obj isa_t = %p&quot;</span>, *(<span class="hljs-keyword">void</span> **)(__bridge <span class="hljs-keyword">void</span>*)_obj1);<br></code></pre></td></tr></table></figure>

<p>控制台输出为:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">TaggedPointerDemo[<span class="hljs-number">63235</span>:<span class="hljs-number">2266690</span>] <span class="hljs-number">4.</span> obj isa_t = <span class="hljs-number">0x45a1f335beb3</span><br></code></pre></td></tr></table></figure>

<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghkfzqpmq2j30fe0doq3n.jpg"></p>
<p>从上图中我们看到<code>has_assoc</code>标志位被置为1.</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>截止到这里，我们通过观察<code>NSTaggedPointer</code>,相关标志位我们基本了解了NSTaggedPointer是如何存储数据以及标志位的作用。</p>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://jinxuebin.cn/2019/06/Objective-C%E4%B8%AD%E7%9A%84%E4%BC%AA%E6%8C%87%E9%92%88/">Objective-C中伪指针Tagged Pointer</a></p>
<p><a href="https://mikeash.com/pyblog/friday-qa-2015-07-31-tagged-pointer-strings.html">Friday Q&amp;A 2015-07-31: Tagged Pointer Strings</a></p>
]]></content>
      <categories>
        <category>内存管理</category>
      </categories>
      <tags>
        <tag>Tagged Pointer</tag>
      </tags>
  </entry>
  <entry>
    <title>__Block 到底做了什么</title>
    <url>/2018/04/25/what-did-block-do/</url>
    <content><![CDATA[<p>Block默认不允许修改外部变量的值,我们可以通过对要修改的变量添加__block修饰,来达到可以在block内部修改外部变量的目的。那么__block到底都做了什么呢？为什么添加了__block就可以在block内部修改外部变量了呢！</p>
<a id="more"></a>



<h2 id="Block与外部变量"><a href="#Block与外部变量" class="headerlink" title="Block与外部变量"></a>Block与外部变量</h2><h2 id="外部变量"><a href="#外部变量" class="headerlink" title="外部变量"></a>外部变量</h2><ul>
<li>自动变量</li>
<li>静态变量</li>
<li>静态全局变量</li>
<li>全局变量</li>
</ul>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-meta">#import <span class="hljs-meta-string">&lt;Foundation/Foundation.h&gt;</span></span><br><br><span class="hljs-keyword">int</span> global_i = <span class="hljs-number">1</span>;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> static_global_j = <span class="hljs-number">2</span>;<br><br><span class="hljs-keyword">int</span> main(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * argv[]) &#123;<br>   <br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> static_k = <span class="hljs-number">3</span>;<br>    <span class="hljs-keyword">int</span> val = <span class="hljs-number">4</span>;<br>    <br>    <span class="hljs-keyword">void</span> (^myBlock)(<span class="hljs-keyword">void</span>) = ^&#123;<br>        global_i ++;<br>        static_global_j ++;<br>        static_k ++;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;Block中 global_i = %d,static_global_j = %d,static_k = %d,val = %d&quot;</span>,global_i,static_global_j,static_k,val);<br>    &#125;;<br>    <br>    global_i ++;<br>    static_global_j ++;<br>    static_k ++;<br>    val ++;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;Block外 global_i = %d,static_global_j = %d,static_k = %d,val = %d&quot;</span>,global_i,static_global_j,static_k,val);<br>    <br>    myBlock();<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>运行结果:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">Block 外  global_i = <span class="hljs-number">2</span>,static_global_j = <span class="hljs-number">3</span>,static_k = <span class="hljs-number">4</span>,val = <span class="hljs-number">5</span><br>Block 中  global_i = <span class="hljs-number">3</span>,static_global_j = <span class="hljs-number">4</span>,static_k = <span class="hljs-number">5</span>,val = <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure>

<p>对于block和外部变量的关系,我们有两个问题需要搞清楚：</p>
<ul>
<li>1.为什么在Block里面不加__bolck不允许更改变量？</li>
<li>2.为什么自动变量的值没有增加，而其他几个变量的值是增加的？自动变量是什么状态下被block捕获进去的？</li>
</ul>
<h3 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> global_i = <span class="hljs-number">1</span>;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> static_global_j = <span class="hljs-number">2</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">main_block_impl_0</span> &#123;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">block_impl</span> <span class="hljs-title">impl</span>;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">main_block_desc_0</span>* <span class="hljs-title">Desc</span>;</span><br>  <span class="hljs-keyword">int</span> *static_k;<br>  <span class="hljs-keyword">int</span> val;<br>  __main_block_impl_0(<span class="hljs-keyword">void</span> *fp, struct __main_block_desc_0 *desc, <span class="hljs-keyword">int</span> *_static_k, <span class="hljs-keyword">int</span> _val, <span class="hljs-keyword">int</span> flags=<span class="hljs-number">0</span>) : static_k(_static_k), val(_val) &#123;<br>    impl.isa = &amp;_NSConcreteStackBlock;<br>    impl.Flags = flags;<br>    impl.FuncPtr = fp;<br>    Desc = desc;<br>  &#125;<br>&#125;;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;<br>  <span class="hljs-keyword">int</span> *static_k = __cself-&gt;static_k; <span class="hljs-comment">// bound by copy</span><br>  <span class="hljs-keyword">int</span> val = __cself-&gt;val; <span class="hljs-comment">// bound by copy</span><br><br>        global_i ++;<br>        static_global_j ++;<br>        (*static_k) ++;<br>        NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_45_k1d9q7c52vz50wz1683_hk9r0000gn_T_main_6fe658_mi_0,global_i,static_global_j,(*static_k),val);<br>    &#125;<br><br><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">main_block_desc_0</span> &#123;</span><br>  <span class="hljs-keyword">size_t</span> reserved;<br>  <span class="hljs-keyword">size_t</span> Block_size;<br>&#125; __main_block_desc_0_DATA = &#123; <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(struct __main_block_impl_0)&#125;;<br><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * argv[])</span> </span>&#123;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> static_k = <span class="hljs-number">3</span>;<br>    <span class="hljs-keyword">int</span> val = <span class="hljs-number">4</span>;<br><br>    <span class="hljs-keyword">void</span> (*myBlock)(<span class="hljs-keyword">void</span>) = ((<span class="hljs-keyword">void</span> (*)())&amp;__main_block_impl_0((<span class="hljs-keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA, &amp;static_k, val));<br><br>    global_i ++;<br>    static_global_j ++;<br>    static_k ++;<br>    val ++;<br>    NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_45_k1d9q7c52vz50wz1683_hk9r0000gn_T_main_6fe658_mi_1,global_i,static_global_j,static_k,val);<br><br>    ((<span class="hljs-keyword">void</span> (*)(__block_impl *))((__block_impl *)myBlock)-&gt;FuncPtr)((__block_impl *)myBlock);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>在<code>__main_block_func_0</code>方法中,我们可以看到 对于全局变量不论是否是静态的都是直接使用!(内存中有一块区域是专门存放全局变量的这些变量不会被销毁,因此可以不用拷贝 直接使用) 对于局部变量 如果是静态变量:</p>
<p><code>int *static_k = __cself-&gt;static_k; // bound by copy</code></p>
<p>新定义了一个变量指向了这个静态变量,但是注意 这里是 <code>int *</code> 这就说明引用的是静态变量的地址。</p>
<p>我们再来看一下val这个局部变量:</p>
<p><code>int val = __cself-&gt;val; // bound by copy</code></p>
<p>同样新定义了一个变量,这个变量的值等于传入的val的值</p>
<p>其实这个方法的具体参数 我们可以直接通过看main函数中的<code>__main_block_impl_0</code>方法就可以看出来</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">void</span> (*myBlock)(<span class="hljs-keyword">void</span>) = ((<span class="hljs-keyword">void</span> (*)())&amp;__main_block_impl_0((<span class="hljs-keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA, &amp;static_k, val));<br></code></pre></td></tr></table></figure>

<p>区别就是静态变量传入的是<code>&amp;static_k</code>,普通局部变量传递的是<code>val</code>.</p>
<p>通过这些,我们可以看出,block内部都是对外部非全局变量进行拷贝,因此如果外部对block内值引用的变量进行了修改不会影响block内变量的值。但是如果是静态变量 那么是会影响的。</p>
<table>
<thead>
<tr>
<th>–</th>
<th>静态变量</th>
<th>静态全局变量</th>
<th>全局变量</th>
<th>自动变量</th>
</tr>
</thead>
<tbody><tr>
<td>block内的传递</td>
<td>地址传递</td>
<td>地址传递</td>
<td>地址传递</td>
<td>值传递</td>
</tr>
</tbody></table>
<p>到此为止，上面提出的第二个问题就解开答案了。</p>
<p>自动变量是以值传递方式传递到Block的构造函数里面去的。Block只捕获Block中会用到的变量。由于只捕获了自动变量的值，并非内存地址，所以Block内部不能改变自动变量的值(block外面变量值的改变也不会影响block内部)。Block捕获的外部变量可以改变值的是静态变量，静态全局变量，全局变量。上面例子也都证明过了。</p>
<p>至此,我们了解 如果要在block内部修改外部的变量,可以使用两种方法:</p>
<ul>
<li>1、传入这个外部变量的内存地址而不是值传递</li>
<li>2、使用__block 修饰</li>
</ul>
<h2 id="Block中外部变量值的修改"><a href="#Block中外部变量值的修改" class="headerlink" title="Block中外部变量值的修改"></a>Block中外部变量值的修改</h2><h3 id="传入内存地址"><a href="#传入内存地址" class="headerlink" title="传入内存地址"></a>传入内存地址</h3><p>先看下面的例子:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-meta">#import <span class="hljs-meta-string">&lt;Foundation/Foundation.h&gt;</span></span><br><br><span class="hljs-keyword">int</span> main(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * argv[]) &#123;<br>    <br>  <span class="hljs-built_in">NSMutableString</span> * str = [[<span class="hljs-built_in">NSMutableString</span> alloc]initWithString:<span class="hljs-string">@&quot;Hello,&quot;</span>];<br>    <br>        <span class="hljs-keyword">void</span> (^myBlock)(<span class="hljs-keyword">void</span>) = ^&#123;<br>            [str appendString:<span class="hljs-string">@&quot;World!&quot;</span>];<br>            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;Block中 str = %@&quot;</span>,str);<br>        &#125;;<br>    <br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;Block外 str = %@&quot;</span>,str);<br>    <br>    myBlock();<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>输出结果:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">Block 外  str = Hello,<br>Block 中  str = Hello,World!<br></code></pre></td></tr></table></figure>

<h4 id="源码解析-1"><a href="#源码解析-1" class="headerlink" title="源码解析"></a>源码解析</h4><p>下面我们利用clang来看一下上面这段代码的具体实现</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">struct</span> __main_block_impl_0 &#123;<br>  <span class="hljs-keyword">struct</span> __block_impl impl;<br>  <span class="hljs-keyword">struct</span> __main_block_desc_0* Desc;<br>  <span class="hljs-built_in">NSMutableString</span> *str;<br>  __main_block_impl_0(<span class="hljs-keyword">void</span> *fp, <span class="hljs-keyword">struct</span> __main_block_desc_0 *desc, <span class="hljs-built_in">NSMutableString</span> *_str, <span class="hljs-keyword">int</span> flags=<span class="hljs-number">0</span>) : str(_str) &#123;<br>    impl.isa = &amp;_NSConcreteStackBlock;<br>    impl.Flags = flags;<br>    impl.FuncPtr = fp;<br>    Desc = desc;<br>  &#125;<br>&#125;;<br><br><span class="hljs-comment">// 注意这里的参数是 *__cself</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> __main_block_func_0(<span class="hljs-keyword">struct</span> __main_block_impl_0 *__cself) &#123;<br>  <span class="hljs-built_in">NSMutableString</span> *str = __cself-&gt;str; <span class="hljs-comment">// bound by copy</span><br><br>            ((<span class="hljs-keyword">void</span> (*)(<span class="hljs-keyword">id</span>, SEL, <span class="hljs-built_in">NSString</span> *))(<span class="hljs-keyword">void</span> *)objc_msgSend)((<span class="hljs-keyword">id</span>)str, sel_registerName(<span class="hljs-string">&quot;appendString:&quot;</span>), (<span class="hljs-built_in">NSString</span> *)&amp;__NSConstantStringImpl__var_folders_45_k1d9q7c52vz50wz1683_hk9r0000gn_T_main_33ff12_mi_1);<br>            <span class="hljs-built_in">NSLog</span>((<span class="hljs-built_in">NSString</span> *)&amp;__NSConstantStringImpl__var_folders_45_k1d9q7c52vz50wz1683_hk9r0000gn_T_main_33ff12_mi_2,str);<br>        &#125;<br>        <br><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> __main_block_copy_0(<span class="hljs-keyword">struct</span> __main_block_impl_0*dst, <span class="hljs-keyword">struct</span> __main_block_impl_0*src) &#123;<br><span class="hljs-comment">//</span><br>_Block_object_assign((<span class="hljs-keyword">void</span>*)&amp;dst-&gt;str, (<span class="hljs-keyword">void</span>*)src-&gt;str, <span class="hljs-number">3</span><span class="hljs-comment">/*BLOCK_FIELD_IS_OBJECT*/</span>);&#125;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> __main_block_dispose_0(<span class="hljs-keyword">struct</span> __main_block_impl_0*src) &#123;_Block_object_dispose((<span class="hljs-keyword">void</span>*)src-&gt;str, <span class="hljs-number">3</span><span class="hljs-comment">/*BLOCK_FIELD_IS_OBJECT*/</span>);&#125;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">struct</span> __main_block_desc_0 &#123;<br>  size_t reserved;<br>  size_t Block_size;<br>  <span class="hljs-keyword">void</span> (*<span class="hljs-keyword">copy</span>)(<span class="hljs-keyword">struct</span> __main_block_impl_0*, <span class="hljs-keyword">struct</span> __main_block_impl_0*);<br>  <span class="hljs-keyword">void</span> (*dispose)(<span class="hljs-keyword">struct</span> __main_block_impl_0*);<br>&#125; __main_block_desc_0_DATA = &#123; <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0&#125;;<br><br><br><span class="hljs-keyword">int</span> main(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * argv[]) &#123;<br>    <span class="hljs-built_in">NSMutableString</span> * str = ((<span class="hljs-built_in">NSMutableString</span> *(*)(<span class="hljs-keyword">id</span>, SEL, <span class="hljs-built_in">NSString</span> *))(<span class="hljs-keyword">void</span> *)objc_msgSend)((<span class="hljs-keyword">id</span>)((<span class="hljs-built_in">NSMutableString</span> *(*)(<span class="hljs-keyword">id</span>, SEL))(<span class="hljs-keyword">void</span> *)objc_msgSend)((<span class="hljs-keyword">id</span>)objc_getClass(<span class="hljs-string">&quot;NSMutableString&quot;</span>), sel_registerName(<span class="hljs-string">&quot;alloc&quot;</span>)), sel_registerName(<span class="hljs-string">&quot;initWithString:&quot;</span>), (<span class="hljs-built_in">NSString</span> *)&amp;__NSConstantStringImpl__var_folders_45_k1d9q7c52vz50wz1683_hk9r0000gn_T_main_33ff12_mi_0);<br><br>        <span class="hljs-keyword">void</span> (*myBlock)(<span class="hljs-keyword">void</span>) = ((<span class="hljs-keyword">void</span> (*)())&amp;__main_block_impl_0((<span class="hljs-keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA, str, <span class="hljs-number">570425344</span>));<br><br>    <span class="hljs-built_in">NSLog</span>((<span class="hljs-built_in">NSString</span> *)&amp;__NSConstantStringImpl__var_folders_45_k1d9q7c52vz50wz1683_hk9r0000gn_T_main_33ff12_mi_3,str);<br><br>    ((<span class="hljs-keyword">void</span> (*)(__block_impl *))((__block_impl *)myBlock)-&gt;FuncPtr)((__block_impl *)myBlock);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>从 <code>static void __main_block_func_0(struct __main_block_impl_0 *__cself) </code>可以看出 传入的参数是指针 <code> NSMutableString *str = __cself-&gt;str; // bound by copy</code> 新建了一个变量指向的是之前的变量的地址。因此block内部改变的仍然是之前的数据。</p>
<h3 id="使用-block修饰"><a href="#使用-block修饰" class="headerlink" title="使用__block修饰"></a>使用__block修饰</h3><p>为什么使用了<code>__block</code>的修饰之后就可以在block内部修改外部变量了呢？这里肯定是系统根据<code>__block</code>检测,做了一些处理。</p>
<p>这里我们分成基本数据类型和对象类型。</p>
<h4 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h4><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">#import &lt;Foundation&#x2F;Foundation.h&gt;<br><br>int main(int argc, const char * argv[]) &#123;<br>    <br>    __block int i &#x3D; 0;<br>    <br>    void (^myBlock)(void) &#x3D; ^&#123;<br>        i ++;<br>        NSLog(@&quot;%d&quot;,i);<br>    &#125;;<br>    <br>    myBlock();<br>    <br>    return 0;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>转换成源码之后:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 外部定义的基本数据类型 变成了这个结构体对象</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">Block_byref_i_0</span> &#123;</span><br>  <span class="hljs-keyword">void</span> *__isa;<br>__Block_byref_i_0 *__forwarding;    <span class="hljs-comment">//这个指针指向的也是这种结构体</span><br> <span class="hljs-keyword">int</span> __flags;<br> <span class="hljs-keyword">int</span> __size;<br> <span class="hljs-keyword">int</span> i;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">main_block_impl_0</span> &#123;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">block_impl</span> <span class="hljs-title">impl</span>;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">main_block_desc_0</span>* <span class="hljs-title">Desc</span>;</span><br>  __Block_byref_i_0 *i; <span class="hljs-comment">// 声明这个i</span><br>  <br>  __main_block_impl_0(<span class="hljs-keyword">void</span> *fp, struct __main_block_desc_0 *desc, __Block_byref_i_0 *_i, <span class="hljs-keyword">int</span> flags=<span class="hljs-number">0</span>) : i(_i-&gt;__forwarding) &#123;<br>    impl.isa = &amp;_NSConcreteStackBlock;<br>    impl.Flags = flags;<br>    impl.FuncPtr = fp;<br>    Desc = desc;<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;<br><span class="hljs-comment">//将外部变量的值 赋值给新建的这个结构体</span><br>  __Block_byref_i_0 *i = __cself-&gt;i; <span class="hljs-comment">// bound by ref</span><br>        <br>        <span class="hljs-comment">//对这个结构体中__forwarding指向的结构体的值做自加操作</span><br>        (i-&gt;__forwarding-&gt;i) ++;<br>        <br>        NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_45_k1d9q7c52vz50wz1683_hk9r0000gn_T_main_3b0837_mi_0,(i-&gt;__forwarding-&gt;i));<br>    &#125;<br>    <br><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) &#123;_Block_object_assign((<span class="hljs-keyword">void</span>*)&amp;dst-&gt;i, (<span class="hljs-keyword">void</span>*)src-&gt;i, <span class="hljs-number">8</span><span class="hljs-comment">/*BLOCK_FIELD_IS_BYREF*/</span>);&#125;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> __main_block_dispose_0(struct __main_block_impl_0*src) &#123;_Block_object_dispose((<span class="hljs-keyword">void</span>*)src-&gt;i, <span class="hljs-number">8</span><span class="hljs-comment">/*BLOCK_FIELD_IS_BYREF*/</span>);&#125;<br><br><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">main_block_desc_0</span> &#123;</span><br>  <span class="hljs-keyword">size_t</span> reserved;<br>  <span class="hljs-keyword">size_t</span> Block_size;<br>  <span class="hljs-keyword">void</span> (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);<br>  <span class="hljs-keyword">void</span> (*dispose)(struct __main_block_impl_0*);<br>&#125; __main_block_desc_0_DATA = &#123; <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * argv[])</span> </span>&#123;<br><span class="hljs-comment">//这里初始化这个__Block_byref_i_0结构体对象 </span><br><span class="hljs-comment">//这里我们可以看到__forwarding = (__Block_byref_i_0 *)&amp;i 这个指针指向自己</span><br>    __attribute__((__blocks__(byref))) __Block_byref_i_0 i = &#123;(<span class="hljs-keyword">void</span>*)<span class="hljs-number">0</span>,(__Block_byref_i_0 *)&amp;i, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(__Block_byref_i_0), <span class="hljs-number">0</span>&#125;;<br><br>    <span class="hljs-keyword">void</span> (*myBlock)(<span class="hljs-keyword">void</span>) = ((<span class="hljs-keyword">void</span> (*)())&amp;__main_block_impl_0((<span class="hljs-keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA, (__Block_byref_i_0 *)&amp;i, <span class="hljs-number">570425344</span>));<br><br>    ((<span class="hljs-keyword">void</span> (*)(__block_impl *))((__block_impl *)myBlock)-&gt;FuncPtr)((__block_impl *)myBlock);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>上面的代码 与我们最初没有使用__block修饰的代码的区别在于:</p>
<ul>
<li>1、外部变量的类型变为了一个<code>__Block_byref_i_0</code>结构体</li>
<li>2、自加操作对应的是<br>  <code>(i-&gt;__forwarding-&gt;i) ++;</code> 默认__forwarding指向自己</li>
</ul>
<p>对于是否可以修改外部变量,我们可以主要集中于这个自加的操作,如果<code>__forwarding</code>永远指向自身那么直接通过i取到i对应的值就可以了为什么中间加一个<code>__forwarding</code>呢？</p>
<p>我们知道, ARC环境下，一旦Block赋值就会触发copy，__block修饰的变量也就会copy到堆上，Block的类型也就变成了__NSMallocBlock。</p>
<p>堆上的Block会持有对象。我们把Block通过copy到了堆上，堆上也会重新复制一份Block，并且该Block也会继续持有该__block修饰的对象。当Block释放的时候，__block修饰的对象因为没有被任何对象引用，也会被释放销毁</p>
<p><code>__forwarding</code>指针这里的作用就是针对堆的Block，把原来<code>__forwarding</code>指针指向自己，换成指向<code>_NSConcreteMallocBlock</code>上复制之后的__block自己。然后堆上的变量的<code>__forwarding</code>再指向自己。这样不管__block怎么复制到堆上，还是在栈上，都可以通过<code>(i-&gt;__forwarding-&gt;i)</code>来访问到变量值。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1194012-5f5f486bab68191f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt="__forwarding"></p>
<p>根据上面的解释,我们可以得出系统使用__block修饰一个外部变量之后为什么就可以在block内部修改外部变量原因：</p>
<p>block创建的时候是在栈上的,对block进行赋值操作之后会将block拷贝到堆上。同时也会将block中使用的对象拷贝到堆上。然后将栈上的__block修饰对象的__forwarding指针指向堆上的拷贝之后的对象。这样我们在block内部修改的时候虽然是修改堆上的对象的值,但是因为栈上的对象的__forwarding指针将堆和栈的对象链接起来。因此达到了修改的目的。</p>
<h4 id="对象类型"><a href="#对象类型" class="headerlink" title="对象类型"></a>对象类型</h4><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">//以下代码是在ARC下执行的</span><br><span class="hljs-meta">#import <span class="hljs-meta-string">&lt;Foundation/Foundation.h&gt;</span></span><br><br><span class="hljs-keyword">int</span> main(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * argv[]) &#123;<br>     <br>    __block <span class="hljs-keyword">id</span> block_obj = [[<span class="hljs-built_in">NSObject</span> alloc]init];<br>    <span class="hljs-keyword">id</span> obj = [[<span class="hljs-built_in">NSObject</span> alloc]init];<br><br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;block_obj = [%@ , %p] , obj = [%@ , %p]&quot;</span>,block_obj , &amp;block_obj , obj , &amp;obj);<br>    <br>    <span class="hljs-keyword">void</span> (^myBlock)(<span class="hljs-keyword">void</span>) = ^&#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;***Block中****block_obj = [%@ , %p] , obj = [%@ , %p]&quot;</span>,block_obj , &amp;block_obj , obj , &amp;obj);<br>    &#125;;<br>    <br>    myBlock();<br>   <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>打印结果:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">block_obj = [&lt;NSObject: <span class="hljs-number">0x100b027d0</span>&gt; , <span class="hljs-number">0x7fff5fbff7e8</span>] , obj = [&lt;NSObject: <span class="hljs-number">0x100b03b50</span>&gt; , <span class="hljs-number">0x7fff5fbff7b8</span>]<br><br>Block****中********block_obj = [&lt;NSObject: <span class="hljs-number">0x100b027d0</span>&gt; , <span class="hljs-number">0x100f000a8</span>] , obj = [&lt;NSObject: <span class="hljs-number">0x100b03b50</span>&gt; , <span class="hljs-number">0x100f00070</span>]<br><br></code></pre></td></tr></table></figure>

<p>从打印结果我们可以看出 block内部与外部:</p>
<ul>
<li>对于使用__block修饰的变量 对象的地址没有发生改变,但是指向这个对象的指针的地址发生了变化(copy操作的影响)。</li>
<li>对于没有使用__block修饰的变量 对象的地址也没有发生变化,指向这个对象的指针地址也发生了变化</li>
</ul>
<p>但从打印结果 我们看不出不同 下面我们利用clang在进行源码的分析。</p>
<h5 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h5><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">Block_byref_block_obj_0</span> &#123;</span><br>  <span class="hljs-keyword">void</span> *__isa;<br>__Block_byref_block_obj_0 *__forwarding;<br> <span class="hljs-keyword">int</span> __flags;<br> <span class="hljs-keyword">int</span> __size;<br> <span class="hljs-keyword">void</span> (*__Block_byref_id_object_copy)(<span class="hljs-keyword">void</span>*, <span class="hljs-keyword">void</span>*);<br> <span class="hljs-keyword">void</span> (*__Block_byref_id_object_dispose)(<span class="hljs-keyword">void</span>*);<br> id block_obj; <span class="hljs-comment">//值和变量名相同</span><br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">main_block_impl_0</span> &#123;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">block_impl</span> <span class="hljs-title">impl</span>;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">main_block_desc_0</span>* <span class="hljs-title">Desc</span>;</span><br>  id obj;<br>  __Block_byref_block_obj_0 *block_obj; <span class="hljs-comment">// by ref</span><br>  __main_block_impl_0(<span class="hljs-keyword">void</span> *fp, struct __main_block_desc_0 *desc, id _obj, __Block_byref_block_obj_0 *_block_obj, <span class="hljs-keyword">int</span> flags=<span class="hljs-number">0</span>) : obj(_obj), block_obj(_block_obj-&gt;__forwarding) &#123;<br>    impl.isa = &amp;_NSConcreteStackBlock;<br>    impl.Flags = flags;<br>    impl.FuncPtr = fp;<br>    Desc = desc;<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;<br><span class="hljs-comment">//这里 对于赋值 可以看出二者的不同之处 一个是值的引用 一个是copy</span><br>  __Block_byref_block_obj_0 *block_obj = __cself-&gt;block_obj; <span class="hljs-comment">// bound by ref</span><br>  id obj = __cself-&gt;obj; <span class="hljs-comment">// bound by copy</span><br><br>        NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_45_k1d9q7c52vz50wz1683_hk9r0000gn_T_main_e64910_mi_1,(block_obj-&gt;__forwarding-&gt;block_obj) , &amp;(block_obj-&gt;__forwarding-&gt;block_obj) , obj , &amp;obj);<br>    &#125;<br>    <br><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) &#123;_Block_object_assign((<span class="hljs-keyword">void</span>*)&amp;dst-&gt;block_obj, (<span class="hljs-keyword">void</span>*)src-&gt;block_obj, <span class="hljs-number">8</span><span class="hljs-comment">/*BLOCK_FIELD_IS_BYREF*/</span>);_Block_object_assign((<span class="hljs-keyword">void</span>*)&amp;dst-&gt;obj, (<span class="hljs-keyword">void</span>*)src-&gt;obj, <span class="hljs-number">3</span><span class="hljs-comment">/*BLOCK_FIELD_IS_OBJECT*/</span>);&#125;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> __main_block_dispose_0(struct __main_block_impl_0*src) &#123;_Block_object_dispose((<span class="hljs-keyword">void</span>*)src-&gt;block_obj, <span class="hljs-number">8</span><span class="hljs-comment">/*BLOCK_FIELD_IS_BYREF*/</span>);_Block_object_dispose((<span class="hljs-keyword">void</span>*)src-&gt;obj, <span class="hljs-number">3</span><span class="hljs-comment">/*BLOCK_FIELD_IS_OBJECT*/</span>);&#125;<br><br><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">main_block_desc_0</span> &#123;</span><br>  <span class="hljs-keyword">size_t</span> reserved;<br>  <span class="hljs-keyword">size_t</span> Block_size;<br>  <span class="hljs-keyword">void</span> (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);<br>  <span class="hljs-keyword">void</span> (*dispose)(struct __main_block_impl_0*);<br>&#125; __main_block_desc_0_DATA = &#123; <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0&#125;;<br><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * argv[])</span> </span>&#123;<br><br>    __attribute__((__blocks__(byref))) __Block_byref_block_obj_0 block_obj = &#123;(<span class="hljs-keyword">void</span>*)<span class="hljs-number">0</span>,(__Block_byref_block_obj_0 *)&amp;block_obj, <span class="hljs-number">33554432</span>, <span class="hljs-keyword">sizeof</span>(__Block_byref_block_obj_0), __Block_byref_id_object_copy_131, __Block_byref_id_object_dispose_131, ((NSObject *(*)(id, SEL))(<span class="hljs-keyword">void</span> *)objc_msgSend)((id)((NSObject *(*)(id, SEL))(<span class="hljs-keyword">void</span> *)objc_msgSend)((id)objc_getClass(<span class="hljs-string">&quot;NSObject&quot;</span>), sel_registerName(<span class="hljs-string">&quot;alloc&quot;</span>)), sel_registerName(<span class="hljs-string">&quot;init&quot;</span>))&#125;;<br><br>    id obj = ((NSObject *(*)(id, SEL))(<span class="hljs-keyword">void</span> *)objc_msgSend)((id)((NSObject *(*)(id, SEL))(<span class="hljs-keyword">void</span> *)objc_msgSend)((id)objc_getClass(<span class="hljs-string">&quot;NSObject&quot;</span>), sel_registerName(<span class="hljs-string">&quot;alloc&quot;</span>)), sel_registerName(<span class="hljs-string">&quot;init&quot;</span>));<br>    NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_45_k1d9q7c52vz50wz1683_hk9r0000gn_T_main_e64910_mi_0,(block_obj.__forwarding-&gt;block_obj) , &amp;(block_obj.__forwarding-&gt;block_obj) , obj , &amp;obj);<br><br>    <span class="hljs-keyword">void</span> (*myBlock)(<span class="hljs-keyword">void</span>) = ((<span class="hljs-keyword">void</span> (*)())&amp;__main_block_impl_0((<span class="hljs-keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA, obj, (__Block_byref_block_obj_0 *)&amp;block_obj, <span class="hljs-number">570425344</span>));<br><br>    ((<span class="hljs-keyword">void</span> (*)(__block_impl *))((__block_impl *)myBlock)-&gt;FuncPtr)((__block_impl *)myBlock);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>根据代码中赋值语句的差异 我们可以看到</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">__Block_byref_block_obj_0 *block_obj = __cself-&gt;block_obj; <span class="hljs-comment">// bound by ref</span><br><span class="hljs-keyword">id</span> obj = __cself-&gt;obj; <span class="hljs-comment">// bound by copy</span><br></code></pre></td></tr></table></figure>

<p>没有使用__block修饰的是copy的方式传递，使用__block修饰的是采用引用的传递方式。<br>这就很显然了 没有使用。</p>
<h3 id="Block在MRC和ARC下的不同"><a href="#Block在MRC和ARC下的不同" class="headerlink" title="Block在MRC和ARC下的不同"></a>Block在MRC和ARC下的不同</h3><h4 id="block修饰变量的位置"><a href="#block修饰变量的位置" class="headerlink" title="__block修饰变量的位置"></a>__block修饰变量的位置</h4><p>ARC环境下，一旦Block赋值就会触发copy，__block修饰的对象就会copy到堆上，Block的类型也变成__NSMallocBlock。ARC环境下也是存在__NSStackBlock的时候，这种情况下，__block就在栈上。</p>
<p>MRC环境下，只有copy，__block修饰的变量才会被复制到堆上，否则，__block修饰的变量一直都在栈上，block也只是__NSStackBlock，这个时候__forwarding指针就只指向自己了。</p>
<h4 id="block修饰变量的操作"><a href="#block修饰变量的操作" class="headerlink" title="__block修饰变量的操作"></a>__block修饰变量的操作</h4><p>在MRC环境下，__block根本不会对指针所指向的对象执行copy操作，而只是把指针进行的复制。</p>
<p>而在ARC环境下，对于声明为__block的外部对象，在block内部会进行retain，以至于在block环境内能安全的引用外部对象，所以才会产生循环引用的问题！</p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>先看下面这段代码:</p>
<p><img src="http://og0h689k8.bkt.clouddn.com/18-4-25/42976109.jpg" alt="blockerror"></p>
<p>如果我们想在block内部修改外部变量的值 系统会提示缺失__block的修饰符！</p>
<p><img src="http://og0h689k8.bkt.clouddn.com/18-4-25/24371620.jpg" alt="__block"></p>
<p>我们添加了__block之后 就可以在block中修改外部变量的值了。</p>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>__block到底做了什么,让一个原本不可以在block内修改的变量变得可以修改了呢？</p>
<p>我们先来看一下,被block修饰之后的变量到底都发生了什么变化.</p>
<p>先看一下对象的地址：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">__block <span class="hljs-built_in">NSInteger</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;定义前：%p&quot;</span>, &amp;a);<br><span class="hljs-keyword">void</span> (^blockName)(<span class="hljs-built_in">NSInteger</span> param) = ^(<span class="hljs-built_in">NSInteger</span> param)&#123;<br>    a = param;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;block内：%p&quot;</span>, &amp;a);<br>&#125;;<br><br>blockName(<span class="hljs-number">11</span>);<br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;定义后：%p&quot;</span>, &amp;a);  <br></code></pre></td></tr></table></figure>

<p>打印结果：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-number">2018</span><span class="hljs-number">-04</span><span class="hljs-number">-25</span> <span class="hljs-number">11</span>:<span class="hljs-number">51</span>:<span class="hljs-number">12.120470</span>+<span class="hljs-number">0800</span> Test[<span class="hljs-number">9140</span>:<span class="hljs-number">975007</span>] 定义前：<span class="hljs-number">0x16f4454a8</span><br><span class="hljs-number">2018</span><span class="hljs-number">-04</span><span class="hljs-number">-25</span> <span class="hljs-number">11</span>:<span class="hljs-number">51</span>:<span class="hljs-number">12.120601</span>+<span class="hljs-number">0800</span> Test[<span class="hljs-number">9140</span>:<span class="hljs-number">975007</span>] block内：<span class="hljs-number">0x100e07c88</span><br><span class="hljs-number">2018</span><span class="hljs-number">-04</span><span class="hljs-number">-25</span> <span class="hljs-number">11</span>:<span class="hljs-number">51</span>:<span class="hljs-number">12.120639</span>+<span class="hljs-number">0800</span> Test[<span class="hljs-number">9140</span>:<span class="hljs-number">975007</span>] 定义后：<span class="hljs-number">0x100e07c88</span><br></code></pre></td></tr></table></figure>

<p>这里我们看到 定以后以及block内部这两个位置 a的内存地址是相同的 但是跟定义前的地址是不同的！</p>
<p>那么__block 是做了什么操作修改了这个变量的内存地址！</p>
<p>我们先对这两个地址进行分析:<br>将这两个16进制内存地址转换为10进制的</p>
<table>
<thead>
<tr>
<th>title</th>
<th>16进制</th>
<th>10进制</th>
</tr>
</thead>
<tbody><tr>
<td>定义前</td>
<td>0x16f4454a8</td>
<td>6161716392</td>
</tr>
<tr>
<td>block内</td>
<td>0x100e07c88</td>
<td>4309679240</td>
</tr>
<tr>
<td>定义后</td>
<td>0x100e07c88</td>
<td>4309679240</td>
</tr>
</tbody></table>
<p>6161716392-4309679240 = 1852037152 </p>
<p><code>这个字节差的有点多呀 什么鬼</code></p>
<p>这是一个很大的值, 因为我们可以确定局部变量a是存放在栈区的 所以 我们可以确认 a在使用__block修饰后被放到了堆区。</p>
<p>这也证实了：<code>a 在定义前是栈区，但只要进入了 block 区域，就变成了堆区。这才是 __block 关键字的真正作用。</code></p>
<p>当我们使用对象类型的时候呢？</p>
<p>看下面这段代码</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-built_in">NSMutableString</span> *a = [<span class="hljs-built_in">NSMutableString</span> stringWithString:<span class="hljs-string">@&quot;Tom&quot;</span>];<br>  <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;\n 定以前：------------------------------------\n\</span><br><span class="hljs-string">        a指向的堆中地址：%p；a在栈中的指针地址：%p&quot;</span>, a, &amp;a);               <span class="hljs-comment">//a在栈区</span><br>  <span class="hljs-keyword">void</span> (^foo)(<span class="hljs-keyword">void</span>) = ^&#123;<br>      a.string = <span class="hljs-string">@&quot;Jerry&quot;</span>;<br>      <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;\n block内部：------------------------------------\n\</span><br><span class="hljs-string">       a指向的堆中地址：%p；a在栈中的指针地址：%p&quot;</span>, a, &amp;a);               <span class="hljs-comment">//a在栈区</span><br>      <span class="hljs-comment">//a = [NSMutableString stringWithString:@&quot;William&quot;];</span><br>  &#125;;<br>  foo();<br>  <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;\n 定以后：------------------------------------\n\</span><br><span class="hljs-string">        a指向的堆中地址：%p；a在栈中的指针地址：%p&quot;</span>, a, &amp;a);    <br></code></pre></td></tr></table></figure>

<p>打印结果:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-number">2018</span><span class="hljs-number">-04</span><span class="hljs-number">-25</span> <span class="hljs-number">13</span>:<span class="hljs-number">56</span>:<span class="hljs-number">00.488632</span>+<span class="hljs-number">0800</span> Test[<span class="hljs-number">9566</span>:<span class="hljs-number">1019521</span>] <br> 定以前：------------------------------------<br>          a指向的堆中地址：<span class="hljs-number">0x100c03fb0</span>；a在栈中的指针地址：<span class="hljs-number">0x16f7554a8</span><br><span class="hljs-number">2018</span><span class="hljs-number">-04</span><span class="hljs-number">-25</span> <span class="hljs-number">13</span>:<span class="hljs-number">56</span>:<span class="hljs-number">00.489045</span>+<span class="hljs-number">0800</span> Test[<span class="hljs-number">9566</span>:<span class="hljs-number">1019521</span>] <br> block内部：------------------------------------<br>              a指向的堆中地址：<span class="hljs-number">0x100c03fb0</span>；a在栈中的指针地址：<span class="hljs-number">0x100c74f20</span><br><span class="hljs-number">2018</span><span class="hljs-number">-04</span><span class="hljs-number">-25</span> <span class="hljs-number">13</span>:<span class="hljs-number">56</span>:<span class="hljs-number">00.489294</span>+<span class="hljs-number">0800</span> Test[<span class="hljs-number">9566</span>:<span class="hljs-number">1019521</span>] <br> 定以后：------------------------------------<br>          a指向的堆中地址：<span class="hljs-number">0x100c03fb0</span>；a在栈中的指针地址：<span class="hljs-number">0x16f7554a8</span><br>error in connection_block_invoke_2: Connection interrupted<br></code></pre></td></tr></table></figure>

<p>由打印我们可以看出 定义前和定义后还有block中 <code>a所指向堆中的内存地址是不变的</code>！,但是在block中会对外部的变量做一个copy操作 将栈中的指针a拷贝到堆中！(不改变该指针指向堆中的值)。</p>
<p><code>重点</code>:对于对象a我们没有使用__block进行修饰但是 我们在block中仍然可以修改这个对象的某一个属性。因此 我们可以得出 block中只是不能修改栈中的指针,但是可以修改栈中指针指向堆中的对象的某些属性。</p>
<p>下面再来看</p>
<p><img src="http://og0h689k8.bkt.clouddn.com/18-4-25/75467588.jpg" alt="修改变量的值"></p>
<p>如果我们想修改这个对象的值(修改这个指针指向的位置而不是修改指针指向位置所代表对象的某个属性)。</p>
<p>系统还是会提示我们 必须要使用block修饰！！！</p>
<p>通过上面的这两个例子我们可以得出结论：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">Block不允许修改外部变量的值，这里所说的外部变量的值，指的是栈中指针的内存地址。栈区是红灯区，堆区才是绿灯区。<br><br>__block 所起到的作用就是只要观察到该变量被 block 所持有，就将“外部变量”在栈中的内存地址放到了堆中。进而在block内部也可以修改外部变量的值。<br><br></code></pre></td></tr></table></figure>


<h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><p><a href="https://www.jianshu.com/p/ee9756f3d5f6">深入研究Block捕获外部变量和__block实现原理</a></p>
]]></content>
      <categories>
        <category>iOS优化</category>
      </categories>
      <tags>
        <tag>Block __block</tag>
      </tags>
  </entry>
  <entry>
    <title>Mach-O 探究</title>
    <url>/2020/08/30/Mach-O/</url>
    <content><![CDATA[<p><code>Mach-O</code>为<code>Mach Object</code>文件格式的缩写，它是一种用于可执行文件，目标代码，动态库，内核转储的文件格式。作为a.out格式的替代，Mach-O提供了更强的扩展性，并提升了符号表中信息的访问速度。<br><code>Mach-O</code>格式为大部分基于<code>Mach</code>内核的操作系统所使用的，包括<code>NeXTSTEP</code>, <code>Mac OS X</code>和<code>iOS</code>，它们都以<code>Mach-O</code>格式作为其可执行文件，动态库，目标代码的文件格式。</p>
<a id="more"></a>


<h3 id="Mach-O简介"><a href="#Mach-O简介" class="headerlink" title="Mach-O简介"></a>Mach-O简介</h3><p>在iOS开发中，我们的代码在编译后会生成一个.app的文件(Product文件夹下),而.app文件我们可以把它看做是一个文件夹,内部存放了APP正常运行所需要的文件，通常比较容易识别的是一些资源文件。如图：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gi8xlznb88j30fm0keajq.jpg"></p>
<p>我们通过显示包内容看下.app文件夹内都有什么：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gi8xow8jvoj30s40duwhk.jpg"></p>
<p>当然我们这片文章的主角也在这个文件夹内：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gi8xfafmakj30yq0hqah8.jpg"></p>
<p>系统识别Mach-O(这个名字是项目的名字)为可执行文件(Mach-O是一种可执行文件格式)，我们来看下这个文件,Mach-O文件是无法直接打开或者查看包内容，这里我们需要借助MachOView工具来查看，工具是开源的如果你想看具体的实现，你可以看<a href="https://github.com/gdbinit/MachOView">工具的源码</a>，当然你可以直接<a href="http://sourceforge.net/projects/machoview/">下载</a>使用。</p>
<p>打开后的页面是这样的：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gi8xv47qi7j31fg0sc44j.jpg"></p>
<h3 id="Mach-O结构"><a href="#Mach-O结构" class="headerlink" title="Mach-O结构"></a>Mach-O结构</h3><p>实际上我们从使用MachOView打开后的文件目录也可以看出，Mach-O的文件结构分为三大部分:<code>Header</code>,<code>Load Commands</code>,<code>Data</code>。</p>
<p>下面是官方提供的一张结构图：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gi8yhakxzbj30b50but9m.jpg"></p>
<p>根据上图，我们将我们看到的目录大致划分为：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gi8yllkqyyj30ju1000y2.jpg"></p>
<ul>
<li>Mach-O 头（Mach Header）：这里描述了 Mach-O 的 CPU 架构、文件类型以及加载命令等信息；</li>
<li>加载命令（Load Command）：当系统加载Mach-O文件时，load command会指导苹果的动态加载器(dyld)h或内核，该如何加载文件的Data数据。</li>
<li>数据区（Data）：Mach-O文件的数据区，包含代码和数据。其中包含若干Segment块，每个Segment块中包含0个或多个seciton。Segment根据对应的load command被dyld加载入内存中。</li>
</ul>
<p><code>注意</code>：通过对比我们发现实际上官网给出的结构并不准确，在实际结果中还包含了<code>Dynamic Loader Info</code>,<code>Function Starts</code>,<code>Symbol Table</code>,<code>Data In Code Entries</code>,<code>Dynamic Symbol Table</code>,<code>String Table</code>,<code>Code Signature</code>等。</p>
<p>下面我们来详细看下每部分的内容</p>
<h3 id="Mach64-Header"><a href="#Mach64-Header" class="headerlink" title="Mach64 Header"></a>Mach64 Header</h3><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gi8xxtz5kij31fa0g6dkw.jpg"></p>
<p>这里我们可以和苹果开源的Darwin源码一起看方便理解,源码在<a href="https://opensource.apple.com/source/xnu/xnu-1456.1.26/EXTERNAL_HEADERS/mach-o/loader.h">这里</a>。</p>
<p>32位</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * The 32-bit mach header appears at the very beginning of the object file for</span><br><span class="hljs-comment"> * 32-bit architectures.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mach_header</span> &#123;</span><br>	<span class="hljs-keyword">uint32_t</span>	magic;		<span class="hljs-comment">/* mach magic number identifier */</span><br>	<span class="hljs-keyword">cpu_type_t</span>	cputype;	<span class="hljs-comment">/* cpu specifier */</span><br>	<span class="hljs-keyword">cpu_subtype_t</span>	cpusubtype;	<span class="hljs-comment">/* machine specifier */</span><br>	<span class="hljs-keyword">uint32_t</span>	filetype;	<span class="hljs-comment">/* type of file */</span><br>	<span class="hljs-keyword">uint32_t</span>	ncmds;		<span class="hljs-comment">/* number of load commands */</span><br>	<span class="hljs-keyword">uint32_t</span>	sizeofcmds;	<span class="hljs-comment">/* the size of all the load commands */</span><br>	<span class="hljs-keyword">uint32_t</span>	flags;		<span class="hljs-comment">/* flags */</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<p>64位:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * The 64-bit mach header appears at the very beginning of object files for</span><br><span class="hljs-comment"> * 64-bit architectures.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mach_header_64</span> &#123;</span><br>	<span class="hljs-keyword">uint32_t</span>	magic;		<span class="hljs-comment">/* mach magic number identifier */</span><br>	<span class="hljs-keyword">cpu_type_t</span>	cputype;	<span class="hljs-comment">/* cpu specifier */</span><br>	<span class="hljs-keyword">cpu_subtype_t</span>	cpusubtype;	<span class="hljs-comment">/* machine specifier */</span><br>	<span class="hljs-keyword">uint32_t</span>	filetype;	<span class="hljs-comment">/* type of file */</span><br>	<span class="hljs-keyword">uint32_t</span>	ncmds;		<span class="hljs-comment">/* number of load commands */</span><br>	<span class="hljs-keyword">uint32_t</span>	sizeofcmds;	<span class="hljs-comment">/* the size of all the load commands */</span><br>	<span class="hljs-keyword">uint32_t</span>	flags;		<span class="hljs-comment">/* flags */</span><br>	<span class="hljs-keyword">uint32_t</span>	reserved;	<span class="hljs-comment">/* reserved */</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<p>我们看到32位和64位的<code>mach_header</code>基本是一致的，只是在64位中新增了<code>reserved</code>字段，下面我们来看下其中每个字段所表示的意义。</p>
<h4 id="Magic-Number"><a href="#Magic-Number" class="headerlink" title="Magic Number"></a>Magic Number</h4><table>
<thead>
<tr>
<th>offset</th>
<th>data</th>
<th>description</th>
<th>value</th>
</tr>
</thead>
<tbody><tr>
<td>00000000</td>
<td>FEEDFACF</td>
<td>Magic Number</td>
<td>MH_MAGIC_64</td>
</tr>
</tbody></table>
<p>我们可以将其直译为<code>魔数</code>，他的值(Value)有两个:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>	MH_MAGIC	0xfeedface	<span class="hljs-comment">/* the mach magic number */</span> 32位</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MH_MAGIC_64 0xfeedfacf <span class="hljs-comment">/* the 64-bit mach magic number */</span> 64位</span><br></code></pre></td></tr></table></figure>
<p>用于这个Mach-O文件的标识，有32位和64位两个值。由此可以看出我们的示例是一个64位的Mach-O文件。</p>
<h4 id="CPU-Type-CPU-SubType"><a href="#CPU-Type-CPU-SubType" class="headerlink" title="CPU Type ,CPU SubType"></a>CPU Type ,CPU SubType</h4><table>
<thead>
<tr>
<th>offset</th>
<th>data</th>
<th>description</th>
<th>value</th>
</tr>
</thead>
<tbody><tr>
<td>00000004</td>
<td>0100000C</td>
<td>CPU Type</td>
<td>CPU_TYPE_64</td>
</tr>
<tr>
<td>00000008</td>
<td>00000000</td>
<td>CPU SubType</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>00000000</td>
<td>CPU_SubType_ARM64_ALL</td>
</tr>
</tbody></table>
<p>CPU Type和CPU SubType 表示支持的CUP架构类型和子类型，如ARM。而具体的类型有哪些我们可以通过查询<code>/mach/machine.h.</code>中的定义查看这里不做过多的扩展,具体可以看<a href="https://opensource.apple.com/source/xnu/xnu-4570.41.2/osfmk/mach/machine.h.auto.html">这里</a><br>我们的示例中，APP是支持所有arm64的机型的:CUP_SUBTYPE_ARM64_ALL。</p>
<h4 id="File-Type"><a href="#File-Type" class="headerlink" title="File Type"></a>File Type</h4><table>
<thead>
<tr>
<th>offset</th>
<th>data</th>
<th>description</th>
<th>value</th>
</tr>
</thead>
<tbody><tr>
<td>0000000C</td>
<td>00000002</td>
<td>File Type</td>
<td>MH_EXECUTE</td>
</tr>
</tbody></table>
<p>File Type 表示 Mach-O的文件类型。包括</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">#define	MH_OBJECT	0x1		&#x2F;* Target 文件：编译器对源码编译后得到的中间结果 *&#x2F;<br>#define	MH_EXECUTE	0x2		&#x2F;* 可执行二进制文件 *&#x2F;<br>#define	MH_FVMLIB	0x3		&#x2F;* VM 共享库文件（还不清楚是什么东西） *&#x2F;<br>#define	MH_CORE		0x4		&#x2F;* Core 文件，一般在 App Crash 产生 *&#x2F;<br>#define	MH_PRELOAD	0x5		&#x2F;* preloaded executable file *&#x2F;<br>#define	MH_DYLIB	0x6		   &#x2F;* 动态库 *&#x2F;<br>#define	MH_DYLINKER	0x7		&#x2F;* 动态连接器 &#x2F;usr&#x2F;lib&#x2F;dyld *&#x2F;<br>#define	MH_BUNDLE	0x8		&#x2F;* 非独立的二进制文件，往往通过 gcc-bundle 生成 *&#x2F;<br>#define	MH_DYLIB_STUB	0x9	&#x2F;* 静态链接文件（还不清楚是什么东西） *&#x2F;<br>#define	MH_DSYM		0xa		&#x2F;* 符号文件以及调试信息，在解析堆栈符号中常用 *&#x2F;<br>#define	MH_KEXT_BUNDLE	0xb	&#x2F;* x86_64 内核扩展 *&#x2F;<br></code></pre></td></tr></table></figure>
<p>这里类型均是在<code>loader.h</code>文件中定义的</p>
<p>对于我们示例中的我们的File Type为 <code>MH_EXECUTE</code>表示 可执行的二进制文件。</p>
<h4 id="ncmds-Number-of-Load-Commands"><a href="#ncmds-Number-of-Load-Commands" class="headerlink" title="ncmds(Number of Load Commands)"></a>ncmds(Number of Load Commands)</h4><table>
<thead>
<tr>
<th>offset</th>
<th>data</th>
<th>description</th>
<th>value</th>
</tr>
</thead>
<tbody><tr>
<td>00000010</td>
<td>00000017</td>
<td>Number of Load Commands</td>
<td>23</td>
</tr>
</tbody></table>
<p>ncmds表示load command的数量。在我们的示例中表示数量为23个。</p>
<h4 id="sizeofcmds-Size-of-Load-Commands"><a href="#sizeofcmds-Size-of-Load-Commands" class="headerlink" title="sizeofcmds(Size of Load Commands)"></a>sizeofcmds(Size of Load Commands)</h4><table>
<thead>
<tr>
<th>offset</th>
<th>data</th>
<th>description</th>
<th>value</th>
</tr>
</thead>
<tbody><tr>
<td>00000014</td>
<td>00000AF8</td>
<td>Size of Load Commands</td>
<td>2808</td>
</tr>
</tbody></table>
<p>sizeofcmds表示所有load command的总大小。示例中总大小为2808。</p>
<h4 id="Flags"><a href="#Flags" class="headerlink" title="Flags"></a>Flags</h4><table>
<thead>
<tr>
<th>offset</th>
<th>data</th>
<th>description</th>
<th>value</th>
</tr>
</thead>
<tbody><tr>
<td>00000018</td>
<td>00200085</td>
<td>Flags</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>00000001</td>
<td>MH_NOUNDEFS</td>
</tr>
<tr>
<td></td>
<td></td>
<td>00000004</td>
<td>MH_DYLDLINK</td>
</tr>
<tr>
<td></td>
<td></td>
<td>00000080</td>
<td>MH_TWOLEVEL</td>
</tr>
<tr>
<td></td>
<td></td>
<td>00200000</td>
<td>MH_PIE</td>
</tr>
</tbody></table>
<p>Flags 是Mach-O文件的标志位。主要作用是告诉系统该如何加载这个Mach-O文件以及该文件的一些特性。有很多值，我们取常见的几种</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>	MH_NOUNDEFS	0x1		<span class="hljs-comment">/* Target 文件中没有带未定义的符号，常为静态二进制文件 */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MH_SPLIT_SEGS	0x20  <span class="hljs-comment">/* Target 文件中的只读 Segment 和可读写 Segment 分开  */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MH_TWOLEVEL	0x80		<span class="hljs-comment">/* 该 Image 使用二级命名空间(two name space binding)绑定方案 */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MH_FORCE_FLAT	0x100 <span class="hljs-comment">/* 使用扁平命名空间(flat name space binding)绑定（与 MH_TWOLEVEL 互斥） */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MH_WEAK_DEFINES	0x8000 <span class="hljs-comment">/* 二进制文件使用了弱符号 */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MH_BINDS_TO_WEAK 0x10000 <span class="hljs-comment">/* 二进制文件链接了弱符号 */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MH_ALLOW_STACK_EXECUTION 0x20000<span class="hljs-comment">/* 允许 Stack 可执行 */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>	MH_PIE 0x200000  <span class="hljs-comment">/* 加载程序在随机的地址空间，只在 MH_EXECUTE中使用 */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MH_NO_HEAP_EXECUTION 0x1000000 <span class="hljs-comment">/* 将 Heap 标记为不可执行，可防止 heap spray 攻击 */</span></span><br></code></pre></td></tr></table></figure>

<p>结合我们的示例，我们共有4个Flags:</p>
<ul>
<li>MH_NOUNDEFS</li>
<li>MH_DYLDLINK dyld是苹果公司的动态链接库，用来把Mach-O文件加载入内存</li>
<li>MH_TWOLEVEL 表示其符号空间中还会包含所在库的信息。这样可以使得不同的库导出通用的符号。与其相对的是扁平命名空间。</li>
<li>MH_PIE 每次系统加载进程后，都会为其随机分配一个虚拟内存空间(在传统系统中，进程每次加载的虚拟内存是相同的。这就让黑客有可能篡改内存来破解软件)</li>
</ul>
<p><code>注意</code>:flags的值也定义在loader.h文件中 都可以通过源码查看。</p>
<h3 id="Load-Commands"><a href="#Load-Commands" class="headerlink" title="Load Commands"></a>Load Commands</h3><p>Load Commands 紧跟在Header之后，用来告诉内核和dyld，如何将各个Segment加载入内存中。load command被源码表示为struct，有若干种load command，但是共同的特点是，在其结构的开头处，必须是如下两个属性：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * The load commands directly follow the mach_header.  The total size of all</span><br><span class="hljs-comment"> * of the commands is given by the sizeofcmds field in the mach_header.  All</span><br><span class="hljs-comment"> * load commands must have as their first two fields cmd and cmdsize.  </span><br><span class="hljs-comment"> * The cmd</span><br><span class="hljs-comment"> * field is filled in with a constant for that command type.  </span><br><span class="hljs-comment"> * Each command type</span><br><span class="hljs-comment"> * has a structure specifically for it.  </span><br><span class="hljs-comment"> * The cmdsize field is the size in bytes</span><br><span class="hljs-comment"> * of the particular load command structure plus anything that follows it that</span><br><span class="hljs-comment"> * is a part of the load command (i.e. section structures, strings, etc.). </span><br><span class="hljs-comment"> *  To</span><br><span class="hljs-comment"> * advance to the next load command the cmdsize can be added to the offset or</span><br><span class="hljs-comment"> * pointer of the current load command.  </span><br><span class="hljs-comment"> * The cmdsize for 32-bit architectures</span><br><span class="hljs-comment"> * MUST be a multiple of 4 bytes and for 64-bit architectures MUST be a multiple</span><br><span class="hljs-comment"> * of 8 bytes (these are forever the maximum alignment of any load commands).</span><br><span class="hljs-comment"> * The padded bytes must be zero.  All tables in the object file must also</span><br><span class="hljs-comment"> * follow these rules so the file can be memory mapped.  Otherwise the pointers</span><br><span class="hljs-comment"> * to these tables will not work well or at all on some machines.  With all</span><br><span class="hljs-comment"> * padding zeroed like objects will compare byte for byte.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">load_command</span> &#123;</span><br>	<span class="hljs-keyword">uint32_t</span> cmd;		<span class="hljs-comment">/* type of load command */</span><br>	<span class="hljs-keyword">uint32_t</span> cmdsize;	<span class="hljs-comment">/* total size of command in bytes */</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<p>对应我们示例中的Load Commands</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gi8zwcgxxfj31py0s645r.jpg"></p>
<p>我们在尝试去理解<code>load_command</code>的注释:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">load commands紧跟着mach_header,load commands的总大小由mach_header汇总的sizeofcmds字段给出，所有的load commands都必须以cmd和cmdsize两个字段作为前两个字段(结合我们的示例也得到验证)，cmd字段的值为commandtype常量，每一个commandtype都有一种特定的结构。cmdsize字段以字节为单位包含loadcommand结构和额外的其他字段(例如  section structures，strings等)。要前进到下一个加载命令，可以将cmdsize添加到当前加载命令的偏移量或指针。对于32位体系结构的cmdsize<br> 必须是4字节的倍数，并且对于64位架构，必须是8字节的倍数（这些永远是所有装入命令的最大对齐),填充字节必须为零。<br></code></pre></td></tr></table></figure>

<h4 id="Segment"><a href="#Segment" class="headerlink" title="Segment"></a>Segment</h4><p>在这么多的load command中，需要我们重点关注的是segment load command，segment command解释了该如何将Data中的各个Segment加载入内存中，而和我们APP相关的逻辑及数据，则大部分位于各个Segment中。</p>
<p>而和我们的Run time相关的Segment，则位于__DATA类型Segment下。</p>
<p>Segment load command也分为32位和64位：</p>
<p>32位</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * The segment load command indicates that a part of this file is to be</span><br><span class="hljs-comment"> * mapped into the task&#x27;s address space.  The size of this segment in memory,</span><br><span class="hljs-comment"> * vmsize, maybe equal to or larger than the amount to map from this file,</span><br><span class="hljs-comment"> * filesize.  The file is mapped starting at fileoff to the beginning of</span><br><span class="hljs-comment"> * the segment in memory, vmaddr.  The rest of the memory of the segment,</span><br><span class="hljs-comment"> * if any, is allocated zero fill on demand.  The segment&#x27;s maximum virtual</span><br><span class="hljs-comment"> * memory protection and initial virtual memory protection are specified</span><br><span class="hljs-comment"> * by the maxprot and initprot fields.  If the segment has sections then the</span><br><span class="hljs-comment"> * section structures directly follow the segment command and their size is</span><br><span class="hljs-comment"> * reflected in cmdsize.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">segment_command</span> &#123;</span> <span class="hljs-comment">/* for 32-bit architectures */</span><br>	<span class="hljs-keyword">uint32_t</span>	cmd;		<span class="hljs-comment">/* LC_SEGMENT */</span><br>	<span class="hljs-keyword">uint32_t</span>	cmdsize;	<span class="hljs-comment">/* includes sizeof section structs */</span><br>	<span class="hljs-keyword">char</span>		segname[<span class="hljs-number">16</span>];	<span class="hljs-comment">/* segment name */</span><br>	<span class="hljs-keyword">uint32_t</span>	vmaddr;		<span class="hljs-comment">/* memory address of this segment */</span><br>	<span class="hljs-keyword">uint32_t</span>	vmsize;		<span class="hljs-comment">/* memory size of this segment */</span><br>	<span class="hljs-keyword">uint32_t</span>	fileoff;	<span class="hljs-comment">/* file offset of this segment */</span><br>	<span class="hljs-keyword">uint32_t</span>	filesize;	<span class="hljs-comment">/* amount to map from the file */</span><br>	<span class="hljs-keyword">vm_prot_t</span>	maxprot;	<span class="hljs-comment">/* maximum VM protection */</span><br>	<span class="hljs-keyword">vm_prot_t</span>	initprot;	<span class="hljs-comment">/* initial VM protection */</span><br>	<span class="hljs-keyword">uint32_t</span>	nsects;		<span class="hljs-comment">/* number of sections in segment */</span><br>	<span class="hljs-keyword">uint32_t</span>	flags;		<span class="hljs-comment">/* flags */</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<p>64位</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * The 64-bit segment load command indicates that a part of this file is to be</span><br><span class="hljs-comment"> * mapped into a 64-bit task&#x27;s address space.  If the 64-bit segment has</span><br><span class="hljs-comment"> * sections then section_64 structures directly follow the 64-bit segment</span><br><span class="hljs-comment"> * command and their size is reflected in cmdsize.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">segment_command_64</span> &#123;</span> <span class="hljs-comment">/* for 64-bit architectures */</span><br>	<span class="hljs-keyword">uint32_t</span>	cmd;		<span class="hljs-comment">/* LC_SEGMENT_64 */</span><br>	<span class="hljs-keyword">uint32_t</span>	cmdsize;	<span class="hljs-comment">/* includes sizeof section_64 structs */</span><br>	<span class="hljs-keyword">char</span>		segname[<span class="hljs-number">16</span>];	<span class="hljs-comment">/* segment name */</span><br>	<span class="hljs-keyword">uint64_t</span>	vmaddr;		<span class="hljs-comment">/* memory address of this segment */</span><br>	<span class="hljs-keyword">uint64_t</span>	vmsize;		<span class="hljs-comment">/* memory size of this segment */</span><br>	<span class="hljs-keyword">uint64_t</span>	fileoff;	<span class="hljs-comment">/* file offset of this segment */</span><br>	<span class="hljs-keyword">uint64_t</span>	filesize;	<span class="hljs-comment">/* amount to map from the file */</span><br>	<span class="hljs-keyword">vm_prot_t</span>	maxprot;	<span class="hljs-comment">/* maximum VM protection */</span><br>	<span class="hljs-keyword">vm_prot_t</span>	initprot;	<span class="hljs-comment">/* initial VM protection */</span><br>	<span class="hljs-keyword">uint32_t</span>	nsects;		<span class="hljs-comment">/* number of sections in segment */</span><br>	<span class="hljs-keyword">uint32_t</span>	flags;		<span class="hljs-comment">/* flags */</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<p>32位和64位的segment_command基本一致，只是在64位的结构中把和寻址相关的数据类型由<code>uint32_t</code>改为<code>uint64_t</code></p>
<p>我们先看下示例中，和Segment相关的Command：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gi90jod69hj30i808ewfe.jpg"></p>
<p>结合源码我们可以看到：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">#define    SEG_PAGEZERO    &quot;__PAGEZERO&quot; &#x2F;* 当时 MH_EXECUTE 文件时，捕获到空指针 *&#x2F;<br>#define    SEG_TEXT    &quot;__TEXT&quot; &#x2F;* 代码&#x2F;只读数据段 *&#x2F;<br>#define    SEG_DATA    &quot;__DATA&quot; &#x2F;* 数据段 *&#x2F;<br>#define    SEG_LINKEDIT    &quot;__LINKEDIT&quot; &#x2F;* 包含需要被动态链接器使用的符号和其他表，包括符号表、字符串表等 *&#x2F;<br></code></pre></td></tr></table></figure>

<p>根据前面结构图我们知道Load Commands实际上是一个二级结构:Segment-&gt;Section,正如示例中所示</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gi90uyqf0ij314k0c8n0z.jpg"></p>
<p>因此，下面我们在看下section的结构</p>
<h4 id="Section"><a href="#Section" class="headerlink" title="Section"></a>Section</h4><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * A segment is made up of zero or more sections.  Non-MH_OBJECT files have</span><br><span class="hljs-comment"> * all of their segments with the proper sections in each, and padded to the</span><br><span class="hljs-comment"> * specified segment alignment when produced by the link editor.  The first</span><br><span class="hljs-comment"> * segment of a MH_EXECUTE and MH_FVMLIB format file contains the mach_header</span><br><span class="hljs-comment"> * and load commands of the object file before its first section.  The zero</span><br><span class="hljs-comment"> * fill sections are always last in their segment (in all formats).  This</span><br><span class="hljs-comment"> * allows the zeroed segment padding to be mapped into memory where zero fill</span><br><span class="hljs-comment"> * sections might be. The gigabyte zero fill sections, those with the section</span><br><span class="hljs-comment"> * type S_GB_ZEROFILL, can only be in a segment with sections of this type.</span><br><span class="hljs-comment"> * These segments are then placed after all other segments.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * The MH_OBJECT format has all of its sections in one segment for</span><br><span class="hljs-comment"> * compactness.  There is no padding to a specified segment boundary and the</span><br><span class="hljs-comment"> * mach_header and load commands are not part of the segment.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Sections with the same section name, sectname, going into the same segment,</span><br><span class="hljs-comment"> * segname, are combined by the link editor.  The resulting section is aligned</span><br><span class="hljs-comment"> * to the maximum alignment of the combined sections and is the new section&#x27;s</span><br><span class="hljs-comment"> * alignment.  The combined sections are aligned to their original alignment in</span><br><span class="hljs-comment"> * the combined section.  Any padded bytes to get the specified alignment are</span><br><span class="hljs-comment"> * zeroed.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * The format of the relocation entries referenced by the reloff and nreloc</span><br><span class="hljs-comment"> * fields of the section structure for mach object files is described in the</span><br><span class="hljs-comment"> * header file &lt;reloc.h&gt;.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">struct</span> section &#123; <span class="hljs-comment">/* for 32-bit architectures */</span><br>	<span class="hljs-keyword">char</span>		sectname[<span class="hljs-number">16</span>];	<span class="hljs-comment">/* name of this section Section 名字 */</span><br>	<span class="hljs-keyword">char</span>		segname[<span class="hljs-number">16</span>];	<span class="hljs-comment">/* segment this section goes in */</span><br>	uint32_t	addr;		<span class="hljs-comment">/* memory address of this section */</span><br>	uint32_t	size;		<span class="hljs-comment">/* size in bytes of this section */</span><br>	uint32_t	offset;		<span class="hljs-comment">/* file offset of this section */</span><br>	uint32_t	align;		<span class="hljs-comment">/* section alignment (power of 2) */</span><br>	uint32_t	reloff;		<span class="hljs-comment">/* file offset of relocation entries */</span><br>	uint32_t	nreloc;		<span class="hljs-comment">/* number of relocation entries */</span><br>	uint32_t	flags;		<span class="hljs-comment">/* flags (section type and attributes)*/</span><br>	uint32_t	reserved1;	<span class="hljs-comment">/* reserved (for offset or index) */</span><br>	uint32_t	reserved2;	<span class="hljs-comment">/* reserved (for count or sizeof) */</span><br>&#125;;<br><br><span class="hljs-keyword">struct</span> section_64 &#123; <span class="hljs-comment">/* for 64-bit architectures */</span><br>	<span class="hljs-keyword">char</span>		sectname[<span class="hljs-number">16</span>];	<span class="hljs-comment">/* Section 名字 */</span><br>	<span class="hljs-keyword">char</span>		segname[<span class="hljs-number">16</span>];	<span class="hljs-comment">/* 所在的Segment名称*/</span><br>	uint64_t	addr;		<span class="hljs-comment">/* Section 所在的内存地址 */</span><br>	uint64_t	size;		<span class="hljs-comment">/* Section 的大小 */</span><br>	uint32_t	offset;		<span class="hljs-comment">/* Section 所在的文件偏移 */</span><br>	uint32_t	align;		<span class="hljs-comment">/* Section 的内存对齐边界 (2 的次幂) */</span><br>	uint32_t	reloff;		<span class="hljs-comment">/* 重定位信息的文件偏移 */</span><br>	uint32_t	nreloc;		<span class="hljs-comment">/* 重定位条目的数目 */</span><br>	uint32_t	flags;		<span class="hljs-comment">/* 标志属性 (section type and attributes)*/</span><br>	uint32_t	reserved1;	<span class="hljs-comment">/* 保留字段1 (for offset or index) */</span><br>	uint32_t	reserved2;	<span class="hljs-comment">/* 保留字段2 (for count or sizeof) */</span><br>	uint32_t	reserved3;	<span class="hljs-comment">/* 保留字段3 */</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<p>在64位和32位的section定义中，64位新增了一个reserved3保留字段，以及将section的addr和size字段由原来的uint32_t类型升级为uint64_t。</p>
<p>在Data中，程序的逻辑和数据是按照Segment（段）存储，在Segment中，又分为0或多个section，每个section中在存储实际的内容。而之所以这么做的原因在于，在section中，可以不用内存对齐达到节约内存的作用，而所有的section作为整体的Segment，又可以整体的内存对齐。</p>
<p>结合我们示例中的一个section结构如下图：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gi914f1x7fj31240ie0vn.jpg"></p>
<h3 id="DATA-数据"><a href="#DATA-数据" class="headerlink" title="DATA(数据)"></a>DATA(数据)</h3><p>Mach-O的Data部分，其实是真正存储APP二进制数据的位置，前面的header和load command，仅是提供文件的说明以及加载信息的功能。</p>
<p>前面我们介绍过，我们通过Load Commands从DATA中读取数据，而Load Commands被划分成了多个Segment，也就是说 我们通过不同的Load Commands从DATA中读取不同的数据。</p>
<p>在介绍Segment的时候我们说过Segment被划分成<code>__PAGEZERO</code>,<code>__TEXT</code>,<code>__DATA</code>,<code>__LINKEDIT</code>这几段。</p>
<p>结合我们的示例，我们发现DATA被划分为:<code>__TEXT</code>,<code>__DATA</code></p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gi91bdekm9j31j80u0gy7.jpg"></p>
<p>下面我们来看下这几个数据段(section):</p>
<h4 id="TEXT段"><a href="#TEXT段" class="headerlink" title="__TEXT段"></a>__TEXT段</h4><p>__TEXT是程序的只读段，用于保存我们所写的代码和字符串常量，const修饰常量等。</p>
<p>下面是几个我们常见的section：</p>
<table>
<thead>
<tr>
<th>Section</th>
<th>存储内容</th>
</tr>
</thead>
<tbody><tr>
<td>__TEXT.__text</td>
<td>主程序代码</td>
</tr>
<tr>
<td>__TEXT.__cstring</td>
<td>C 语言字符串</td>
</tr>
<tr>
<td>__TEXT.__const</td>
<td>const 关键字修饰的常量</td>
</tr>
<tr>
<td>__TEXT.__stubs</td>
<td>用于 Stub 的占位代码，很多地方称之为桩代码。</td>
</tr>
<tr>
<td>__TEXT.__stubs_helper</td>
<td>当 Stub 无法找到真正的符号地址后的最终指向</td>
</tr>
<tr>
<td>__TEXT.__objc_methname</td>
<td>Objective-C 方法名称</td>
</tr>
<tr>
<td>__TEXT.__objc_methtype</td>
<td>Objective-C 方法类型</td>
</tr>
<tr>
<td>__TEXT.__objc_classname</td>
<td>Objective-C 类名称</td>
</tr>
</tbody></table>
<p>我们来结合示例看下这几个section的内容：</p>
<h5 id="cstring"><a href="#cstring" class="headerlink" title="cstring"></a>cstring</h5><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gi939ehxldj31vk0mu7ef.jpg"></p>
<p>我们可以从中看到<code>lw_property</code>,<code>lw_publicproperty</code>这两个属性名。以及我们打印的NSLog中的内容,同时我们发现，我们可能定义的某些三方key或者appid在这里都暴露在外部。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">static const NSString *lw_constsecretKey &#x3D; @&quot;11234455556&quot;;<br></code></pre></td></tr></table></figure>

<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gi93d875bdj31r60imtgw.jpg"></p>
<h5 id="objc-methname"><a href="#objc-methname" class="headerlink" title="objc_methname"></a>objc_methname</h5><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gi91tzgretj31oq0j247e.jpg"></p>
<p>我们可以看到我们自定义的方法名<code>lw_publicMethod</code>,<code>lw_privateMethod</code>以及<code>lw_property</code>,<code>lw_publicproperty</code>重写的setter和getter方法。</p>
<h5 id="classname"><a href="#classname" class="headerlink" title="classname"></a>classname</h5><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gi91z90xhnj31og0fo43z.jpg"></p>
<p>我们可以看到我们自定义的类的类:<code>LWCustomClass</code></p>
<h4 id="DATA"><a href="#DATA" class="headerlink" title="_DATA"></a>_DATA</h4><p>__DATA段用于存储程序中所定义的数据，可读写。__DATA段下常见的sectin有：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gigtuycksmj30jo0pqgpu.jpg"></p>
<p>下面我们看下常见的__DATA下的section:</p>
<table>
<thead>
<tr>
<th>Section</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>__DATA.__data</td>
<td>初始化过的可变数据</td>
</tr>
<tr>
<td>__DATA.__la_symbol_ptr</td>
<td>lazy binding 的指针表，表中的指针一开始都指向 __stub_helper</td>
</tr>
<tr>
<td>__DATA.nl_symbol_ptr</td>
<td>非 lazy binding 的指针表，每个表项中的指针都指向一个在装载过程中，被动态链机器搜索完成的符号</td>
</tr>
<tr>
<td>__DATA.__const</td>
<td>没有初始化过的常量</td>
</tr>
<tr>
<td>__DATA.__cfstring</td>
<td>程序中使用的 Core Foundation 字符串（CFStringRefs）</td>
</tr>
<tr>
<td>__DATA.__bss</td>
<td>BSS，存放为初始化的全局变量，即常说的静态内存分配</td>
</tr>
<tr>
<td>__DATA.__common</td>
<td>没有初始化过的符号声明</td>
</tr>
<tr>
<td>__DATA.__objc_classlist</td>
<td>Objective-C 类列表</td>
</tr>
<tr>
<td>__DATA.__objc_protolist</td>
<td>Objective-C 协议列表</td>
</tr>
<tr>
<td>__DATA.__objc_imginfo</td>
<td>Objective-C 镜像信息</td>
</tr>
<tr>
<td>__DATA.__objc_selfrefs</td>
<td>Objective-C self 引用</td>
</tr>
<tr>
<td>__DATA.__objc_protorefs</td>
<td>Objective-C 原型引用</td>
</tr>
<tr>
<td>__DATA.__objc_superrefs</td>
<td>Objective-C 超类引用</td>
</tr>
</tbody></table>
<p>这些以objc开头的DATA字段都是跟runtime有关的，后面我们会详细分析。</p>
<h5 id="objc-imageinfo"><a href="#objc-imageinfo" class="headerlink" title="__objc_imageinfo"></a>__objc_imageinfo</h5><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gih51mnkp7j31n60s6agt.jpg"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">objc_image_info</span> &#123;</span><br>    <span class="hljs-keyword">uint32_t</span> version; <span class="hljs-comment">// currently 0</span><br>    <span class="hljs-keyword">uint32_t</span> flags;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> __cplusplus &gt;= 201103L</span><br>  <span class="hljs-keyword">private</span>:<br>  <span class="hljs-comment">// 位移枚举 </span><br>    <span class="hljs-keyword">enum</span> : <span class="hljs-keyword">uint32_t</span> &#123;<br>        IsReplacement       = <span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">0</span>,  <span class="hljs-comment">// used for Fix&amp;Continue, now ignored</span><br>        SupportsGC          = <span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">1</span>,  <span class="hljs-comment">// 是否支持垃圾回收</span><br>        RequiresGC          = <span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">2</span>,  <span class="hljs-comment">// 镜像是否需要回收</span><br>        OptimizedByDyld     = <span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">3</span>,  <span class="hljs-comment">// image is from an optimized shared cache</span><br>        CorrectedSynthesize = <span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">4</span>,  <span class="hljs-comment">// used for an old workaround, now ignored</span><br>        IsSimulated         = <span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">5</span>,  <span class="hljs-comment">// image compiled for a simulator platform</span><br>        HasCategoryClassProperties  = <span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">6</span>,  <span class="hljs-comment">// class properties in category_t</span><br><br>        SwiftVersionMaskShift = <span class="hljs-number">8</span>,<br>        SwiftVersionMask    = <span class="hljs-number">0xff</span> &lt;&lt; SwiftVersionMaskShift  <span class="hljs-comment">// Swift ABI version</span><br><br>    &#125;;<br>   <span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">enum</span> : <span class="hljs-keyword">uint32_t</span> &#123;<br>        SwiftVersion1   = <span class="hljs-number">1</span>,<br>        SwiftVersion1_2 = <span class="hljs-number">2</span>,<br>        SwiftVersion2   = <span class="hljs-number">3</span>,<br>        SwiftVersion3   = <span class="hljs-number">4</span><br>    &#125;;<br><br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isReplacement</span><span class="hljs-params">()</span>   <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> flags &amp; IsReplacement; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">supportsGC</span><span class="hljs-params">()</span>      <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> flags &amp; SupportsGC; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">requiresGC</span><span class="hljs-params">()</span>      <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> flags &amp; RequiresGC; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">optimizedByDyld</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> flags &amp; OptimizedByDyld; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">hasCategoryClassProperties</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> flags &amp; HasCategoryClassProperties; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">containsSwift</span><span class="hljs-params">()</span>   <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> (flags &amp; SwiftVersionMask) != <span class="hljs-number">0</span>; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">uint32_t</span> <span class="hljs-title">swiftVersion</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> (flags &amp; SwiftVersionMask) &gt;&gt; SwiftVersionMaskShift; &#125;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>&#125; objc_image_info;<br></code></pre></td></tr></table></figure>

<p>我们发现<code>objc_image_info</code>中主要是有version字段和flag字段，</p>
<h5 id="objc-classlist"><a href="#objc-classlist" class="headerlink" title="__objc_classlist"></a>__objc_classlist</h5><p>这个section列出了所有的class，包括meta class。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gih4x7u5ckj31pr0u01b9.jpg"></p>
<p>图中的value值是就是这个类结构体的地址(包括元类)，类结构体的结构为objc中的objc_class结构体，结构如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">struct</span> objc_class : objc_object &#123;<br>    <span class="hljs-comment">// Class ISA;</span><br>    Class superclass;<br>    cache_t cache;             <span class="hljs-comment">// formerly cache pointer and vtable</span><br>    class_data_bits_t bits;    <span class="hljs-comment">// class_rw_t * plus custom rr/alloc flags</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="objc-catlist"><a href="#objc-catlist" class="headerlink" title="__objc_catlist"></a>__objc_catlist</h5><p>这里可以查看代码中的所有分类，其value的值为指向分类结构体的指针</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gih63wv6xzj31mv0u04jn.jpg"></p>
<p>对应oc中的结构为category_t，具体结构如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">struct</span> category_t &#123;<br>    <span class="hljs-comment">// 是指 class_name 而不是 category_name</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name;<br>    <span class="hljs-comment">// 要扩展的类对象，编译期间是不会定义的，而是在运行时通过 * name 对应到对应的类对象。</span><br>    classref_t cls;<br>    <span class="hljs-comment">// 对象方法列表</span><br>    <span class="hljs-keyword">struct</span> method_list_t *instanceMethods;<br>    <span class="hljs-comment">// 类方法列表</span><br>    <span class="hljs-keyword">struct</span> method_list_t *classMethods;<br>    <span class="hljs-comment">// 协议列表</span><br>    <span class="hljs-keyword">struct</span> protocol_list_t *protocols;<br>    <span class="hljs-comment">// 实例属性</span><br>    <span class="hljs-keyword">struct</span> property_list_t *instanceProperties;<br>    <span class="hljs-comment">// Fields below this point are not always present on disk.</span><br>    <span class="hljs-comment">// 类属性(这个结构体以_开头命名？？？)</span><br>    <span class="hljs-keyword">struct</span> property_list_t *_classProperties;<br>    <span class="hljs-comment">// methodsForMeta 返回类方法列表或者对象方法列表</span><br>    method_list_t *methodsForMeta(<span class="hljs-keyword">bool</span> isMeta) &#123;<br>        <span class="hljs-keyword">if</span> (isMeta) <span class="hljs-keyword">return</span> classMethods;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> instanceMethods;<br>    &#125;<br>    <span class="hljs-comment">// 属性列表返回方法</span><br>    property_list_t *propertiesForMeta(<span class="hljs-keyword">bool</span> isMeta, <span class="hljs-keyword">struct</span> header_info *hi);<br>&#125;;<br></code></pre></td></tr></table></figure>

<h5 id="objc-protolist"><a href="#objc-protolist" class="headerlink" title="__objc_protolist"></a>__objc_protolist</h5><p>该Section中记录了项目中所有的协议。 其value值为指向协议的指针</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gih6ao4ee6j31nd0u01b2.jpg"></p>
<p>协议的结构体为protocol_t，具体如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><br><span class="hljs-keyword">struct</span> protocol_t : objc_object &#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *mangledName;<br>    <span class="hljs-keyword">struct</span> protocol_list_t *protocols;<br>    method_list_t *instanceMethods;<br>    method_list_t *classMethods;<br>    method_list_t *optionalInstanceMethods;<br>    method_list_t *optionalClassMethods;<br>    property_list_t *instanceProperties;<br>    uint32_t size;   <span class="hljs-comment">// sizeof(protocol_t)</span><br>    uint32_t flags;<br>    <span class="hljs-comment">// Fields below this point are not always present on disk.</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> **_extendedMethodTypes;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *_demangledName;<br>    property_list_t *_classProperties;<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="objc-classrefs"><a href="#objc-classrefs" class="headerlink" title="__objc_classrefs"></a>__objc_classrefs</h5><p>该section记录了哪些class被引用了，这里记录了所有被实例化的class，有些类虽然在包里，但是我们并未使用，因此这里不会有。<br><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gih6fqzemuj31rl0u0dyd.jpg"></p>
<h5 id="objc-selrefs"><a href="#objc-selrefs" class="headerlink" title="__objc_selrefs"></a>__objc_selrefs</h5><p>这section记录哪些SEL对应的字符串被引用了，有系统方法，也有自定义方法：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gih4rgf693j31lk0u07qb.jpg"></p>
<h5 id="objc-superrefs"><a href="#objc-superrefs" class="headerlink" title="__objc_superrefs"></a>__objc_superrefs</h5><p>该section记录了调用super方法的类。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gih6sbnruvj31uy0u04gr.jpg"></p>
<p>比如，在子类方法中，我们调用了父类的方法，就会将子类记录在这里。</p>
<h5 id="objc-const"><a href="#objc-const" class="headerlink" title="__objc_const"></a>__objc_const</h5><p>该section用来记录在OC内存初始化过程中的不可变内容。这里所谓的不可变内容并不是我们在程序中所写的const NSInteger k = 5这种常量数据（它存在__TEXT的const section中），而是在OC内存布局中不可变得部分。</p>
<h3 id="应用启动"><a href="#应用启动" class="headerlink" title="应用启动"></a>应用启动</h3><p>根据上面介绍的在应用启动期间，dyld和kern会读取Mach-O文件中的Load Command去读取和加载_DATA数据段下的内容，而这一切都发生在main函数之前。所以我们看下main函数之前都发生了什么？</p>
<h4 id="启动调用堆栈"><a href="#启动调用堆栈" class="headerlink" title="启动调用堆栈"></a>启动调用堆栈</h4><p>添加一个符号断点(Symbolic BreakPoint)让应用在执行到<code>_objc_init</code>方法是断点执行。<br><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gip6quvmz0j30yk0d6qnx.jpg"></p>
<p>这样我们就能看到下面的这个调用栈:</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gip6q2kpiwj30nw0le4oi.jpg"></p>
<p>因为<code>_objc_init</code>方法是runtime的入口，因此在这之前调用的方法都是dyld和ImageLoader的操作</p>
<h4 id="dyld"><a href="#dyld" class="headerlink" title="dyld"></a>dyld</h4><p>dyld(the dynamic link editor)动态链接器,系统 kernel 做好启动程序的初始准备后，交给 dyld 负责，dyld的主要工作内容为(参考<a href="https://www.mikeash.com/pyblog/friday-qa-2012-11-09-dyld-dynamic-linking-on-os-x.html"> dyld: Dynamic Linking On OS X </a>):</p>
<ul>
<li>从 kernel 留下的原始调用栈引导和启动自己</li>
<li>将程序依赖的动态链接库递归加载进内存，当然这里有缓存机制</li>
<li>non-lazy 符号立即 link 到可执行文件，lazy 的存表里</li>
<li>Runs static initializers for the executable</li>
<li>找到可执行文件的 main 函数，准备参数并调用</li>
<li>程序执行中负责绑定 lazy 符号、提供 runtime dynamic loading services、提供调试器接口</li>
<li>程序main函数 return 后执行 static terminator</li>
<li>某些场景下 main 函数结束后调 libSystem 的 _exit 函数</li>
</ul>
<h4 id="ImageLoader"><a href="#ImageLoader" class="headerlink" title="ImageLoader"></a>ImageLoader</h4><p>这里的image不是图片的意思，它是一个二进制文件，你可以把他理解为一个镜像文件。内部是被编译过的符号、代码等，因此<code>ImageLoader</code>作用是将这些文件加载进内存，且每一个文件对应一个<code>ImageLoader</code>实例来负责加载。</p>
<p>他的主要工作为：</p>
<ul>
<li>在程序运行时它先将动态链接的 image 递归加载 （也就是上面测试栈中一串的递归调用的时刻）</li>
<li>再从可执行文件 image 递归加载所有符号</li>
</ul>
<h4 id="ImageLoaderMachO"><a href="#ImageLoaderMachO" class="headerlink" title="ImageLoaderMachO"></a>ImageLoaderMachO</h4><p>顾名思义这里应该是去加载MachO文件，从堆栈中我们可以看到主要跟<code>doInitialization</code>方法和<code>doModInitFunctions</code>方法。</p>
<h5 id="doInitialization"><a href="#doInitialization" class="headerlink" title="doInitialization"></a>doInitialization</h5><p>这个方法的主要作用是：获取<code>Mach-O</code>的init方法的地址并调用</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">ImageLoaderMachO::doInitialization</span><span class="hljs-params">(<span class="hljs-keyword">const</span> LinkContext&amp; context)</span></span><br><span class="hljs-function"></span>&#123;<br>	CRSetCrashLogMessage2(<span class="hljs-keyword">this</span>-&gt;getPath());<br><br>	<span class="hljs-comment">// mach-o has -init and static initializers</span><br>	doImageInit(context);<br>	doModInitFunctions(context);<br>	<br>	CRSetCrashLogMessage2(<span class="hljs-literal">NULL</span>);<br>	<br>	<span class="hljs-keyword">return</span> (fHasDashInit || fHasInitializers);<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ImageLoaderMachO::doImageInit</span><span class="hljs-params">(<span class="hljs-keyword">const</span> LinkContext&amp; context)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">if</span> ( fHasDashInit ) &#123;<br>		<span class="hljs-comment">// mach-o文件中指令的个数</span><br>		<span class="hljs-keyword">const</span> <span class="hljs-keyword">uint32_t</span> cmd_count = ((macho_header*)fMachOData)-&gt;ncmds;<br>		<span class="hljs-comment">// 遍历指令</span><br>		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">uint32_t</span> i = <span class="hljs-number">0</span>; i &lt; cmd_count; ++i) &#123;<br>			<span class="hljs-keyword">switch</span> (cmd-&gt;cmd) &#123;<br>				<span class="hljs-keyword">case</span> LC_ROUTINES_COMMAND:<br>					<span class="hljs-comment">// 获取macho_routines_command的init_address</span><br>					Initializer func = (Initializer)(((struct macho_routines_command*)cmd)-&gt;init_address + fSlide);<br>					<span class="hljs-comment">// 执行-init方法</span><br>					func(context.argc, context.argv, context.envp, context.apple, &amp;context.programVars);<br>					<span class="hljs-keyword">break</span>;<br>			&#125;<br>			<span class="hljs-comment">// 计算下一个指令((char*)cmd)+cmd-&gt;cmdsize</span><br>			cmd = (<span class="hljs-keyword">const</span> struct load_command*)(((<span class="hljs-keyword">char</span>*)cmd)+cmd-&gt;cmdsize);<br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="doModInitFunctions"><a href="#doModInitFunctions" class="headerlink" title="doModInitFunctions"></a>doModInitFunctions</h5><p>这个方法的主要作用是：获取<code>Mach-O</code>的static initializer的地址并调用</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ImageLoaderMachO::doModInitFunctions</span><span class="hljs-params">(<span class="hljs-keyword">const</span> LinkContext&amp; context)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">if</span> ( fHasInitializers ) &#123;<br>	   <span class="hljs-comment">// mach-o文件中指令的个数</span><br>		<span class="hljs-keyword">const</span> <span class="hljs-keyword">uint32_t</span> cmd_count = ((macho_header*)fMachOData)-&gt;ncmds;<br>		<span class="hljs-comment">// 遍历所有的指令</span><br>		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">uint32_t</span> i = <span class="hljs-number">0</span>; i &lt; cmd_count; ++i) &#123;<br>		   <span class="hljs-comment">// 如果指令是Mach-o中的LC_SEGMENT_COMMAND</span><br>			<span class="hljs-keyword">if</span> ( cmd-&gt;cmd == LC_SEGMENT_COMMAND ) &#123;<br>			     <span class="hljs-comment">// 从sectionsStart到sectionsEnd</span><br>					<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> struct macho_section* sect=sectionsStart; sect &lt; sectionsEnd; ++sect) &#123;<br>					<span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> type = sect-&gt;flags &amp; SECTION_TYPE;<br>					<span class="hljs-keyword">if</span> ( type == S_MOD_INIT_FUNC_POINTERS ) &#123;<br>						<br>						<span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i=<span class="hljs-number">0</span>; i &lt; count; ++i) &#123;<br>							<span class="hljs-keyword">if</span> ( context.verboseInit )<br>								dyld::<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;dyld: calling initializer function %p in %s\n&quot;</span>, func, <span class="hljs-keyword">this</span>-&gt;getPath());<br>							<span class="hljs-comment">// 执行initializer方法</span><br>							func(context.argc, context.argv, context.envp, context.apple, &amp;context.programVars);<br>						&#125;<br>					&#125;<br>				&#125;<br>			&#125;<br>			<span class="hljs-comment">// 根据指令的地址+指令大小获取到下一个指令</span><br>			cmd = (<span class="hljs-keyword">const</span> struct load_command*)(((<span class="hljs-keyword">char</span>*)cmd)+cmd-&gt;cmdsize);<br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>


<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>上述我们介绍了Mach-O文件的主要结构，以及每个segment和section的功能和字段的作用，结尾处我们通过查看应用启动调用堆栈来确认Mach-O文件何时被ImageLoader解析并加载到内存中，提供给后续的runtime使用。鉴于main函数之前系统内核,dyld,ImageLoader,rumtime做了很多准备，我们决定新开一篇文章来讲述这个过程发生了什么，敬请期待！</p>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://opensource.apple.com/source/dyld/dyld-95.3/src/ImageLoaderMachO.cpp.auto.html">XNU源码</a><br><a href="http://hawk0620.github.io/blog/2018/03/22/study-mach-o-file/#%E5%A6%82%E4%BD%95%E7%94%A8%20MachO%20%E6%96%87%E4%BB%B6%E5%85%B3%E8%81%94%E7%B1%BB%E7%9A%84%E6%96%B9%E6%B3%95%E5%90%8D">探秘 Mach-O 文件</a><br><a href="https://jianli2017.top/wiki/IOS/MachO/MachO_FileStructure/">Mach-O文件结构理解</a><br><a href="https://zhangbuhuai.com/post/macho-dynamic-link.html">Mach-O 与动态链接</a><br><a href="https://blog.sunnyxx.com/2014/08/30/objc-pre-main/">iOS 程序 main 函数之前发生了什么</a></p>
]]></content>
      <categories>
        <category>iOS高级开发</category>
      </categories>
      <tags>
        <tag>Mach-O 加载器</tag>
      </tags>
  </entry>
  <entry>
    <title>SDWebImage - 图片下载</title>
    <url>/2016/01/27/SDWebImage-2/</url>
    <content><![CDATA[<p>本文是系列文章《SDWebImage源码解析》中的图片下载部分，本文详细的介绍了SDWebImage在图片下载过程中所做的一些处理和对于下载操作的管理。</p>
<a id="more"></a>


<h3 id="外层方法调用"><a href="#外层方法调用" class="headerlink" title="外层方法调用"></a>外层方法调用</h3><h4 id="最外层方法的调用"><a href="#最外层方法的调用" class="headerlink" title="最外层方法的调用"></a>最外层方法的调用</h4><p>首先，看一下使用SD进行图片下载时，调用的代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">[cell.imageView sd_setImageWithURL:<br>			[NSURL URLWithString:<br>						[_objects objectAtIndex:indexPath.row]]<br>            placeholderImage:[UIImage imageNamed:@&quot;placeholder&quot;] <br>            options:indexPath.row &#x3D;&#x3D; 0 ?<br>				SDWebImageRefreshCached : 0];<br><br></code></pre></td></tr></table></figure>
<p>很简单，需要的参数只有URL、placeholderImage和options三个,从字面的意思就可以看到<br>URL:要下载图片的URL<br>placeholderImage：要显示的占位图<br>options:下载时候的一些条件设置</p>
<h4 id="非必要参数的包装"><a href="#非必要参数的包装" class="headerlink" title="非必要参数的包装"></a>非必要参数的包装</h4><p>方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">- (void)sd_setImageWithURL:(NSURL *)url placeholderImage:(UIImage *)placeholder options:(SDWebImageOptions)options progress:(SDWebImageDownloaderProgressBlock)progressBlock completed:(SDWebImageCompletionBlock)completedBlock<br><br></code></pre></td></tr></table></figure>
<p>在最外面调用的基础上增加了两个参数<br>progress:下载进度跟进的回调<br>completed:下载完成的进度的回调</p>
<p>下面从这个方法开始，对于图片的下载过程做一个详细的分析</p>
<h3 id="开始下载操作（包括缓存的查找）"><a href="#开始下载操作（包括缓存的查找）" class="headerlink" title="开始下载操作（包括缓存的查找）"></a>开始下载操作（包括缓存的查找）</h3><h4 id="取消现有的图片的下载："><a href="#取消现有的图片的下载：" class="headerlink" title="取消现有的图片的下载："></a>取消现有的图片的下载：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">[self sd_cancelCurrentImageLoad];<br><br></code></pre></td></tr></table></figure>
<p>看一下具体实现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">- (void)sd_cancelImageLoadOperationWithKey:(NSString *)key &#123;<br>    &#x2F;&#x2F; 取消下载队列中正在进行的操作 这个方法后面会介绍<br>    NSMutableDictionary *operationDictionary &#x3D; <br>    								[self operationDictionary];<br>    &#x2F;&#x2F;防止重复下载							<br>    id operations &#x3D; [operationDictionary objectForKey:key];<br>    <br>    if (operations) &#123;<br>        if ([operations isKindOfClass:[NSArray class]]) &#123;<br>            for (id &lt;SDWebImageOperation&gt; operation<br>                                               in operations)<br>             &#123;<br>                if (operation) &#123;<br>                    [operation cancel];<br>                &#125;<br>            &#125;<br>        &#125; else if ([operations  conformsToProtocol:<br>        						@protocol(SDWebImageOperation)])<br>        &#123;<br>            [(id&lt;SDWebImageOperation&gt;) operations cancel];<br>        &#125;<br>        &#x2F;&#x2F;将这个任务移除<br>        [operationDictionary removeObjectForKey:key];<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>这个方法是在每一次图片下载开始之前，如果存在正在下载的任务，那么现将这个任务取消，目的是为了防止重复下载。</p>
<p>获取当前的操作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">- (NSMutableDictionary *)operationDictionary &#123;<br>    NSMutableDictionary *operations &#x3D; <br>    		objc_getAssociatedObject(self, &amp;loadOperationKey);<br>    		<br>    if (operations) &#123;<br>        return operations;<br>    &#125;<br>    <br>    operations &#x3D; [NSMutableDictionary dictionary];<br>    <br>    objc_setAssociatedObject(self, &amp;loadOperationKey,<br>    		 operations, OBJC_ASSOCIATION_RETAIN_NONATOMIC);<br>    		 <br>    return operations;<br>&#125;<br><br></code></pre></td></tr></table></figure>


<p><code>问题</code>：这里为啥非要operations是一个遵守的SDWebImageOperation的对象？</p>
<p><font color = red>这里希望大家指导一下</font></p>
<p><code>问题</code>:operations对象什么情况下会是一个数组？</p>
<p><font color = red>这里希望大家指导一下</font></p>
<p><code>问题：</code></p>
<p>每次下载之前，都把原来的下载给暂停了，是不是以为这一次只能下载一张图片？</p>
<p>解答：并不是这样的，这个方法首先是写在了UIView的分类中的，每一个UIView以及他的子类（UIButton或者UIImageView）都拥有一个operationDictionary，每次之前取消，可以理解为一个UIImageview保证对应一个URL</p>
<p>与取消对应的添加操作：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">- (void)sd_setImageLoadOperation:(id)operation forKey:(NSString *)key &#123;<br>    [self sd_cancelImageLoadOperationWithKey:key];<br>    NSMutableDictionary *operationDictionary &#x3D; [self <br>    									operationDictionary];<br>    [operationDictionary setObject:operation forKey:key];<br>&#125;<br></code></pre></td></tr></table></figure>


<h4 id="占位图片的设置"><a href="#占位图片的设置" class="headerlink" title="占位图片的设置"></a>占位图片的设置</h4><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">if (!(options &amp; SDWebImageDelayPlaceholder)) &#123;<br>    dispatch_main_async_safe(^&#123;<br>        self.image &#x3D; placeholder;<br>    &#125;);<br>&#125;<br><br>&#x2F;**<br> * By default, placeholder images are loaded while the image is loading. This flag will delay the loading<br> * of the placeholder image until after the image has finished loading.<br> *&#x2F;<br>&#x2F;&#x2F;默认情况，占位图片在图片加载过程中会显示<br>&#x2F;&#x2F;如果设置了这个属性，将会延迟占位图片的加载时间（图片加载完成之后）<br><br>SDWebImageDelayPlaceholder &#x3D; 1 &lt;&lt; 9,<br>主要是设置占位图片显示的时机<br><br></code></pre></td></tr></table></figure>

<p>如果没有设置为SDWebImageDelayPlaceholder那么立即设置图片的占位图，那么如果设置了SDWebImageDelayPlaceholder这个属性之后什么时间设置占位图片呢</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">if ((options &amp; SDWebImageDelayPlaceholder)) &#123;<br>     wself.image &#x3D; placeholder;<br>     [wself setNeedsLayout];<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>在图片下载完成之后，如果下载失败image = nil 时，会将占位图片设置</p>
<p>占位图片设置完成后，就开始了图片的加载，也就是本片文章的重头戏，图片缓存中查找或者图片的下载</p>
<h4 id="创建一个新的下载操作"><a href="#创建一个新的下载操作" class="headerlink" title="创建一个新的下载操作"></a>创建一个新的下载操作</h4><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">id &lt;SDWebImageOperation&gt; operation &#x3D; 			<br>		[SDWebImageManager.sharedManager downloadImageWithURL:url <br>		options:options <br>		progress:progressBlock <br>		completed:^(UIImage *image, NSError *error, <br>					SDImageCacheType cacheType, <br>					BOOL finished, NSURL *imageURL)<br><br></code></pre></td></tr></table></figure>
<p>创建一个新的下载操作，并将下载操作添加到下载队列中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&#x2F;&#x2F;添加到下载队列中<br>[self sd_setImageLoadOperation:operation <br>							forKey:@&quot;UIImageViewImageLoad&quot;];<br><br></code></pre></td></tr></table></figure>

<p>下面的代码是在</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">id &lt;SDWebImageOperation&gt; operation &#x3D;<br>	 	[SDWebImageManager.sharedManager 		<br>	 					downloadImageWithURL:url <br>	 					options:options<br>	 					progress:progressBlock <br>	 					completed:^(UIImage *image, NSError<br>	 					 *error, SDImageCacheType cacheType, BOOL<br>	 					 finished, NSURL *imageURL)<br>&#123;<br>	&#x2F;&#x2F;图片下载完成之后的操作<br>&#125;);<br><br></code></pre></td></tr></table></figure>

<h4 id="操作的执行"><a href="#操作的执行" class="headerlink" title="操作的执行"></a>操作的执行</h4><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&#x2F;**<br> * 如果缓存中没有给定URL对应的图片，下载这张图片，否则返回缓存的图片<br> *<br> * @param url            要下载图片的URL<br> * @param options        图片下载的request的选项设置<br> * @param progressBlock  下载进度监听的回调<br> * @param completedBlock 下载完成的回调（必要的参数不可为nil）<br> *<br> *   completedBlock<br> *   <br> *&#x2F;<br>	当使用SDWebImageProgressiveDownload时，参数finished被设置为NO，图片下载的过程中这个回调将会被调用很多次返回的是一个部分图片，当图片完整下载完成的时候这个回调会在最后调用一下，设置一个完整的图片，同事将参数finished设置为YES<br><br>- (id &lt;SDWebImageOperation&gt;)downloadImageWithURL:(NSURL *)url<br>                                         options:(SDWebImageOptions)options<br>                                        progress:(SDWebImageDownloaderProgressBlock)progressBlock<br>                                       completed:(SDWebImageCompletionWithFinishedBlock)completedBlock;<br><br></code></pre></td></tr></table></figure>

<p>两个补充的参数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">completedBlock的类型<br><br>typedef void(^SDWebImageCompletionWithFinishedBlock)<br> 				(UIImage *image, NSError *error, <br> 				SDImageCacheType cacheType,<br> 	 			BOOL finished, NSURL *imageURL);<br><br>SDImageCacheType类型：<br><br>	typedef NS_ENUM(NSInteger, SDImageCacheType) &#123;<br>    &#x2F;**<br>     * The image wasn&#39;t available the SDWebImage caches, but was<br>     	 downloaded from the web.<br>     *&#x2F;<br>    SDImageCacheTypeNone,<br>    &#x2F;**<br>     * The image was obtained from the disk cache.<br>     *&#x2F;<br>    SDImageCacheTypeDisk,<br>    &#x2F;**<br>     * The image was obtained from the memory cache.<br>     *&#x2F;<br>    SDImageCacheTypeMemory<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h4 id="必要的参数completedBlock"><a href="#必要的参数completedBlock" class="headerlink" title="必要的参数completedBlock"></a>必要的参数completedBlock</h4><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&#x2F;&#x2F; Invoking this method without a completedBlock is <br>	pointless<br>NSAssert(completedBlock !&#x3D; nil,<br>		 @&quot;If you mean to prefetch the image, use -<br>		 [SDWebImagePrefetcher prefetchURLs] instead&quot;);<br><br></code></pre></td></tr></table></figure>
<p>如果传入的completedBlock是nil,将会报错！！！！！<br>解释：如果没有completedBlock，将没办法给imageview设置图片，所以下面的代码就没有意义了</p>
<p><a href="http://www.cnblogs.com/moondark/archive/2012/03/12/2392315.html">断言学习入门</a></p>
<h4 id="对URL做特殊处理"><a href="#对URL做特殊处理" class="headerlink" title="对URL做特殊处理"></a>对URL做特殊处理</h4><p>由于在某些时候，出于某些特殊的原因，Xcode不会对这里的类型匹配做出警告的提示，所以作者在这里增加了一个容错处理，允许这里传递一个字符串类型的URL</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">if ([url isKindOfClass:NSString.class]) &#123;<br>    url &#x3D; [NSURL URLWithString:(NSString *)url];<br>&#125;<br><br>&#x2F;&#x2F; Prevents app crashing on argument type error like sending NSNull instead of NSURL<br>if (![url isKindOfClass:NSURL.class]) &#123;<br>    url &#x3D; nil;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h4 id="再次新建一个操作"><a href="#再次新建一个操作" class="headerlink" title="再次新建一个操作"></a>再次新建一个操作</h4><p> 新建了一个SDWebImageCombinedOperation对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">__block SDWebImageCombinedOperation *operation &#x3D; <br>    				[SDWebImageCombinedOperation new];<br>    				<br>__weak SDWebImageCombinedOperation *weakOperation &#x3D; operation;<br><br></code></pre></td></tr></table></figure>

<p>这里看一下SDWebImageCombinedOperation:这是一个遵守了SDWebImageOperation协议的对象继承自NSObject，包含了一个属性cacheOperation为NSOperation类型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">@interface SDWebImageCombinedOperation : NSObject <br>										&lt;SDWebImageOperation&gt;<br><br>@property (assign, nonatomic, getter &#x3D; isCancelled) BOOL <br>												     cancelled;<br>												     <br>@property (copy, nonatomic) SDWebImageNoParamsBlock cancelBlock;<br><br>@property (strong, nonatomic) NSOperation *cacheOperation;<br><br>@end<br><br></code></pre></td></tr></table></figure>

<p><code>注意</code>：downloadImageWithURL返回的这个id类型（遵守SDWebImageOperation协议）的对象</p>
<h4 id="黑名单处理"><a href="#黑名单处理" class="headerlink" title="黑名单处理"></a>黑名单处理</h4><p>判断当前要下载的图片的URL是否存在于黑名单中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">BOOL isFailedUrl &#x3D; NO;<br>  @synchronized (self.failedURLs) &#123;<br>      isFailedUrl &#x3D; [self.failedURLs containsObject:url];<br>  &#125;<br><br></code></pre></td></tr></table></figure>

<h4 id="URL是否合法"><a href="#URL是否合法" class="headerlink" title="URL是否合法"></a>URL是否合法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">if (url.absoluteString.length &#x3D;&#x3D; 0 <br>				|| (!(options &amp; SDWebImageRetryFailed)<br> 				&amp;&amp; isFailedUrl)) <br>&#123;<br>    dispatch_main_sync_safe(^&#123;<br>        NSError *error &#x3D; [NSError <br>        	errorWithDomain:NSURLErrorDomain <br>        	code:NSURLErrorFileDoesNotExist <br>        	userInfo:nil];<br>        completedBlock(nil, error, SDImageCacheTypeNone, YES, url);<br>    &#125;);<br>    return operation;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p><a href="http://blog.sina.com.cn/s/blog_71715bf801019ymq.html">如何自定义错误</a></p>
<h4 id="将操作添加到正在进行的队列中"><a href="#将操作添加到正在进行的队列中" class="headerlink" title="将操作添加到正在进行的队列中"></a>将操作添加到正在进行的队列中</h4><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">@synchronized (self.runningOperations) &#123;<br>    [self.runningOperations addObject:operation];<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p><code>@synchronized</code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">　　@synchronized，代表这个方法加锁, 相当于不管哪一个线程（例如线程A），运行到这个方法时,都要检查有没有其它线程例如B正在用这个方法，有的话要等正在使用synchronized方法的线程B运行完这个方法后再运行此线程A,没有的话,直接运行。它包括两种用法：synchronized 方法和 synchronized 块。<br><br>@synchronized 方法控制对类（一般在IOS中用在单例中）的访问：每个类实例对应一把锁，每个 synchronized 方法都必须获得调用该方法锁方能执行，否则所属就会发生线程阻塞，方法一旦执行，就独占该锁，直到从该方法返回时才将锁释放，此后被阻塞的线程方能获得该锁，重新进入可执行状态。这种机制确保了同一时刻对于每一个类，至多只有一个处于可执行状态，从而有效避免了类成员变量的访问冲突（只要所有可能访问类的方法均被声明为 synchronized）<br><br></code></pre></td></tr></table></figure>

<h4 id="获取cachekey"><a href="#获取cachekey" class="headerlink" title="获取cachekey"></a>获取cachekey</h4><p>NSString *key = [self cacheKeyForURL:url];</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">- (NSString *)cacheKeyForURL:(NSURL *)url &#123;<br>    if (self.cacheKeyFilter) &#123;<br>        return self.cacheKeyFilter(url);<br>    &#125;<br>    else &#123;<br>        return [url absoluteString];<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p><code>self.cacheKeyFilter</code>是什么东西?</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&#x2F;&#x2F;cache filter 在SDWebImageManager每次将URL转换为cache key的时候调用，功能是去掉图片URL中的动态部分<br>[[SDWebImageManager sharedManager] setCacheKeyFilter:^(NSURL *url) &#123;<br>    url &#x3D; [[NSURL alloc] initWithScheme:url.scheme host:url.host path:url.path];<br>    return [url absoluteString];<br>&#125;];<br><br> * @endcode<br> *&#x2F;<br> <br> @property (nonatomic, copy) SDWebImageCacheKeyFilterBlock cacheKeyFilter;<br><br></code></pre></td></tr></table></figure>
<p>cache filter 是一个SDWebImageManager每次需要讲一个URL转换为cachekey时会调用的一个方法，用来去掉图片URL中的动态部分</p>
<h4 id="图片缓存"><a href="#图片缓存" class="headerlink" title="图片缓存"></a>图片缓存</h4><p>查找这张图片有没有被缓存过，具体的缓存查找策略会在后面单独写一篇文章</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">- (NSOperation *)queryDiskCacheForKey:(NSString *)key done:(SDWebImageQueryCompletedBlock)doneBlock<br><br></code></pre></td></tr></table></figure>

<h4 id="图片下载"><a href="#图片下载" class="headerlink" title="图片下载"></a>图片下载</h4><p><code>下面就开始了正式的“下载” 根据第一部分的介绍，我们知道，在每次下载之前，我们都会先去缓存中查找一下，看是否存在，所以这里可以先跳到缓存看一下</code></p>
<p>如果，这张图片没有被缓存过，那么就要开始下载这张图片</p>
<h4 id="图片要从网络获取的条件"><a href="#图片要从网络获取的条件" class="headerlink" title="图片要从网络获取的条件"></a>图片要从网络获取的条件</h4><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">if (operation.isCancelled) &#123;<br>    @synchronized (self.runningOperations) &#123;<br>    	[self.runningOperations removeObject:operation];<br>    &#125;<br><br>    return;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>这里的operation是一个SDWebImageCombinedOperation，具体内容跟上面的那个差不多，就不赘述了</p>
<h4 id="图片下载的条件"><a href="#图片下载的条件" class="headerlink" title="图片下载的条件"></a>图片下载的条件</h4><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">if ((!image || options &amp; SDWebImageRefreshCached) <br>&amp;&amp; (![self.delegate respondsToSelector:<br>			@selector(imageManager:shouldDownloadImageForURL:)] || [self.delegate imageManager:self <br>			shouldDownloadImageForURL:url]))<br><br></code></pre></td></tr></table></figure>
<p>下面来好好分析一下这个条件：<br>!image 图片存在 即缓存中没有找到<br>options &amp; SDWebImageRefreshCached:图片找到了是否需要跟新缓存（重新下载）</p>
<p>是否实现了imageManager:shouldDownloadImageForURL:方法<br>[self.delegate respondsToSelector:<br>            @selector(imageManager:shouldDownloadImageForURL:)<br>如果实现了 就执行这个方法<br>[self.delegate imageManager:self shouldDownloadImageForURL:url]</p>
<h5 id="小插曲"><a href="#小插曲" class="headerlink" title="小插曲"></a>小插曲</h5><p>imageManager:shouldDownloadImageForURL:是干啥的？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&#x2F;**<br> * Controls which image should be downloaded when the image is not found in the cache.<br> *<br> * @param imageManager The current &#96;SDWebImageManager&#96;<br> * @param imageURL     The url of the image to be downloaded<br> *<br> * @return Return NO to prevent the downloading of the image on cache misses. If not implemented, YES is implied.<br> *&#x2F;<br> &#x2F;&#x2F;当缓存中图片不存在的时候，用这个方法来判断是否需要下载这张图片<br> &#x2F;&#x2F;返回NO来阻止图片的下载，如果没实现默认返回yes（始终下载）<br>- (BOOL)imageManager:(SDWebImageManager *)imageManager shouldDownloadImageForURL:(NSURL *)imageURL;<br><br></code></pre></td></tr></table></figure>

<p>这里 我们队这整个的判断做一下分析：<br>如果图片没有缓存或者需要更新缓存 || 如果没实现代理方法则下载，实现代理方法则根据代理方法的返回值进行判断</p>
<p>判断好条件，接下来我们继续看</p>
<h4 id="是否需要更新缓存"><a href="#是否需要更新缓存" class="headerlink" title="是否需要更新缓存"></a>是否需要更新缓存</h4><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">if (image &amp;&amp; options &amp; SDWebImageRefreshCached) &#123;<br>   dispatch_main_sync_safe(^&#123;<br>		&#x2F;&#x2F;缓存中已经有这张图片了，但是因为要更新缓存，所以会有重新下载<br>		&#x2F;&#x2F;这样是NSURLCache有机会从服务器端刷新自身缓存。<br>       completedBlock(image, nil, cacheType, YES, url);<br>   &#125;);<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>如果缓存中有这张图片，但是用户设置了需要更新缓存，那么因为已经有这种图片了，所以直接调用completedBlock去显示图片，同时也会继续往后走去下载图片来更新缓存</p>
<h4 id="图片下载的参数设置"><a href="#图片下载的参数设置" class="headerlink" title="图片下载的参数设置"></a>图片下载的参数设置</h4><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">if (options &amp; SDWebImageProgressiveDownload) <br>downloaderOptions |&#x3D; SDWebImageDownloaderProgressiveDownload;<br><br>if (options &amp; SDWebImageRefreshCached)<br> downloaderOptions |&#x3D; SDWebImageDownloaderUseNSURLCache;<br> <br>if (options &amp; SDWebImageContinueInBackground)<br> downloaderOptions |&#x3D; SDWebImageDownloaderContinueInBackground;<br> <br>if (options &amp; SDWebImageHandleCookies)<br> downloaderOptions |&#x3D; SDWebImageDownloaderHandleCookies;<br> <br>if (options &amp; SDWebImageAllowInvalidSSLCertificates) <br>	downloaderOptions |&#x3D; 		<br>			SDWebImageDownloaderAllowInvalidSSLCertificates;<br>			<br>if (options &amp; SDWebImageHighPriority) <br>		downloaderOptions |&#x3D; SDWebImageDownloaderHighPriority;<br>		<br>if (image &amp;&amp; options &amp; SDWebImageRefreshCached) &#123;<br>     &#x2F;&#x2F;如果设置了SDWebImageRefreshCached就不能设置SDWebImageDownloaderProgressiveDownload属性，因为，SDWebImageRefreshCached说明缓存中存在了，图片会理解执行completion方法<br>     downloaderOptions &amp;&#x3D; <br>     					~SDWebImageDownloaderProgressiveDownload;<br><br>     &#x2F;&#x2F;如果图片下载设置了SDWebImageRefreshCached就必须设置SDWebImageDownloaderIgnoreCachedResponse 为了保证更新NSURLCache<br>     downloaderOptions |&#x3D; <br>     			SDWebImageDownloaderIgnoreCachedResponse;<br>&#125;<br>            <br><br></code></pre></td></tr></table></figure>

<h4 id="开始下载"><a href="#开始下载" class="headerlink" title="开始下载"></a>开始下载</h4><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">id &lt;SDWebImageOperation&gt; subOperation &#x3D; [self.imageDownloader downloadImageWithURL:url options:downloaderOptions progress:progressBlock completed:^(UIImage *downloadedImage, NSData *data, NSError *error, BOOL finished)<br><br></code></pre></td></tr></table></figure>
<p>这里又新起了一个遵守SDWebImageOperation协议的subOperation</p>
<p>下面，我们到这个方法里面去看一下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">__block SDWebImageDownloaderOperation *operation;<br>__weak __typeof(self)wself &#x3D; self;<br><br></code></pre></td></tr></table></figure>
<p>这里创建的operation是我们图片下载的主力SDWebImageDownloaderOperation</p>
<h4 id="添加进度监听"><a href="#添加进度监听" class="headerlink" title="添加进度监听"></a>添加进度监听</h4><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">  - (void)addProgressCallback:(SDWebImageDownloaderProgressBlock)progressBlock completedBlock:(SDWebImageDownloaderCompletedBlock)completedBlock forURL:(NSURL *)url createCallback:(SDWebImageNoParamsBlock)createCallback &#123;<br>    &#x2F;&#x2F;URL不能为nil，因为在URLCallbacks中URL要作为key值，所以URL不可以为nil,如果为nil那么立即调用completedBlock返回土片数据为nil<br>    if (url &#x3D;&#x3D; nil) &#123;<br>        if (completedBlock !&#x3D; nil) &#123;<br>            completedBlock(nil, nil, nil, NO);<br>        &#125;<br>        return;<br>    &#125;<br>	<br>	&#x2F;&#x2F;一个图片的下载progressBlock可能会被执行很多次，而且很多次的执行可能并不是在同一个线程中，所以这里使用一个数组来保存<br>    dispatch_barrier_sync(self.barrierQueue, ^&#123;<br>        BOOL first &#x3D; NO;<br>        &#x2F;&#x2F;数组保存<br>        if (!self.URLCallbacks[url]) &#123;<br>            self.URLCallbacks[url] &#x3D; [NSMutableArray new];<br>            first &#x3D; YES;<br>        &#125;<br><br>        NSMutableArray *callbacksForURL &#x3D; <br>        							self.URLCallbacks[url];<br>        NSMutableDictionary *callbacks &#x3D;<br>        						 [NSMutableDictionary new];<br>        						 <br>        if (progressBlock)<br>         callbacks[kProgressCallbackKey] &#x3D; [progressBlock copy];<br>         <br>        if (completedBlock)<br>       callbacks[kCompletedCallbackKey] &#x3D; [completedBlock copy];<br>       <br>        [callbacksForURL addObject:callbacks];<br>        self.URLCallbacks[url] &#x3D; callbacksForURL;<br>		&#x2F;&#x2F;每张图片只有在第一次回调的时候会执行createCallback（）；<br>        if (first) &#123;<br>            createCallback();<br>        &#125;<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>可以通过下面这张图片来了解结构层次：<br><img src="http://images2015.cnblogs.com/blog/715314/201512/715314-20151204161948408-1934962430.png" alt="层次结构"></p>
<p><code>问题</code>：</p>
<p>同一个URL,为什么在self.URLCallbacks中对应的是一个数组？有没有可能会造成控件的浪费？<br>解答：暂时还不太清楚 先往后面看看</p>
<h4 id="createCallback回调内容"><a href="#createCallback回调内容" class="headerlink" title="createCallback回调内容"></a>createCallback回调内容</h4><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">NSTimeInterval timeoutInterval &#x3D; wself.downloadTimeout;<br>if (timeoutInterval &#x3D;&#x3D; 0.0) &#123;<br>     timeoutInterval &#x3D; 15.0;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>如果用户没有主动设置下载超时timeoutInterval，则默认为15</p>
<h5 id="创建图片下载的请求"><a href="#创建图片下载的请求" class="headerlink" title="创建图片下载的请求"></a>创建图片下载的请求</h5><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">NSMutableURLRequest *request &#x3D; [[NSMutableURLRequest alloc] <br>					initWithURL:url<br> 					cachePolicy:<br> 				  (options &amp; SDWebImageDownloaderUseNSURLCache ?<br>					NSURLRequestUseProtocolCachePolicy : <br>					NSURLRequestReloadIgnoringLocalCacheData) <br>					timeoutInterval:timeoutInterval];<br> 				  <br></code></pre></td></tr></table></figure>
<p>这里主要是设置了缓存策略和超时的时长，其中缓存策略：<br>options &amp; SDWebImageDownloaderUseNSURLCache ?<br>                    NSURLRequestUseProtocolCachePolicy :<br>                    NSURLRequestReloadIgnoringLocalCacheData</p>
<p>是否设置了SDWebImageDownloaderUseNSURLCache属性，并根据这个属性的设置设置NSURLRequest的缓存策略</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&#x2F;&#x2F;默认情况下不使用NSURLCache，可以通过设置这个属性使用NSURLCache<br> SDWebImageDownloaderUseNSURLCache &#x3D; 1 &lt;&lt; 2,<br><br></code></pre></td></tr></table></figure>

<p>三种策略关系的简述：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">SDWebImageDownloaderUseNSURLCache：在SDWebImage中，缺省情况下，request是不使用NSURLCache的，但是若使用该选项，就默认使用NSURLCache默认的缓存策略：NSURLRequestUseProtocolCachePolicy。<br><br>NSURLRequestUseProtocolCachePolicy：对特定的 URL 请求使用网络协议（如HTTP）中实现的缓存逻辑。这是默认的策略。该策略表示如果缓存不存在，直接从服务端获取。<br>如果缓存存在，会根据response中的Cache-Control字段判断 下一步操作，如: Cache-Control字段为must-revalidata, 则 询问服务端该数据是否有更新，无更新话 直接返回给用户缓存数据，若已更新，则请求服务端.<br>NSURLRequestReloadIgnoringLocalCacheData：数据需要从原始地址(一般就是重新从服务器获取)加载。不使用现有缓存<br><br></code></pre></td></tr></table></figure>



<h5 id="请求的其他参数设置"><a href="#请求的其他参数设置" class="headerlink" title="请求的其他参数设置"></a>请求的其他参数设置</h5><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">request.HTTPShouldHandleCookies &#x3D; (options &amp;<br>						 SDWebImageDownloaderHandleCookies);<br><br></code></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&#x2F;&#x2F; 如果设置HTTPShouldHandleCookies为YES，就处理存储在<br>	NSHTTPCookieStore中的cookies。<br>&#x2F;&#x2F; HTTPShouldHandleCookies表示是否应该给request设置cookie并随<br>	request一起发送出去。<br>   SDWebImageDownloaderHandleCookies &#x3D; 1 &lt;&lt; 5,<br><br></code></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&#x2F;&#x2F; HTTPShouldUsePipelining表示receiver(理解为iOS客户端)的下一个信息是否必须等到上一个请求回复才能发送。<br>&#x2F;&#x2F; 如果为YES表示可以，NO表示必须等receiver收到先前的回复才能发送下个信息。<br><br>request.HTTPShouldUsePipelining &#x3D; YES;<br></code></pre></td></tr></table></figure>

<h5 id="Header的设置"><a href="#Header的设置" class="headerlink" title="Header的设置"></a>Header的设置</h5><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">if (wself.headersFilter) &#123;<br>    request.allHTTPHeaderFields &#x3D; wself.headersFilter(url,<br>    								 [wself.HTTPHeaders copy]);<br>  &#125; else &#123;<br>            request.allHTTPHeaderFields &#x3D; wself.HTTPHeaders;<br>        &#125;<br><br></code></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"> &#x2F;&#x2F;设置一个过滤器来设置每一个下载图片的HTTP请求的请求头<br> &#x2F;&#x2F;这个代码块在每一个图片的下载请求中都会被调用，返回一个可以用作HTTP请求header的字典<br>@property (nonatomic, copy) <br>		SDWebImageDownloaderHeadersFilterBlock headersFilter;<br><br></code></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&#x2F;&#x2F; 简单看下HTTPHeader的初始化部分（如果下载webp图片，需要的header不一样）：<br>&#x2F;&#x2F; #ifdef SD_WEBP<br>&#x2F;&#x2F; _HTTPHeaders &#x3D; [@&#123;@&quot;Accept&quot;: @&quot;image&#x2F;webp,image&#x2F;*;q&#x3D;0.8&quot;&#125; <br>	mutableCopy];<br>&#x2F;&#x2F; #else<br>&#x2F;&#x2F; _HTTPHeaders &#x3D; [@&#123;@&quot;Accept&quot;: @&quot;image&#x2F;*;q&#x3D;0.8&quot;&#125; mutableCopy];<br>&#x2F;&#x2F; #endif<br><br></code></pre></td></tr></table></figure>

<h5 id="图片下载完成后是否需要解码"><a href="#图片下载完成后是否需要解码" class="headerlink" title="图片下载完成后是否需要解码"></a>图片下载完成后是否需要解码</h5><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">shouldDecompressImages:图片下载完成是否需要解码<br><br></code></pre></td></tr></table></figure>
<p><code>注意</code>：解压缩已经下载的图片或者在缓存中的图片，可以提高性能，但是会耗费很多空间，缺省情况下是要解压缩图片。</p>
<h5 id="身份验证"><a href="#身份验证" class="headerlink" title="身份验证"></a>身份验证</h5><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br>urlCredential:<br><br>	web 服务可以在返回 http 响应时附带认证要求的challenge，作用是询问 http 请求的发起方是谁，这时发起方应提供正确的用户名和密码（即认证信息），然后 web 服务才会返回真正的 http 响应。<br><br>	收到认证要求时，NSURLConnection 的委托对象会收到相应的消息并得到一个 NSURLAuthenticationChallenge 实例。该实例的发送方遵守 <br>	<br>	NSURLAuthenticationChallengeSender 协议。为了继续收到真实的数据，需要向该发送方向发回一个 NSURLCredential 实例<br><br>if (wself.urlCredential) &#123;<br>     operation.credential &#x3D; wself.urlCredential;<br>&#125; else if (wself.username &amp;&amp; wself.password) &#123;<br>     operation.credential &#x3D; [NSURLCredential <br>     						credentialWithUser:wself.username<br>      								   password:wself.password 			persistence:NSURLCredentialPersistenceForSession];<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>NSURLCredentialPersistenceForSession表示在应用终止时，丢弃相应的 credential 。</p>
<p><a href="http://blog.csdn.net/majiakun1/article/details/17013379">urlCredential详情参考这里</a></p>
<h5 id="下载的优先级"><a href="#下载的优先级" class="headerlink" title="下载的优先级"></a>下载的优先级</h5><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">if (options &amp; SDWebImageDownloaderHighPriority) &#123;<br>    operation.queuePriority &#x3D; NSOperationQueuePriorityHigh;<br>  &#125; else if (options &amp; SDWebImageDownloaderLowPriority) &#123;<br>    operation.queuePriority &#x3D; NSOperationQueuePriorityLow;<br>  &#125;<br><br></code></pre></td></tr></table></figure>
<p>这个就不做过多的解释了，一看就能明白</p>
<h5 id="添加到下载队列"><a href="#添加到下载队列" class="headerlink" title="添加到下载队列"></a>添加到下载队列</h5><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">[wself.downloadQueue addOperation:operation];<br><br></code></pre></td></tr></table></figure>
<p>这里的downloadQueue是一个NSOperationQueue</p>
<h5 id="设置操作队列的执行顺序"><a href="#设置操作队列的执行顺序" class="headerlink" title="设置操作队列的执行顺序"></a>设置操作队列的执行顺序</h5><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">if (wself.executionOrder &#x3D;&#x3D; <br>					SDWebImageDownloaderLIFOExecutionOrder) &#123;<br>    &#x2F;&#x2F; Emulate LIFO execution order by systematically adding new <br>    	operations as last operation&#39;s dependency<br>    [wself.lastAddedOperation addDependency:operation];<br>     wself.lastAddedOperation &#x3D; operation;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>如果是先进先出，队列的结构，后来新加入的队列自然后在后面执行，如果是后进先出，栈结构 需要设置操作的依赖</p>
<p>说到这里，下面就剩下正式的发送请求</p>
<h4 id="下载请求"><a href="#下载请求" class="headerlink" title="下载请求"></a>下载请求</h4><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">这里的参数应该是都比较清楚了，不在赘述<br>- (id)initWithRequest:(NSURLRequest *)request<br>              options:(SDWebImageDownloaderOptions)options<br>             progress:(SDWebImageDownloaderProgressBlock)progressBlock<br>            completed:(SDWebImageDownloaderCompletedBlock)completedBlock<br>            cancelled:(SDWebImageNoParamsBlock)cancelBlock<br><br></code></pre></td></tr></table></figure>
<p>这个方法的返回值也是也operation用户可以定义，默认是SDWebImageDownloaderOperation</p>
<h4 id="图片下载progressBlock"><a href="#图片下载progressBlock" class="headerlink" title="图片下载progressBlock"></a>图片下载progressBlock</h4><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">progress:^(NSInteger receivedSize, NSInteger expectedSize) &#123;<br>                                                             	SDWebImageDownloader *sself &#x3D; wself;<br>	if (!sself) return;<br>                                                             	__block NSArray *callbacksForURL;<br>                                                             	dispatch_sync(sself.barrierQueue, ^&#123;<br>                                                                 		callbacksForURL &#x3D; [sself.URLCallbacks[url] copy];<br>                                                            <br>    &#125;);<br>    <br>   for (NSDictionary *callbacks in callbacksForURL) &#123;<br>                                                                 		dispatch_async(dispatch_get_main_queue(), ^&#123;<br>                                                                     			SDWebImageDownloaderProgressBlock callback &#x3D; <br>                                                                     							callbacks[kProgressCallbackKey];<br>                                                         	if (callback) callback(receivedSize, expectedSize);<br>                                                                 &#125;);<br><br></code></pre></td></tr></table></figure>
<p><code>注意：</code><br>这里每一个URL对应的callbacksForURL是一个数组，数组中存放的是针对同一个URL的下载过程中的一些操作，这里对于同一个URL数组中的所有内容都做更新。</p>
<p>下载完成的回调(执行回调，删除回调的保存)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">                                                        completed:^(UIImage *image, NSData *data, NSError *error, BOOL finished) &#123;<br>                                                            SDWebImageDownloader *sself &#x3D; wself;<br>if (!sself) return;                                                     __block NSArray *callbacksForURL;                                                dispatch_barrier_sync(sself.barrierQueue, ^&#123;<br>	callbacksForURL &#x3D; [sself.URLCallbacks[url] copy];<br>	if (finished) &#123;<br>		[sself.URLCallbacks removeObjectForKey:url];<br>	&#125;<br>&#125;);<br>    for (NSDictionary *callbacks in callbacksForURL) &#123;<br>		SDWebImageDownloaderCompletedBlock callback <br>						&#x3D;callbacks[kCompletedCallbackKey];<br>                                                                if (callback) callback(image, data, error, finished);<br> &#125;<br> &#125;<br><br></code></pre></td></tr></table></figure>

<p>下载操作被取消的回调：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">                                                                                                                cancelled:^&#123;<br>                                                            SDWebImageDownloader *sself &#x3D; wself;<br>if (!sself) return;                                             dispatch_barrier_async(sself.barrierQueue, ^&#123;<br>	[sself.URLCallbacks removeObjectForKey:url];<br>&#125;);<br>&#125;];<br><br></code></pre></td></tr></table></figure>

<p>到目前为止，除了具体的下载细节，图片下载就基本完成了！！！开始执行下载完成的回调</p>
<h5 id="图片下载完成（包含成功或者失败）："><a href="#图片下载完成（包含成功或者失败）：" class="headerlink" title="图片下载完成（包含成功或者失败）："></a>图片下载完成（包含成功或者失败）：</h5><p>这里要注意下，突然发现当前存在着好几个operation，先通过下面这张图片，理一下层次结构</p>
<p><img src="http://images2015.cnblogs.com/blog/715314/201512/715314-20151226140749593-1190538283.png" alt="icon"></p>
<p>现在回到了SDWebImageDownloader的downloadImageWithURL:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">__strong __typeof(weakOperation) strongOperation &#x3D;<br>												 weakOperation;<br>												 <br>if (!strongOperation || strongOperation.isCancelled) &#123;<br> &#x2F;&#x2F; Do nothing if the operation was cancelled<br> &#x2F;&#x2F; See #699 for more details<br> &#x2F;&#x2F; if we would call the completedBlock, there could be a race<br>  condition between this block and another completedBlock for<br>   the same object, so if this one is called second, we will <br>   overwrite the new data<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p><code>问题</code>：</p>
<p>这里的解释是：如果操作被取消了，就不执行任何操作。如果我们调用了completedBlock，那么在同一个对象的另一个completedBlock之间就存在一个竞争关系，因此，如果这个方法被重复调用两次，我们会重写新的数据</p>
<h4 id="图片下载失败处理"><a href="#图片下载失败处理" class="headerlink" title="图片下载失败处理"></a>图片下载失败处理</h4><p>确定下载失败的原因，触发下载完成的回调（返回必要信息），同时加入黑名单</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">dispatch_main_sync_safe(^&#123;<br>  if (strongOperation &amp;&amp; !strongOperation.isCancelled) &#123;<br>      completedBlock(nil, error, SDImageCacheTypeNone,<br>       finished, url);<br>     &#125;<br> &#125;);<br><br> if (error.code !&#x3D; NSURLErrorNotConnectedToInternet<br>     &amp;&amp; error.code !&#x3D; NSURLErrorCancelled<br>     &amp;&amp; error.code !&#x3D; NSURLErrorTimedOut<br>     &amp;&amp; error.code !&#x3D; NSURLErrorInternationalRoamingOff<br>     &amp;&amp; error.code !&#x3D; NSURLErrorDataNotAllowed<br>     &amp;&amp; error.code !&#x3D; NSURLErrorCannotFindHost<br>     &amp;&amp; error.code !&#x3D; NSURLErrorCannotConnectToHost) &#123;<br>     @synchronized (self.failedURLs) &#123;<br>          [self.failedURLs addObject:url];<br>     &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p><code>注意：这里不管用户是否设置，都会将这个下载失败的URL加入到黑名单中</code></p>
<h4 id="图片下载成功"><a href="#图片下载成功" class="headerlink" title="图片下载成功"></a>图片下载成功</h4><p>判断是否为下载失败后的重试,如果是重试，那么就将这个图片从黑名单中移除</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">if ((options &amp; SDWebImageRetryFailed)) &#123;<br>   @synchronized (self.failedURLs) &#123;<br>       [self.failedURLs removeObject:url];<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>是否设置了SDWebImageRefreshCached（相同的URL 图片改变之后是否更新缓存）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">if (options &amp; SDWebImageRefreshCached &amp;&amp; <br>							image &amp;&amp; !downloadedImage) &#123;<br>   &#x2F;&#x2F; Image refresh hit the NSURLCache cache, do not call the<br>    completion block<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>图片下载完成之后，是否需要对图片进行相应的处理（根据SDWebImageTransformAnimatedImage属性，用户可进行设置）：</p>
<p>先看一下图片下载成功之后判断条件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">(downloadedImage &amp;&amp; (!downloadedImage.images || (options &amp; SDWebImageTransformAnimatedImage)) &amp;&amp; [self.delegate respondsToSelector:@selector(imageManager:transformDownloadedImage:withURL:)]) <br><br></code></pre></td></tr></table></figure>
<p>downloadedImage:图片下载成功</p>
<p>图片不是gif且需要在图片下载完成之后，对图片进行其他操作<br>(!downloadedImage.images || (options &amp;<br>                SDWebImageTransformAnimatedImage))</p>
<p>是否实现了图片下载完成之后形变的代理方法</p>
<p>[self.delegate respondsToSelector:@selector(imageManager:transformDownloadedImage:withURL:)</p>
<p>如果满足了上面的三个条件，表明在图片下载完成之后需要对图片进行形变：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">如果要进行形变，这个代理方法需要开发者实现<br>UIImage *transformedImage &#x3D; [self.delegate imageManager:self <br>		transformDownloadedImage:downloadedImage withURL:url];<br><br></code></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">  &#x2F;&#x2F;完成形变操作，且图片下载完成（图片没下载完成回到用这个方法吗）<br> if (transformedImage &amp;&amp; finished) &#123;<br>     BOOL imageWasTransformed &#x3D;<br>     			 ![transformedImage isEqual:downloadedImage];<br>     &#x2F;&#x2F;图片保存<br>     [self.imageCache storeImage:transformedImage <br>     		 recalculateFromImage:imageWasTransformed<br>      				imageData:(imageWasTransformed ? nil : data)<br>      				forKey:key toDisk:cacheOnDisk];<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>调用下载完成的回调</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">dispatch_main_sync_safe(^&#123;<br>	&#x2F;&#x2F;operation 没有被取消<br>    if (strongOperation &amp;&amp; !strongOperation.isCancelled) &#123;<br>		completedBlock(transformedImage, nil, 	<br>						SDImageCacheTypeNone, finished, url);<br>    &#125;<br>&#125;);<br><br></code></pre></td></tr></table></figure>

<p><code>如果不需要再图片下载完成之后，对图片进行其他的处理,那么就做一下图片的缓存同时调用图片下载完成的回调即可</code></p>
<h5 id="图片下载完成最后移除"><a href="#图片下载完成最后移除" class="headerlink" title="图片下载完成最后移除"></a>图片下载完成最后移除</h5><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">if (finished) &#123;<br>   @synchronized (self.runningOperations) &#123;<br>   if (strongOperation) &#123;<br>     [self.runningOperations removeObject:strongOperation];<br>   &#125;<br> &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>


<h4 id="操作的取消"><a href="#操作的取消" class="headerlink" title="操作的取消"></a>操作的取消</h4><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">operation.cancelBlock &#x3D; ^&#123;<br>	&#x2F;&#x2F;首先取消SDWebImageDownloaderOperation<br>   [subOperation cancel];<br>                <br>   @synchronized (self.runningOperations) &#123;<br>    __strong __typeof(weakOperation) strongOperation &#x3D; <br>    											weakOperation;<br>    if (strongOperation) &#123;<br>    	&#x2F;&#x2F;移除这一操作<br>        [self.runningOperations removeObject:strongOperation];<br>    &#125;<br> &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>
<p><code>注意</code>：这里取消的是operation而不是subOperation</p>
<p>operation:是一个NSOperation类型的<br>subOperation：是一个SDWebImageDownloaderOperation类型的</p>
<p>下面我们来仔细的看一下取消操作：</p>
<p> [subOperation cancel];</p>
<p>这是SDWebImageDownloaderOperation种重写的取消</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">- (void)cancel &#123;<br>    @synchronized (self) &#123;<br>        if (self.thread) &#123;<br>            [self <br>            performSelector:@selector(cancelInternalAndStop) <br>            onThread:self.thread withObject:nil <br>            					  waitUntilDone:NO];<br>        &#125;<br>        else &#123;<br>            [self cancelInternal];<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>仔细观察一下这里的取消操作，会根据是否存在self.thread执行两个方法：</p>
<p>cancelInternalAndStop和cancelInternal</p>
<p>比较一下这两个方法可以看到cancelInternalAndStop只是比多了一句：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">CFRunLoopStop(CFRunLoopGetCurrent());<br><br></code></pre></td></tr></table></figure>
<p>用来停止当前线程的运行循环。</p>
<h4 id="没找到图片："><a href="#没找到图片：" class="headerlink" title="没找到图片："></a>没找到图片：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">dispatch_main_sync_safe(^&#123;<br>   __strong __typeof(weakOperation) strongOperation &#x3D; <br>   												weakOperation;<br>   if (strongOperation &amp;&amp; !weakOperation.isCancelled) &#123;<br>       completedBlock(nil, nil, SDImageCacheTypeNone, YES, url);<br>   &#125;<br>&#125;);<br>@synchronized (self.runningOperations) &#123;<br>    [self.runningOperations removeObject:operation];<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h4 id="图片在查找到或者下载完成之后图片的显示"><a href="#图片在查找到或者下载完成之后图片的显示" class="headerlink" title="图片在查找到或者下载完成之后图片的显示"></a>图片在查找到或者下载完成之后图片的显示</h4><p>SDWebImageAvoidAutoSetImage 图片下载完成之后是否立即设置给ImageView<br>在这里如果想要对图片的显示添加一些动画，我们可以从这里着手</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&#x2F;&#x2F;下载完成之后是否自动设置图片<br>   SDWebImageAvoidAutoSetImage &#x3D; 1 &lt;&lt; 11<br><br></code></pre></td></tr></table></figure>

<p>图片显示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">dispatch_main_sync_safe(^&#123;<br>  if (!wself) return;<br>  &#x2F;&#x2F;用户是否设置了需要手动设置图片的显示<br>  if (image <br>  		&amp;&amp; (options &amp; SDWebImageAvoidAutoSetImage)<br>   		&amp;&amp; completedBlock)<br>  &#123;<br>      completedBlock(image, error, cacheType, url);<br>      return;<br>  &#125;<br>   else if (image) &#123;<br>      wself.image &#x3D; image;<br>      [wself setNeedsLayout];<br>   &#125; else &#123;<br>   	  &#x2F;&#x2F;图片下载失败延时显示占位图片<br>      if ((options &amp; SDWebImageDelayPlaceholder)) &#123;<br>            wself.image &#x3D; placeholder;<br>            [wself setNeedsLayout];<br>      &#125;<br>  &#125;<br>  &#x2F;&#x2F;图片下载成功之后的回调<br>  if (completedBlock &amp;&amp; finished) &#123;<br>       completedBlock(image, error, cacheType, url);<br>    &#125;<br>  &#125;);<br><br></code></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>源码分析</category>
      </categories>
      <tags>
        <tag>SDWebImage</tag>
        <tag>下载</tag>
      </tags>
  </entry>
  <entry>
    <title>祭最近的一次面试</title>
    <url>/2018/04/21/latest-interview/</url>
    <content><![CDATA[<p>最近工作事情不多,本着紧跟潮流的想法,在公司附近找了几家公司面试,涨涨经验顺便看看最近iOS都在招什么方向的的人！ 本人计算机专业毕业(不过基本已经把老师讲的还给老师了),因此在这次面试中 完全被虐。因此,打算写一篇文章来祭奠我的这次面试！</p>
<a id="more"></a>

<h2 id="面试题目"><a href="#面试题目" class="headerlink" title="面试题目"></a>面试题目</h2><h3 id="都学过哪些数据结构？"><a href="#都学过哪些数据结构？" class="headerlink" title="都学过哪些数据结构？"></a>都学过哪些数据结构？</h3><p>数据结构：是指相互之间存在着一种或多种关系的数据元素的集合和该集合中数据元素之间的关系组成<br>包括三个组成成分：数据的逻辑结构、物理结构（存储结构）、数据运算结构。</p>
<h4 id="数据的逻辑结构："><a href="#数据的逻辑结构：" class="headerlink" title="数据的逻辑结构："></a>数据的逻辑结构：</h4><ul>
<li>1、集合（数据之间无关系）</li>
<li>2、线性结构（一对一）</li>
<li>3、树形结构（一对多）</li>
<li>4、图形结构（多对多）</li>
</ul>
<h4 id="数据的物理结构：指数据在计算机存储空间的存放形式"><a href="#数据的物理结构：指数据在计算机存储空间的存放形式" class="headerlink" title="数据的物理结构：指数据在计算机存储空间的存放形式"></a>数据的物理结构：指数据在计算机存储空间的存放形式</h4><p>顺序存储、链表存储、索引存储、散列存储</p>
<h5 id="常用的数据结构："><a href="#常用的数据结构：" class="headerlink" title="常用的数据结构："></a>常用的数据结构：</h5><ul>
<li>1、数组</li>
<li>2、栈（先进后出、线性表）</li>
<li>3、队列（先进先出、后进后出、线性表）</li>
<li>4、链表（每个节点包括两个部分：一个存储数据元素的数据域、另一个存储下一个节点地址的指针域）</li>
<li>5、树</li>
<li>6、图</li>
<li>7、堆（是一种动态的树形结构）</li>
<li>8、散列表</li>
</ul>
<h3 id="数组和链表的区别"><a href="#数组和链表的区别" class="headerlink" title="数组和链表的区别"></a>数组和链表的区别</h3><h4 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h4><p>顺序表是在计算机内存中以数组的形式保存的线性表，是指用一组地址连续的存储单元依次存储数据元素的线性结构。只要确定了起始位置，表中任一元素的地址都通过下列公式得到：LOC（ai）=LOC（a1）+（i-1）*L 　1≤i≤n 其中，L是元素占用存储单元的长度。</p>
<h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><ul>
<li>长度固定，必须在分配内存之前确定数组的长度。</li>
<li>存储空间连续，即允许元素的随机访问。</li>
<li>存储密度大，内存中存储的全部是数据元素。</li>
<li>要访问特定元素，可以使用索引访问，时间复杂度为 。</li>
<li>要想在顺序表中插入或删除一个元素，都涉及到之后所有元素的移动，因此时间复杂度为 。</li>
</ul>
<p><img src="https://img-blog.csdn.net/20160323220752422" alt="顺序表"></p>
<h4 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h4><p>单链表是一种链式存取的数据结构，用一组地址任意的存储单元存放线性表中的数据元素。它的数据是以结点（类型一般为结构体）来表示的，每个结点的构成：数据（类型为要存储的数据的类型） + 指针（结构体指针），数据就是链表里具体要存储的东西，指针就是用来把每个节点都连接起来，使它们形成一个链状</p>
<p><img src="https://img-blog.csdn.net/20160323214456532" alt="链表"></p>
<h5 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h5><ul>
<li>长度不固定，可以任意增删。</li>
<li>存储空间不连续，数据元素之间使用指针相连，每个数据元素只能访问周围的一个元素（根据单链表还是双链表有所不同）。</li>
<li>存储密度小，因为每个数据元素，都需要额外存储一个指向下一元素的指针（双链表则需要两个指针）。</li>
<li>要访问特定元素，只能从链表头开始，遍历到该元素，时间复杂度为 。</li>
<li>在特定的数据元素之后插入或删除元素，不涉及到其他元素的移动，因此时间复杂度为 。双链表还允许在特定的数据元素之前插入或删除元素。</li>
</ul>
<h4 id="区别和优缺点"><a href="#区别和优缺点" class="headerlink" title="区别和优缺点"></a>区别和优缺点</h4><h5 id="空间的开辟"><a href="#空间的开辟" class="headerlink" title="空间的开辟"></a>空间的开辟</h5><p>顺序表的实现一般是实现连续开辟一段空间，然后在进行数据的增删查改（静态顺序表），所以顺序表一般是固定空间大小的；而单链表则是一次只开辟一个结点的空间，用来存储当前要保存的数据及指向下一个结点或NULL的指针，所以单链表的空间大小时动态变化的。（当然，顺序表也可以在初始化时利用malloc函数来开辟一块空间，每当空间不够用时，再用realloc来把当前空间扩容成2倍，从而也能实现空间的动态变化（动态顺序表））。</p>
<h5 id="空间的使用"><a href="#空间的使用" class="headerlink" title="空间的使用"></a>空间的使用</h5><p>当我们不知道要存储多少数据时，用顺序表来开辟的空间如果太大，就会造成一定程度上的浪费，而用单链表是实现时，因为是每需要存储一个数据时，才开辟一个空间，虽然有非数据项的指针占空间，但相比顺序表来说，浪费不是那么明显；反之，当我们知道存储的数据的数量时，用顺序表来开辟对应的空间大小，来存储数据，因为顺序表中每个元素的存储密度为 1，就完全不会有浪费的空间，而用单链表，因为每个结点都会有非数据项得指针，那么就会造成空间的浪费。再者 链表可能会产生内存碎片</p>
<h5 id="访问随机元素的时间复杂度"><a href="#访问随机元素的时间复杂度" class="headerlink" title="访问随机元素的时间复杂度"></a>访问随机元素的时间复杂度</h5><p>因为顺序表的结构就像是数组一样，可以用下标来访问它的元素，所以它的元素是支持随机访问的；相比之下，单链表的数据是链式存储的，它的元素是不支持随机访问的，想要知道某个元素，只能从头结点开始遍历整个链表，知道找到了该元素为止。因此顺序表访问随机元素的时间复杂度是O（1），而单链表访问随机元素的平均时间复杂度是O（n）。</p>
<h6 id="随机位置插入、删除元素的时间复杂度"><a href="#随机位置插入、删除元素的时间复杂度" class="headerlink" title="随机位置插入、删除元素的时间复杂度"></a>随机位置插入、删除元素的时间复杂度</h6><p>因为顺序表的元素是连续存储的，因此要在特定位置插入、删除元素需要把它之后的元素全部后移或前移一个元素的位置，时间开销很大；而单链表在插入或删除元素时，只需要改变它的前驱元素及插入或删除元素的指向即可。因此，顺序表在插入随机位置插入、删除元素的平均时间复杂度是O（n），单链表在插入随机位置插入、删除元素的时间复杂度是O（1）。</p>
<p>综上 <code>在查询操作使用的比较频繁时，使用顺序表会好一些；在插入、删除操作使用的比较频繁时，使用单链表会好一些。</code></p>
<h3 id="树学过哪些树-什么是完全二叉树-霍夫曼树-红黑树-图"><a href="#树学过哪些树-什么是完全二叉树-霍夫曼树-红黑树-图" class="headerlink" title="树学过哪些树 什么是完全二叉树 霍夫曼树 红黑树 图"></a>树学过哪些树 什么是完全二叉树 霍夫曼树 红黑树 图</h3><h4 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h4><p>二叉树是有限个结点的集合，这个集合或者是空集，或者是由一个根结点和两株互不相交的二叉树组成，其中一株叫根的做左子树，另一棵叫做根的右子树</p>
<p>二叉树的性质：</p>
<ul>
<li>性质1：在二叉树中第 i 层的结点数最多为2^(i-1)（i ≥ 1）</li>
<li>性质2：高度为k的二叉树其结点总数最多为2^k－1（ k ≥ 1）</li>
<li>性质3：对任意的非空二叉树 T ，如果叶结点的个数为 n0，而其度为 2 的结点数为 n2，则：n0 = n2 + 1</li>
</ul>
<h4 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h4><p>深度为k且有2^k －1个结点的二叉树称为满二叉树</p>
<ul>
<li>性质4：具有 n 个结点的完全二叉树的深度为 log2n + 1</li>
</ul>
<p><code>注意</code>:仅有前序和后序遍历，不能确定一个二叉树，必须有中序遍历的结果</p>
<h4 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h4><p>深度为 k 的，有n个结点的二叉树，当且仅当其每个结点都与深度为 k 的满二叉树中编号从 1 至 n 的结点一一对应，称之为完全二叉树。（除最后一层外，每一层上的节点数均达到最大值；在最后一层上只缺少右边的若干结点）</p>
<h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4><p>如果一棵完全二叉树的任意一个非终端结点的元素都不小于其左儿子结点和右儿子结点（如果有的话） 的元素，则称此完全二叉树为<code>最大堆</code>。</p>
<p>同样，如果一棵完全二叉树的任意一个非终端结点的元素都不大于其左儿子结点和右儿子结点（如果 有的话）的元素，则称此完全二叉树为<code>最小堆</code>。</p>
<p><code>最大堆的根结点中的元素在整个堆中是最大的</code>；</p>
<p><code>最小堆的根结点中的元素在整个堆中是最小的</code>。</p>
<h4 id="哈弗曼树"><a href="#哈弗曼树" class="headerlink" title="哈弗曼树"></a>哈弗曼树</h4><p>定义：给定n个权值作为n的叶子结点，构造一棵二叉树，若带权路径长度达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树(Huffman tree)。</p>
<h5 id="构造："><a href="#构造：" class="headerlink" title="构造："></a>构造：</h5><p>假设有n个权值，则构造出的哈夫曼树有n个叶子结点。 n个权值分别设为 w1、w2、…、wn，则哈夫曼树的构造规则为：</p>
<ul>
<li>将w1、w2、…，wn看成是有 n 棵树的森林(每棵树仅有一个结点)；</li>
<li>在森林中选出两个根结点的权值最小的树合并，作为一棵新树的左、右子树，且新树的根结点权值为其左、右子树根结点权值之和；</li>
<li>从森林中删除选取的两棵树，并将新树加入森林；</li>
<li>重复(2)、(3)步，直到森林中只剩一棵树为止，该树即为所求得的哈夫曼树。</li>
</ul>
<p><img src="https://gss3.bdstatic.com/-Po3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=408997773a12b31bd361c57be7715d1f/0df431adcbef7609783292af2ddda3cc7cd99ec0.jpg" alt="哈弗曼树"></p>
<h4 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a>二叉排序树</h4><p>二叉排序树（Binary Sort Tree）又称二叉查找树（Binary Search Tree），亦称二叉搜索树。</p>
<p>二叉排序树或者是一棵空树，或者是具有下列性质的二叉树：</p>
<ul>
<li>若左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li>
<li>若右子树不空，则右子树上所有结点的值均大于或等于它的根结点的值；</li>
<li>左、右子树也分别为二叉排序树；</li>
<li>没有键值相等的节点</li>
</ul>
<p>二分查找的时间复杂度是O(log(n))，最坏情况下的时间复杂度是O(n)（相当于顺序查找）</p>
<p><img src="https://gss2.bdstatic.com/9fo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=b3c80026d72a6059461de948495d5ffe/94cad1c8a786c9179df9bed6c93d70cf3ac75763.jpg" alt="二叉排序树"></p>
<h4 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h4><p>平衡二叉树（balanced binary tree）,又称 AVL 树。它或者是一棵空树,或者是具有如下性质的二叉树：</p>
<ul>
<li>它的左子树和右子树都是平衡二叉树，</li>
<li>左子树和右子树的深度之差的绝对值不超过1。</li>
</ul>
<p>平衡二叉树是对二叉搜索树(又称为二叉排序树)的一种改进。二叉搜索树有一个缺点就是，树的结构是无法预料的，随意性很大，它只与节点的值和插入的顺序有关系，往往得到的是一个不平衡的二叉树。在最坏的情况下，可能得到的是一个单支二叉树，其高度和节点数相同，相当于一个单链表，对其正常的时间复杂度有O(log(n))变成了O(n)，从而丧失了二叉排序树的一些应该有的优点</p>
<p><img src="https://gss2.bdstatic.com/9fo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=f997b13a8c01a18be4e61a1dff466c6d/3801213fb80e7bec26a434f7242eb9389b506bad.jpg" alt="平衡二叉树"></p>
<h4 id="B-树"><a href="#B-树" class="headerlink" title="B-树"></a>B-树</h4><p>B-树：B-树是一种非二叉的查找树， 除了要满足查找树的特性，还要满足以下结构特性：</p>
<p>一棵 m 阶的B-树：</p>
<ul>
<li>树的根或者是一片叶子(一个节点的树),或者其儿子数在 2 和 m 之间。</li>
<li>除根外，所有的非叶子结点的孩子数在 m/2 和 m 之间。</li>
<li>所有的叶子结点都在相同的深度。</li>
</ul>
<p>B-树的平均深度为logm/2(N)。执行查找的平均时间为O(logm)；</p>
<h4 id="Trie-树"><a href="#Trie-树" class="headerlink" title="Trie 树"></a>Trie 树</h4><p>Trie 树，又称前缀树，字典树， 是一种有序树，用于保存关联数组，其中的键通常是字符串。与二叉查找树不同，键不是直接保存在节点中，而是由节点在树中的位置决定。一个节点的所有子孙都有相同的前缀，也就是这个节点对应的字符串，而根节点对应空字符串。一般情况下，不是所有的节点都有对应的值，只有叶子节点和部分内部节点所对应的键才有相关的值。</p>
<p>Trie 树查询和插入时间复杂度都是 O(n)，是一种以空间换时间的方法。当节点树较多的时候，Trie 树占用的内存会很大。</p>
<p>Trie 树常用于搜索提示。如当输入一个网址，可以自动搜索出可能的选择。当没有完全匹配的搜索结果，可以返回前缀最相似的可能。</p>
<h3 id="哈希表-给一个数据如何存到哈希表中-如何得到这个key"><a href="#哈希表-给一个数据如何存到哈希表中-如何得到这个key" class="headerlink" title="哈希表 给一个数据如何存到哈希表中 如何得到这个key"></a>哈希表 给一个数据如何存到哈希表中 如何得到这个key</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>哈希表（Hash Table，也叫散列表），是根据关键码值 (Key-Value) 而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。哈希表的实现主要需要解决两个问题，哈希函数和冲突解决。</p>
<h4 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h4><p>根据key,计算出key对应记录的储存位置</p>
<p><code>position = f(key)</code></p>
<p>哈希函数也叫散列函数，它对不同的输出值得到一个固定长度的消息摘要。理想的哈希函数对于不同的输入应该产生不同的结构，同时散列结果应当具有同一性（输出值尽量均匀）和雪崩效应（微小的输入值变化使得输出值发生巨大的变化）</p>
<h4 id="冲突解决"><a href="#冲突解决" class="headerlink" title="冲突解决"></a>冲突解决</h4><p>现实中的哈希函数不是完美的，当两个不同的输入值对应一个输出值时，就会产生“碰撞”，这个时候便需要解决冲突。</p>
<p>常见的冲突解决方法有开放定址法，链地址法，建立公共溢出区等。实际的哈希表实现中，使用最多的是链地址法</p>
<h4 id="链地址法"><a href="#链地址法" class="headerlink" title="链地址法"></a>链地址法</h4><p>链地址法的基本思想是，为每个 Hash 值建立一个单链表，当发生冲突时，将记录插入到链表中。</p>
<p>例 2 设有 8 个元素 { a,b,c,d,e,f,g,h } ，采用某种哈希函数得到的地址分别为： {0 ， 2 ， 4 ， 1 ， 0 ， 8 ， 7 ， 2} ，当哈希表长度为 10 时，采用链地址法解决冲突的哈希表如下图所示：</p>
<p><img src="https://github.com/HIT-Alibaba/interview/blob/master/img/hash-table.jpg?raw=true" alt="链地址法"></p>
<h3 id="算法学过哪些"><a href="#算法学过哪些" class="headerlink" title="算法学过哪些"></a>算法学过哪些</h3><h4 id="常见排序算法"><a href="#常见排序算法" class="headerlink" title="常见排序算法"></a>常见排序算法</h4><h5 id="常见的稳定排序算法有："><a href="#常见的稳定排序算法有：" class="headerlink" title="常见的稳定排序算法有："></a>常见的稳定排序算法有：</h5><ul>
<li>冒泡排序（Bubble Sort） — O(n²)</li>
<li>插入排序（Insertion Sort）— O(n²)</li>
<li>桶排序（Bucket Sort）— O(n); 需要 O(k) 额外空间</li>
<li>计数排序 (Counting Sort) — O(n+k); 需要 O(n+k) 额外空间</li>
<li>合并排序（Merge Sort）— O(nlogn); 需要 O(n) 额外空间</li>
<li>二叉排序树排序 （Binary tree sort） — O(n log n) 期望时间; O(n²)最坏时间; 需要 O(n) 额外空间</li>
<li>基数排序（Radix sort）— O(n·k); 需要 O(n) 额外空间</li>
</ul>
<h5 id="常见的不稳定排序算法有："><a href="#常见的不稳定排序算法有：" class="headerlink" title="常见的不稳定排序算法有："></a>常见的不稳定排序算法有：</h5><ul>
<li>选择排序（Selection Sort）— O(n²)</li>
<li>希尔排序（Shell Sort）— O(nlogn)</li>
<li>堆排序（Heapsort）— O(nlogn)</li>
<li>快速排序（Quicksort）— O(nlogn) 期望时间, O(n²) 最坏情况; 对于大的、乱数串行一般相信是最快的已知排</li>
</ul>
<p><a href="https://blog.csdn.net/whuslei/article/details/6442755">常见排序算法小结</a></p>
<h4 id="常用查找算法"><a href="#常用查找算法" class="headerlink" title="常用查找算法"></a>常用查找算法</h4><ul>
<li>顺序查找 时间复杂度为O(n)</li>
<li>二分查找 O(log2n)</li>
<li>分块查找</li>
<li>树表查找</li>
<li>哈希表查找</li>
</ul>
<p><a href="http://codingxiaxw.cn/2017/01/14/66-leetcode-find/">常用查找算法</a></p>
<h3 id="内存的分区？"><a href="#内存的分区？" class="headerlink" title="内存的分区？"></a>内存的分区？</h3><p>一个程序的可执行文件在内存中的结果，从大的角度可以分为两个部分：只读部分和可读写部分。只读部分包括程序代码（.text）和程序中的常量（.rodata）。可读写部分（也就是变量）大致可以分成下面几个部分：</p>
<ul>
<li>.data： 初始化了的全局变量和静态变量</li>
<li>.bss： 即 Block Started by Symbol， 未初始化的全局变量和静态变量（这个我感觉上课真的没讲过啊我去。。。）</li>
<li>heap： 堆，使用 malloc, realloc, 和 free 函数控制的变量，堆在所有的线程，共享库，和动态加载的模块中被共享使用</li>
<li>stack： 栈，函数调用时使用栈来保存函数现场，自动变量（即生命周期限制在某个 scope 的变量）也存放在栈中。</li>
<li>文字常量区   —常量字符串就是放在这里的。程序结束后由系统释放  </li>
<li>程序代码区—存放函数体的二进制代码。</li>
</ul>
<h3 id="堆和栈的区别？-系统如何去管理栈的内存-是运行期间还是编译之后就确定了"><a href="#堆和栈的区别？-系统如何去管理栈的内存-是运行期间还是编译之后就确定了" class="headerlink" title="堆和栈的区别？ 系统如何去管理栈的内存 是运行期间还是编译之后就确定了?"></a>堆和栈的区别？ 系统如何去管理栈的内存 是运行期间还是编译之后就确定了?</h3><h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><p>栈是用于存放本地变量，内部临时变量以及有关上下文的内存区域。程序在调用函数时，<code>操作系统会自动通过压栈和弹栈完成保存函数现场等操作</code>，不需要程序员手动干预。</p>
<p>栈是一块连续的内存区域，栈顶的地址和栈的最大容量是系统预先规定好的。能从栈获得的空间较小。如果申请的空间超过栈的剩余空间时，例如<code>递归深度过深</code>，将提示<code>stackoverflow</code>。</p>
<p>栈是机器系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高</p>
<h4 id="堆-1"><a href="#堆-1" class="headerlink" title="堆"></a>堆</h4><p>堆是用于存放除了栈里的东西之外所有其他东西的内存区域，当使用malloc和free时就是在操作堆中的内存。对于堆来说，<code>释放工作由程序员控制</code>，<code>容易产生memory leak</code>。</p>
<p>堆是向高地址扩展的数据结构，<code>是不连续的内存区域</code>。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。</p>
<p>对于堆来讲，<code>频繁的new/delete势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低</code>。对于栈来讲，则不会存在这个问题，<code>因为栈是先进后出的队列，永远都不可能有一个内存块从栈中间弹出</code>。</p>
<p>堆都是动态分配的，没有静态分配的堆。栈有2种分配方式：静态分配和动态分配。静态分配是编译器完成的，比如局部变量的分配。动态分配由alloca函数进行分配，但是栈的动态分配和堆是不同的，他的动态分配是由编译器进行释放，无需我们手工实现。</p>
<p>计算机底层并没有对堆的支持，堆则是C/C++函数库提供的，同时由于上面提到的碎片问题，都会导致堆的效率比栈要低</p>
<h4 id="堆和栈的区别"><a href="#堆和栈的区别" class="headerlink" title="堆和栈的区别"></a>堆和栈的区别</h4><h5 id="申请方式"><a href="#申请方式" class="headerlink" title="申请方式"></a>申请方式</h5><ul>
<li>栈：由系统自动分配</li>
<li>堆：  需要程序员自己申请，并指明大小，在c中malloc函数    </li>
</ul>
<h5 id="申请后系统的响应"><a href="#申请后系统的响应" class="headerlink" title="申请后系统的响应"></a>申请后系统的响应</h5><ul>
<li><p>栈：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢<br>出。   </p>
</li>
<li><p>堆：首先应该知道操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，<br>会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表<br>中删除，并将该结点的空间分配给程序，另外，对于大多数系统，会在这块内存空间中的<br>首地址处记录本次分配的大小，这样，代码中的delete语句才能正确的释放本内存空间。<br>另外，由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部<br>分重新放入空闲链表中。    </p>
</li>
</ul>
<h5 id="申请大小的限制"><a href="#申请大小的限制" class="headerlink" title="申请大小的限制"></a>申请大小的限制</h5><ul>
<li><p>栈 ：栈顶的地址和栈的最大容量是系统预先规定好的 如果申请的空间超过栈的剩余空间时，将<br>提示overflow。因此，能从栈获得的空间较小</p>
</li>
<li><p>堆：是不连续的内存区域 堆的大小受限于计算机系统中有效的虚拟内存</p>
</li>
</ul>
<h5 id="申请效率"><a href="#申请效率" class="headerlink" title="申请效率"></a>申请效率</h5><ul>
<li>栈：栈由系统自动分配，速度较快。但程序员是无法控制的。    </li>
<li>堆：堆是由new分配的内存，一般速度比较慢，而且容易产生内存碎片,不过用起来最方便.    </li>
</ul>
<h5 id="存储内容"><a href="#存储内容" class="headerlink" title="存储内容"></a>存储内容</h5><ul>
<li><p>栈:在函数调用时，第一个进栈的是主函数中后的下一条指令（函数调用语句的下一条可<br>执行语句）的地址，然后是函数的各个参数，在大多数的C编译器中，参数是由右往左入栈<br>的，然后是函数中的局部变量。注意静态变量是不入栈的。 </p>
</li>
<li><p>堆:一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容由程序员安排。    </p>
</li>
</ul>
<h5 id="存取效率"><a href="#存取效率" class="headerlink" title="存取效率"></a>存取效率</h5><p>栈&gt;堆</p>
<h3 id="那种内存容易产生内存碎片-为什么会产生内存碎片"><a href="#那种内存容易产生内存碎片-为什么会产生内存碎片" class="headerlink" title="那种内存容易产生内存碎片? 为什么会产生内存碎片"></a>那种内存容易产生内存碎片? 为什么会产生内存碎片</h3><p>内存碎片容易发生在堆上,因为只有堆我们才会自己去管理内存的申请使用和释放,栈区是不会碎片化的,因为栈区一直遵守后进先出的逻辑。</p>
<h4 id="内存碎片"><a href="#内存碎片" class="headerlink" title="内存碎片"></a>内存碎片</h4><p>内存分配有静态分配和动态分配两种</p>
<p>静态分配在程序编译链接时分配的大小和使用寿命就已经确定，而应用上要求操作系统可以提供给进程运行时申请和释放任意大小内存的功能，这就是内存的动态分配</p>
<p><code>动态分配会导致内存的碎片化</code></p>
<h4 id="内存碎片类型"><a href="#内存碎片类型" class="headerlink" title="内存碎片类型"></a>内存碎片类型</h4><h5 id="内部碎片："><a href="#内部碎片：" class="headerlink" title="内部碎片："></a>内部碎片：</h5><p>因为所有的内存分配必须起始于可被 4、8 或 16 整除（视处理器体系结构而定）的地址或者因为MMU的分页机制的限制，决定内存分配算法<code>仅能把预定大小的内存块分配给客户</code>。假设当某个客户请求一个 43 字节的内存块时，因为没有适合大小的内存，所以它可能会获得 44字节、48字节等稍大一点的字节，因此由所需大小四舍五入而产生的多余空间就叫内部碎片。</p>
<h5 id="外部碎片"><a href="#外部碎片" class="headerlink" title="外部碎片"></a>外部碎片</h5><p>频繁的分配与回收物理页面会导致大量的、连续且小的页面块夹杂在已分配的页面中间，就会产生外部碎片。假设有一块一共有100个单位的连续空闲内存空间，范围是099。如果你从中申请一块内存，如10个单位，那么申请出来的内存块就为09区间。这时候你继续申请一块内存，比如说5个单位大，第二块得到的内存块就应该为1014区间。如果你把第一块内存块释放，然后再申请一块大于10个单位的内存块，比如说20个单位。因为刚被释放的内存块不能满足新的请求，所以只能从15开始分配出20个单位的内存块。现在整个内存空间的状态是09空闲，1014被占用，1524被占用，2599空闲。其中09就是一个内存碎片了。如果1014一直被占用，而以后申请的空间都大于10个单位，那么09就永远用不上了，变成外部碎片</p>
<h3 id="内存的对齐"><a href="#内存的对齐" class="headerlink" title="内存的对齐"></a>内存的对齐</h3><p>看的我一脸懵逼 直接放别人的文章吧,以后慢慢参悟！</p>
<p><a href="https://songlee24.github.io/2014/09/20/memory-alignment/">C/C++内存对齐</a></p>
<h3 id="线程调度算法-什么是优先级反转？"><a href="#线程调度算法-什么是优先级反转？" class="headerlink" title="线程调度算法 什么是优先级反转？"></a>线程调度算法 什么是优先级反转？</h3><h4 id="线程调度算法"><a href="#线程调度算法" class="headerlink" title="线程调度算法"></a>线程调度算法</h4><h5 id="先到先服务算法"><a href="#先到先服务算法" class="headerlink" title="先到先服务算法"></a>先到先服务算法</h5><p>用一个FIFO（先进先出）队列就可以满足要求。所有的线程构成一个队列，最先进入队列的线程获得处理器执行权，等到放弃处理器执行权时，又回到队列尾部，下一个线程继续执行。若有新的线程进来，则添加到队列尾部。此算法简单，易于实现，但是，如果每个线程执行的任务单元所需要的时间长短不一的话，则算法的实际效果可能非常不公平。</p>
<h5 id="时间片轮转调度算法"><a href="#时间片轮转调度算法" class="headerlink" title="时间片轮转调度算法"></a>时间片轮转调度算法</h5><p>处理器的时间被分成了最大长度不超过某个值的时间片段，称为时间片，然后，用轮转方法分配给每一个线程。当一个线程获得了处理器执行权以后，按照自身的逻辑执行下去，直到时间片用完，或者自己主动放弃执行权（比如要等待一个信号量）。系统在获得了处理器控制权以后，用轮转方法找到下一个正在等待运行的线程，让它继续执行。这种线程调度方法实现简单，所有满足运行条件的线程排成一个队列，然后按照时间片的间隔，轮流让每一个线程获得处理器执行权。由于时钟中断每次都要打断一个线程的运行，所以，这种做法存在固有的线程切换开销，而时间片长短的选择会影响到线程切换开销所占的比例。在现代操作系统中，时间片通常设置为几毫秒到几十、上百毫秒。由于现代计算机的指令周期越来越短，线程切换开销（通常几百条指令或几千条指令，取决于算法实现的复杂程度）也在减小。这种算法使用很广泛，它不仅简单，也确实能公平地分配处理器资源。</p>
<h5 id="优先级调度算法。"><a href="#优先级调度算法。" class="headerlink" title="优先级调度算法。"></a>优先级调度算法。</h5><p>在时间片轮转算法中，一个基本的假设是所有的线程都同等重要。这一假设在专用计算机上可能是非常合理的，但是，在现代多用途的计算机上，可能难以胜任多种不同类型的应用程序并发执行的实际情形。优先级调度算法是这种算法的一个改进，其基本思路是，每个线程都有一个优先级值，高优先级的线程总是优先被考虑在处理器上执行。操作系统在管理线程时，可以使用一个优先级队列，或者每一个优先级用一个队列来存放所有满足执行条件的线程，这样，当一个线程用完了它的时间片或者自动放弃处理器执行权时，系统选择优先级最高的线程作为下一个要运行的线程。每一个线程在队列中的位置是由它的优先级来决定的。同等优先级的线程使用轮转或先到先执行的策略。</p>
<p>简单优先级算法的<code>潜在问题</code>是，高优先级的线程可能会霸占处理器资源不放，从而导致低优先级的线程一点执行机会都没有。所以，一些变种的优先级算法考虑引入动态优先级，即每个线程有静态的优先级和动态的优先级。所谓动态的优先级是在静态优先级的基础上根据某些特定的条件提升或降低线程的优先级，系统调度器根据线程的动态优先级来安排它们的执行顺序。例如，连续执行了多个时间片的线程可能要降低优先级，而长时间没有得到时间片的低优先级线程可能会得到优先级提升。</p>
<h4 id="优先级反转"><a href="#优先级反转" class="headerlink" title="优先级反转"></a>优先级反转</h4><p><a href="http://www.cnblogs.com/kuliuheng/p/4080997.html">多线程编程之优先级翻转问题</a></p>
<h4 id="OC的对象存在哪里-存的是那些东西？"><a href="#OC的对象存在哪里-存的是那些东西？" class="headerlink" title="OC的对象存在哪里 存的是那些东西？"></a>OC的对象存在哪里 存的是那些东西？</h4><p>OC的对象肯定是存放子啊堆中的！</p>
<p>存放的具体内容 应该是这个对象所属的类所具有的 例如</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">objc_class</span> &#123;</span><br>    Class _Nonnull isa  OBJC_ISA_AVAILABILITY;  <span class="hljs-comment">//isa指针指向类的元类(metaClass)</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> !__OBJC2__</span><br>    Class _Nullable super_class                              OBJC2_UNAVAILABLE; <span class="hljs-comment">//父类</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * _Nonnull name                               OBJC2_UNAVAILABLE; <span class="hljs-comment">//类名</span><br>    <span class="hljs-keyword">long</span> version                                             OBJC2_UNAVAILABLE; <span class="hljs-comment">//类版本</span><br>    <span class="hljs-keyword">long</span> info                                                OBJC2_UNAVAILABLE; <span class="hljs-comment">//类的信息</span><br>    <span class="hljs-keyword">long</span> instance_size                                       OBJC2_UNAVAILABLE; <span class="hljs-comment">//类实例对象的大小</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">objc_ivar_list</span> * _<span class="hljs-title">Nullable</span> <span class="hljs-title">ivars</span>                  <span class="hljs-title">OBJC2_UNAVAILABLE</span>;</span> <span class="hljs-comment">//实例变量的列表</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">objc_method_list</span> * _<span class="hljs-title">Nullable</span> * _<span class="hljs-title">Nullable</span> <span class="hljs-title">methodLists</span>                    <span class="hljs-title">OBJC2_UNAVAILABLE</span>;</span><span class="hljs-comment">//方法列表</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">objc_cache</span> * _<span class="hljs-title">Nonnull</span> <span class="hljs-title">cache</span>                       <span class="hljs-title">OBJC2_UNAVAILABLE</span>;</span> <span class="hljs-comment">//方法的缓存</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">objc_protocol_list</span> * _<span class="hljs-title">Nullable</span> <span class="hljs-title">protocols</span>          <span class="hljs-title">OBJC2_UNAVAILABLE</span>;</span> <span class="hljs-comment">//协议列表</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><br>&#125; OBJC2_UNAVAILABLE;<br></code></pre></td></tr></table></figure>

<h3 id="父类和子类的内存是分配在一起的吗？-爷爷类-父类-子类-！"><a href="#父类和子类的内存是分配在一起的吗？-爷爷类-父类-子类-！" class="headerlink" title="父类和子类的内存是分配在一起的吗？ 爷爷类 父类 子类 ！"></a>父类和子类的内存是分配在一起的吗？ 爷爷类 父类 子类 ！</h3><p>创建一个对象的时候，发生了两件事情，一是分配对象所需的内存，二是调用构造函数进行初始化。子类对象包含从父类对象继承过来的成员，实现上来说，一般也是子类的内存区域中有一部分就是父类的内存区域。调用父类构造函数的时候，这块父类对象的内存区域就被初始化了。为了避免未初始化的问题，语法强制子类调用父类构造函数。</p>
<p>属性（包括父类）都保存在对象本身的存储空间内；本类的实例方法保存在类对象中，本类的类方法保存在元类对象中；父类的实例方法保存在各级 super class 中，父类的类方法保存在各级 super meta class 中。</p>
<p><img src="https://img-blog.csdn.net/20160513101728296" alt="对象内存"><br><img src="https://img-blog.csdn.net/20160513104920809" alt="类对象"></p>
<p>子类的对象的大小实际是包含着父类一直到根类的大小的集合。跟方法没有关系。每个类的方法(实例方法和类方法都是固定的) 跟实际的对象没关系！只跟类有关系</p>
<h3 id="调用方法的流程-对象方法和类方法"><a href="#调用方法的流程-对象方法和类方法" class="headerlink" title="调用方法的流程 对象方法和类方法"></a>调用方法的流程 对象方法和类方法</h3><p><img src="http://static.oschina.net/uploads/img/201311/25085218_epWy.png" alt="方法调用流程"></p>
<p>如果当前类(元类)没有找到对应的实例方法(类方法),那么就去他的父类(父类的元类)查找,如果一直到根类仍然无法找到这个方法，那么会抛出unrecognized selector sent to instance异常</p>
<p>如果想要阻止这次异常 可以使用运行时的方法进行补救！</p>
<p><img src="https://raw.githubusercontent.com/WiInputMethod/interview/master/img/ios-runtime-method-resolve.png" alt="运行时补救"></p>
<h3 id="元类是个什么东西-元类只是存放类方法吗？"><a href="#元类是个什么东西-元类只是存放类方法吗？" class="headerlink" title="元类是个什么东西 元类只是存放类方法吗？"></a>元类是个什么东西 元类只是存放类方法吗？</h3><p>类对象(class object)中包含了类的实例变量，实例方法的定义，而元类对象(metaclass object)中包括了类的类方法(也就是C++中的静态方法)的定义。类对象和元类对象中水果公司当然还会包含一些其它的东西，以后也可能添加其它的内容，但对于我们了解其内存布局来说，只需要记住：类对象存的是关于实例对象的信息(变量，实例方法等)，而元类对象(metaclass object)中存储的是关于类的信息(类的版本，名字，类方法等)。要注意的是，类对象(class object)和元类对象(metaclass object)的定义都是objc_class结构，其不同仅仅是在用途上，比如其中的方法列表在类对象(instance object)中保存的是实例方法(instance method)，而在元类对象(metaclass object)中则保存的是类方法(class method)。</p>
<p>15、为什么类方法和实例方法分开存？</p>
<ul>
<li>类方法不需要创建一个类的实例就可以调用！对象方法必须创建这个类的实例才可以调用</li>
<li>如果放在一起 可能存在重名的情况</li>
</ul>
<h3 id="谈谈Runloop"><a href="#谈谈Runloop" class="headerlink" title="谈谈Runloop"></a>谈谈Runloop</h3><p><a href="https://blog.ibireme.com/2015/05/18/runloop/">深入理解RunLoop</a><br><a href="https://hit-alibaba.github.io/interview/iOS/ObjC-Basic/Runloop.html">RunLoop</a></p>
<h3 id="runloop和线程是什么关系？-runloop和autoreleasepool是什么关系"><a href="#runloop和线程是什么关系？-runloop和autoreleasepool是什么关系" class="headerlink" title="runloop和线程是什么关系？ runloop和autoreleasepool是什么关系"></a>runloop和线程是什么关系？ runloop和autoreleasepool是什么关系</h3><h4 id="Runloop和线程"><a href="#Runloop和线程" class="headerlink" title="Runloop和线程"></a>Runloop和线程</h4><p>线程和 RunLoop 之间是一一对应的，其关系是保存在一个全局的 Dictionary 里。线程刚创建时并没有 RunLoop，如果你不主动获取，那它一直都不会有。RunLoop 的创建是发生在第一次获取时，RunLoop 的销毁是发生在线程结束时。你只能在一个线程的内部获取其 RunLoop（主线程除外）。</p>
<p>首先我们要明确一个概念，线程一般都是一次执行完任务，就销毁了。<br>而添加了runloop，并运行起来，实际上是添加了一个do,while循环，这样这个线程的程序一直卡在这个do,while循环上，这样相当于线程的任务一直没有执行完，所以线程一直不会销毁。</p>
<p>所以，一旦我们添加了一个runloop，并run了，我们如果要销毁这个线程，必须停止runloop</p>
<h4 id="Runloop和-autoreleasepool"><a href="#Runloop和-autoreleasepool" class="headerlink" title="Runloop和 autoreleasepool"></a>Runloop和 autoreleasepool</h4><p>App启动后，苹果在主线程 RunLoop 里注册了两个 Observer，其回调都是 _wrapRunLoopWithAutoreleasePoolHandler()。</p>
<p>第一个 Observer 监视的事件是 Entry(即将进入Loop)，其回调内会调用 _objc_autoreleasePoolPush() 创建自动释放池。其 order 是-2147483647，优先级最高，保证创建释放池发生在其他所有回调之前。</p>
<p>第二个 Observer 监视了两个事件： BeforeWaiting(准备进入休眠) 时调用_objc_autoreleasePoolPop() 和 _objc_autoreleasePoolPush() 释放旧的池并创建新池；Exit(即将退出Loop) 时调用 _objc_autoreleasePoolPop() 来释放自动释放池。这个 Observer 的 order 是 2147483647，优先级最低，保证其释放池子发生在其他所有回调之后。</p>
<p>在主线程执行的代码，通常是写在诸如事件回调、Timer回调内的。这些回调会被 RunLoop 创建好的 AutoreleasePool 环绕着，所以不会出现内存泄漏，开发者也不必显示创建 Pool 了</p>
<h3 id="一个runloop中可以有多个autoreleasepool吗？"><a href="#一个runloop中可以有多个autoreleasepool吗？" class="headerlink" title="一个runloop中可以有多个autoreleasepool吗？"></a>一个runloop中可以有多个autoreleasepool吗？</h3><pre><code>可以,这个不多说!</code></pre>
<h3 id="如何拿到一个runloop的所有状态"><a href="#如何拿到一个runloop的所有状态" class="headerlink" title="如何拿到一个runloop的所有状态"></a>如何拿到一个runloop的所有状态</h3><p>CFRunLoopObserverRef是观察者，能够监听RunLoop的状态改变</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&#x2F;&#x2F;创建一个runloop监听者<br><br>    CFRunLoopObserverRef observer &#x3D; CFRunLoopObserverCreateWithHandler(CFAllocatorGetDefault(),kCFRunLoopAllActivities, YES, 0, ^(CFRunLoopObserverRef observer, CFRunLoopActivity activity) &#123;<br><br>        NSLog(@&quot;监听runloop状态改变---%zd&quot;,activity);<br><br>    &#125;);<br><br>    &#x2F;&#x2F;为runloop添加一个监听者<br><br>    CFRunLoopAddObserver(CFRunLoopGetCurrent(), observer, kCFRunLoopDefaultMode);<br><br>    CFRelease(observer);<br><br></code></pre></td></tr></table></figure>

<p>监听的状态:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123;<br><br>    kCFRunLoopEntry &#x3D; (1UL &lt;&lt; 0),   &#x2F;&#x2F;即将进入Runloop<br><br>    kCFRunLoopBeforeTimers &#x3D; (1UL &lt;&lt; 1),    &#x2F;&#x2F;即将处理NSTimer<br><br>    kCFRunLoopBeforeSources &#x3D; (1UL &lt;&lt; 2),   &#x2F;&#x2F;即将处理Sources<br><br>    kCFRunLoopBeforeWaiting &#x3D; (1UL &lt;&lt; 5),   &#x2F;&#x2F;即将进入休眠<br><br>    kCFRunLoopAfterWaiting &#x3D; (1UL &lt;&lt; 6),    &#x2F;&#x2F;刚从休眠中唤醒<br><br>    kCFRunLoopExit &#x3D; (1UL &lt;&lt; 7),            &#x2F;&#x2F;即将退出runloop<br><br>    kCFRunLoopAllActivities &#x3D; 0x0FFFFFFFU   &#x2F;&#x2F;所有状态改变<br><br>&#125;;<br><br></code></pre></td></tr></table></figure>

<h3 id="NSTimer是准确的timer吗？为什么？"><a href="#NSTimer是准确的timer吗？为什么？" class="headerlink" title="NSTimer是准确的timer吗？为什么？"></a>NSTimer是准确的timer吗？为什么？</h3><p>NSTimer不是准确的timer 其所在的 RunLoop 会定时检测是否可以触发 NSTimer 的事件，但由于 iOS 有多个 RunLoop 的运行模式，如果被切到另一个 run loop，NSTimer 就不会被触发。每个 RunLoop 的循环间隔也无法保证，当某个任务耗时比较久，RunLoop 的下一个消息处理就只能顺延，导致 NSTimer 的时间已经到达，但 Runloop 却无法及时触发 NSTimer，导致该时间点的回调被错过。</p>
<p>苹果官方文档：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">A timer is not a real-time mechanism; it fires only when one of the run loop modes to which the timer has been added is running and able to check if the timer’s firing time has passed. If a timer’s firing time occurs during a long callout or while the run loop is in a mode that is not monitoring the timer, the timer does not fire until the next time the run loop checks the timer.<br></code></pre></td></tr></table></figure>

<h4 id="其他更准确的Timer"><a href="#其他更准确的Timer" class="headerlink" title="其他更准确的Timer"></a>其他更准确的Timer</h4><h5 id="CADisplayLink"><a href="#CADisplayLink" class="headerlink" title="CADisplayLink"></a>CADisplayLink</h5><p>CADisplayLink是一个频率能达到屏幕刷新率的定时器类。iPhone屏幕刷新频率为60帧/秒，也就是说最小间隔可以达到1/60s。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">CADisplayLink * displayLink &#x3D; [CADisplayLink displayLinkWithTarget:self selector:@selector(logInfo)];<br>[displayLink addToRunLoop:[NSRunLoop currentRunLoop] forMode:NSDefaultRunLoopMode];<br><br></code></pre></td></tr></table></figure>
<h5 id="GCD定时器"><a href="#GCD定时器" class="headerlink" title="GCD定时器"></a>GCD定时器</h5><p>我们知道，RunLoop是dispatch_source_t实现的timer，所以理论上来说，GCD定时器的精度比NSTimer只高不低。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">NSTimeInterval interval &#x3D; 1.0;<br>_timer &#x3D; dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0));<br>dispatch_source_set_timer(_timer, dispatch_walltime(NULL, 0), interval * NSEC_PER_SEC, 0);<br>dispatch_source_set_event_handler(_timer, ^&#123;<br>    NSLog(@&quot;GCD timer test&quot;);<br>&#125;);<br>dispatch_resume(_timer);<br></code></pre></td></tr></table></figure>

<h5 id="mach-absolute-time"><a href="#mach-absolute-time" class="headerlink" title="mach_absolute_time"></a>mach_absolute_time</h5><p>使用mach_absolute_time()来实现更高精度的定时器。<br>iPhone上有这么一个均匀变化的东西来提供给我们作为时间参考，就是CPU的时钟周期数（ticks）。<br>通过mach_absolute_time()获取CPU已运行的tick数量。将tick数经过转换变成秒或者纳秒，从而实现时间的计算。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">#include &lt;mach&#x2F;mach.h&gt;<br>#include &lt;mach&#x2F;mach_time.h&gt;<br> <br>static const uint64_t NANOS_PER_USEC &#x3D; 1000ULL;<br>static const uint64_t NANOS_PER_MILLISEC &#x3D; 1000ULL * NANOS_PER_USEC;<br>static const uint64_t NANOS_PER_SEC &#x3D; 1000ULL * NANOS_PER_MILLISEC;<br> <br>static mach_timebase_info_data_t timebase_info;<br><br>static uint64_t nanos_to_abs(uint64_t nanos) &#123;<br>    return nanos * timebase_info.denom &#x2F; timebase_info.numer;<br>&#125;<br><br>void waitSeconds(int seconds) &#123;<br>    mach_timebase_info(&amp;timebase_info);<br>    uint64_t time_to_wait &#x3D; nanos_to_abs(seconds * NANOS_PER_SEC);<br>    uint64_t now &#x3D; mach_absolute_time();<br>    mach_wait_until(now + time_to_wait);<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p><code>理论上这是iPhone上最精准的定时器，可以达到纳秒级别的精度</code></p>
<p>21、performselector在一个子线程执行,是会自动执行的吗？</p>
<p>performSelector原理是：设置一个timer，添加到当前线程Runloop，默认是NSDefaultRunLoopMode；通过NSTimer的 scheduledTimerWithTimeIntervaly创建的定时器，也是自动被添加到当前RunLoop中，默认是NSDefaultRunLoopMode；</p>
<p>在子线程中，因为默认没有RunLoop，所以他们不执行；想要执行，需要创建并启动Runloop</p>
<p>手动开启：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">- (void)viewDidLoad<br>&#123;<br>    [super viewDidLoad];<br>    <br>    [self threadInfo:@&quot;UI&quot;];<br>    <br>    _isNewThreadAborted &#x3D; NO;<br>    _thread &#x3D; [[NSThread alloc] initWithTarget:self selector:@selector(newThread:) object:nil];<br>    &#x2F;&#x2F;开始线程<br>    [_thread start];<br>    &#x2F;&#x2F;在另一个线程中的Run Loop中执行Selector<br>    [self performSelector:@selector(test:) onThread:_thread withObject:nil waitUntilDone:NO];    <br>&#125;<br><br>&#x2F;&#x2F;在新线程中创建并开始一个NSRunLoop<br>- (void)newThread:(id)obj<br>&#123;<br>    @autoreleasepool<br>    &#123;<br>        NSRunLoop *currentRunLoop &#x3D; [NSRunLoop currentRunLoop];<br>        while (!_isNewThreadAborted)<br>        &#123;<br>            [currentRunLoop runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]];<br>        &#125;<br>        NSLog(@&quot;线程停止&quot;);<br>    &#125;<br>&#125;<br><br>&#x2F;&#x2F;Selector执行<br>- (void)test:(id)obj<br>&#123;<br>    [self threadInfo:@&quot;test&quot;];<br>    _isNewThreadAborted &#x3D; YES;<br>&#125;<br><br>- (void)threadInfo:(NSString*)category<br>&#123;<br>    NSLog(@&quot;%@ - %@&quot;, category, [NSThread currentThread]);<br>&#125;<br><br></code></pre></td></tr></table></figure>


<h3 id="GCD-队列和线程是什么关系？"><a href="#GCD-队列和线程是什么关系？" class="headerlink" title="GCD 队列和线程是什么关系？"></a>GCD 队列和线程是什么关系？</h3><h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><ul>
<li>主队列</li>
<li>串行队列</li>
<li>并发队列</li>
<li>全局队列</li>
</ul>
<h4 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h4><ul>
<li>同步执行</li>
<li>异步执行 </li>
</ul>
<h4 id="交叉出现的情况"><a href="#交叉出现的情况" class="headerlink" title="交叉出现的情况"></a>交叉出现的情况</h4><h5 id="串行队列，同步执行"><a href="#串行队列，同步执行" class="headerlink" title="串行队列，同步执行"></a>串行队列，同步执行</h5><p>不会开线程，顺序执行</p>
<h5 id="串行队列，异步执行"><a href="#串行队列，异步执行" class="headerlink" title="串行队列，异步执行"></a>串行队列，异步执行</h5><p>会开线程(1条)，顺序执行</p>
<h5 id="并发队列，异步执行"><a href="#并发队列，异步执行" class="headerlink" title="并发队列，异步执行"></a>并发队列，异步执行</h5><p>会开线程，不会顺序执行，具体开几条线程取决于队列</p>
<h5 id="并发队列，同步执行"><a href="#并发队列，同步执行" class="headerlink" title="并发队列，同步执行"></a>并发队列，同步执行</h5><p>和串行队列同步执行效果一样</p>
<h5 id="主队列，异步执行"><a href="#主队列，异步执行" class="headerlink" title="主队列，异步执行"></a>主队列，异步执行</h5><p>不开线程，异步任务必须等待主线程上的任务完成之后才会被调用</p>
<h5 id="主队列、同步执行"><a href="#主队列、同步执行" class="headerlink" title="主队列、同步执行"></a>主队列、同步执行</h5><p>会发生死锁，因为，同步任务要求必须顺序执行，但是同步任务必须等待主队列中没有任务可以被调用的时候才会被执行，因此这两方会造成死锁的情况</p>
<h5 id="同步任务的特点"><a href="#同步任务的特点" class="headerlink" title="同步任务的特点"></a>同步任务的特点</h5><p>可以再多个异步任务调度前，指定一个同步任务，让所有的异步任务，等待同步任务执行完成，这就是所谓的依赖关系</p>
<h5 id="全局队列"><a href="#全局队列" class="headerlink" title="全局队列"></a>全局队列</h5><p>系统提供给程序员，方便程序员使用的全局队列，有关服务质量的问题，使用下面的代码能够做到IOS7&amp;IOS8的适配，全局队列本质上就是一个异步队列</p>
<h3 id="一个队列可以管理多少线程？"><a href="#一个队列可以管理多少线程？" class="headerlink" title="一个队列可以管理多少线程？"></a>一个队列可以管理多少线程？</h3><p>并发队列可以分配多个线程，同时处理不同的任务；效率虽然提升了，但是多线程的并发是用时间片轮转方法实现的，线程创建、销毁、上下文切换等会消耗CPU 资源。</p>
<p>目前iPhone的处理器是多核（2个、4个），适当的并发可以提高效率，但是无节制地并发，如将大量任务不加思索就用并发队列来执行，这只会大量增加线程数，抢占CPU资源，甚至会挤占掉主线程的 CPU 资源（极端情况）。</p>
<p>可以使用 NSOperationQueue 设置maxConcurrentOperationCount 最大并发数</p>
<h4 id="串行队列中的所有任务都会在一条线程中执行吗"><a href="#串行队列中的所有任务都会在一条线程中执行吗" class="headerlink" title="串行队列中的所有任务都会在一条线程中执行吗"></a>串行队列中的所有任务都会在一条线程中执行吗</h4><pre><code>串行队列中的任务不会开多条线程,回一个一个执行,但是每一个任务所在的线程不一定是一个,但同时只会存在一条线程</code></pre>
<h3 id="白板画线-如何在点之间连线-用什么去重绘的"><a href="#白板画线-如何在点之间连线-用什么去重绘的" class="headerlink" title="白板画线(如何在点之间连线)  用什么去重绘的"></a>白板画线(如何在点之间连线)  用什么去重绘的</h3><p>利用贝塞尔曲线</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">-(<span class="hljs-built_in">UIBezierPath</span>*)drawSigleLine:(<span class="hljs-built_in">NSArray</span>*)line needStroke:(<span class="hljs-built_in">BOOL</span>)needStroke<br>&#123;<br>    <span class="hljs-built_in">NSUInteger</span> pointsCount = line.count;<br>    <br>    ArtWhiteBoardPoint *firstPoint = [line objectAtIndex:<span class="hljs-number">0</span>];<br>    <span class="hljs-built_in">UIBezierPath</span> *path = [[<span class="hljs-built_in">UIBezierPath</span> alloc] init];<br>    path.lineWidth = [<span class="hljs-keyword">self</span> getDrawWidth:firstPoint.penStyle.lineWidth];<br>    path.lineJoinStyle = kCGLineJoinRound;<br>    path.lineCapStyle = kCGLineCapRound;<br>    <span class="hljs-built_in">UIColor</span> *lineColor;<br>    <span class="hljs-keyword">if</span> (firstPoint.penStyle.isEarser) &#123;<br>        lineColor = [<span class="hljs-built_in">UIColor</span> clearColor];<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        lineColor = [<span class="hljs-built_in">UIColor</span> colorWithHexString:firstPoint.penStyle.colorString alpha:<span class="hljs-number">1.0</span>];<br>    &#125;<br>    <span class="hljs-keyword">if</span> (lineColor == [<span class="hljs-built_in">UIColor</span> clearColor]) &#123;<br>        path.lineCapStyle = kCGLineCapSquare;<br>        path.lineWidth = [<span class="hljs-keyword">self</span> getDrawWidth:[<span class="hljs-keyword">self</span>.dataSource earserWidth:firstPoint.penStyle.isLargeEarser]];<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">NSUInteger</span> j = <span class="hljs-number">0</span> ; j &lt; pointsCount; j ++) &#123;<br>        ArtWhiteBoardPoint *point = [line objectAtIndex:j];<br>        <span class="hljs-built_in">CGPoint</span> p;<br>        p = <span class="hljs-built_in">CGPointMake</span>(point.xScale * <span class="hljs-keyword">self</span>.frame.size.width ,  point.yScale * <span class="hljs-keyword">self</span>.frame.size.height);<br>        <br>        <span class="hljs-keyword">if</span> (j == <span class="hljs-number">0</span>) &#123;<br>            [path moveToPoint:p];<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>.controlP1.x==p.x&amp;&amp;<span class="hljs-keyword">self</span>.controlP1.y==p.y) &#123;<br>                <br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                [path addQuadCurveToPoint:<span class="hljs-built_in">CGPointMake</span>((<span class="hljs-keyword">self</span>.controlP1.x+p.x)/<span class="hljs-number">2</span>, (<span class="hljs-keyword">self</span>.controlP1.y+p.y)/<span class="hljs-number">2</span>) controlPoint:<span class="hljs-keyword">self</span>.controlP1];<br>            &#125;<br>            <br>            <br>        &#125;<br>        <span class="hljs-keyword">self</span>.controlP1 = p;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (needStroke) &#123;<br>        [lineColor setStroke];<br>        <br>        <span class="hljs-keyword">if</span> (lineColor == [<span class="hljs-built_in">UIColor</span> clearColor]) &#123;<br>            [path strokeWithBlendMode:kCGBlendModeCopy alpha:<span class="hljs-number">1.0</span>];<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            [path strokeWithBlendMode:kCGBlendModeNormal alpha:<span class="hljs-number">1.0</span>];<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> path;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><a href="https://cloud.tencent.com/developer/article/1018499">iOS开发之画图板(贝塞尔曲线)</a></p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://hit-alibaba.github.io/interview/basic/algo/Hash-Table.html">面试基础-哈希表</a></p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>数据结果 算法 计算机基础</tag>
      </tags>
  </entry>
  <entry>
    <title>滚动视图的ReloadData和VisibleCells</title>
    <url>/2019/10/20/reloadDataandvisibleCells/</url>
    <content><![CDATA[<p>作为<code>UIScrollView</code>的子类<code>UITableView</code>和<code>UICollectionView</code>是我们平时开发中最常使用的两个列表控件。同时在一些复杂的页面中也经常嵌套使用,同时由于对其有些方法理解的不够深入,很容易导致一些比较诡异的问题。</p>
<p>因此这里单独写一篇文章来介绍这两个常用控件中的几个常用的方法,希望可以加深大家对<code>UITableView</code>和<code>UICollectionView</code>的理解。</p>
<a id="more"></a>

<h3 id="数据刷新-reloadData"><a href="#数据刷新-reloadData" class="headerlink" title="数据刷新 reloadData"></a>数据刷新 reloadData</h3><p><code>为了更好的理解方法的调用链,我们会添加一个队runloop的监听</code></p>
<h4 id="UITableView"><a href="#UITableView" class="headerlink" title="UITableView"></a>UITableView</h4><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g83s1tlrh1j30ak0kjaag.jpg" alt="demo"></p>
<p>上图是我们demo的样子(只有一个cell)。</p>
<p>下面我们来看代码:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">- (<span class="hljs-keyword">void</span>)reloadTableData &#123;<br> <br>    [<span class="hljs-keyword">self</span>.tableView reloadData];<br> <br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;reloadData 执行完成&quot;</span>);<br> <br>&#125;<br></code></pre></td></tr></table></figure>
<p>点击Demo中左上角的reloadData会调用reloadTableData方法。</p>
<p>下面我们来看控制台打印结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">2019-10-08 19:32:21.875441+0800 LayoutIfNeed[3662:223502] RunLoop被唤醒<br> <br>2019-10-08 19:32:21.876164+0800 LayoutIfNeed[3662:223502] RunLoop即将处理Timer事件<br> <br>2019-10-08 19:32:21.876295+0800 LayoutIfNeed[3662:223502] RunLoop即将处理Source事件<br> <br>2019-10-08 19:32:21.877622+0800 LayoutIfNeed[3662:223502] -[ULTableView reloadData]<br> <br>2019-10-08 19:32:21.880310+0800 LayoutIfNeed[3662:223502] -[ViewController numberOfSectionsInTableView:]<br> <br>2019-10-08 19:32:21.880779+0800 LayoutIfNeed[3662:223502] -[ULTableView setNeedsLayout]<br> <br>2019-10-08 19:32:21.881075+0800 LayoutIfNeed[3662:223502] -[ViewController tableView:numberOfRowsInSection:]<br> <br>2019-10-08 19:32:21.881755+0800 LayoutIfNeed[3662:223502] -[ULTableView setNeedsLayout]<br> <br>2019-10-08 19:32:21.881921+0800 LayoutIfNeed[3662:223502] -[ULTableView setNeedsLayout]<br> <br>2019-10-08 19:32:21.882095+0800 LayoutIfNeed[3662:223502] -[ULTableView setNeedsLayout]<br> <br>2019-10-08 19:32:21.882227+0800 LayoutIfNeed[3662:223502] reloadData 执行完成<br> <br>2019-10-08 19:32:21.883112+0800 LayoutIfNeed[3662:223502] RunLoop即将处理Timer事件<br> <br>2019-10-08 19:32:21.883582+0800 LayoutIfNeed[3662:223502] RunLoop即将处理Source事件<br> <br>2019-10-08 19:32:21.906191+0800 LayoutIfNeed[3662:223502] RunLoop即将休眠<br> <br>2019-10-08 19:32:21.907129+0800 LayoutIfNeed[3662:223502] -[ULTableView layoutSubviews]<br> <br>2019-10-08 19:32:21.907349+0800 LayoutIfNeed[3662:223502] -[ULTableView dequeueReusableCellWithIdentifier:]<br> <br>2019-10-08 19:32:21.908622+0800 LayoutIfNeed[3662:223502] -[ViewController tableView:cellForRowAtIndexPath:] 0 0<br> <br>2019-10-08 19:32:21.909076+0800 LayoutIfNeed[3662:223502] -[ViewController tableView:heightForRowAtIndexPath:]<br> <br>2019-10-08 19:32:21.909236+0800 LayoutIfNeed[3662:223502] -[ULTableView setNeedsLayout]<br> <br>2019-10-08 19:32:21.909670+0800 LayoutIfNeed[3662:223502] -[ULTableView setNeedsLayout]<br> <br>2019-10-08 19:32:21.909991+0800 LayoutIfNeed[3662:223502] -[ULTableView layoutSubviews]<br></code></pre></td></tr></table></figure>

<p>首先看到了我们比较熟悉的方法<code>numberOfSectionsInTableView</code>、<code>dequeueReusableCellWithIdentifier</code>、<code>tableView:heightForRowAtIndexPath:</code>、<code>tableView:cellForRowAtIndexPath:</code></p>
<p>这些方法都是我们比较熟悉的方法了,这里我就不再赘述。</p>
<p>其次根据log我们可以比较清晰的的出另外一个结论：<br><code>reloadData是一个异步方法,reloadData在当前的Runloop中只是做了setNeedsLayout(表示当前view在下一个runloop到来时需要被更新),显然当前Runloop结束后才根据之前设置setNeedsLayout的标记执行layoutSubviews方法进而触发页面的更新</code></p>
<h4 id="UICollectionView"><a href="#UICollectionView" class="headerlink" title="UICollectionView"></a>UICollectionView</h4><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g83un68eevj30l4152q4f.jpg" alt="demo"></p>
<p>上图是我们demo的样子(只展示了一个cell)。</p>
<p>下面我们在来看下代码：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">- (<span class="hljs-keyword">void</span>)reloadCollectionViewData &#123;<br>    [<span class="hljs-keyword">self</span>.collectionView reloadData];<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;reloadData 执行完成&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>点击demo的左上角按钮即调用reloadData方法<br>下面看下打印结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">2019-10-19 21:50:36.219755+0800 LayoutIfNeed[4002:2375227] RunLoop被唤醒<br>2019-10-19 21:50:36.220045+0800 LayoutIfNeed[4002:2375227] RunLoop即将处理Timer事件<br>2019-10-19 21:50:36.220326+0800 LayoutIfNeed[4002:2375227] RunLoop即将处理Source事件<br>2019-10-19 21:50:36.221302+0800 LayoutIfNeed[4002:2375227] -[ULCollectionView reloadData]<br>2019-10-19 21:50:36.221610+0800 LayoutIfNeed[4002:2375227] -[ULCollectionView setNeedsLayout]<br>2019-10-19 21:50:36.221826+0800 LayoutIfNeed[4002:2375227] -[ULCollectionView setNeedsLayout]<br>2019-10-19 21:50:36.221993+0800 LayoutIfNeed[4002:2375227] -[ULCollectionView setNeedsLayout]<br>2019-10-19 21:50:36.222109+0800 LayoutIfNeed[4002:2375227] -[ULCollectionView setNeedsLayout]<br>2019-10-19 21:50:36.222532+0800 LayoutIfNeed[4002:2375227] -[ULCollectionView setNeedsLayout]<br>2019-10-19 21:50:36.222939+0800 LayoutIfNeed[4002:2375227] reloadData 执行完成<br>2019-10-19 21:50:36.223924+0800 LayoutIfNeed[4002:2375227] RunLoop即将处理Timer事件<br>2019-10-19 21:50:36.224480+0800 LayoutIfNeed[4002:2375227] RunLoop即将处理Source事件<br>2019-10-19 21:50:36.225190+0800 LayoutIfNeed[4002:2375227] RunLoop即将休眠<br>2019-10-19 21:50:36.226107+0800 LayoutIfNeed[4002:2375227] -[ULCollectionView layoutSubviews]<br>2019-10-19 21:50:36.226609+0800 LayoutIfNeed[4002:2375227] -[ULCollectionViewController numberOfSectionsInCollectionView:]<br>2019-10-19 21:50:36.226864+0800 LayoutIfNeed[4002:2375227] -[ULCollectionViewController collectionView:numberOfItemsInSection:]<br>2019-10-19 21:50:36.323486+0800 LayoutIfNeed[4002:2375227] -[ULCollectionView dequeueReusableCellWithReuseIdentifier:forIndexPath:]<br>2019-10-19 21:50:36.324053+0800 LayoutIfNeed[4002:2375227] -[ULCollectionViewController collectionView:cellForItemAtIndexPath:]<br></code></pre></td></tr></table></figure>
<p>从log中我们看出<code>UICollectionView</code>与<code>UITableView</code>的效果一致。因此其结论与<code>UITableView</code>也是一致。</p>
<h4 id="tableView中嵌套collectionView"><a href="#tableView中嵌套collectionView" class="headerlink" title="tableView中嵌套collectionView"></a>tableView中嵌套collectionView</h4><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g83yoeib27j30l4152gn7.jpg" alt="demo"></p>
<p>demo中tableView含两个cell 第一个cell上add一个collectionView,第二个cell为一个tableViewCell</p>
<p>点击右上角<code>reloadTableData</code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">- (void)reloadTableData &#123;<br>    NSLog(@&quot;%s&quot;,__func__);<br>    [self.tableView reloadData];<br>&#125;<br></code></pre></td></tr></table></figure>

<p>log:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">2019-10-20 08:45:10.415969+0800 LayoutIfNeed[5741:2466905] UIInnerCollectionView RunLoop即将处理Source事件<br>2019-10-20 08:45:10.417080+0800 LayoutIfNeed[5741:2466905] -[TableCollectionViewController reloadTableData]<br>2019-10-20 08:45:10.417207+0800 LayoutIfNeed[5741:2466905] -[ULTableView reloadData]<br>2019-10-20 08:45:10.417477+0800 LayoutIfNeed[5741:2466905] -[TableCollectionViewController numberOfSectionsInTableView:]<br>2019-10-20 08:45:10.417632+0800 LayoutIfNeed[5741:2466905] -[ULTableView setNeedsLayout]<br>2019-10-20 08:45:10.418072+0800 LayoutIfNeed[5741:2466905] -[TableCollectionViewController tableView:numberOfRowsInSection:]<br>2019-10-20 08:45:10.418353+0800 LayoutIfNeed[5741:2466905] -[ULTableView setNeedsLayout]<br>2019-10-20 08:45:10.418493+0800 LayoutIfNeed[5741:2466905] -[ULTableView setNeedsLayout]<br>2019-10-20 08:45:10.418716+0800 LayoutIfNeed[5741:2466905] -[ULTableView setNeedsLayout]<br>2019-10-20 08:45:10.419573+0800 LayoutIfNeed[5741:2466905] TableCollectionViewController RunLoop即将处理Timer事件<br>2019-10-20 08:45:10.419701+0800 LayoutIfNeed[5741:2466905] UIInnerCollectionView RunLoop即将处理Timer事件<br>2019-10-20 08:45:10.419813+0800 LayoutIfNeed[5741:2466905] TableCollectionViewController RunLoop即将处理Source事件<br>2019-10-20 08:45:10.420023+0800 LayoutIfNeed[5741:2466905] UIInnerCollectionView RunLoop即将处理Source事件<br>2019-10-20 08:45:10.420644+0800 LayoutIfNeed[5741:2466905] TableCollectionViewController RunLoop即将休眠<br>2019-10-20 08:45:10.420774+0800 LayoutIfNeed[5741:2466905] UIInnerCollectionView RunLoop即将休眠<br>2019-10-20 08:45:10.421129+0800 LayoutIfNeed[5741:2466905] -[ULTableView layoutSubviews]<br>2019-10-20 08:45:10.421393+0800 LayoutIfNeed[5741:2466905] -[ULTableView dequeueReusableCellWithIdentifier:]<br>2019-10-20 08:45:10.421851+0800 LayoutIfNeed[5741:2466905] -[TableCollectionViewController tableView:cellForRowAtIndexPath:] 0 0<br>2019-10-20 08:45:10.422269+0800 LayoutIfNeed[5741:2466905] -[ULCollectionView reloadData]<br>2019-10-20 08:45:10.422648+0800 LayoutIfNeed[5741:2466905] -[ULCollectionView setNeedsLayout]<br>2019-10-20 08:45:10.423020+0800 LayoutIfNeed[5741:2466905] -[ULCollectionView setNeedsLayout]<br>2019-10-20 08:45:10.423360+0800 LayoutIfNeed[5741:2466905] -[ULCollectionView setNeedsLayout]<br>2019-10-20 08:45:10.423758+0800 LayoutIfNeed[5741:2466905] -[ULCollectionView setNeedsLayout]<br>2019-10-20 08:45:10.424125+0800 LayoutIfNeed[5741:2466905] -[ULCollectionView setNeedsLayout]<br>2019-10-20 08:45:10.424765+0800 LayoutIfNeed[5741:2466905] -[TableCollectionViewController tableView:heightForRowAtIndexPath:]<br>2019-10-20 08:45:10.424898+0800 LayoutIfNeed[5741:2466905] -[ULTableView setNeedsLayout]<br>2019-10-20 08:45:10.425206+0800 LayoutIfNeed[5741:2466905] -[ULCollectionView layoutSubviews]<br>2019-10-20 08:45:10.425470+0800 LayoutIfNeed[5741:2466905] -[UIInnerCollectionView numberOfSectionsInCollectionView:]<br>2019-10-20 08:45:10.425776+0800 LayoutIfNeed[5741:2466905] -[UIInnerCollectionView collectionView:numberOfItemsInSection:]<br>2019-10-20 08:45:10.427618+0800 LayoutIfNeed[5741:2466905] -[ULCollectionView dequeueReusableCellWithReuseIdentifier:forIndexPath:]<br>2019-10-20 08:45:10.427884+0800 LayoutIfNeed[5741:2466905] -[UIInnerCollectionView collectionView:cellForItemAtIndexPath:]<br>2019-10-20 08:45:10.428257+0800 LayoutIfNeed[5741:2466905] -[ULTableView dequeueReusableCellWithIdentifier:]<br>2019-10-20 08:45:10.428505+0800 LayoutIfNeed[5741:2466905] -[TableCollectionViewController tableView:cellForRowAtIndexPath:] 0 1<br>2019-10-20 08:45:10.429038+0800 LayoutIfNeed[5741:2466905] -[TableCollectionViewController tableView:heightForRowAtIndexPath:]<br>2019-10-20 08:45:10.429178+0800 LayoutIfNeed[5741:2466905] -[ULTableView setNeedsLayout]<br>2019-10-20 08:45:10.429590+0800 LayoutIfNeed[5741:2466905] -[ULTableView setNeedsLayout]<br>2019-10-20 08:45:10.429988+0800 LayoutIfNeed[5741:2466905] -[ULTableView layoutSubviews]<br></code></pre></td></tr></table></figure>

<p>根据上面的log我们看到UITableView在执行reloadData之后仍让只是做了标记。在下一个runloop到来之后触发<code>UITableView</code>的<code>layoutSubviews</code>方法进而又触发该Cell中UICollectionView的reloadData操作</p>
<p>如果我们不主动的调用reloadData呢？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">2019-10-20 09:05:20.372536+0800 LayoutIfNeed[5867:2475442] -[TableCollectionViewController reloadTableData]<br>2019-10-20 09:05:40.060940+0800 LayoutIfNeed[5867:2475442] -[ULTableView reloadData]<br>2019-10-20 09:05:40.061223+0800 LayoutIfNeed[5867:2475442] -[TableCollectionViewController numberOfSectionsInTableView:]<br>2019-10-20 09:05:40.061361+0800 LayoutIfNeed[5867:2475442] -[ULTableView setNeedsLayout]<br>2019-10-20 09:05:40.061539+0800 LayoutIfNeed[5867:2475442] -[TableCollectionViewController tableView:numberOfRowsInSection:]<br>2019-10-20 09:05:40.061691+0800 LayoutIfNeed[5867:2475442] -[ULTableView setNeedsLayout]<br>2019-10-20 09:05:40.061812+0800 LayoutIfNeed[5867:2475442] -[ULTableView setNeedsLayout]<br>2019-10-20 09:05:40.061950+0800 LayoutIfNeed[5867:2475442] -[ULTableView setNeedsLayout]<br>2019-10-20 09:05:40.062454+0800 LayoutIfNeed[5867:2475442] -[ULTableView layoutSubviews]<br>2019-10-20 09:05:40.062653+0800 LayoutIfNeed[5867:2475442] -[ULTableView dequeueReusableCellWithIdentifier:]<br>2019-10-20 09:05:40.062829+0800 LayoutIfNeed[5867:2475442] -[TableCollectionViewController tableView:cellForRowAtIndexPath:] 0 0<br>2019-10-20 09:06:08.551189+0800 LayoutIfNeed[5867:2475442] -[TableCollectionViewController tableView:heightForRowAtIndexPath:]<br>2019-10-20 09:06:08.551448+0800 LayoutIfNeed[5867:2475442] -[ULTableView setNeedsLayout]<br>2019-10-20 09:06:08.551836+0800 LayoutIfNeed[5867:2475442] -[ULTableView dequeueReusableCellWithIdentifier:]<br>2019-10-20 09:06:08.552087+0800 LayoutIfNeed[5867:2475442] -[TableCollectionViewController tableView:cellForRowAtIndexPath:] 0 1<br>2019-10-20 09:06:08.552490+0800 LayoutIfNeed[5867:2475442] -[TableCollectionViewController tableView:heightForRowAtIndexPath:]<br>2019-10-20 09:06:08.552625+0800 LayoutIfNeed[5867:2475442] -[ULTableView setNeedsLayout]<br>2019-10-20 09:06:08.552972+0800 LayoutIfNeed[5867:2475442] -[ULTableView setNeedsLayout]<br>2019-10-20 09:06:08.553263+0800 LayoutIfNeed[5867:2475442] -[ULTableView layoutSubviews]<br></code></pre></td></tr></table></figure>

<p>根据上面的日志我们看到,外部TableView的reloadData甚至是TableView的<code>layoutSubviews</code>操作均不会影响Cell中CollectionView。</p>
<h4 id="CollectionView中嵌套tableView"><a href="#CollectionView中嵌套tableView" class="headerlink" title="CollectionView中嵌套tableView"></a>CollectionView中嵌套tableView</h4><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g83z4a87hlj30l4152td5.jpg" alt="demo"></p>
<p>点击右上角reloadData 执行下面的代码</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">- (<span class="hljs-keyword">void</span>)reloadCollectionViewData &#123;<br>    [<span class="hljs-keyword">self</span>.collectionView reloadData];<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;reloadData 执行完成&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>下面我们来看下log</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">2019-10-20 08:48:14.430891+0800 LayoutIfNeed[5782:2468993] -[ULCollectionView reloadData]<br>2019-10-20 08:48:14.431133+0800 LayoutIfNeed[5782:2468993] -[ULCollectionView setNeedsLayout]<br>2019-10-20 08:48:14.431393+0800 LayoutIfNeed[5782:2468993] -[ULCollectionView setNeedsLayout]<br>2019-10-20 08:48:14.431817+0800 LayoutIfNeed[5782:2468993] -[ULCollectionView setNeedsLayout]<br>2019-10-20 08:48:14.432207+0800 LayoutIfNeed[5782:2468993] -[ULCollectionView setNeedsLayout]<br>2019-10-20 08:48:14.432420+0800 LayoutIfNeed[5782:2468993] -[ULCollectionView setNeedsLayout]<br>2019-10-20 08:48:14.432648+0800 LayoutIfNeed[5782:2468993] reloadData 执行完成<br>2019-10-20 08:48:14.433422+0800 LayoutIfNeed[5782:2468993] CollectionTableViewController RunLoop即将处理Timer事件<br>2019-10-20 08:48:14.433560+0800 LayoutIfNeed[5782:2468993] UIInnerTableView RunLoop即将处理Timer事件<br>2019-10-20 08:48:14.433762+0800 LayoutIfNeed[5782:2468993] CollectionTableViewController RunLoop即将处理Source事件<br>2019-10-20 08:48:14.434047+0800 LayoutIfNeed[5782:2468993] UIInnerTableView RunLoop即将处理Source事件<br>2019-10-20 08:48:14.434736+0800 LayoutIfNeed[5782:2468993] CollectionTableViewController RunLoop即将休眠<br>2019-10-20 08:48:14.434865+0800 LayoutIfNeed[5782:2468993] UIInnerTableView RunLoop即将休眠<br>2019-10-20 08:48:14.435240+0800 LayoutIfNeed[5782:2468993] -[ULCollectionView layoutSubviews]<br>2019-10-20 08:48:14.435422+0800 LayoutIfNeed[5782:2468993] -[CollectionTableViewController numberOfSectionsInCollectionView:]<br>2019-10-20 08:48:14.435568+0800 LayoutIfNeed[5782:2468993] -[CollectionTableViewController collectionView:numberOfItemsInSection:]<br>2019-10-20 08:48:14.437589+0800 LayoutIfNeed[5782:2468993] -[ULCollectionView dequeueReusableCellWithReuseIdentifier:forIndexPath:]<br>2019-10-20 08:48:14.438094+0800 LayoutIfNeed[5782:2468993] -[CollectionTableViewController collectionView:cellForItemAtIndexPath:]<br>2019-10-20 08:48:14.438444+0800 LayoutIfNeed[5782:2468993] -[ULTableView reloadData]<br>2019-10-20 08:48:14.438847+0800 LayoutIfNeed[5782:2468993] -[UIInnerTableView numberOfSectionsInTableView:]<br>2019-10-20 08:48:14.439129+0800 LayoutIfNeed[5782:2468993] -[ULTableView setNeedsLayout]<br>2019-10-20 08:48:14.439520+0800 LayoutIfNeed[5782:2468993] -[UIInnerTableView tableView:numberOfRowsInSection:]<br>2019-10-20 08:48:14.439828+0800 LayoutIfNeed[5782:2468993] -[ULTableView setNeedsLayout]<br>2019-10-20 08:48:14.440130+0800 LayoutIfNeed[5782:2468993] -[ULTableView setNeedsLayout]<br>2019-10-20 08:48:14.440494+0800 LayoutIfNeed[5782:2468993] -[ULTableView setNeedsLayout]<br>2019-10-20 08:48:14.441025+0800 LayoutIfNeed[5782:2468993] -[ULTableView layoutSubviews]<br>2019-10-20 08:48:14.441239+0800 LayoutIfNeed[5782:2468993] -[ULTableView dequeueReusableCellWithIdentifier:]<br>2019-10-20 08:48:14.441523+0800 LayoutIfNeed[5782:2468993] -[UIInnerTableView tableView:cellForRowAtIndexPath:] 0 0<br>2019-10-20 08:48:14.442092+0800 LayoutIfNeed[5782:2468993] -[UIInnerTableView tableView:heightForRowAtIndexPath:]<br>2019-10-20 08:48:14.442281+0800 LayoutIfNeed[5782:2468993] -[ULTableView setNeedsLayout]<br>2019-10-20 08:48:14.442722+0800 LayoutIfNeed[5782:2468993] -[ULTableView dequeueReusableCellWithIdentifier:]<br>2019-10-20 08:48:14.443052+0800 LayoutIfNeed[5782:2468993] -[UIInnerTableView tableView:cellForRowAtIndexPath:] 0 1<br>2019-10-20 08:48:14.443557+0800 LayoutIfNeed[5782:2468993] -[UIInnerTableView tableView:heightForRowAtIndexPath:]<br>2019-10-20 08:48:14.443796+0800 LayoutIfNeed[5782:2468993] -[ULTableView setNeedsLayout]<br>2019-10-20 08:48:14.444251+0800 LayoutIfNeed[5782:2468993] -[ULTableView dequeueReusableCellWithIdentifier:]<br>2019-10-20 08:48:14.444577+0800 LayoutIfNeed[5782:2468993] -[UIInnerTableView tableView:cellForRowAtIndexPath:] 0 2<br>2019-10-20 08:48:14.445056+0800 LayoutIfNeed[5782:2468993] -[UIInnerTableView tableView:heightForRowAtIndexPath:]<br>2019-10-20 08:48:14.445428+0800 LayoutIfNeed[5782:2468993] -[ULTableView setNeedsLayout]<br>2019-10-20 08:48:14.445989+0800 LayoutIfNeed[5782:2468993] -[ULTableView dequeueReusableCellWithIdentifier:]<br>2019-10-20 08:48:14.446264+0800 LayoutIfNeed[5782:2468993] -[UIInnerTableView tableView:cellForRowAtIndexPath:] 0 3<br>2019-10-20 08:48:14.446693+0800 LayoutIfNeed[5782:2468993] -[UIInnerTableView tableView:heightForRowAtIndexPath:]<br>2019-10-20 08:48:14.447040+0800 LayoutIfNeed[5782:2468993] -[ULTableView setNeedsLayout]<br>2019-10-20 08:48:14.447631+0800 LayoutIfNeed[5782:2468993] -[ULTableView dequeueReusableCellWithIdentifier:]<br>2019-10-20 08:48:14.448047+0800 LayoutIfNeed[5782:2468993] -[UIInnerTableView tableView:cellForRowAtIndexPath:] 0 4<br>2019-10-20 08:48:14.448584+0800 LayoutIfNeed[5782:2468993] -[UIInnerTableView tableView:heightForRowAtIndexPath:]<br>2019-10-20 08:48:14.448971+0800 LayoutIfNeed[5782:2468993] -[ULTableView setNeedsLayout]<br>2019-10-20 08:48:14.449616+0800 LayoutIfNeed[5782:2468993] -[ULTableView setNeedsLayout]<br>2019-10-20 08:48:14.450075+0800 LayoutIfNeed[5782:2468993] -[ULTableView layoutSubviews]<br></code></pre></td></tr></table></figure>

<p>上述结果同TableView中嵌套CollectionView相似。被嵌套的控件的</p>
<p>那么我们同样看下如果我们在TableView的CellForRow方法中不主动调用reloadData时log的结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">2019-10-20 08:58:07.783966+0800 LayoutIfNeed[5845:2473209] -[ULCollectionView reloadData]<br>2019-10-20 08:58:07.784219+0800 LayoutIfNeed[5845:2473209] -[ULCollectionView setNeedsLayout]<br>2019-10-20 08:58:07.784382+0800 LayoutIfNeed[5845:2473209] -[ULCollectionView setNeedsLayout]<br>2019-10-20 08:58:07.784507+0800 LayoutIfNeed[5845:2473209] -[ULCollectionView setNeedsLayout]<br>2019-10-20 08:58:07.784605+0800 LayoutIfNeed[5845:2473209] -[ULCollectionView setNeedsLayout]<br>2019-10-20 08:58:07.784705+0800 LayoutIfNeed[5845:2473209] -[ULCollectionView setNeedsLayout]<br>2019-10-20 08:58:07.784817+0800 LayoutIfNeed[5845:2473209] reloadData 执行完成<br>2019-10-20 08:58:07.785197+0800 LayoutIfNeed[5845:2473209] CollectionTableViewController RunLoop即将处理Timer事件<br>2019-10-20 08:58:07.785327+0800 LayoutIfNeed[5845:2473209] UIInnerTableView RunLoop即将处理Timer事件<br>2019-10-20 08:58:07.785671+0800 LayoutIfNeed[5845:2473209] CollectionTableViewController RunLoop即将处理Source事件<br>2019-10-20 08:58:07.786006+0800 LayoutIfNeed[5845:2473209] UIInnerTableView RunLoop即将处理Source事件<br>2019-10-20 08:58:07.786776+0800 LayoutIfNeed[5845:2473209] CollectionTableViewController RunLoop即将休眠<br>2019-10-20 08:58:07.786927+0800 LayoutIfNeed[5845:2473209] UIInnerTableView RunLoop即将休眠<br>2019-10-20 08:58:07.787353+0800 LayoutIfNeed[5845:2473209] -[ULCollectionView layoutSubviews]<br>2019-10-20 08:58:07.787514+0800 LayoutIfNeed[5845:2473209] -[CollectionTableViewController numberOfSectionsInCollectionView:]<br>2019-10-20 08:58:07.787615+0800 LayoutIfNeed[5845:2473209] -[CollectionTableViewController collectionView:numberOfItemsInSection:]<br>2019-10-20 08:58:07.789470+0800 LayoutIfNeed[5845:2473209] -[ULCollectionView dequeueReusableCellWithReuseIdentifier:forIndexPath:]<br>2019-10-20 08:58:07.789994+0800 LayoutIfNeed[5845:2473209] -[CollectionTableViewController collectionView:cellForItemAtIndexPath:]<br></code></pre></td></tr></table></figure>
<p>根据上面的log我们可以得出一个结论 如果不主动触发,外部的CollectionView调用reloadData并不会影响cell中嵌套的TableView</p>
<h3 id="VisibleCell"><a href="#VisibleCell" class="headerlink" title="VisibleCell"></a>VisibleCell</h3><h4 id="UITableView-1"><a href="#UITableView-1" class="headerlink" title="UITableView"></a>UITableView</h4><p><code>demo同上</code></p>
<p>下面我们直接看代码：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">- (<span class="hljs-keyword">void</span>)reloadTableData &#123;<br> <br>    [<span class="hljs-keyword">self</span>.tableView reloadData];<br> <br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;reloadData 执行完成&quot;</span>);<br> <br>    <span class="hljs-built_in">NSArray</span> *array = [<span class="hljs-keyword">self</span>.tableView visibleCells];<br> <br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;visibleCells----:%@&quot;</span>,@(array.count));<br> <br> <br>    <span class="hljs-built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;<br> <br>        <span class="hljs-built_in">NSArray</span> *array = [<span class="hljs-keyword">self</span>.tableView visibleCells];<br> <br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;visibleCells==== :%@&quot;</span>,@(array.count));<br>    &#125;);<br> <br>&#125;<br></code></pre></td></tr></table></figure>
<p>由于在reloadData中我们知道该方法是一个异步的,一次在获取visibleCell的时候我们使用两种方法</p>
<ul>
<li>1、直接调用<code>[self.tableView visibleCells]</code></li>
<li>2、使用GCD在下一个runloop到来时在去获取Runloop</li>
</ul>
<p>下面看下上面代码的执行结果:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">2019-10-08 19:40:28.825840+0800 LayoutIfNeed[3696:229565] RunLoop被唤醒<br> <br>2019-10-08 19:40:28.826209+0800 LayoutIfNeed[3696:229565] RunLoop即将处理Timer事件<br> <br>2019-10-08 19:40:28.826463+0800 LayoutIfNeed[3696:229565] RunLoop即将处理Source事件<br> <br>2019-10-08 19:40:28.827665+0800 LayoutIfNeed[3696:229565] -[ULTableView reloadData]<br> <br>2019-10-08 19:40:28.828167+0800 LayoutIfNeed[3696:229565] -[ViewController numberOfSectionsInTableView:]<br> <br>2019-10-08 19:40:28.830161+0800 LayoutIfNeed[3696:229565] -[ULTableView setNeedsLayout]<br> <br>2019-10-08 19:40:28.830560+0800 LayoutIfNeed[3696:229565] -[ViewController tableView:numberOfRowsInSection:]<br> <br>2019-10-08 19:40:28.830946+0800 LayoutIfNeed[3696:229565] -[ULTableView setNeedsLayout]<br> <br>2019-10-08 19:40:28.831849+0800 LayoutIfNeed[3696:229565] -[ULTableView setNeedsLayout]<br> <br>2019-10-08 19:40:28.832015+0800 LayoutIfNeed[3696:229565] -[ULTableView setNeedsLayout]<br> <br>2019-10-08 19:40:28.832149+0800 LayoutIfNeed[3696:229565] reloadData 执行完成<br> <br>2019-10-08 19:40:28.832346+0800 LayoutIfNeed[3696:229565] -[ULTableView dequeueReusableCellWithIdentifier:]<br> <br>2019-10-08 19:40:28.832904+0800 LayoutIfNeed[3696:229565] -[ViewController tableView:cellForRowAtIndexPath:] 0 0<br> <br>2019-10-08 19:40:28.833739+0800 LayoutIfNeed[3696:229565] -[ViewController tableView:heightForRowAtIndexPath:]<br> <br>2019-10-08 19:40:28.833904+0800 LayoutIfNeed[3696:229565] -[ULTableView setNeedsLayout]<br> <br>2019-10-08 19:40:28.834391+0800 LayoutIfNeed[3696:229565] -[ULTableView setNeedsLayout]<br> <br>2019-10-08 19:40:28.834894+0800 LayoutIfNeed[3696:229565] visibleCells----:1<br> <br>2019-10-08 19:40:28.835912+0800 LayoutIfNeed[3696:229565] visibleCells&#x3D;&#x3D;&#x3D;&#x3D; :1<br> <br>2019-10-08 19:40:28.836664+0800 LayoutIfNeed[3696:229565] RunLoop即将处理Timer事件<br> <br>2019-10-08 19:40:28.837310+0800 LayoutIfNeed[3696:229565] RunLoop即将处理Source事件<br> <br>2019-10-08 19:40:28.838118+0800 LayoutIfNeed[3696:229565] RunLoop即将休眠<br> <br>2019-10-08 19:40:28.839862+0800 LayoutIfNeed[3696:229565] -[ULTableView layoutSubviews]<br></code></pre></td></tr></table></figure>

<p>通过log我们可以看到</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">两次&#96;visibleCells&#96;方法都返回了正确的cells数据是一致的且均是正确的<br></code></pre></td></tr></table></figure>
<p>疑问一：</p>
<p><code>reloadData</code>是异步的,它是会调用<code>setNeedLayout</code>方法标记当前view在下一次Runloop到来时刷新页面,为什么获取<code>visibleCell</code>会是正确的？</p>
<p>疑问二：</p>
<p>为什么<code>cellforRow</code>的方法调用不是在reloadData的下一次Runloop到来时才被调用而是在当前的Runloop中就被调用？</p>
<p>下面我们通过在<code>cellForRow</code>方法中添加断点的方式确认下在<code>visibleCell</code>被调用的时候都做了什么。</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g83v94813xj314m08waik.jpg" alt="调用堆栈"></p>
<p>根据这个断点的截图我们发现在调用visibleCell(截图右侧)的时候会触发<code>createPreparedCell</code>的调用,这个方法又间接的调用了<code>cellForRow</code>的代理方法。因此我们在当前runloop中使用visibleCell就可以获取到正确的值。</p>
<h4 id="UICollectionView-1"><a href="#UICollectionView-1" class="headerlink" title="UICollectionView"></a>UICollectionView</h4><p><code>Demo同上</code></p>
<p>下面我们来直接看代码：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">- (<span class="hljs-keyword">void</span>)reloadCollectionViewData &#123;<br> <br>    [<span class="hljs-keyword">self</span>.collectionView reloadData];<br> <br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;reloadData 执行完成&quot;</span>);<br> <br> <br>    <span class="hljs-built_in">NSArray</span> *array = [<span class="hljs-keyword">self</span>.collectionView visibleCells];<br> <br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;visibleCells----:%@&quot;</span>,@(array.count));<br> <br> <br>    <span class="hljs-built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;<br> <br>        <span class="hljs-built_in">NSArray</span> *array = [<span class="hljs-keyword">self</span>.collectionView visibleCells];<br> <br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;visibleCells==== :%@&quot;</span>,@(array.count));<br> <br>    &#125;);<br> <br>&#125;<br></code></pre></td></tr></table></figure>

<p>—————–我是分割线——————</p>
<p>大家可以思考下结果,然后在接着往下看…..</p>
<p>—————–我是分割线——————</p>
<p>下面我们直接看下log</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">2019-10-09 15:09:32.564096+0800 LayoutIfNeed[5995:609901] RunLoop被唤醒<br>2019-10-09 15:09:32.564291+0800 LayoutIfNeed[5995:609901] RunLoop即将处理Timer事件<br>2019-10-09 15:09:32.564403+0800 LayoutIfNeed[5995:609901] RunLoop即将处理Source事件<br>2019-10-09 15:09:32.565137+0800 LayoutIfNeed[5995:609901] -[ULCollectionView reloadData]<br>2019-10-09 15:09:32.565606+0800 LayoutIfNeed[5995:609901] -[ULCollectionView setNeedsLayout]<br>2019-10-09 15:09:32.565806+0800 LayoutIfNeed[5995:609901] -[ULCollectionView setNeedsLayout]<br>2019-10-09 15:09:32.566099+0800 LayoutIfNeed[5995:609901] -[ULCollectionView setNeedsLayout]<br>2019-10-09 15:09:32.566650+0800 LayoutIfNeed[5995:609901] -[ULCollectionView setNeedsLayout]<br>2019-10-09 15:09:32.567124+0800 LayoutIfNeed[5995:609901] -[ULCollectionView setNeedsLayout]<br>2019-10-09 15:09:32.567806+0800 LayoutIfNeed[5995:609901] reloadData 执行完成<br>2019-10-09 15:09:32.568103+0800 LayoutIfNeed[5995:609901] visibleCells----:0<br>2019-10-09 15:09:32.569715+0800 LayoutIfNeed[5995:609901] visibleCells&#x3D;&#x3D;&#x3D;&#x3D; :0<br>2019-10-09 15:09:32.570232+0800 LayoutIfNeed[5995:609901] RunLoop即将处理Timer事件<br>2019-10-09 15:09:32.570603+0800 LayoutIfNeed[5995:609901] RunLoop即将处理Source事件<br>2019-10-09 15:09:32.571044+0800 LayoutIfNeed[5995:609901] RunLoop即将处理Timer事件<br>2019-10-09 15:09:32.571513+0800 LayoutIfNeed[5995:609901] RunLoop即将处理Source事件<br>2019-10-09 15:09:32.572296+0800 LayoutIfNeed[5995:609901] RunLoop即将休眠<br>2019-10-09 15:09:32.572800+0800 LayoutIfNeed[5995:609901] -[ULCollectionView layoutSubviews]<br>2019-10-09 15:09:32.572981+0800 LayoutIfNeed[5995:609901] -[ULCollectionViewController numberOfSectionsInCollectionView:]<br>2019-10-09 15:09:32.573112+0800 LayoutIfNeed[5995:609901] -[ULCollectionViewController collectionView:numberOfItemsInSection:]<br>2019-10-09 15:09:32.575343+0800 LayoutIfNeed[5995:609901] -[ULCollectionView dequeueReusableCellWithReuseIdentifier:forIndexPath:]<br>2019-10-09 15:09:32.575858+0800 LayoutIfNeed[5995:609901] -[ULCollectionViewController collectionView:cellForItemAtIndexPath:]<br>2019-10-09 15:09:32.576419+0800 LayoutIfNeed[5995:609901] -[ULCollectionView layoutSubviews] visibleCell 1<br></code></pre></td></tr></table></figure>

<p>额！！！！！！！！！！！！！！！！</p>
<p>通过log我们发现：</p>
<p>我们两次获取visibleCell的数据均不正确,但是我们发现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">2019-10-09 15:09:32.576419+0800 LayoutIfNeed[5995:609901] -[ULCollectionView layoutSubviews] visibleCell 1<br></code></pre></td></tr></table></figure>
<p>在collectionView执行完<code>layoutSubviews</code>后获取的visibleCell是正确的。</p>
<p>同时我们注意到调用visibleCell时并没有像UITableView一样触发cellForRow被提前调用。</p>
<p>下面我们在观察下cellForRow被调用的时候的调用栈</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g83wam8lmbj30cu09ddmm.jpg" alt="调用栈"></p>
<p>我们看到对于UICollectionView在调用了layoutSubviews之后才会触发下面方法的调用<br><code>-[UICollectionView _createPreparedCellForItemAtIndexPath:withLayoutAttributes:applyAttributes:isFocused:notify:] </code></p>
<p>这个位置是跟UITableView是一致的！</p>
<h4 id="UITableView中嵌套UICollectionView"><a href="#UITableView中嵌套UICollectionView" class="headerlink" title="UITableView中嵌套UICollectionView"></a>UITableView中嵌套UICollectionView</h4><p>首先我们来确认下 如果在UITableView中调用了visibleCell是否会影响到内部的CollectionView</p>
<h5 id="页面加载完成后"><a href="#页面加载完成后" class="headerlink" title="页面加载完成后"></a>页面加载完成后</h5><p>下面我们直接看log</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">2019-10-20 09:42:36.408243+0800 LayoutIfNeed[6044:2489041] -[TableCollectionViewController reloadTableData]<br>2019-10-20 09:42:36.408414+0800 LayoutIfNeed[6044:2489041] visibleCells----:2<br></code></pre></td></tr></table></figure>

<p>log 显示页面加载完成后 我们在调用visibleCell时不会影响内部的CollectionView</p>
<h5 id="页面加载完成前"><a href="#页面加载完成前" class="headerlink" title="页面加载完成前"></a>页面加载完成前</h5><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">[self.view addSubview:self.tableView];<br>NSArray *array &#x3D; [self.tableView visibleCells];<br>  NSLog(@&quot;visibleCells----:%@&quot;,@(array.count));<br></code></pre></td></tr></table></figure>

<p>这里为了验证效果 我们暂时不主动调用reloadData </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">2019-10-20 09:48:53.813778+0800 LayoutIfNeed[6081:2491415] -[ULTableView setNeedsLayout]<br>2019-10-20 09:48:53.814644+0800 LayoutIfNeed[6081:2491415] visibleCells----:0<br>2019-10-20 09:48:53.816761+0800 LayoutIfNeed[6081:2491415] -[TableCollectionViewController numberOfSectionsInTableView:]<br>2019-10-20 09:48:53.816960+0800 LayoutIfNeed[6081:2491415] -[TableCollectionViewController tableView:numberOfRowsInSection:]<br>2019-10-20 09:48:53.817162+0800 LayoutIfNeed[6081:2491415] -[ULTableView setNeedsLayout]<br>2019-10-20 09:48:53.817733+0800 LayoutIfNeed[6081:2491415] -[ULTableView setNeedsLayout]<br>2019-10-20 09:48:53.828370+0800 LayoutIfNeed[6081:2491415] -[ULTableView layoutSubviews]<br>2019-10-20 09:48:53.828573+0800 LayoutIfNeed[6081:2491415] -[ULTableView reloadData]<br>2019-10-20 09:48:53.828713+0800 LayoutIfNeed[6081:2491415] -[TableCollectionViewController numberOfSectionsInTableView:]<br>2019-10-20 09:48:53.828853+0800 LayoutIfNeed[6081:2491415] -[TableCollectionViewController tableView:numberOfRowsInSection:]<br>2019-10-20 09:48:53.828974+0800 LayoutIfNeed[6081:2491415] -[ULTableView setNeedsLayout]<br>2019-10-20 09:48:53.829170+0800 LayoutIfNeed[6081:2491415] -[ULTableView dequeueReusableCellWithIdentifier:]<br>2019-10-20 09:48:53.829604+0800 LayoutIfNeed[6081:2491415] -[TableCollectionViewController tableView:cellForRowAtIndexPath:] 0 0<br>2019-10-20 09:48:53.830285+0800 LayoutIfNeed[6081:2491415] -[ULCollectionView setNeedsLayout]<br>2019-10-20 09:48:53.830449+0800 LayoutIfNeed[6081:2491415] -[ULCollectionView setNeedsLayout]<br>2019-10-20 09:48:53.830576+0800 LayoutIfNeed[6081:2491415] -[ULCollectionView setNeedsLayout]<br>2019-10-20 09:48:53.830811+0800 LayoutIfNeed[6081:2491415] -[ULCollectionView reloadData]<br>2019-10-20 09:48:53.830948+0800 LayoutIfNeed[6081:2491415] -[ULCollectionView setNeedsLayout]<br>2019-10-20 09:48:53.831085+0800 LayoutIfNeed[6081:2491415] -[ULCollectionView setNeedsLayout]<br>2019-10-20 09:48:53.831213+0800 LayoutIfNeed[6081:2491415] -[ULCollectionView setNeedsLayout]<br>2019-10-20 09:48:53.831308+0800 LayoutIfNeed[6081:2491415] -[ULCollectionView setNeedsLayout]<br>2019-10-20 09:48:53.831640+0800 LayoutIfNeed[6081:2491415] -[ULCollectionView setNeedsLayout]<br>2019-10-20 09:48:53.832722+0800 LayoutIfNeed[6081:2491415] -[TableCollectionViewController tableView:heightForRowAtIndexPath:]<br>2019-10-20 09:48:53.832866+0800 LayoutIfNeed[6081:2491415] -[ULTableView setNeedsLayout]<br>2019-10-20 09:48:53.833304+0800 LayoutIfNeed[6081:2491415] -[ULCollectionView layoutSubviews]<br>2019-10-20 09:48:53.833478+0800 LayoutIfNeed[6081:2491415] -[UIInnerCollectionView numberOfSectionsInCollectionView:]<br>2019-10-20 09:48:53.833595+0800 LayoutIfNeed[6081:2491415] -[UIInnerCollectionView collectionView:numberOfItemsInSection:]<br>2019-10-20 09:48:53.835002+0800 LayoutIfNeed[6081:2491415] -[ULCollectionView dequeueReusableCellWithReuseIdentifier:forIndexPath:]<br>2019-10-20 09:48:53.835350+0800 LayoutIfNeed[6081:2491415] -[UIInnerCollectionView collectionView:cellForItemAtIndexPath:]<br>2019-10-20 09:48:53.835618+0800 LayoutIfNeed[6081:2491415] -[ULCollectionView layoutSubviews] visibleCell 1<br>2019-10-20 09:48:53.835801+0800 LayoutIfNeed[6081:2491415] -[ULTableView dequeueReusableCellWithIdentifier:]<br>2019-10-20 09:48:53.836383+0800 LayoutIfNeed[6081:2491415] -[TableCollectionViewController tableView:cellForRowAtIndexPath:] 0 1<br>2019-10-20 09:48:53.837371+0800 LayoutIfNeed[6081:2491415] -[TableCollectionViewController tableView:heightForRowAtIndexPath:]<br>2019-10-20 09:48:53.837523+0800 LayoutIfNeed[6081:2491415] -[ULTableView setNeedsLayout]<br>2019-10-20 09:48:53.838066+0800 LayoutIfNeed[6081:2491415] -[ULTableView setNeedsLayout]<br>2019-10-20 09:48:53.838735+0800 LayoutIfNeed[6081:2491415] -[ULTableView layoutSubviews]<br></code></pre></td></tr></table></figure>
<p>根据上面的log 我们看到即使在页面加载的时候我们不主动调用reloadData页面也可以正常加载,是因为<code>addsubview/init</code>操作会触发<code>layoutSubviews</code>方法。这样即使没有reloadData页面也可以正常加载。</p>
<h5 id="确认VisibleCell调用获取的数值"><a href="#确认VisibleCell调用获取的数值" class="headerlink" title="确认VisibleCell调用获取的数值"></a>确认VisibleCell调用获取的数值</h5><p>先确认下代码</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">- (<span class="hljs-keyword">void</span>)reloadVisibleCell &#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%s&quot;</span>,__func__);<br>    [<span class="hljs-keyword">self</span>.tableView reloadData];<br>    <span class="hljs-built_in">NSArray</span> *tableViewVisibleCells = [<span class="hljs-keyword">self</span>.tableView visibleCells];<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;UITableView visibleCount%@&quot;</span>,@(tableViewVisibleCells.count));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">UITableViewCell</span> *cell <span class="hljs-keyword">in</span> tableViewVisibleCells) &#123;<br>    <span class="hljs-comment">// cell 上加载内容的视图，对应可能是CollectionView</span><br>        [cell.contentView.subviews enumerateObjectsUsingBlock:^(__kindof <span class="hljs-built_in">UIView</span> * _Nonnull obj, <span class="hljs-built_in">NSUInteger</span> idx, <span class="hljs-built_in">BOOL</span> * _Nonnull stop) &#123;<br>            <span class="hljs-keyword">if</span> ([obj isKindOfClass:[<span class="hljs-built_in">UIInnerCollectionView</span> <span class="hljs-keyword">class</span>]]) &#123;<br>                <span class="hljs-built_in">UIInnerCollectionView</span> *collectionView = (<span class="hljs-built_in">UIInnerCollectionView</span> *)obj;<br>                <span class="hljs-built_in">NSArray</span> *array = [collectionView visibleCell];<br>                <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;UIInnerCollectionView visibleCount%@&quot;</span>,@(array.count));<br>            &#125;<br>        &#125;];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>log:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">2019-10-20 10:57:19.462632+0800 LayoutIfNeed[6313:2513531] -[TableCollectionViewController reloadVisibleCell]<br>2019-10-20 10:57:19.462805+0800 LayoutIfNeed[6313:2513531] -[ULTableView reloadData]<br>2019-10-20 10:57:19.463147+0800 LayoutIfNeed[6313:2513531] -[TableCollectionViewController numberOfSectionsInTableView:]<br>2019-10-20 10:57:19.463397+0800 LayoutIfNeed[6313:2513531] -[ULTableView setNeedsLayout]<br>2019-10-20 10:57:19.463800+0800 LayoutIfNeed[6313:2513531] -[TableCollectionViewController tableView:numberOfRowsInSection:]<br>2019-10-20 10:57:19.464301+0800 LayoutIfNeed[6313:2513531] -[ULTableView setNeedsLayout]<br>2019-10-20 10:57:19.464657+0800 LayoutIfNeed[6313:2513531] -[ULTableView setNeedsLayout]<br>2019-10-20 10:57:19.464797+0800 LayoutIfNeed[6313:2513531] -[ULTableView setNeedsLayout]<br>2019-10-20 10:57:19.465240+0800 LayoutIfNeed[6313:2513531] -[ULTableView dequeueReusableCellWithIdentifier:]<br>2019-10-20 10:57:19.465619+0800 LayoutIfNeed[6313:2513531] -[TableCollectionViewController tableView:cellForRowAtIndexPath:] 0 0<br>2019-10-20 10:57:19.466193+0800 LayoutIfNeed[6313:2513531] -[TableCollectionViewController tableView:heightForRowAtIndexPath:]<br>2019-10-20 10:57:19.466357+0800 LayoutIfNeed[6313:2513531] -[ULTableView setNeedsLayout]<br>2019-10-20 10:57:19.466656+0800 LayoutIfNeed[6313:2513531] -[ULTableView dequeueReusableCellWithIdentifier:]<br>2019-10-20 10:57:19.466921+0800 LayoutIfNeed[6313:2513531] -[TableCollectionViewController tableView:cellForRowAtIndexPath:] 0 1<br>2019-10-20 10:57:19.467452+0800 LayoutIfNeed[6313:2513531] -[TableCollectionViewController tableView:heightForRowAtIndexPath:]<br>2019-10-20 10:57:19.467690+0800 LayoutIfNeed[6313:2513531] -[ULTableView setNeedsLayout]<br>2019-10-20 10:57:19.468489+0800 LayoutIfNeed[6313:2513531] -[ULTableView setNeedsLayout]<br>2019-10-20 10:57:19.468747+0800 LayoutIfNeed[6313:2513531] UITableView visibleCount2<br>2019-10-20 10:57:19.468898+0800 LayoutIfNeed[6313:2513531] UIInnerCollectionView visibleCount1<br></code></pre></td></tr></table></figure>

<p>从上面的log我们可以看到,我们在reloadData后获取到的visibleCell都是正确的！</p>
<h4 id="UICollectionView中嵌套UITableView"><a href="#UICollectionView中嵌套UITableView" class="headerlink" title="UICollectionView中嵌套UITableView"></a>UICollectionView中嵌套UITableView</h4><h5 id="页面加载时"><a href="#页面加载时" class="headerlink" title="页面加载时"></a>页面加载时</h5><p>代码：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">[<span class="hljs-keyword">self</span>.view addSubview:<span class="hljs-keyword">self</span>.collectionView];<br><span class="hljs-built_in">NSArray</span> *collectionViewVisibleCell = [<span class="hljs-keyword">self</span>.collectionView visibleCells];<br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;UICollectionView visibleCount%@&quot;</span>,@(collectionViewVisibleCell.count));<br></code></pre></td></tr></table></figure>

<p>log:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">2019-10-20 11:12:00.989745+0800 LayoutIfNeed[6388:2521314] -[ULCollectionView setNeedsLayout]<br>2019-10-20 11:12:00.989925+0800 LayoutIfNeed[6388:2521314] -[ULCollectionView setNeedsLayout]<br>2019-10-20 11:12:00.990034+0800 LayoutIfNeed[6388:2521314] -[ULCollectionView setNeedsLayout]<br>2019-10-20 11:12:00.990269+0800 LayoutIfNeed[6388:2521314] -[ULCollectionView reloadData]<br>2019-10-20 11:12:00.990395+0800 LayoutIfNeed[6388:2521314] -[ULCollectionView setNeedsLayout]<br>2019-10-20 11:12:00.990533+0800 LayoutIfNeed[6388:2521314] -[ULCollectionView setNeedsLayout]<br>2019-10-20 11:12:00.990894+0800 LayoutIfNeed[6388:2521314] -[ULCollectionView setNeedsLayout]<br>2019-10-20 11:12:00.991304+0800 LayoutIfNeed[6388:2521314] -[ULCollectionView setNeedsLayout]<br>2019-10-20 11:12:00.991690+0800 LayoutIfNeed[6388:2521314] -[ULCollectionView setNeedsLayout]<br>2019-10-20 11:12:00.992034+0800 LayoutIfNeed[6388:2521314] UICollectionView visibleCount0<br>2019-10-20 11:12:00.994969+0800 LayoutIfNeed[6388:2521314] -[ULCollectionView setNeedsLayout]<br>2019-10-20 11:12:00.995134+0800 LayoutIfNeed[6388:2521314] -[ULCollectionView setNeedsLayout]<br>2019-10-20 11:12:00.995228+0800 LayoutIfNeed[6388:2521314] -[ULCollectionView setNeedsLayout]<br>2019-10-20 11:12:00.995342+0800 LayoutIfNeed[6388:2521314] -[ULCollectionView setNeedsLayout]<br>2019-10-20 11:12:00.995465+0800 LayoutIfNeed[6388:2521314] -[ULCollectionView setNeedsLayout]<br>2019-10-20 11:12:00.995567+0800 LayoutIfNeed[6388:2521314] -[ULCollectionView setNeedsLayout]<br>2019-10-20 11:12:00.995673+0800 LayoutIfNeed[6388:2521314] -[ULCollectionView setNeedsLayout]<br>2019-10-20 11:12:00.995772+0800 LayoutIfNeed[6388:2521314] -[ULCollectionView setNeedsLayout]<br>2019-10-20 11:12:00.995894+0800 LayoutIfNeed[6388:2521314] -[ULCollectionView setNeedsLayout]<br>2019-10-20 11:12:01.009260+0800 LayoutIfNeed[6388:2521314] -[ULCollectionView layoutSubviews]<br>2019-10-20 11:12:01.009536+0800 LayoutIfNeed[6388:2521314] -[CollectionTableViewController numberOfSectionsInCollectionView:]<br>2019-10-20 11:12:01.009651+0800 LayoutIfNeed[6388:2521314] -[CollectionTableViewController collectionView:numberOfItemsInSection:]<br>2019-10-20 11:12:01.010533+0800 LayoutIfNeed[6388:2521314] -[ULCollectionView dequeueReusableCellWithReuseIdentifier:forIndexPath:]<br>2019-10-20 11:12:01.010844+0800 LayoutIfNeed[6388:2521314] -[CollectionTableViewController collectionView:cellForItemAtIndexPath:]<br>2019-10-20 11:12:01.011126+0800 LayoutIfNeed[6388:2521314] -[ULTableView setNeedsLayout]<br>2019-10-20 11:12:01.012000+0800 LayoutIfNeed[6388:2521314] -[ULTableView reloadData]<br>2019-10-20 11:12:01.012172+0800 LayoutIfNeed[6388:2521314] -[UIInnerTableView numberOfSectionsInTableView:]<br>2019-10-20 11:12:01.012511+0800 LayoutIfNeed[6388:2521314] -[UIInnerTableView tableView:numberOfRowsInSection:]<br>2019-10-20 11:12:01.013372+0800 LayoutIfNeed[6388:2521314] -[ULTableView setNeedsLayout]<br>2019-10-20 11:12:01.015872+0800 LayoutIfNeed[6388:2521314] -[UIInnerTableView numberOfSectionsInTableView:]<br>2019-10-20 11:12:01.016756+0800 LayoutIfNeed[6388:2521314] -[UIInnerTableView tableView:numberOfRowsInSection:]<br>2019-10-20 11:12:01.017156+0800 LayoutIfNeed[6388:2521314] -[UIInnerTableView numberOfSectionsInTableView:]<br>2019-10-20 11:12:01.017900+0800 LayoutIfNeed[6388:2521314] -[UIInnerTableView tableView:numberOfRowsInSection:]<br>2019-10-20 11:12:01.018193+0800 LayoutIfNeed[6388:2521314] -[ULTableView setNeedsLayout]<br>2019-10-20 11:12:01.020487+0800 LayoutIfNeed[6388:2521314] -[ULCollectionView layoutSubviews] visibleCell 1<br>2019-10-20 11:12:01.021245+0800 LayoutIfNeed[6388:2521314] -[ULTableView layoutSubviews]<br>2019-10-20 11:12:01.021410+0800 LayoutIfNeed[6388:2521314] -[ULTableView dequeueReusableCellWithIdentifier:]<br>2019-10-20 11:12:01.021747+0800 LayoutIfNeed[6388:2521314] -[UIInnerTableView tableView:cellForRowAtIndexPath:] 0 0<br>2019-10-20 11:12:01.024221+0800 LayoutIfNeed[6388:2521314] -[UIInnerTableView tableView:heightForRowAtIndexPath:]<br>2019-10-20 11:12:01.024501+0800 LayoutIfNeed[6388:2521314] -[ULTableView setNeedsLayout]<br>2019-10-20 11:12:01.024982+0800 LayoutIfNeed[6388:2521314] -[ULTableView dequeueReusableCellWithIdentifier:]<br>2019-10-20 11:12:01.025291+0800 LayoutIfNeed[6388:2521314] -[UIInnerTableView tableView:cellForRowAtIndexPath:] 0 1<br>2019-10-20 11:12:01.025908+0800 LayoutIfNeed[6388:2521314] -[UIInnerTableView tableView:heightForRowAtIndexPath:]<br>2019-10-20 11:12:01.026027+0800 LayoutIfNeed[6388:2521314] -[ULTableView setNeedsLayout]<br>2019-10-20 11:12:01.026418+0800 LayoutIfNeed[6388:2521314] -[ULTableView dequeueReusableCellWithIdentifier:]<br>2019-10-20 11:12:01.026711+0800 LayoutIfNeed[6388:2521314] -[UIInnerTableView tableView:cellForRowAtIndexPath:] 0 2<br>2019-10-20 11:12:01.027502+0800 LayoutIfNeed[6388:2521314] -[UIInnerTableView tableView:heightForRowAtIndexPath:]<br>2019-10-20 11:12:01.027624+0800 LayoutIfNeed[6388:2521314] -[ULTableView setNeedsLayout]<br>2019-10-20 11:12:01.028011+0800 LayoutIfNeed[6388:2521314] -[ULTableView dequeueReusableCellWithIdentifier:]<br>2019-10-20 11:12:01.028316+0800 LayoutIfNeed[6388:2521314] -[UIInnerTableView tableView:cellForRowAtIndexPath:] 0 3<br>2019-10-20 11:12:01.029025+0800 LayoutIfNeed[6388:2521314] -[UIInnerTableView tableView:heightForRowAtIndexPath:]<br>2019-10-20 11:12:01.029192+0800 LayoutIfNeed[6388:2521314] -[ULTableView setNeedsLayout]<br>2019-10-20 11:12:01.029692+0800 LayoutIfNeed[6388:2521314] -[ULTableView dequeueReusableCellWithIdentifier:]<br>2019-10-20 11:12:01.030077+0800 LayoutIfNeed[6388:2521314] -[UIInnerTableView tableView:cellForRowAtIndexPath:] 0 4<br>2019-10-20 11:12:01.030814+0800 LayoutIfNeed[6388:2521314] -[UIInnerTableView tableView:heightForRowAtIndexPath:]<br>2019-10-20 11:12:01.030965+0800 LayoutIfNeed[6388:2521314] -[ULTableView setNeedsLayout]<br>2019-10-20 11:12:01.031518+0800 LayoutIfNeed[6388:2521314] -[ULTableView setNeedsLayout]<br>2019-10-20 11:12:01.032057+0800 LayoutIfNeed[6388:2521314] -[ULTableView layoutSubviews]<br></code></pre></td></tr></table></figure>

<h5 id="页面加载完成后-1"><a href="#页面加载完成后-1" class="headerlink" title="页面加载完成后"></a>页面加载完成后</h5><p>代码：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">- (<span class="hljs-keyword">void</span>)reloadVisibleCell &#123;<br>    [<span class="hljs-keyword">self</span>.collectionView reloadData];<br>     <span class="hljs-built_in">NSArray</span> *collectionViewVisibleCell = [<span class="hljs-keyword">self</span>.collectionView visibleCells];<br>     <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;UICollectionView visibleCount%@&quot;</span>,@(collectionViewVisibleCell.count));<br>&#125;<br></code></pre></td></tr></table></figure>

<p>log:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">2019-10-20 11:15:40.370300+0800 LayoutIfNeed[6412:2522955] -[ULCollectionView reloadData]<br>2019-10-20 11:15:40.370570+0800 LayoutIfNeed[6412:2522955] -[ULCollectionView setNeedsLayout]<br>2019-10-20 11:15:40.370746+0800 LayoutIfNeed[6412:2522955] -[ULCollectionView setNeedsLayout]<br>2019-10-20 11:15:40.370893+0800 LayoutIfNeed[6412:2522955] -[ULCollectionView setNeedsLayout]<br>2019-10-20 11:15:40.371005+0800 LayoutIfNeed[6412:2522955] -[ULCollectionView setNeedsLayout]<br>2019-10-20 11:15:40.371120+0800 LayoutIfNeed[6412:2522955] -[ULCollectionView setNeedsLayout]<br>2019-10-20 11:15:40.371309+0800 LayoutIfNeed[6412:2522955] UICollectionView visibleCount0<br>2019-10-20 11:15:44.145073+0800 LayoutIfNeed[6412:2522955] -[ULCollectionView layoutSubviews]<br>2019-10-20 11:15:44.145280+0800 LayoutIfNeed[6412:2522955] -[CollectionTableViewController numberOfSectionsInCollectionView:]<br>2019-10-20 11:15:44.145406+0800 LayoutIfNeed[6412:2522955] -[CollectionTableViewController collectionView:numberOfItemsInSection:]<br>2019-10-20 11:15:44.146433+0800 LayoutIfNeed[6412:2522955] -[ULCollectionView dequeueReusableCellWithReuseIdentifier:forIndexPath:]<br>2019-10-20 11:15:44.146820+0800 LayoutIfNeed[6412:2522955] -[CollectionTableViewController collectionView:cellForItemAtIndexPath:]<br></code></pre></td></tr></table></figure>

<h5 id="确认VisibleCell调用获取的数值-1"><a href="#确认VisibleCell调用获取的数值-1" class="headerlink" title="确认VisibleCell调用获取的数值"></a>确认VisibleCell调用获取的数值</h5><p>我们先看下代码：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">- (<span class="hljs-keyword">void</span>)reloadVisibleCell &#123;<br>    [<span class="hljs-keyword">self</span>.collectionView reloadData];<br>     <span class="hljs-built_in">NSArray</span> *collectionViewVisibleCell = [<span class="hljs-keyword">self</span>.collectionView visibleCells];<br>     <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;UICollectionView visibleCount%@&quot;</span>,@(collectionViewVisibleCell.count));<br>     <span class="hljs-keyword">for</span> (<span class="hljs-built_in">UICollectionViewCell</span> *cell <span class="hljs-keyword">in</span> collectionViewVisibleCell) &#123;<br>     <span class="hljs-comment">// cell 上加载内容的视图，对应可能是CollectionView</span><br>         [cell.contentView.subviews enumerateObjectsUsingBlock:^(__kindof <span class="hljs-built_in">UIView</span> * _Nonnull obj, <span class="hljs-built_in">NSUInteger</span> idx, <span class="hljs-built_in">BOOL</span> * _Nonnull stop) &#123;<br>             <span class="hljs-keyword">if</span> ([obj isKindOfClass:[<span class="hljs-built_in">UIInnerTableView</span> <span class="hljs-keyword">class</span>]]) &#123;<br>                 <span class="hljs-built_in">UIInnerTableView</span> *tableView = (<span class="hljs-built_in">UIInnerTableView</span> *)obj;<br>                 <span class="hljs-built_in">NSArray</span> *array = [tableView visibleCell];<br>                 <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;UIInnerTableView visibleCount%@&quot;</span>,@(array.count));<br>             &#125;<br>         &#125;];<br>     &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>然后我们在看下log</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">2019-10-20 11:08:33.397037+0800 LayoutIfNeed[6370:2519870] -[ULCollectionView reloadData]<br>2019-10-20 11:08:33.397305+0800 LayoutIfNeed[6370:2519870] -[ULCollectionView setNeedsLayout]<br>2019-10-20 11:08:33.397527+0800 LayoutIfNeed[6370:2519870] -[ULCollectionView setNeedsLayout]<br>2019-10-20 11:08:33.397721+0800 LayoutIfNeed[6370:2519870] -[ULCollectionView setNeedsLayout]<br>2019-10-20 11:08:33.397823+0800 LayoutIfNeed[6370:2519870] -[ULCollectionView setNeedsLayout]<br>2019-10-20 11:08:33.397913+0800 LayoutIfNeed[6370:2519870] -[ULCollectionView setNeedsLayout]<br>2019-10-20 11:08:33.398032+0800 LayoutIfNeed[6370:2519870] UICollectionView visibleCount0<br>2019-10-20 11:08:38.437912+0800 LayoutIfNeed[6370:2519870] -[ULCollectionView layoutSubviews]<br>2019-10-20 11:08:38.438140+0800 LayoutIfNeed[6370:2519870] -[CollectionTableViewController numberOfSectionsInCollectionView:]<br>2019-10-20 11:08:38.438250+0800 LayoutIfNeed[6370:2519870] -[CollectionTableViewController collectionView:numberOfItemsInSection:]<br>2019-10-20 11:08:38.489045+0800 LayoutIfNeed[6370:2519870] -[ULCollectionView dequeueReusableCellWithReuseIdentifier:forIndexPath:]<br>2019-10-20 11:08:38.489259+0800 LayoutIfNeed[6370:2519870] -[CollectionTableViewController collectionView:cellForItemAtIndexPath:]<br></code></pre></td></tr></table></figure>
<p>从上面的log我们可以看出,reloadData之后 因为collectionView并没有调用<code>layoutIfNeed</code>所以在这之后无法获取到<code>visibleCell</code>,所以肯定不会影响到内部的TableView所以获取TableView的<code>visibleCell</code>肯定也是无效的。</p>
<p>未完待续…</p>
]]></content>
      <categories>
        <category>iOS基础</category>
      </categories>
      <tags>
        <tag>reloadData visibleCells</tag>
      </tags>
  </entry>
  <entry>
    <title>RunTime的那些事儿</title>
    <url>/2018/03/02/runtime-common-method/</url>
    <content><![CDATA[<p>Runtime 又叫运行时，是一套底层的 C 语言 API，其为 iOS 内部的核心之一，我们平时编写的 OC 代码，底层都是基于它来实现的!</p>
<a id="more"></a>

<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">[receiver message];<br>&#x2F;&#x2F; 底层运行时会被编译器转化为：<br>objc_msgSend(receiver, selector)<br>&#x2F;&#x2F; 如果其还有参数比如：<br>[receiver message:(id)arg...];<br>&#x2F;&#x2F; 底层运行时会被编译器转化为：<br>objc_msgSend(receiver, selector, arg1, arg2, ...)<br></code></pre></td></tr></table></figure>

<p>Objective-C 是一门动态语言，它会将一些工作放在代码运行时才处理而并非编译时。也就是说，有很多类和成员变量在我们编译的时是不知道的，而在运行时，我们所编写的代码会转换成完整的确定的代码运行。</p>
<p>因此，编译器是不够的，我们还需要一个运行时系统(Runtime system)来处理编译后的代码。</p>
<p>Runtime 基本是用 C 和汇编写的。</p>
<h2 id="了解Runtime的方式"><a href="#了解Runtime的方式" class="headerlink" title="了解Runtime的方式"></a>了解Runtime的方式</h2><p>Objc 在三种层面上与 Runtime 系统进行交互：</p>
<blockquote>
<p>通过 Objective-C 源代码<br>通过 Foundation 框架的 NSObject 类定义的方法<br>通过对 Runtime 库函数的直接调用</p>
</blockquote>
<h3 id="通过-Objective-C-源代码"><a href="#通过-Objective-C-源代码" class="headerlink" title="通过 Objective-C 源代码"></a>通过 Objective-C 源代码</h3><p>多数情况我们只需要编写 OC 代码即可，Runtime 系统自动在幕后搞定一切，还记得简介中如果我们调用方法，编译器会将 OC 代码转换成运行时代码，在运行时确定数据结构和函数。</p>
<h3 id="通过-Foundation-框架的-NSObject-类定义的方法"><a href="#通过-Foundation-框架的-NSObject-类定义的方法" class="headerlink" title="通过 Foundation 框架的 NSObject 类定义的方法"></a>通过 Foundation 框架的 NSObject 类定义的方法</h3><p>Cocoa 程序中绝大部分类都是 NSObject 类的子类，所以都继承了 NSObject 的行为。(<code>NSProxy</code> 类时个例外，它是个抽象超类)</p>
<p>一些情况下，NSObject 类仅仅定义了完成某件事情的模板，并没有提供所需要的代码。例如 <code>-description</code> 方法，该方法返回类内容的字符串表示，该方法主要用来调试程序。NSObject 类并不知道子类的内容，所以它只是返回类的名字和对象的地址，NSObject 的子类可以重新实现。</p>
<blockquote>
<p><code>-class</code>方法返回对象的类；<br><code>-isKindOfClass:</code> 和 <code>-isMemberOfClass:</code> 方法检查对象是否存在于指定的类的继承体系中(是否是其子类或者父类或者当前类的成员变量)；</p>
</blockquote>
<blockquote>
<p><code>-respondsToSelector:</code> 检查对象能否响应指定的消息；<br><code>-conformsToProtocol:</code>检查对象是否实现了指定协议类的方法；<br><code>-methodForSelector:</code> 返回指定方法实现的地址</p>
</blockquote>
<h3 id="通过对-Runtime-库函数的直接调用"><a href="#通过对-Runtime-库函数的直接调用" class="headerlink" title="通过对 Runtime 库函数的直接调用"></a>通过对 Runtime 库函数的直接调用</h3><p>Runtime 系统是具有公共接口的动态共享库。头文件存放于<code>/usr/include/objc</code>目录下，这意味着我们使用时只需要引入<code>objc/Runtime.h</code>头文件即可。</p>
<p>许多函数可以让你使用纯 C 代码来实现 Objc 中同样的功能。除非是写一些 Objc 与其他语言的桥接或是底层的 debug 工作，你在写 Objc 代码时一般不会用到这些 C 语言函数。对于公共接口都有哪些，后面会讲到。我将会参考苹果官方的 API 文档。</p>
<h2 id="Runtime-详解"><a href="#Runtime-详解" class="headerlink" title="Runtime 详解"></a>Runtime 详解</h2><p>要想全面了解 Runtime 机制，我们必须先了解 Runtime 的一些术语，他们都对应着数据结构。</p>
<h3 id="SEL"><a href="#SEL" class="headerlink" title="SEL"></a>SEL</h3><p>它是<code>selector</code>在 Objc 中的表示(Swift 中是 Selector 类)</p>
<p><code>Selector</code> 是方法选择器，其实作用就和名字一样，日常生活中，我们通过人名辨别谁是谁，注意 Objc 在相同的类中不会有命名相同的两个方法</p>
<p><code>selector</code> 对方法名进行包装，以便找到对应的方法实现</p>
<p>数据结构：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">typedef struct objc_selector *SEL;<br><br></code></pre></td></tr></table></figure>

<p>我们可以看出它是个映射到方法的 C 字符串，你可以通过 Objc 编译器器命令<code>@selector() </code>或者 Runtime 系统的 <code>sel_registerName</code> 函数来获取一个 SEL 类型的方法选择器。</p>
<p><code>注意</code>：</p>
<p>不同类中相同名字的方法所对应的 selector 是相同的，由于变量的类型不同，所以不会导致它们调用方法实现混乱。</p>
<h3 id="id"><a href="#id" class="headerlink" title="id"></a>id</h3><p>id 是一个参数类型，它是指向某个类的实例的指针。定义如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">typedef struct objc_object *id;<br>struct objc_object &#123; Class isa; &#125;;<br></code></pre></td></tr></table></figure>

<p>以上定义，看到 <code>objc_object</code> 结构体包含一个 <code>isa</code> 指针，根据 <code>isa</code> 指针就可以找到对象所属的类。</p>
<p><code>注意</code>：<br><code>isa</code> 指针在代码运行时并不总指向实例对象所属的类型，所以不能依靠它来确定类型，要想确定类型还是需要用对象的 <code>-class</code> 方法。</p>
<p>PS:KVO 的实现机理就是将被观察对象的 isa 指针指向一个中间类而不是真实类型，</p>
<h3 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h3><p>Class 其实是指向 <code>objc_class</code> 结构体的指针</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> objc_class *Class;<br><br></code></pre></td></tr></table></figure>

<p>objc_class 的数据结构如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">objc_class</span> &#123;</span><br>    Class isa  OBJC_ISA_AVAILABILITY;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> !__OBJC2__</span><br>    Class super_class                                        OBJC2_UNAVAILABLE;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name                                         OBJC2_UNAVAILABLE;<br>    <span class="hljs-keyword">long</span> version                                             OBJC2_UNAVAILABLE;<br>    <span class="hljs-keyword">long</span> info                                                OBJC2_UNAVAILABLE;<br>    <span class="hljs-keyword">long</span> instance_size                                       OBJC2_UNAVAILABLE;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">objc_ivar_list</span> *<span class="hljs-title">ivars</span>                             <span class="hljs-title">OBJC2_UNAVAILABLE</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">objc_method_list</span> **<span class="hljs-title">methodLists</span>                    <span class="hljs-title">OBJC2_UNAVAILABLE</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">objc_cache</span> *<span class="hljs-title">cache</span>                                 <span class="hljs-title">OBJC2_UNAVAILABLE</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">objc_protocol_list</span> *<span class="hljs-title">protocols</span>                     <span class="hljs-title">OBJC2_UNAVAILABLE</span>;</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><br>&#125; OBJC2_UNAVAILABLE;<br></code></pre></td></tr></table></figure>

<p>从 <code>objc_class</code> 可以看到，一个运行时类中关联了它的父类指针、类名、成员变量、方法、缓存以及附属的协议。</p>
<p>其中 <code>objc_ivar_list</code> 和 <code>objc_method_list</code> 分别是成员变量列表和方法列表：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 成员变量列表</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">objc_ivar_list</span> &#123;</span><br>    <span class="hljs-keyword">int</span> ivar_count                                           OBJC2_UNAVAILABLE;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> __LP64__</span><br>    <span class="hljs-keyword">int</span> space                                                OBJC2_UNAVAILABLE;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>    <span class="hljs-comment">/* variable length structure */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">objc_ivar</span> <span class="hljs-title">ivar_list</span>[1]                            <span class="hljs-title">OBJC2_UNAVAILABLE</span>;</span><br>&#125;                                                            OBJC2_UNAVAILABLE;<br><br><span class="hljs-comment">// 方法列表</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">objc_method_list</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">objc_method_list</span> *<span class="hljs-title">obsolete</span>                        <span class="hljs-title">OBJC2_UNAVAILABLE</span>;</span><br><br>    <span class="hljs-keyword">int</span> method_count                                         OBJC2_UNAVAILABLE;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> __LP64__</span><br>    <span class="hljs-keyword">int</span> space                                                OBJC2_UNAVAILABLE;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>    <span class="hljs-comment">/* variable length structure */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">objc_method</span> <span class="hljs-title">method_list</span>[1]                        <span class="hljs-title">OBJC2_UNAVAILABLE</span>;</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>由此可见，我们可以动态修改 <code>*methodList</code> 的值来添加成员方法，这也是 Category 实现的原理，同样解释了 Category 不能添加属性的原因。这里可以参考下美团技术团队的文章：<a href="https://tech.meituan.com/DiveIntoCategory.html">深入理解 Objective-C: Category</a>。</p>
<p><code>objc_ivar_list</code> 结构体用来存储成员变量的列表，而 <code>objc_ivar</code> 则是存储了单个成员变量的信息；<br>‘同理，<code>objc_method_list</code> 结构体存储着方法数组的列表，而单个方法的信息则由 <code>objc_method</code> 结构体存储</p>
<p>值得注意的时，<code>objc_class</code> 中也有一个 isa 指针，这说明 Objc 类本身也是一个对象。为了处理类和对象的关系，Runtime 库创建了一种叫做 <code>Meta Class(元类)</code> 的东西，类对象所属的类就叫做元类。<code>Meta Class</code> 表述了类对象本身所具备的元数据。</p>
<p>我们所熟悉的类方法，就源自于 <code>Meta Class</code>。我们可以理解为类方法就是类对象的实例方法。每个类仅有一个类对象，而每个类对象仅有一个与之相关的元类。</p>
<p>当你发出一个类似 <code>[NSObject alloc](类方法) </code>的消息时，实际上，这个消息被发送给了一个类对象<code>(Class Object)</code>，这个类对象必须是一个元类的实例，而这个元类同时也是一个根元类<code>(Root Meta Class)</code>的实例。所有元类的 isa 指针最终都指向根元类。</p>
<p>所以当 <code>[NSObject alloc]</code> 这条消息发送给类对象的时候，运行时代码 <code>objc_msgSend()</code> 会去它元类中查找能够响应消息的方法实现，如果找到了，就会对这个类对象执行方法调用</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1330553-81f64a11ad20c764.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="执行方法调用"></p>
<p>上图实现是 <code>super_class</code> 指针，虚线时 isa 指针。而根元类的父类是 <code>NSObject</code>，isa指向了自己。而 NSObject 没有父类。</p>
<p>最后 <code>objc_class</code> 中还有一个 <code>objc_cache</code> ，缓存，它的作用很重要，后面会提到。</p>
<h3 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h3><p>Method 代表类中某个方法的类型</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">objc_method</span> *<span class="hljs-title">Method</span>;</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">objc_method</span> &#123;</span><br>    SEL method_name                                          OBJC2_UNAVAILABLE;<br>    <span class="hljs-keyword">char</span> *method_types                                       OBJC2_UNAVAILABLE;<br>    IMP method_imp                                           OBJC2_UNAVAILABLE;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>objc_method</code> 存储了方法名，方法类型和方法实现：</p>
<blockquote>
<p>方法名类型为 SEL<br>方法类型 <code>method_types</code> 是个 char 指针，存储方法的参数类 型和返回值类型<br><code>method_imp</code> 指向了方法的实现，本质是一个函数指针</p>
</blockquote>
<h3 id="Ivar"><a href="#Ivar" class="headerlink" title="Ivar"></a>Ivar</h3><p>Ivar 是表示成员变量的类型。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">objc_ivar</span> *<span class="hljs-title">Ivar</span>;</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">objc_ivar</span> &#123;</span><br>    <span class="hljs-keyword">char</span> *ivar_name                                          OBJC2_UNAVAILABLE;<br>    <span class="hljs-keyword">char</span> *ivar_type                                          OBJC2_UNAVAILABLE;<br>    <span class="hljs-keyword">int</span> ivar_offset                                          OBJC2_UNAVAILABLE;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> __LP64__</span><br>    <span class="hljs-keyword">int</span> space                                                OBJC2_UNAVAILABLE;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>其中 <code>ivar_offset</code> 是基地址偏移字节</p>
<h3 id="IMP"><a href="#IMP" class="headerlink" title="IMP"></a>IMP</h3><p>IMP在objc.h中的定义是：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">id</span> <span class="hljs-params">(*IMP)</span><span class="hljs-params">(id, SEL, ...)</span></span>;<br></code></pre></td></tr></table></figure>

<p>IMP在objc.h中的定义是：</p>
<p><code>typedef id (*IMP)(id, SEL, ...);</code></p>
<p>它就是一个函数指针，这是由编译器生成的。当你发起一个 ObjC 消息之后，最终它会执行的那段代码，就是由这个函数指针指定的。而 <code>IMP</code> 这个函数指针就指向了这个方法的实现。</p>
<p>如果得到了执行某个实例某个方法的入口，我们就可以绕开消息传递阶段，直接执行方法，这在后面 Cache 中会提到。</p>
<p>你会发现 IMP 指向的方法与 <code>objc_msgSend</code> 函数类型相同，参数都包含 <code>id</code> 和 <code>SEL</code> 类型。每个方法名都对应一个 <code>SEL</code> 类型的方法选择器，而每个实例对象中的 <code>SEL</code> 对应的方法实现肯定是唯一的，通过一组 <code>id</code>和 <code>SEL</code> 参数就能确定唯一的方法实现地址。</p>
<p>而一个确定的方法也只有唯一的一组 <code>id</code> 和 <code>SEL </code>参数</p>
<h3 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h3><p>Cache 定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">objc_cache</span> *<span class="hljs-title">Cache</span></span><br><span class="hljs-class"></span><br><span class="hljs-class"><span class="hljs-title">struct</span> <span class="hljs-title">objc_cache</span> &#123;</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> mask <span class="hljs-comment">/* total = mask + 1 */</span>                 OBJC2_UNAVAILABLE;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> occupied                                    OBJC2_UNAVAILABLE;<br>    Method buckets[<span class="hljs-number">1</span>]                                        OBJC2_UNAVAILABLE;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>Cache 为方法调用的性能进行优化，每当实例对象接收到一个消息时，它不会直接在 <code>isa</code> 指针指向的类的方法列表中遍历查找能够响应的方法，因为每次都要查找效率太低了，而是优先在 Cache 中查找。</p>
<p>Runtime 系统会把被调用的方法存到 Cache 中，如果一个方法被调用，那么它有可能今后还会被调用，下次查找的时候就会效率更高。就像计算机组成原理中 CPU 绕过主存先访问 Cache 一样。</p>
<h3 id="Property"><a href="#Property" class="headerlink" title="Property"></a>Property</h3><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">objc_property</span> *<span class="hljs-title">Property</span>;</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">objc_property</span> *<span class="hljs-title">objc_property_t</span>;</span><span class="hljs-comment">//这个更常用</span><br></code></pre></td></tr></table></figure>

<p>可以通过class_copyPropertyList 和 protocol_copyPropertyList 方法获取类和协议中的属性：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">objc_property_t</span> *<span class="hljs-title">class_copyPropertyList</span><span class="hljs-params">(Class cls, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> *outCount)</span></span><br><span class="hljs-function"><span class="hljs-keyword">objc_property_t</span> *<span class="hljs-title">protocol_copyPropertyList</span><span class="hljs-params">(Protocol *proto, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> *outCount)</span></span><br></code></pre></td></tr></table></figure>

<p><code>返回的是属性列表，列表中每个元素都是一个 objc_property_t 指针</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#import <span class="hljs-meta-string">&lt;Foundation/Foundation.h&gt;</span></span><br><br>@interface Person : NSObject<br><br><span class="hljs-comment">/** 姓名 */</span><br>@property (strong, nonatomic) NSString *name;<br><br><span class="hljs-comment">/** age */</span><br>@property (assign, nonatomic) <span class="hljs-keyword">int</span> age;<br><br><span class="hljs-comment">/** weight */</span><br>@property (assign, nonatomic) <span class="hljs-keyword">double</span> weight;<br><br>@end<br><br></code></pre></td></tr></table></figure>

<p>以上是一个 Person 类，有3个属性。让我们用上述方法获取类的运行时属性。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> outCount = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">objc_property_t</span> *properties = class_copyPropertyList([Person class], &amp;outCount);<br><br>    NSLog(@<span class="hljs-string">&quot;%d&quot;</span>, outCount);<br><br>    <span class="hljs-keyword">for</span> (NSInteger i = <span class="hljs-number">0</span>; i &lt; outCount; i++) &#123;<br>        NSString *name = @(property_getName(properties[i]));<br>        NSString *attributes = @(property_getAttributes(properties[i]));<br>        NSLog(@<span class="hljs-string">&quot;%@--------%@&quot;</span>, name, attributes);<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>打印结果：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-number">2014</span><span class="hljs-number">-11</span><span class="hljs-number">-10</span> <span class="hljs-number">11</span>:<span class="hljs-number">27</span>:<span class="hljs-number">28.473</span> test[<span class="hljs-number">2321</span>:<span class="hljs-number">451525</span>] <span class="hljs-number">3</span><br><span class="hljs-number">2014</span><span class="hljs-number">-11</span><span class="hljs-number">-10</span> <span class="hljs-number">11</span>:<span class="hljs-number">27</span>:<span class="hljs-number">28.473</span> test[<span class="hljs-number">2321</span>:<span class="hljs-number">451525</span>] name--------T@<span class="hljs-string">&quot;NSString&quot;</span>,&amp;,N,V_name<br><span class="hljs-number">2014</span><span class="hljs-number">-11</span><span class="hljs-number">-10</span> <span class="hljs-number">11</span>:<span class="hljs-number">27</span>:<span class="hljs-number">28.473</span> test[<span class="hljs-number">2321</span>:<span class="hljs-number">451525</span>] age--------Ti,N,V_age<br><span class="hljs-number">2014</span><span class="hljs-number">-11</span><span class="hljs-number">-10</span> <span class="hljs-number">11</span>:<span class="hljs-number">27</span>:<span class="hljs-number">28.474</span> test[<span class="hljs-number">2321</span>:<span class="hljs-number">451525</span>] weight--------Td,N,V_weight<br></code></pre></td></tr></table></figure>

<p><code>property_getName</code> 用来查找属性的名称，返回 c 字符串。<code>property_getAttributes</code> 函数挖掘属性的真实名称和 @encode 类型，返回 c 字符串。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">objc_property_t</span> <span class="hljs-title">class_getProperty</span><span class="hljs-params">(Class cls, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name)</span></span><br><span class="hljs-function"><span class="hljs-keyword">objc_property_t</span> <span class="hljs-title">protocol_getProperty</span><span class="hljs-params">(Protocol *proto, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name, BOOL isRequiredProperty, BOOL isInstanceProperty)</span></span><br></code></pre></td></tr></table></figure>
<p><code>·class_getProperty</code> 和 <code>protocol_getProperty</code> 通过给出属性名在类和协议中获得属性的引用。</p>
<h2 id="消息"><a href="#消息" class="headerlink" title="消息"></a>消息</h2><p>消息发送步骤：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1330553-87d03a7c0971c730.gif?imageMogr2/auto-orient/strip" alt="消息转发步骤"></p>
<p>详解：</p>
<blockquote>
<p>首先检测这个 selector 是不是要忽略。比如 Mac OS X 开发，有了垃圾回收就不理会 retain，release 这些函数。<br>检测这个 selector 的 target 是不是 nil，Objc 允许我们对一个 nil 对象执行任何方法不会 Crash，因为运行时会被忽略掉。<br>如果上面两步都通过了，那么就开始查找这个类的实现 IMP，先从 cache 里查找，如果找到了就运行对应的函数去执行相应的代码。<br>如果 cache 找不到就找类的方法列表中是否有对应的方法。<br>如果类的方法列表中找不到就到父类的方法列表中查找，一直找到 NSObject 类为止。<br>如果还找不到，就要开始进入动态方法解析了，后面会提到</p>
</blockquote>
<p>在消息的传递中，编译器会根据情况在 <code>objc_msgSend</code> ， <code>objc_msgSend_stret</code> ， <code>objc_msgSendSuper</code> ， <code>objc_msgSendSuper_stret</code> 这四个方法中选择一个调用。</p>
<ul>
<li>如果消息是传递给父类，那么会调用名字带有 Super 的函数，</li>
<li>如果消息返回值是数据结构而不是简单值时，会调用名字带有 stret 的函数。</li>
</ul>
<h3 id="方法中的隐藏参数"><a href="#方法中的隐藏参数" class="headerlink" title="方法中的隐藏参数"></a>方法中的隐藏参数</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">疑问：<br>我们经常用到关键字 self ，但是 self 是如何获取当前方法的对象呢？<br></code></pre></td></tr></table></figure>

<p>其实，这也是 Runtime 系统的作用，self 实在方法运行时被动态传入的。</p>
<p>当 <code>objc_msgSend</code> 找到方法对应实现时，它将直接调用该方法实现，并将消息中所有参数都传递给方法实现，同时，它还将传递两个隐藏参数：</p>
<blockquote>
<p>接受消息的对象(self 所指向的内容，当前方法的对象指针)<br>方法选择器(_cmd 指向的内容，当前方法的 SEL 指针)</p>
</blockquote>
<p>因为在源代码方法的定义中，我们并没有发现这两个参数的声明。它们时在代码被编译时被插入方法实现中的。尽管这些参数没有被明确声明，在源代码中我们仍然可以引用它们。</p>
<p>这两个参数中， self更实用。它是在方法实现中访问消息接收者对象的实例变量的途径。</p>
<p>这时我们可能会想到另一个关键字 super ，实际上 super 关键字接收到消息时，编译器会创建一个 <code>objc_super</code> 结构体：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">objc_super</span> &#123;</span> id receiver; Class <span class="hljs-class"><span class="hljs-keyword">class</span>;</span> &#125;;<br></code></pre></td></tr></table></figure>

<p>这个结构体指明了消息应该被传递给特定的父类。 receiver 仍然是 self 本身，当我们想通过 <code>[super class]</code> 获取父类时，编译器其实是将指向 self 的 id 指针和 class 的 SEL 传递给了 <code>objc_msgSendSuper</code> 函数。</p>
<p>只有在 NSObject 类中才能找到 class 方法，然后 class 方法底层被转换为 <code>object_getClass()</code>， 接着底层编译器将代码转换为 <code>objc_msgSend(objc_super-&gt;receiver, @selector(class))</code>，<br>传入的第一个参数是指向 self 的 id 指针，与调用 <code>[self class]</code> 相同，所以我们得到的永远都是 self 的类型。因此你会发现：<br>// 这句话并不能获取父类的类型，只能获取当前类的类型名</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%@&quot;</span>, <span class="hljs-built_in">NSStringFromClass</span>([<span class="hljs-keyword">super</span> <span class="hljs-keyword">class</span>]));<br></code></pre></td></tr></table></figure>

<h3 id="获取方法地址"><a href="#获取方法地址" class="headerlink" title="获取方法地址"></a>获取方法地址</h3><p>NSObject 类中有一个实例方法：<code>methodForSelector</code>，你可以用它来获取某个方法选择器对应的 IMP ，举个例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">void (*setter)(id, SEL, BOOL);<br>int i;<br><br>setter &#x3D; (void (*)(id, SEL, BOOL))[target<br>    methodForSelector:@selector(setFilled:)];<br>for ( i &#x3D; 0 ; i &lt; 1000 ; i++ )<br>    setter(targetList[i], @selector(setFilled:), YES);<br></code></pre></td></tr></table></figure>

<p>当方法被当做函数调用时，两个隐藏参数也必须明确给出，上面的例子调用了1000次函数，你也可以尝试给 target 发送1000次 setFilled: 消息会花多久。</p>
<p>虽然可以更高效的调用方法，但是这种做法很少用，除非时需要持续大量重复调用某个方法的情况，才会选择使用以免消息发送泛滥。</p>
<p><code>注意：methodForSelector:方法是由 Runtime 系统提供的，而不是 Objc 自身的特性</code></p>
<h3 id="动态方法解析"><a href="#动态方法解析" class="headerlink" title="动态方法解析"></a>动态方法解析</h3><p>你可以动态提供一个方法实现。如果我们使用关键字 @dynamic 在类的实现文件中修饰一个属性，表明我们会为这个属性动态提供存取方法，编译器不会再默认为我们生成这个属性的 setter 和 getter 方法了，需要我们自己提供。</p>
<p><code>@dynamic propertyName;</code></p>
<p>这时，我们可以通过分别重载 <code>resolveInstanceMethod:</code> 和 <code>resolveClassMethod:</code> 方法添加实例方法实现和类方法实现。</p>
<p>当 Runtime 系统在 Cache 和类的方法列表(包括父类)中找不到要执行的方法时，Runtime 会调用 <code>resolveInstanceMethod: </code>或 <code>resolveClassMethod:</code> 来给我们一次动态添加方法实现的机会。我们需要用 <code>class_addMethod</code> 函数完成向特定类添加特定方法实现的操作：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">void dynamicMethodIMP(id self, SEL _cmd) &#123;<br>    &#x2F;&#x2F; implementation ....<br>&#125;<br>@implementation MyClass<br>+ (BOOL)resolveInstanceMethod:(SEL)aSEL<br>&#123;<br>    if (aSEL &#x3D;&#x3D; @selector(resolveThisMethodDynamically)) &#123;<br>          class_addMethod([self class], aSEL, (IMP) dynamicMethodIMP, &quot;v@:&quot;);<br>          return YES;<br>    &#125;<br>    return [super resolveInstanceMethod:aSEL];<br>&#125;<br>@end<br><br></code></pre></td></tr></table></figure>

<p>上面的例子为 <code>resolveThisMethodDynamically</code> 方法添加了实现内容，就是 <code>dynamicMethodIMP</code> 方法中的代码。其中 “v@:” 表示返回值和参数，这个符号表示的含义见：<a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html">Type Encoding</a></p>
<p>注意：<br>动态方法解析会在消息转发机制侵入前执行，动态方法解析器将会首先给予提供该方法选择器对应的 IMP 的机会。如果你想让该方法选择器被传送到转发机制，就让 <code>resolveInstanceMethod: </code>方法返回 NO。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1330553-400bc5bde4db1725.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="消息转发"></p>
<h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h3><p>消息转发机制执行前，Runtime 系统允许我们替换消息的接收者为其他对象。通过 <code>- (id)forwardingTargetForSelector:(SEL)aSelector</code> 方法。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">- (<span class="hljs-keyword">id</span>)forwardingTargetForSelector:(SEL)aSelector<br>&#123;<br>    <span class="hljs-keyword">if</span>(aSelector == <span class="hljs-keyword">@selector</span>(mysteriousMethod:))&#123;<br>        <span class="hljs-keyword">return</span> alternateObject;<br>    &#125;<br>    <span class="hljs-keyword">return</span> [<span class="hljs-keyword">super</span> forwardingTargetForSelector:aSelector];<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果此方法返回 nil 或者 self，则会计入消息转发机制(<code>forwardInvocation:</code>)，否则将向返回的对象重新发送消息。</p>
<h3 id="转发"><a href="#转发" class="headerlink" title="转发"></a>转发</h3><p>当动态方法解析不做处理返回 NO 时，则会触发消息转发机制。这时 <code>forwardInvocation:</code> 方法会被执行，我们可以重写这个方法来自定义我们的转发逻辑：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">- (<span class="hljs-keyword">void</span>)forwardInvocation:(<span class="hljs-built_in">NSInvocation</span> *)anInvocation<br>&#123;<br>    <span class="hljs-keyword">if</span> ([someOtherObject respondsToSelector:<br>            [anInvocation selector]])<br>        [anInvocation invokeWithTarget:someOtherObject];<br>    <span class="hljs-keyword">else</span><br>        [<span class="hljs-keyword">super</span> forwardInvocation:anInvocation];<br>&#125;<br></code></pre></td></tr></table></figure>
<p>唯一参数是个 <code>NSInvocation</code> 类型的对象，该对象封装了原始的消息和消息的参数。我们可以实现 <code>forwardInvocation:</code> 方法来对不能处理的消息做一些处理。也可以将消息转发给其他对象处理，而不抛出错误。</p>
<p><code>注意：</code></p>
<p>参数 anInvocation 是从哪来的？</p>
<pre><code>在 forwardInvocation: 消息发送前，Runtime 系统会向对象发送methodSignatureForSelector: 消息，并取到返回的方法签名用于生成 NSInvocation 对象。所以重写 
forwardInvocation: 的同时也要重写 methodSignatureForSelector: 方法，否则会抛异常。</code></pre>
<h3 id="消息转发"><a href="#消息转发" class="headerlink" title="消息转发"></a>消息转发</h3><p>当一个对象由于没有相应的方法实现而无法相应某消息时，运行时系统将通过 <code>forwardInvocation:</code> 消息通知该对象。每个对象都继承了 <code>forwardInvocation:</code> 方法。但是， NSObject 中的方法实现只是简单的调用了 <code>doesNotRecognizeSelector:</code>。通过实现自己的 <code>forwardInvocation:</code> 方法，我们可以将消息转发给其他对象。</p>
<p><code>forwardInvocation: </code>方法就是一个不能识别消息的分发中心，将这些不能识别的消息转发给不同的接收对象，或者转发给同一<br>个对象，再或者将消息翻译成另外的消息，亦或者简单的“吃掉”某些消息，因此没有响应也不会报错。这一切都取决于方法的具体实现。</p>
<h3 id="转发和多继承"><a href="#转发和多继承" class="headerlink" title="转发和多继承"></a>转发和多继承</h3><p>转发和继承相似，可用于为 Objc 编程添加一些多继承的效果。就像下图那样，一个对象把消息转发出去，就好像它把另一个对象中的方法接过来或者“继承”过来一样。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1330553-c7ef6392ecc9ee9d.gif?imageMogr2/auto-orient/strip" alt="转发"></p>
<p>这使得在不同继承体系分支下的两个类可以实现“继承”对方的方法，在上图中 <code>Warrior</code> 和 <code>Diplomat</code> 没有继承关系，但是 <code>Warrior</code> 将 <code>negotiate</code> 消息转发给了 <code>Diplomat</code> 后，就好似 <code>Diploma</code>t 是 <code>Warrior</code> 的超类一样。</p>
<p>消息转发弥补了 Objc 不支持多继承的性质，也避免了因为多继承导致单个类变得臃肿复杂</p>
<h3 id="转发与继承"><a href="#转发与继承" class="headerlink" title="转发与继承"></a>转发与继承</h3><p>虽然转发可以实现继承的功能，但是 NSObject 还是必须表面上很严谨，像 <code>respondsToSelector:</code> 和 <code>isKindOfClass:</code> 这类方法只会考虑继承体系，不会考虑转发链。</p>
<p>如果上图中的 Warrior 对象被问到是否能响应 negotiate消息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">if ( [aWarrior respondsToSelector:@selector(negotiate)] )<br></code></pre></td></tr></table></figure>

<p>回答当然是 NO， 尽管它能接受 negotiate 消息而不报错，因为它靠转发消息给 Diplomat 类响应消息。</p>
<p>如果你就是想要让别人以为 Warrior 继承到了 Diplomat 的 negotiate 方法，你得重新实现 <code>respondsToSelector:</code> 和 <code>isKindOfClass:</code> 来加入你的转发算法：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">- (<span class="hljs-built_in">BOOL</span>)respondsToSelector:(SEL)aSelector<br>&#123;<br>    <span class="hljs-keyword">if</span> ( [<span class="hljs-keyword">super</span> respondsToSelector:aSelector] )<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">YES</span>;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">/* Here, test whether the aSelector message can     *</span><br><span class="hljs-comment">         * be forwarded to another object and whether that  *</span><br><span class="hljs-comment">         * object can respond to it. Return YES if it can.  */</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NO</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>除了 <code>respondsToSelector:</code> 和 <code>isKindOfClass:</code> 之外，<code>instancesRespondToSelector:</code> 中也应该写一份转发算法。如果使用了协议，<code>conformsToProtocol:</code> 同样也要加入到这一行列中。</p>
<p>如果一个对象想要转发它接受的任何远程消息，它得给出一个方法标签来返回准确的方法描述 <code>methodSignatureForSelector:</code>，这个方法会最终响应被转发的消息。从而生成一个确定的 <code>NSInvocation</code> 对象描述消息和消息参数。这个方法最终响应被转发的消息。它需要像下面这样实现：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">- (<span class="hljs-built_in">NSMethodSignature</span>*)methodSignatureForSelector:(SEL)selector<br>&#123;<br>    <span class="hljs-built_in">NSMethodSignature</span>* signature = [<span class="hljs-keyword">super</span> methodSignatureForSelector:selector];<br>    <span class="hljs-keyword">if</span> (!signature) &#123;<br>       signature = [surrogate methodSignatureForSelector:selector];<br>    &#125;<br>    <span class="hljs-keyword">return</span> signature;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="健壮的实例变量-Non-Fragile-ivars"><a href="#健壮的实例变量-Non-Fragile-ivars" class="headerlink" title="健壮的实例变量(Non Fragile ivars)"></a>健壮的实例变量(Non Fragile ivars)</h3><p>在 Runtime 的现行版本中，最大的特点就是健壮的实例变量了。当一个类被编译时，实例变量的内存布局就形成了，它表明访问类的实例变量的位置。实例变量一次根据自己所占空间而产生位移</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1330553-bcbc243a281ef8d9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>上图左是 NSObject 类的实例变量布局。右边是我们写的类的布局。这样子有一个很大的缺陷，就是缺乏拓展性。哪天苹果更新了 NSObject 类的话，就会出现问题：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1330553-33263710847f6d86.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>我们自定义的类的区域和父类的区域重叠了。只有苹果将父类改为以前的布局才能拯救我们，但这样导致它们不能再拓展它们的框架了，因为成员变量布局被固定住了。在脆弱的实例变量(Fragile ivar)环境下，需要我们重新编译继承自 Apple 的类来恢复兼容。</p>
<p>在健壮的实例变量下，编译器生成的实例变量布局跟以前一样，但是当 Runtime 系统检测到与父类有部分重叠时它会调整你新添加的实例变量的位移，那样你再子类中新添加的成员变量就被保护起来了。</p>
<p>注意：<br>在健壮的实例变量下，不要使用 <code>siof(SomeClass)</code>，而是用 <code>class_getInstanceSize([SomeClass class])</code> 代替；也不要使用 <code>offsetof(SomeClass, SomeIvar)</code>，而要使用 <code>ivar_getOffset(class_getInstanceVariable([SomeClass class], &quot;SomeIvar&quot;))</code> 来代替。</p>
<h2 id="Runtime-在iOS中的应用"><a href="#Runtime-在iOS中的应用" class="headerlink" title="Runtime 在iOS中的应用"></a>Runtime 在iOS中的应用</h2><h3 id="KVO"><a href="#KVO" class="headerlink" title="KVO"></a>KVO</h3><p>KVO，即：<code>Key-Value Observing</code>，它提供一种机制，当指定的对象的属性被修改后，则其观察者就会接受到通知。简单的说就是每次指定的被观察的对象的属性被修改后，KVO就会自动通知相应的观察者了。</p>
<h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><br><span class="hljs-meta">#import <span class="hljs-meta-string">&quot;ViewController.h&quot;</span></span><br><span class="hljs-meta">#import <span class="hljs-meta-string">&quot;Person.h&quot;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">ViewController</span> ()</span><br><span class="hljs-comment">/** p1 */</span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">strong</span>, <span class="hljs-keyword">nonatomic</span>) Person *p1;<br><br><span class="hljs-keyword">@end</span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">ViewController</span></span><br><br>- (<span class="hljs-keyword">void</span>)viewDidLoad &#123;<br>    [<span class="hljs-keyword">super</span> viewDidLoad];<br>    <span class="hljs-comment">// 1.什么是通知</span><br>    <br>    <span class="hljs-comment">// 3个对象</span><br>    <span class="hljs-keyword">self</span>.p1 = [[Person alloc] init];<br>    <span class="hljs-keyword">self</span>.p1.name = <span class="hljs-string">@&quot;p1&quot;</span>;<br>    <br>    <span class="hljs-comment">// KVO是监听对象的属性值的改变的</span><br>    [<span class="hljs-keyword">self</span>.p1 addObserver:<span class="hljs-keyword">self</span> forKeyPath:<span class="hljs-string">@&quot;name&quot;</span> options:<span class="hljs-built_in">NSKeyValueObservingOptionNew</span> | <span class="hljs-built_in">NSKeyValueObservingOptionOld</span> context:<span class="hljs-literal">nil</span>];<br>    <span class="hljs-keyword">self</span>.p1.name = <span class="hljs-string">@&quot;123&quot;</span>;<br>    <br>&#125;<br><br><span class="hljs-comment">// 这个方法时属于 NSObject 类的，任何对象都可以作为观察者</span><br>- (<span class="hljs-keyword">void</span>)observeValueForKeyPath:(<span class="hljs-built_in">NSString</span> *)keyPath ofObject:(<span class="hljs-keyword">id</span>)object change:(<span class="hljs-built_in">NSDictionary</span>&lt;<span class="hljs-built_in">NSString</span> *,<span class="hljs-keyword">id</span>&gt; *)change context:(<span class="hljs-keyword">void</span> *)context<br>&#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;监听到了%@的%@属性发生了改变&quot;</span>, object, keyPath);<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%@&quot;</span>, change);<br>&#125;<br><br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure>
<p>打印结果：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">打印结果：<br><span class="hljs-number">2014</span><span class="hljs-number">-05</span><span class="hljs-number">-11</span> <span class="hljs-number">19</span>:<span class="hljs-number">55</span>:<span class="hljs-number">34.319</span> KVO和KVC和通知代理[<span class="hljs-number">559</span>:<span class="hljs-number">109378</span>] 监听到了&lt;Person: <span class="hljs-number">0x15ee2baa0</span>&gt;的name属性发生了改变<br><span class="hljs-number">2014</span><span class="hljs-number">-05</span><span class="hljs-number">-11</span> <span class="hljs-number">19</span>:<span class="hljs-number">55</span>:<span class="hljs-number">34.320</span> KVO和KVC和通知代理[<span class="hljs-number">559</span>:<span class="hljs-number">109378</span>] <span class="hljs-number">123</span><br></code></pre></td></tr></table></figure>
<h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><p>当 p1.name 的值改变时，p1对象的 isa 指针会指向 NSKVONotifying_Person，意味着，在程序运行时，会动态生成一个 NSKVONotifying_Person 类，该类继承于 Person，而且该类中也有个 -setName: 方法，方法中在设置 name 的同时实现了：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><br>- (<span class="hljs-keyword">void</span>)setName:(<span class="hljs-built_in">NSString</span> *)name<br>&#123;<br>    [<span class="hljs-keyword">super</span> setName:name];<br>    <br>    <span class="hljs-comment">// 这两个方法底层会调用observer的- (void)observeValueForKeyPath: ofObject: change: context:这个方法</span><br>    [<span class="hljs-keyword">self</span> willChangeValueForKey:<span class="hljs-string">@&quot;age&quot;</span>];<br>    [<span class="hljs-keyword">self</span> didChangeValueForKey:<span class="hljs-string">@&quot;age&quot;</span>];<br>&#125;<br></code></pre></td></tr></table></figure>


<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><h3 id="实现原理-1"><a href="#实现原理-1" class="headerlink" title="实现原理"></a>实现原理</h3><p>无论我们有没有主动引入 Category 的头文件，Category 中的方法都会被添加进主类中。我们可以通过<code>·- performSelector: </code>等<br>方式对<code>Category</code>中的相应方法进行调用，之所以需要在调用的地方引入 Category 的头文件，只是为了“照顾”编译器同学的感受</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs oc">static void attachCategories(Class cls, category_list *cats, bool flush_caches) &#123;  <br>    if (!cats) return;<br>    bool isMeta &#x3D; cls-&gt;isMetaClass();<br><br>    method_list_t **mlists &#x3D; (method_list_t **)malloc(cats-&gt;count * sizeof(*mlists));<br>    &#x2F;&#x2F; Count backwards through cats to get newest categories first<br>    int mcount &#x3D; 0;<br>    int i &#x3D; cats-&gt;count;<br>    while (i--) &#123;<br>        auto&amp; entry &#x3D; cats-&gt;list[i];<br><br>        method_list_t *mlist &#x3D; entry.cat-&gt;methodsForMeta(isMeta);<br>        if (mlist) &#123;<br>            mlists[mcount++] &#x3D; mlist;<br>        &#125;<br>    &#125;<br><br>    auto rw &#x3D; cls-&gt;data();<br><br>    prepareMethodLists(cls, mlists, mcount, NO, fromBundle);<br>    rw-&gt;methods.attachLists(mlists, mcount);<br>    free(mlists);<br>    if (flush_caches  &amp;&amp;  mcount &gt; 0) flushCaches(cls);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>通过 while 循环，我们遍历所有的 category，也就是参数 <code>cats</code> 中的 <code>list</code> 属性。对于每一个 category，得到它的方法列表 <code>mlist</code> 并存入 <code>mlists</code> 中。</p>
<p>换句话说，我们将所有 <code>category</code> 中的方法拼接到了一个大的二维数组中，数组的每一个元素都是装有一个 <code>category</code> 所有方法的容器</p>
<p>在 while 循环外，我们得到了拼接成的方法，此时需要与类原来的方法合并</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs oc">void attachLists(List* const * addedLists, uint32_t addedCount) &#123;  <br>    if (addedCount &#x3D;&#x3D; 0) return;<br>    uint32_t oldCount &#x3D; array()-&gt;count;<br>    uint32_t newCount &#x3D; oldCount + addedCount;<br>    setArray((array_t *)realloc(array(), array_t::byteSize(newCount)));<br>    array()-&gt;count &#x3D; newCount;<br>    memmove(array()-&gt;lists + addedCount, array()-&gt;lists, oldCount * sizeof(array()-&gt;lists[0]));<br>    memcpy(array()-&gt;lists, addedLists, addedCount * sizeof(array()-&gt;lists[0]));<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这段代码很简单，其实就是先调用 realloc() 函数将原来的空间拓展，然后把原来的数组复制到后面，最后再把新数组复制到前面。</p>
<p>因此 category 中定义的同名方法不会替换类中原有的方法，但是对原方法的调用实际上会调用 category 中的方法。</p>
<h3 id="Objective-C-load-vs-initialize"><a href="#Objective-C-load-vs-initialize" class="headerlink" title="Objective-C +load vs +initialize"></a>Objective-C +load vs +initialize</h3><h4 id="load"><a href="#load" class="headerlink" title="+load"></a>+load</h4><p>这样的调用方式就使得 <code>+load</code> 方法拥有了一个非常有趣的特性，那就是子类、父类和分类中的 <code>+load</code> 方法的实现是被区别对待的。也就是说如果子类没有实现 <code>+load</code> 方法，那么当它被加载时 runtime 是不会去调用父类的 <code>+load</code> 方法的。同理，当一个类和它的分类都实现了 <code>+load</code> 方法时，两个方法都会被调用。因此，我们常常可以利用这个特性做一些“邪恶”的事情，比如说方法混淆<a href="http://nshipster.com/method-swizzling/">Method Swizzling</a>。</p>
<h4 id="initialize"><a href="#initialize" class="headerlink" title="+initialize"></a>+initialize</h4><p><code>+initialize</code> 方法是在类或它的子类收到第一条消息之前被调用的，这里所指的消息包括实例方法和类方法的调用。也就是说 <code>+initialize</code> 方法是以懒加载的方式被调用的，如果程序一直没有给某个类或它的子类发送消息，那么这个类的 <code>+initialize</code> 方法是永远不会被调用的。那这样设计有什么好处呢？好处是显而易见的，那就是节省系统资源，避免浪费。</p>
<p>因此，如果一个子类没有实现 +initialize 方法，那么父类的实现是会被执行多次的。有时候，这可能是你想要的；但如果我们想确保自己的 +initialize 方法只执行一次，避免多次执行可能带来的副作用时，我们可以使用下面的代码来实现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">+ (void)initialize &#123;<br>  if (self &#x3D;&#x3D; [ClassName self]) &#123;<br>    &#x2F;&#x2F; ... do the initialization ...<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h4><table>
<thead>
<tr>
<th></th>
<th align="center">+load</th>
<th align="right">+initialize</th>
</tr>
</thead>
<tbody><tr>
<td>调用时机</td>
<td align="center">被添加到runtime时</td>
<td align="right">收到第一条消息前，可能永远不调用</td>
</tr>
<tr>
<td>调用顺序</td>
<td align="center">父类-&gt;子类-&gt;分类</td>
<td align="right">父类-&gt;子类</td>
</tr>
<tr>
<td>调用次数</td>
<td align="center">1次</td>
<td align="right">多次</td>
</tr>
<tr>
<td>是否需要显式调用父类实现</td>
<td align="center">否</td>
<td align="right">否</td>
</tr>
<tr>
<td>是否沿用父类的实现</td>
<td align="center">否</td>
<td align="right">是</td>
</tr>
<tr>
<td>分类中的实现</td>
<td align="center">类和分类都执行</td>
<td align="right">覆盖类中的方法，只执行分类的实现</td>
</tr>
</tbody></table>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="http://www.cnblogs.com/ioshe/p/5489086.html">iOS开发-Runtime详解（简书）</a><br><a href="https://opensource.apple.com/source/objc4/">Runtime源码</a><br><a href="http://lizhaoloveit.com/2014/05/11/KVO/">KVO</a><br><a href="https://tech.meituan.com/DiveIntoCategory.html">深入理解Objective-C：Category</a><br><a href="https://www.jianshu.com/p/55f781f8c915">iOS成员属性和成员变量的区别</a></p>
]]></content>
      <categories>
        <category>Runtime</category>
      </categories>
      <tags>
        <tag>Runtime SEL Method</tag>
      </tags>
  </entry>
  <entry>
    <title>Runtime之消息转发</title>
    <url>/2020/11/15/runtime-msgsend/</url>
    <content><![CDATA[<p>我们都知道，在iOS开发中方法的调用实现实际上是通过消息发送的机制实现的，我们可以简单的理解为：</p>
<p>[A a];调用A类的a方法，实际上就是给类A的a方法发消息。</p>
<p>在这个过程中又会经历：方法查找、方法调用、方法转发这几个阶段，下面我们来通过这几个阶段来看下Runtime在这几个环境是如何实现的。</p>
<a id="more"></a>


<p>在研究方法调用之前，我们先看几个方法调用先关的结构，了解这些结构之后会方便我们后续了解消息的调用流程。</p>
<h4 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h4><p>在我们上文介绍方法交换时，我们利用class_getInstanceMethod方法获取某个方法时，返回的结构体都是Method，我们先来看下这个结构体包含的内容：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> method_t *Method;<br><br><span class="hljs-comment">// OC实例方法或类方法结构体</span><br><span class="hljs-keyword">struct</span> method_t &#123;<br>    <span class="hljs-comment">// 方法名</span><br>    SEL name;<br>    <span class="hljs-comment">// 记录方法返回值和方法参数</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *types;<br>    <span class="hljs-comment">// 方法实现</span><br>    MethodListIMP imp;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>从上面的结构中我们看到一个方法的结构体中包含三个属性：方法名 name SEL 类型；types 方法编码方式包含该方法的返回值类型和参数类型；方法实现地址；</p>
<p>下面我们先从一个简单的例子来看下这三个值分别是什么样的，然后我们在进行深入的研究：</p>
<p>首先我们有一个方法，如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">- (<span class="hljs-built_in">BOOL</span>)canSayHi:(<span class="hljs-built_in">NSString</span> *)name &#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;can say hi to %@&quot;</span>,name);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">YES</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>然后我们尝试获取这个方法的方法名，编码方式，以及方法实现：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">- (<span class="hljs-keyword">void</span>)getMethodStructure &#123;<br>    Method method = class_getInstanceMethod([<span class="hljs-keyword">self</span> <span class="hljs-keyword">class</span>], <span class="hljs-keyword">@selector</span>(canSayHi:));<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;method sel %@&quot;</span>,<span class="hljs-built_in">NSStringFromSelector</span>(method_getName(method)));<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;method types %@&quot;</span>,[<span class="hljs-built_in">NSString</span> stringWithFormat:<span class="hljs-string">@&quot;%s&quot;</span>,method_getTypeEncoding(method)]);<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;method imp %p&quot;</span>,method_getImplementation(method));<br>&#125;<br></code></pre></td></tr></table></figure>

<p>然后我们看下打印结果：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-number">2020</span><span class="hljs-number">-10</span><span class="hljs-number">-31</span> <span class="hljs-number">17</span>:<span class="hljs-number">32</span>:<span class="hljs-number">26.711510</span>+<span class="hljs-number">0800</span> Runtime_MsgSend[<span class="hljs-number">24686</span>:<span class="hljs-number">737212</span>] method sel canSayHi:<br><span class="hljs-number">2020</span><span class="hljs-number">-10</span><span class="hljs-number">-31</span> <span class="hljs-number">17</span>:<span class="hljs-number">32</span>:<span class="hljs-number">26.711697</span>+<span class="hljs-number">0800</span> Runtime_MsgSend[<span class="hljs-number">24686</span>:<span class="hljs-number">737212</span>] method types B24@<span class="hljs-number">0</span>:<span class="hljs-number">8</span>@<span class="hljs-number">16</span><br><span class="hljs-number">2020</span><span class="hljs-number">-10</span><span class="hljs-number">-31</span> <span class="hljs-number">17</span>:<span class="hljs-number">32</span>:<span class="hljs-number">26.711830</span>+<span class="hljs-number">0800</span> Runtime_MsgSend[<span class="hljs-number">24686</span>:<span class="hljs-number">737212</span>] method imp <span class="hljs-number">0x100725c20</span><br></code></pre></td></tr></table></figure>

<p>打印结果非常清晰这个方法的方法名为<code>canSayHi:</code>，方法编码方式为<code>B24@0:8@16</code>,方法实现地址为<code>0x100725c20</code>。</p>
<p>下面我们来仔细看下这三个属性的意义：</p>
<h5 id="SEL"><a href="#SEL" class="headerlink" title="SEL"></a>SEL</h5><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">/// An opaque type that represents a method selector.</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> objc_selector *SEL;<br></code></pre></td></tr></table></figure>
<p>从定义我们可以看出SEL 实际上是一个<code>objc_selector</code>类型的结构体，但是这个结构体在Runtime中我们并没有找到定义。</p>
<p>我们先来看下官方文档给出的解释：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">A selector is the name used to select a method to execute <span class="hljs-keyword">for</span> an object, or the <br>unique identifier that replaces the name when the source code is compiled. A <br>selector by itself doesn’t <span class="hljs-keyword">do</span> anything. It simply identifies a method. The only <br>thing that makes the selector method name different from a plain string is that<br> the compiler makes sure that selectors are unique. What makes a selector useful <br> is that (<span class="hljs-keyword">in</span> conjunction with the runtime) it acts like a dynamic function pointer <br> that, <span class="hljs-keyword">for</span> a given name, automatically points to the implementation of a method <br> appropriate <span class="hljs-keyword">for</span> whichever <span class="hljs-keyword">class</span> it’s used with. Suppose you had a selector <span class="hljs-keyword">for</span> <br> the method run, and classes Dog, Athlete, and ComputerSimulation (each of which <br> implemented a method run). The selector could be used with an instance of each of <br> the classes to invoke its run method—even though the implementation might be <br> different <span class="hljs-keyword">for</span> each.<br></code></pre></td></tr></table></figure>

<p>大概的意思是：selector表示某个对象的某个方法的名字，selector跟一个普通字符串的唯一区别是selector用来在编译时保证方法名的唯一。</p>
<p>因此在绝大多数情况下，我们可以直接把SEL当做一个字符串看待。下面我们来验证下：</p>
<p>在一个类中我们有同名(参数和返回值也相同)的类方法和对象方法</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">- (<span class="hljs-built_in">BOOL</span>)canSayHi:(<span class="hljs-built_in">NSString</span> *)name &#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;can say hi to %@&quot;</span>,name);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">YES</span>;<br>&#125;<br><br>+ (<span class="hljs-built_in">BOOL</span>)canSayHi:(<span class="hljs-built_in">NSString</span> *)name &#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;can say hi to %@&quot;</span>,name);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">YES</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>下面我们来打印下这两个方法的实现：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">- (<span class="hljs-keyword">void</span>)getMethodStructure &#123;<br>    Method method = class_getInstanceMethod([<span class="hljs-keyword">self</span> <span class="hljs-keyword">class</span>], <span class="hljs-keyword">@selector</span>(canSayHi:));<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;method sel %@&quot;</span>,<span class="hljs-built_in">NSStringFromSelector</span>(method_getName(method)));<br><br>    Method method1 = class_getClassMethod([<span class="hljs-keyword">self</span> <span class="hljs-keyword">class</span>], <span class="hljs-keyword">@selector</span>(canSayHi:));<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;method sel %@&quot;</span>,<span class="hljs-built_in">NSStringFromSelector</span>(method_getName(method1)));<br><br>    <span class="hljs-built_in">BOOL</span> isEqual = sel_isEqual(method_getName(method), method_getName(method1));<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;isEqual %@&quot;</span>,@(isEqual));<br>&#125;<br></code></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-number">2020</span><span class="hljs-number">-10</span><span class="hljs-number">-31</span> <span class="hljs-number">17</span>:<span class="hljs-number">54</span>:<span class="hljs-number">22.838428</span>+<span class="hljs-number">0800</span> Runtime_MsgSend[<span class="hljs-number">24985</span>:<span class="hljs-number">752267</span>] method sel canSayHi:<br><span class="hljs-number">2020</span><span class="hljs-number">-10</span><span class="hljs-number">-31</span> <span class="hljs-number">17</span>:<span class="hljs-number">54</span>:<span class="hljs-number">22.838743</span>+<span class="hljs-number">0800</span> Runtime_MsgSend[<span class="hljs-number">24985</span>:<span class="hljs-number">752267</span>] method sel canSayHi:<br><span class="hljs-number">2020</span><span class="hljs-number">-10</span><span class="hljs-number">-31</span> <span class="hljs-number">17</span>:<span class="hljs-number">54</span>:<span class="hljs-number">22.839079</span>+<span class="hljs-number">0800</span> Runtime_MsgSend[<span class="hljs-number">24985</span>:<span class="hljs-number">752267</span>] isEqual <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>
<p>首先我们通过打印发现这两个方法的方法名是相同的都是<code>canSayHi:</code>,但是鉴于我们上面看到在runtime中SEL的定义实际上是一个objc_selector结构体，因此我们还是使用sel_isEqual方法来判断这两个方法是否相等，从打印结果来看，显而易见两者是相等的。鉴于系统并未开放objc_selector结构体，我们大多数情况下将SEL看做方法名标识的字符串也是没问题的。</p>
<h5 id="types"><a href="#types" class="headerlink" title="types"></a>types</h5><p>方法的type实际上是个字符串，从上面的打印我们看到<code>canSayHi:</code>方法的值为<code>B24@0:8@16</code>这又该怎么解析呢？</p>
<p>实际苹果官方文档专门有针对这个字段的解释具体可以看<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html">这里</a></p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gk8otsc5unj30rs0h075z.jpg"></p>
<p>下面我们对<code>B24@0:8@16</code>进行拆解解析：</p>
<table>
<thead>
<tr>
<th>B</th>
<th>24</th>
<th>@</th>
<th>0</th>
<th>:</th>
<th>8</th>
<th>@</th>
<th>16</th>
</tr>
</thead>
<tbody><tr>
<td>返回值类型为bool</td>
<td>占用总空间为24字节</td>
<td>id(SEL)</td>
<td>从0开始存储</td>
<td>SEL</td>
<td>从第0位开始占8位空间</td>
<td>id(NSString)</td>
<td>从8位开始占16位空间</td>
</tr>
</tbody></table>
<p>这个位置研究的不是太明白，有比较了解的可以回复我，或者贴下文档地址，感激！！！</p>
<h5 id="MethodListIMP"><a href="#MethodListIMP" class="headerlink" title="MethodListIMP"></a>MethodListIMP</h5><p>我们来看下MethodListIMP的定义：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">using MethodListIMP = IMP;<br></code></pre></td></tr></table></figure>
<p>IMP的定义如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">/// A pointer to the function of a method implementation. </span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> !OBJC_OLD_DISPATCH_PROTOTYPES</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">void</span> (*IMP)(<span class="hljs-keyword">void</span> <span class="hljs-comment">/* id, SEL, ... */</span> ); <br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">id</span> _Nullable (*IMP)(<span class="hljs-keyword">id</span> _Nonnull, SEL _Nonnull, ...); <br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br></code></pre></td></tr></table></figure>

<p>实际上MethodListIMP就是IMP。</p>
<p>而从我们上面打印的结果看IMP实际就是一个指针，指向方法实现的函数，IMP和SEL是一一对应的。</p>
<p>那是否意味着，我们拿到方法的地址之后可以直接调用这个方法？？？ 下面我们来验证下，当然为了方便我们先简单的定义一个没有参数也没有返回值的方法：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">- (<span class="hljs-keyword">void</span>)test &#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;test&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>然后我们调用下面这个方法：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">- (<span class="hljs-keyword">void</span>)exeIMP &#123;<br>    Method method = class_getInstanceMethod([<span class="hljs-keyword">self</span> <span class="hljs-keyword">class</span>], <span class="hljs-keyword">@selector</span>(test));<br>    IMP imp = method_getImplementation(method);<br>    imp();<br>&#125;<br></code></pre></td></tr></table></figure>
<p>我们看下结果：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-number">2020</span><span class="hljs-number">-10</span><span class="hljs-number">-31</span> <span class="hljs-number">18</span>:<span class="hljs-number">39</span>:<span class="hljs-number">18.334411</span>+<span class="hljs-number">0800</span> Runtime_MsgSend[<span class="hljs-number">25510</span>:<span class="hljs-number">782591</span>] test<br></code></pre></td></tr></table></figure>

<p>方法调用成功！</p>
<p>上述就是Method结构体的介绍，接下来我们来看下消息的调用流程。</p>
<h4 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h4><p>我们都知道方法调用的实现实际上是通过objc_msgSend方法，下面我们来看下这个方法：</p>
<h5 id="objc-msgSend"><a href="#objc-msgSend" class="headerlink" title="objc_msgSend"></a>objc_msgSend</h5><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">/** </span><br><span class="hljs-comment"> * Sends a message with a simple return value to an instance of a class.</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * @param self A pointer to the instance of the class that is to receive the message.</span><br><span class="hljs-comment"> * @param op The selector of the method that handles the message.</span><br><span class="hljs-comment"> * @param ... </span><br><span class="hljs-comment"> *   A variable argument list containing the arguments to the method.</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * @return The return value of the method.</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * @note When it encounters a method call, the compiler generates a call to one of the</span><br><span class="hljs-comment"> *  functions \c objc_msgSend, \c objc_msgSend_stret, \c objc_msgSendSuper, or \c objc_msgSendSuper_stret.</span><br><span class="hljs-comment"> *  Messages sent to an object’s superclass (using the \c super keyword) are sent using \c objc_msgSendSuper; </span><br><span class="hljs-comment"> *  other messages are sent using \c objc_msgSend. Methods that have data structures as return values</span><br><span class="hljs-comment"> *  are sent using \c objc_msgSendSuper_stret and \c objc_msgSend_stret.</span><br><span class="hljs-comment"> */</span><br>OBJC_EXPORT <span class="hljs-keyword">id</span> _Nullable<br>objc_msgSend(<span class="hljs-keyword">id</span> _Nullable <span class="hljs-keyword">self</span>, SEL _Nonnull op, ...)<br>    OBJC_AVAILABLE(<span class="hljs-number">10.0</span>, <span class="hljs-number">2.0</span>, <span class="hljs-number">9.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">2.0</span>);<br></code></pre></td></tr></table></figure>

<p>参数介绍：</p>
<table>
<thead>
<tr>
<th>self</th>
<th>op</th>
<th>…</th>
</tr>
</thead>
<tbody><tr>
<td>表示指向类的实例(类是元类的实例)的指针用来接收消息</td>
<td>SEL 类型 表示调用的方法的方法名</td>
<td>方法的参数</td>
</tr>
</tbody></table>
<p>注意：当这个方法被调用时，实际上编译器会调用<code>objc_msgSend</code>、<code>objc_msgSend_stret</code>、<code>objc_msgSendSuper</code>、<code>objc_msgSendSuper_stret</code>。当给对象的superclass发送消息时(使用super关键词)调用<code>objc_msgSendSuper</code>方法；当方法有返回值时调用的是<code>objc_msgSendSuper_stret</code>或者<code>objc_msgSend_stret</code></p>
<h5 id="objc-msgSendSuper"><a href="#objc-msgSendSuper" class="headerlink" title="objc_msgSendSuper"></a>objc_msgSendSuper</h5><p>我们来看下这个方法的实现：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">/** </span><br><span class="hljs-comment"> * Sends a message with a simple return value to the superclass of an instance of a class.</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * @param super A pointer to an \c objc_super data structure. Pass values identifying the</span><br><span class="hljs-comment"> *  context the message was sent to, including the instance of the class that is to receive the</span><br><span class="hljs-comment"> *  message and the superclass at which to start searching for the method implementation.</span><br><span class="hljs-comment"> * @param op A pointer of type SEL. Pass the selector of the method that will handle the message.</span><br><span class="hljs-comment"> * @param ...</span><br><span class="hljs-comment"> *   A variable argument list containing the arguments to the method.</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * @return The return value of the method identified by \e op.</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * @see objc_msgSend</span><br><span class="hljs-comment"> */</span><br>OBJC_EXPORT <span class="hljs-keyword">id</span> _Nullable<br>objc_msgSendSuper(<span class="hljs-keyword">struct</span> objc_super * _Nonnull <span class="hljs-keyword">super</span>, SEL _Nonnull op, ...)<br>    OBJC_AVAILABLE(<span class="hljs-number">10.0</span>, <span class="hljs-number">2.0</span>, <span class="hljs-number">9.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">2.0</span>);<br></code></pre></td></tr></table></figure>

<p>我们看到这个方法的第一个参数是objc_super类型，我们在进一步看下这个类型：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">/// Specifies the superclass of an instance. </span><br><span class="hljs-keyword">struct</span> objc_super &#123;<br>    <span class="hljs-comment">/// Specifies an instance of a class.</span><br>    __<span class="hljs-keyword">unsafe_unretained</span> _Nonnull <span class="hljs-keyword">id</span> receiver;<br><br>    <span class="hljs-comment">/// Specifies the particular superclass of the instance to message. </span><br>    __<span class="hljs-keyword">unsafe_unretained</span> _Nonnull Class super_class;<br>    <span class="hljs-comment">/* super_class is the first class to search */</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<p>结合上面对objc_msgSendSuper注释的理解，我们可以看出objc_super结构体中两个属性的含义：</p>
<ul>
<li>receiver: 调用super方法的子类，用于方法发送后消息的接收</li>
<li>super_class：子类 receiver的父类 方法查找会先从这个类开始</li>
</ul>
<h5 id="objc-msgSend-1"><a href="#objc-msgSend-1" class="headerlink" title="objc_msgSend"></a>objc_msgSend</h5><p>objc_msgSend方法的实现，在runtime中实际是用汇编语言实现的，下面我们来看下实现，顺便猜想实现原理：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">	ENTRY _objc_msgSend<br>	<span class="hljs-comment">//cbz 比较（Compare），如果结果为零（Zero）就转移（只能跳到后面的指令）</span><br>    <span class="hljs-comment">//在汇编代码中 r0 表示函数的第一个参数，所以 r0 代表消息的接受者，</span><br>    <span class="hljs-comment">// 判断 r0 (消息接受者)是否为空，如果为空跳转到 标签 `LNilReceiver_f`</span><br>	cbz	r0, LNilReceiver_f<br>    <span class="hljs-comment">// 将 [r0] 的值加载到r9寄存器</span><br>	ldr	r9, [r0]		<span class="hljs-comment">// r9 = self-&gt;isa</span><br>    <span class="hljs-comment">// 调用GetClassFromIsa方法 根据isa获取到对应的类</span><br>	GetClassFromIsa			<span class="hljs-comment">// r9 = class</span><br>    <span class="hljs-comment">// 调用CacheLookup方法 查找方法缓存</span><br>	CacheLookup NORMAL<br>	<span class="hljs-comment">// cache hit, IMP in r12, eq already set for nonstret forwarding</span><br>    <span class="hljs-comment">// 如果缓存命中 IMP 放到r12中 调用imp方法</span><br>	bx	r12			<span class="hljs-comment">// call imp</span><br><br><br>    <span class="hljs-comment">// 没有找到缓存的方法</span><br>	CacheLookup2 NORMAL<br>	<span class="hljs-comment">// cache miss r0的内容加载到r9中</span><br>	ldr	r9, [r0]		<span class="hljs-comment">// r9 = self-&gt;isa</span><br>    <span class="hljs-comment">// 调用GetClassFromIsa方法 根据isa获取到对应的类</span><br>	GetClassFromIsa			<span class="hljs-comment">// r9 = class</span><br>    <span class="hljs-comment">// b 跳转指令，可带条件跳转与cmp配合使用</span><br>    <span class="hljs-comment">// 跳转去执行 __objc_msgSend_uncached 既然没有找到方法,就去从类,父类,元类中查找</span><br>	b	__objc_msgSend_uncached<br><br>LNilReceiver:<br>	<span class="hljs-comment">// r0 is already zero</span><br>    <span class="hljs-comment">// 消息接受者为空 表示r0为空</span><br>	mov	r1, #<span class="hljs-number">0</span><br>	mov	r2, #<span class="hljs-number">0</span><br>	mov	r3, #<span class="hljs-number">0</span><br>    <span class="hljs-comment">// return 0</span><br>	FP_RETURN_ZERO<br>    <span class="hljs-comment">// 直接调用lr方法</span><br>	bx	lr	<br><br>	END_ENTRY _objc_msgSend<br></code></pre></td></tr></table></figure>

<p>从上面的调用流程中我们看到，首先会判断这条消息的接收者是否为nil,如果为nil直接调用LNilReceiver_f方法，如果不为nil，先根据isa获取到对应的类，然后在方法调用的缓存中查找是否有缓存如果有直接调用，如果没有则去调用__objc_msgSend_uncached方法。</p>
<p>下面我们在来看下这个方法：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">STATIC_ENTRY __objc_msgSend_uncached<br><br>	<span class="hljs-comment">// THIS IS NOT A CALLABLE C FUNCTION</span><br>	<span class="hljs-comment">// Out-of-band r9 is the class to search</span><br>	<br>	MethodTableLookup NORMAL	<span class="hljs-comment">// returns IMP in r12</span><br>	<br>	bx	r12<br><br>	END_ENTRY __objc_msgSend_uncached<br></code></pre></td></tr></table></figure>
<p>从上图我们看出__objc_msgSend_uncached方法主要是调用了MethodTableLookup方法，而在这个方法中，主要又是调用了_class_lookupMethodAndLoadCache3方法，那么我们来看下这个方法的实现：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">// 查找IMP</span><br>IMP _class_lookupMethodAndLoadCache3(<span class="hljs-keyword">id</span> obj, SEL sel, Class cls)<br>&#123;<br>    <span class="hljs-keyword">return</span> lookUpImpOrForward(cls, sel, obj, <br>                              <span class="hljs-literal">YES</span><span class="hljs-comment">/*initialize*/</span>, <span class="hljs-literal">NO</span><span class="hljs-comment">/*cache*/</span>, <span class="hljs-literal">YES</span><span class="hljs-comment">/*resolver*/</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>实际上就是调用了lookUpImpOrForward，对于这个方法我们就比较熟悉了。</p>
<h6 id="lookUpImpOrForward"><a href="#lookUpImpOrForward" class="headerlink" title="lookUpImpOrForward"></a>lookUpImpOrForward</h6><p>我们先来看下这个方法的实现：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">// 当方法调用的缓存中找不到对应的方法时就会调用这个方法</span><br><span class="hljs-comment">// cls 消息的接受者</span><br><span class="hljs-comment">// sel 要调用的方法</span><br><span class="hljs-comment">// initialize 是否已经初始化</span><br><span class="hljs-comment">// cache 是否需要查找缓存 但是只是在当前类使用 在父类统一都会先查找缓存在查找方法列表</span><br><span class="hljs-comment">// resolver 是否需要动态解析</span><br>IMP lookUpImpOrForward(Class cls, SEL sel, <span class="hljs-keyword">id</span> inst, <br>                       <span class="hljs-keyword">bool</span> initialize, <span class="hljs-keyword">bool</span> cache, <span class="hljs-keyword">bool</span> resolver)<br>&#123;<br>    IMP imp = <span class="hljs-literal">nil</span>;<br>    <span class="hljs-keyword">bool</span> triedResolver = <span class="hljs-literal">NO</span>;<br><br>    runtimeLock.assertUnlocked();<br><br>    <span class="hljs-comment">// Optimistic cache lookup</span><br>    <span class="hljs-comment">// 如果在缓存中找到对应的方法 则直接返回</span><br>    <span class="hljs-keyword">if</span> (cache) &#123; <span class="hljs-comment">//从汇编过来是NO</span><br>        imp = cache_getImp(cls, sel);<br>        <span class="hljs-keyword">if</span> (imp) <span class="hljs-keyword">return</span> imp;<br>    &#125;<br><br>    runtimeLock.lock();<br>	<span class="hljs-comment">//检查是否是已知的 项目的所有类都是从镜像加载出来的 这里是在镜像加载出的类中查找 如果不是则返回false</span><br>    <span class="hljs-comment">// 但是这里并没有使用返回值</span><br>    checkIsKnownClass(cls);<br><br>    <span class="hljs-comment">// 这个类的内容还没有被加载 会通过镜像加载这个类先关的内容 比如 属性 方法列表</span><br>    <span class="hljs-keyword">if</span> (!cls-&gt;isRealized()) &#123;<br>        realizeClass(cls);<br>    &#125;<br>    <span class="hljs-comment">// 如果类需要被initialize但是目前还没有初始化</span><br>    <span class="hljs-keyword">if</span> (initialize  &amp;&amp;  !cls-&gt;isInitialized()) &#123;<br>		<span class="hljs-comment">//当cls需要初始化和没有初始化的时候 进行cls初始化，</span><br>		<span class="hljs-comment">//初始化会加入到一个线程，同步执行，先初始化父类，再初始化子类</span><br>		<span class="hljs-comment">//数据的大小最小是4，扩容规则是：n*2+1;</span><br>        runtimeLock.unlock();<br>        _class_initialize (_class_getNonMetaClass(cls, inst));<br>        runtimeLock.lock();<br>    &#125;<br><br>    <br> retry:    <br>    runtimeLock.assertLocked();<br><br>    <span class="hljs-comment">//再次获取imp</span><br>    imp = cache_getImp(cls, sel);<br>    <span class="hljs-keyword">if</span> (imp) <span class="hljs-keyword">goto</span> done;<br><br>    <span class="hljs-comment">// Try this class&#x27;s method lists.</span><br>    <span class="hljs-comment">//在本类中查找method</span><br>    &#123;<span class="hljs-comment">//从cls-&gt;data()-&gt;methods查找method</span><br>        Method meth = getMethodNoSuper_nolock(cls, sel);<br>        <span class="hljs-keyword">if</span> (meth) &#123;<span class="hljs-comment">//找到添加到cache中</span><br>            log_and_fill_cache(cls, meth-&gt;imp, sel, inst, cls);<br>            imp = meth-&gt;imp;<br>            <span class="hljs-keyword">goto</span> done;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// Try superclass caches and method lists.</span><br>	<span class="hljs-comment">//从cls-&gt;superclass-&gt;data()-&gt;methods查找methd，supercls没有查找出来，再查找父类的父类。</span><br>    &#123;<br>        <span class="hljs-keyword">unsigned</span> attempts = unreasonableClassCount();<br>        <span class="hljs-comment">// 递归查找父类 直到父类为nil</span><br>        <span class="hljs-keyword">for</span> (Class curClass = cls-&gt;superclass;<br>             curClass != <span class="hljs-literal">nil</span>;<br>             curClass = curClass-&gt;superclass)<br>        &#123;<br>            <span class="hljs-comment">// Halt if there is a cycle in the superclass chain.</span><br>            <span class="hljs-keyword">if</span> (--attempts == <span class="hljs-number">0</span>) &#123;<br>                _objc_fatal(<span class="hljs-string">&quot;Memory corruption in class list.&quot;</span>);<br>            &#125;<br>            <br>            <span class="hljs-comment">// Superclass cache.</span><br>            imp = cache_getImp(curClass, sel);<br>            <span class="hljs-keyword">if</span> (imp) &#123;<br>                <span class="hljs-keyword">if</span> (imp != (IMP)_objc_msgForward_impcache) &#123;<br>                    <span class="hljs-comment">// Found the method in a superclass. Cache it in this class.</span><br>					<span class="hljs-comment">//将父类添加到 子类的缓存中</span><br>                    log_and_fill_cache(cls, imp, sel, inst, curClass);<br>                    <span class="hljs-keyword">goto</span> done;<br>                &#125;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// Found a forward:: entry in a superclass.</span><br>                    <span class="hljs-comment">// Stop searching, but don&#x27;t cache yet; call method </span><br>                    <span class="hljs-comment">// resolver for this class first.</span><br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>            <br>            <span class="hljs-comment">// Superclass method list.</span><br>            Method meth = getMethodNoSuper_nolock(curClass, sel);<br>            <span class="hljs-keyword">if</span> (meth) &#123;<br>                log_and_fill_cache(cls, meth-&gt;imp, sel, inst, curClass);<br>                imp = meth-&gt;imp;<br>                <span class="hljs-keyword">goto</span> done;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// No implementation found. Try method resolver once.</span><br>	<span class="hljs-comment">//如果都没找到 动态方法解析阶段</span><br><br>    <span class="hljs-keyword">if</span> (resolver  &amp;&amp;  !triedResolver) &#123;<br>        runtimeLock.unlock();<br>        _class_resolveMethod(cls, sel, inst);<br>        runtimeLock.lock();<br>        <span class="hljs-comment">// Don&#x27;t cache the result; we don&#x27;t hold the lock so it may have </span><br>        <span class="hljs-comment">// changed already. Re-do the search from scratch instead.</span><br>        triedResolver = <span class="hljs-literal">YES</span>;<br>        <span class="hljs-keyword">goto</span> retry;<br>    &#125;<br><br>    <span class="hljs-comment">//如果没找到resolveInstanceMethod 和resolveClassMethod，</span><br><span class="hljs-comment">//	进行消息转发 阶段</span><br>    imp = (IMP)_objc_msgForward_impcache;<br>	<span class="hljs-comment">//填充 cache</span><br>    cache_fill(cls, sel, imp, inst);<br><br> done:<br>    runtimeLock.unlock();<br><br>    <span class="hljs-keyword">return</span> imp;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这个方法的实现比较长，下面我们从下图中来看下整个流程：</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gk9sd6lnxrj31100u0atm.jpg"></p>
<p>下面我们来看下lookUpImpOrForward方法执行内部的几个条件和关键方法</p>
<h6 id="checkIsKnownClass"><a href="#checkIsKnownClass" class="headerlink" title="checkIsKnownClass"></a>checkIsKnownClass</h6><p>我们来看下这个方法的实现,在这个方法的实现中主要是调用了isKnownClass方法，我们直接看这个方法的实现：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">// 判断一个类是否为已知类</span><br><span class="hljs-comment">// 在共享cache或者加载镜像的数据段或者通过obj_allocateClassPair方法创建的类</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> isKnownClass(Class cls) &#123;<br>    <span class="hljs-comment">// 查找的顺序是先查找共享缓存，然后是通过obj_allocateClassPair创建的类，最后才是从MACH-O的数据段进行查找</span><br>    <span class="hljs-keyword">return</span> (sharedRegionContains(cls) ||<br>            NXHashMember(allocatedClasses, cls) ||<br>            dataSegmentsContain(cls));<br>&#125;<br></code></pre></td></tr></table></figure>

<p>什么情况下会出现非已知的类呢？<br>当我们使用NSStringFromClass()方法创建一个类时，如果这个类的名字写错了这里就检测为一个未知类。</p>
<h6 id="realizeClass"><a href="#realizeClass" class="headerlink" title="realizeClass"></a>realizeClass</h6><p>递归初始化类(父类)的结构，对类的第一次初始化，包括配置类的读写空间（class_rw_t）并且返回类的正确的结构体，就相当于搭好了这个类的框架这里主要是为了后续可以从类的方法列表中查找方法。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">static</span> Class realizeClass(Class cls)<br>&#123;<br>    runtimeLock.assertLocked();<br><br>    <span class="hljs-keyword">if</span> (!cls) <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>;<br>    <span class="hljs-keyword">if</span> (cls-&gt;isRealized()) <span class="hljs-keyword">return</span> cls;<br>    assert(cls == remapClass(cls));<br><br>    <span class="hljs-comment">// fixme verify class is not in an un-dlopened part of the shared cache?</span><br>    <span class="hljs-comment">//首先将rw赋值给ro，因为数据结构一样可以直接强制转化</span><br>    ro = (<span class="hljs-keyword">const</span> class_ro_t *)cls-&gt;data();<br>    <span class="hljs-keyword">if</span> (ro-&gt;flags &amp; RO_FUTURE) &#123;<span class="hljs-comment">//是否已经初始化过，初始化过的哈 则 cls-&gt;rw 已经初始化过</span><br>        rw = cls-&gt;data();<br>        ro = cls-&gt;data()-&gt;ro;<br>        cls-&gt;changeInfo(RW_REALIZED|RW_REALIZING, RW_FUTURE);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 正常情况下 申请class_rw_t空间</span><br>        rw = (class_rw_t *)calloc(<span class="hljs-keyword">sizeof</span>(class_rw_t), <span class="hljs-number">1</span>);<br>        rw-&gt;ro = ro;<span class="hljs-comment">//cls-&gt;rw-&gt;ro 指向现在的ro</span><br>        rw-&gt;flags = RW_REALIZED|RW_REALIZING;<span class="hljs-comment">//realized = 1 and  realizing = 1</span><br>        cls-&gt;setData(rw);<span class="hljs-comment">//赋值</span><br>    &#125;<br><br>    isMeta = ro-&gt;flags &amp; RO_META;<span class="hljs-comment">//是否是元类</span><br><br>    rw-&gt;version = isMeta ? <span class="hljs-number">7</span> : <span class="hljs-number">0</span>;  <span class="hljs-comment">// 元类版本是7，旧版的6，否就是0</span><br><br>    <span class="hljs-comment">// Choose an index for this class.</span><br><span class="hljs-comment">//设置cls的索引</span><br>	cls-&gt;chooseClassArrayIndex();<br><br>    <span class="hljs-comment">// 如果父类没有初始化则进行初始化</span><br>    <span class="hljs-comment">// root_class 做完需要设置RW_REALIZED=1，</span><br>    <span class="hljs-comment">// root metaclasses 需要执行完.</span><br>	<span class="hljs-comment">//从NXMapTable 获取cls ，然后进行初始化</span><br>	<span class="hljs-comment">//从NXMapTable 获取cls-&gt;isa ，然后进行初始化</span><br>    supercls = realizeClass(remapClass(cls-&gt;superclass));<br>    metacls = realizeClass(remapClass(cls-&gt;ISA()));<br><br>    <span class="hljs-comment">// Update superclass and metaclass in case of remapping</span><br>    cls-&gt;superclass = supercls;<br>    cls-&gt;initClassIsa(metacls);<br><br>	<span class="hljs-comment">// 协调实例变量偏移/布局</span><br>	<span class="hljs-comment">//可能重新申请空间 class_ro_t,更新我们的class_ro_t</span><br>    <span class="hljs-keyword">if</span> (supercls  &amp;&amp;  !isMeta) reconcileInstanceVariables(cls, supercls, ro);<br><br>    <span class="hljs-comment">// 设置setInstanceSize 从ro-&gt;instanceSize</span><br>    cls-&gt;setInstanceSize(ro-&gt;instanceSize);<br><br>	<span class="hljs-comment">//拷贝flags 从ro到rw中</span><br>    <span class="hljs-keyword">if</span> (ro-&gt;flags &amp; RO_HAS_CXX_STRUCTORS) &#123;<br>        cls-&gt;setHasCxxDtor();<br>        <span class="hljs-keyword">if</span> (! (ro-&gt;flags &amp; RO_HAS_CXX_DTOR_ONLY)) &#123;<br>            cls-&gt;setHasCxxCtor();<br>        &#125;<br>    &#125;<br><span class="hljs-comment">//添加superclass指针</span><br>    <span class="hljs-keyword">if</span> (supercls) &#123;<br>        addSubclass(supercls, cls);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        addRootClass(cls);<br>    &#125;<br><br>    <span class="hljs-comment">// Attach categories</span><br>	<span class="hljs-comment">//类别的方法 在编译的时候没有添加到二进制文件中，在运行的时候添加进去的</span><br>    methodizeClass(cls);<br><br>    <span class="hljs-keyword">return</span> cls;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这个方法主要操作是：</p>
<ul>
<li>将class-&gt;data指向的数据强制转化为class_ro_t结构体，因为编译期间class-&gt;data指向的就是class_ro_t结构体，所以这一步的转化是没有问题的</li>
<li>生成一个class_rw_t结构体</li>
<li>将class_rw_t的ro指针指向上一步转化出的class_ro_t结构体</li>
<li>设置class_rw_t的flags值</li>
<li>设置class-&gt;data指向class_rw_t结构体</li>
<li>调用methodizeClass函数</li>
</ul>
<p>因为这里不是我们本次介绍的主角，所以我们不在进一步的详细介绍。</p>
<h6 id="class-initialize"><a href="#class-initialize" class="headerlink" title="_class_initialize"></a>_class_initialize</h6><p>上一步在realizeClass中我们完成了类的初始化，_class_initialize这个方法主要是调用我们OC中的+ (void)initialize方法，在_class_initialize中主要是调用了callInitialize方法，我们看下这个方法的实现</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">// 调用类中的+ (void)initialize方法</span><br><span class="hljs-keyword">void</span> callInitialize(Class cls)<br>&#123;<br>    ((<span class="hljs-keyword">void</span>(*)(Class, SEL))objc_msgSend)(cls, SEL_initialize);<br>    <span class="hljs-keyword">asm</span>(<span class="hljs-string">&quot;&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>而调用规则</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">void</span> _class_initialize(Class cls) &#123;<br>    supercls = cls-&gt;superclass;<br>    <span class="hljs-keyword">if</span> (supercls  &amp;&amp;  !supercls-&gt;isInitialized()) &#123;<br>        _class_initialize(supercls);<br>    &#125;<br>    <span class="hljs-comment">// 调用+initialize方法</span><br>    callInitialize(cls);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>从上面的调用顺序上我们可以看出类的+initialize方法的调用顺序是先调用父类在调用子类。且子类不会覆盖父类。如果子类没有实现这个方法那么会调用父类的方法，也就是说父类的方法会调用多次。</p>
<h6 id="getMethodNoSuper-nolock"><a href="#getMethodNoSuper-nolock" class="headerlink" title="getMethodNoSuper_nolock"></a>getMethodNoSuper_nolock</h6><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">// 在类的方法列表中查找对应的方法实现</span><br><span class="hljs-keyword">static</span> method_t *<br>getMethodNoSuper_nolock(Class cls, SEL sel)<br>&#123;<br>    runtimeLock.assertLocked();<br><br>    assert(cls-&gt;isRealized());<br>    <span class="hljs-comment">// fixme nil cls? </span><br>    <span class="hljs-comment">// fixme nil sel?</span><br><br>    <span class="hljs-comment">// 方法列表的遍历</span><br>    <span class="hljs-keyword">for</span> (auto mlists = cls-&gt;data()-&gt;methods.beginLists(),<br>              end = cls-&gt;data()-&gt;methods.endLists(); <br>         mlists != end;<br>         ++mlists)<br>    &#123;<br>        <span class="hljs-comment">// 在mlists中查找sel</span><br>        method_t *m = search_method_list(*mlists, sel);<br>        <span class="hljs-keyword">if</span> (m) <span class="hljs-keyword">return</span> m;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>;<br>&#125;<br></code></pre></td></tr></table></figure>


<h6 id="log-and-fill-cache和cache-getImp"><a href="#log-and-fill-cache和cache-getImp" class="headerlink" title="log_and_fill_cache和cache_getImp"></a>log_and_fill_cache和cache_getImp</h6><p>cache_getImp的实现在Runtime中并未找到实现，不过我们可以从log_and_fill_cache的实现反推cache_getImp的实现，所以我们先看下log_and_fill_cache的实现</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">// 方法缓存</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> cache_fill_nolock(Class cls, SEL sel, IMP imp, <span class="hljs-keyword">id</span> receiver)<br>&#123;<br>    cacheUpdateLock.assertLocked();<br><br>    <span class="hljs-comment">// 获取到类对应的缓存</span><br>    cache_t *cache = getCache(cls);<br>    <span class="hljs-comment">// 从类对应的缓存中找到方法缓存的key</span><br>    cache_key_t key = getKey(sel);<br><br>    <span class="hljs-comment">// 在cache中根据key和receiver查找bucket</span><br>    bucket_t *bucket = cache-&gt;find(key, receiver);<br>    <span class="hljs-comment">// 如果key==0 k++</span><br>    <span class="hljs-keyword">if</span> (bucket-&gt;key() == <span class="hljs-number">0</span>) cache-&gt;incrementOccupied();<br>    <span class="hljs-comment">// 存储缓存</span><br>    bucket-&gt;set(key, imp);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>从上面的代码中我们可以看出，我们可以通过类名获取到类对应的方法缓存cache，然后根据方法名获取到缓存的cache的key,然后根据key和receiver获取到对应缓存的bucket，然后将要缓存方法添加到缓存中，这里我们注意bucket是通过key和receiver获取而不是cls。所以这里我们添加的缓存是子类的缓存中。</p>
<p>下面我们来看下bucket_t的结构:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">struct</span> bucket_t &#123;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> __arm64__</span><br>    MethodCacheIMP _imp;<br>    cache_key_t _key;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><br>    <span class="hljs-comment">// unsigned long 的指针，其实是一个被 hash 化的一串数值，就是方法的 sel</span><br>    cache_key_t _key;<br>    <span class="hljs-comment">// 保存着对应的函数地址</span><br>    MethodCacheIMP _imp;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="class-resolveMethod"><a href="#class-resolveMethod" class="headerlink" title="_class_resolveMethod"></a>_class_resolveMethod</h5><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">// 动态解析方法</span><br><span class="hljs-keyword">void</span> _class_resolveMethod(Class cls, SEL sel, <span class="hljs-keyword">id</span> inst)<br>&#123;<br>    <span class="hljs-comment">// 不是元类 则调用动态解析实例方法</span><br>    <span class="hljs-keyword">if</span> (! cls-&gt;isMetaClass()) &#123;<br>        <span class="hljs-comment">//首先调用</span><br>		_class_resolveInstanceMethod(cls, sel, inst);<br>    &#125; <br>    <span class="hljs-keyword">else</span> &#123;<br>		<span class="hljs-comment">//如果是元类 则应该动态解析类方法</span><br>        _class_resolveClassMethod(cls, sel, inst);<br>        <span class="hljs-comment">// 查找这个类的方法列表中是否有这个方法对应的IMP</span><br>        <span class="hljs-keyword">if</span> (!lookUpImpOrNil(cls, sel, inst, <br>                            <span class="hljs-literal">NO</span><span class="hljs-comment">/*initialize*/</span>, <span class="hljs-literal">YES</span><span class="hljs-comment">/*cache*/</span>, <span class="hljs-literal">NO</span><span class="hljs-comment">/*resolver*/</span>)) <br>        &#123;<br>            <span class="hljs-comment">// 如果方法列表中没有找到IMP 则调用_class_resolveInstanceMethod方法？？？？？ 为什么</span><br>            _class_resolveInstanceMethod(cls, sel, inst);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>看完了上面的方法，我们有个疑问：为什么在元类的情况下，在调用了_class_resolveClassMethod方法后，我们仍然要判断lookUpImpOrNil如果没有找到方法则调用_class_resolveInstanceMethod？？？</p>
<p>下面我们来先看下_class_resolveClassMethod方法</p>
<h6 id="class-resolveClassMethod"><a href="#class-resolveClassMethod" class="headerlink" title="_class_resolveClassMethod"></a>_class_resolveClassMethod</h6><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">// 动态解析类方法</span><br><span class="hljs-comment">// 调用_class_resolveClassMethod 查找一个要被添加到cls的方法</span><br><span class="hljs-comment">// cls 应该是元类</span><br><span class="hljs-comment">// 如果方法已经存在了就不需要检查了</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> _class_resolveClassMethod(Class cls, SEL sel, <span class="hljs-keyword">id</span> inst)<br>&#123;<br>    assert(cls-&gt;isMetaClass());<br><br>    <span class="hljs-comment">// 先判断resolveClassMethod方法是否实现 如果没实现则直接return</span><br>    <span class="hljs-keyword">if</span> (! lookUpImpOrNil(cls, SEL_resolveClassMethod, inst, <br>                         <span class="hljs-literal">NO</span><span class="hljs-comment">/*initialize*/</span>, <span class="hljs-literal">YES</span><span class="hljs-comment">/*cache*/</span>, <span class="hljs-literal">NO</span><span class="hljs-comment">/*resolver*/</span>)) <br>    &#123;<br>        <span class="hljs-comment">// Resolver not implemented.</span><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// resolveClassMethod在cls中实现了</span><br>    <span class="hljs-built_in">BOOL</span> (*msg)(Class, SEL, SEL) = (<span class="hljs-keyword">typeof</span>(msg))objc_msgSend;<br>    <span class="hljs-comment">// 调用_class_getNonMetaClass(cls, inst)的SEL_resolveClassMethod方法参数为SEL</span><br>    <span class="hljs-keyword">bool</span> resolved = msg(_class_getNonMetaClass(cls, inst), <br>                        SEL_resolveClassMethod, sel);<br><br>    <span class="hljs-comment">// Cache the result (good or bad) so the resolver doesn&#x27;t fire next time.</span><br>    <span class="hljs-comment">// +resolveClassMethod adds to self-&gt;ISA() a.k.a. cls</span><br>    <span class="hljs-comment">// 在cls类中再次查找sel是否实现</span><br>    IMP imp = lookUpImpOrNil(cls, sel, inst, <br>                             <span class="hljs-literal">NO</span><span class="hljs-comment">/*initialize*/</span>, <span class="hljs-literal">YES</span><span class="hljs-comment">/*cache*/</span>, <span class="hljs-literal">NO</span><span class="hljs-comment">/*resolver*/</span>);<br><br>    <span class="hljs-keyword">if</span> (resolved  &amp;&amp;  PrintResolving) &#123;<br>        <span class="hljs-keyword">if</span> (imp) &#123;<br>            _objc_inform(<span class="hljs-string">&quot;RESOLVE: method %c[%s %s] &quot;</span><br>                         <span class="hljs-string">&quot;dynamically resolved to %p&quot;</span>, <br>                         cls-&gt;isMetaClass() ? <span class="hljs-string">&#x27;+&#x27;</span> : <span class="hljs-string">&#x27;-&#x27;</span>, <br>                         cls-&gt;nameForLogging(), sel_getName(sel), imp);<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// Method resolver didn&#x27;t add anything?</span><br>            _objc_inform(<span class="hljs-string">&quot;RESOLVE: +[%s resolveClassMethod:%s] returned YES&quot;</span><br>                         <span class="hljs-string">&quot;, but no new implementation of %c[%s %s] was found&quot;</span>,<br>                         cls-&gt;nameForLogging(), sel_getName(sel), <br>                         cls-&gt;isMetaClass() ? <span class="hljs-string">&#x27;+&#x27;</span> : <span class="hljs-string">&#x27;-&#x27;</span>, <br>                         cls-&gt;nameForLogging(), sel_getName(sel));<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>从上面的代码我们可以看出_class_resolveClassMethod方法首先是查找SEL_resolveClassMethod在cls中是否有实现IMP，如果没有那么我们也不需要进行动态解析 直接返回。如果实现了，那么调用SEL_resolveClassMethod这个方法根据这个方法的返回值判断这个方法是否需要动态解析。然后我们在根据方法名在cls中查找对应的IMP，这里获取到IMP后纯粹是为了打日志。</p>
<p>下面我们看下lookUpImpOrNil这个方法</p>
<h6 id="lookUpImpOrNil"><a href="#lookUpImpOrNil" class="headerlink" title="lookUpImpOrNil"></a>lookUpImpOrNil</h6><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">// 与lookUpImpOrForward方法类似 但是如果imp是_objc_msgForward_impcache时返回nil</span><br>IMP lookUpImpOrNil(Class cls, SEL sel, <span class="hljs-keyword">id</span> inst, <br>                   <span class="hljs-keyword">bool</span> initialize, <span class="hljs-keyword">bool</span> cache, <span class="hljs-keyword">bool</span> resolver)<br>&#123;<br>    <span class="hljs-comment">// 获取cls中sel方法的实现IMP 如果没有找到返回_objc_msgForward_impcache 表示需要转发</span><br>    IMP imp = lookUpImpOrForward(cls, sel, inst, initialize, cache, resolver);<br>    <span class="hljs-comment">// 如果需要转发那么返回nil</span><br>    <span class="hljs-keyword">if</span> (imp == _objc_msgForward_impcache) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>;<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> imp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>实际上lookUpImpOrNil方法是对lookUpImpOrForward进行了一次包装，当找不到对应方法时直接返回nil而不是_objc_msgForward_impcache。</p>
<p>从上面实现我们看出实际上在_class_resolveClassMethod方法中我们并没有做什么时机操作，只是判断了cls中的SEL_resolveClassMethod方法是否实现，如果实现了那么返回的是true还是false。</p>
<p>那么接下来我们继续看下动态解析类方法后面做了什么？</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">// 查找这个类的方法列表中是否有这个方法对应的IMP</span><br>        <span class="hljs-keyword">if</span> (!lookUpImpOrNil(cls, sel, inst, <br>                            <span class="hljs-literal">NO</span><span class="hljs-comment">/*initialize*/</span>, <span class="hljs-literal">YES</span><span class="hljs-comment">/*cache*/</span>, <span class="hljs-literal">NO</span><span class="hljs-comment">/*resolver*/</span>)) <br>        &#123;<br>            <span class="hljs-comment">// 如果方法列表中没有找到IMP 则调用_class_resolveInstanceMethod方法？？？？？ 为什么</span><br>            _class_resolveInstanceMethod(cls, sel, inst);<br>        &#125;<br></code></pre></td></tr></table></figure>

<p>我们看到这里判断 如果当前类没有动态解析这个方法那么我们直接调用_class_resolveInstanceMethod方法。</p>
<p>那么我们先看下_class_resolveInstanceMethod这个方法里到底做了什么，然后再去思考上面提出的问题。</p>
<p>####### _class_resolveInstanceMethod</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> _class_resolveInstanceMethod(Class cls, SEL sel, <span class="hljs-keyword">id</span> inst)<br>&#123;<br>    <span class="hljs-keyword">if</span> (! lookUpImpOrNil(cls-&gt;ISA(), SEL_resolveInstanceMethod, cls, <br>                         <span class="hljs-literal">NO</span><span class="hljs-comment">/*initialize*/</span>, <span class="hljs-literal">YES</span><span class="hljs-comment">/*cache*/</span>, <span class="hljs-literal">NO</span><span class="hljs-comment">/*resolver*/</span>)) <br>    &#123;<br>        <span class="hljs-comment">// Resolver not implemented.</span><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><span class="hljs-comment">//如果找到SEL_resolveInstanceMethod 则使用objc_msgSend函数</span><br>    <span class="hljs-built_in">BOOL</span> (*msg)(Class, SEL, SEL) = (<span class="hljs-keyword">typeof</span>(msg))objc_msgSend;<br>    <span class="hljs-keyword">bool</span> resolved = msg(cls, SEL_resolveInstanceMethod, sel);<br><br>    <span class="hljs-comment">// Cache the result (good or bad) so the resolver doesn&#x27;t fire next time.</span><br>    <span class="hljs-comment">// +resolveInstanceMethod adds to self a.k.a. cls</span><br>    IMP imp = lookUpImpOrNil(cls, sel, inst, <br>                             <span class="hljs-literal">NO</span><span class="hljs-comment">/*initialize*/</span>, <span class="hljs-literal">YES</span><span class="hljs-comment">/*cache*/</span>, <span class="hljs-literal">NO</span><span class="hljs-comment">/*resolver*/</span>);<br><br>    <span class="hljs-keyword">if</span> (resolved  &amp;&amp;  PrintResolving) &#123;<br>        <span class="hljs-keyword">if</span> (imp) &#123;<br>            _objc_inform(<span class="hljs-string">&quot;RESOLVE: method %c[%s %s] &quot;</span><br>                         <span class="hljs-string">&quot;dynamically resolved to %p&quot;</span>, <br>                         cls-&gt;isMetaClass() ? <span class="hljs-string">&#x27;+&#x27;</span> : <span class="hljs-string">&#x27;-&#x27;</span>, <br>                         cls-&gt;nameForLogging(), sel_getName(sel), imp);<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// Method resolver didn&#x27;t add anything?</span><br>            _objc_inform(<span class="hljs-string">&quot;RESOLVE: +[%s resolveInstanceMethod:%s] returned YES&quot;</span><br>                         <span class="hljs-string">&quot;, but no new implementation of %c[%s %s] was found&quot;</span>,<br>                         cls-&gt;nameForLogging(), sel_getName(sel), <br>                         cls-&gt;isMetaClass() ? <span class="hljs-string">&#x27;+&#x27;</span> : <span class="hljs-string">&#x27;-&#x27;</span>, <br>                         cls-&gt;nameForLogging(), sel_getName(sel));<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>实际上_class_resolveInstanceMethod方法和_class_resolveClassMethod的实现基本一致，只不过将SEL_resolveClassMethod改成了SEL_resolveInstanceMethod。</p>
<p>但是实际上在_class_resolveInstanceMethod和_class_resolveClassMethod方法中我们并没有做什么事情，只是调用了SEL_resolveClassMethod和SEL_resolveInstanceMethod这两个方法。 然后重新走了一次lookUpImpOrForward方法。因此这相当于给我们一次机会让我们在SEL_resolveClassMethod或者SEL_resolveInstanceMethod方法中给方法添加一个默认实现。</p>
<p>比如下面的代码：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">+ (<span class="hljs-built_in">BOOL</span>)resolveInstanceMethod:(SEL)sel &#123;<br>    <span class="hljs-keyword">if</span> (sel == <span class="hljs-keyword">@selector</span>(resolveThisMethodDynamically)) &#123;<br>          class_addMethod([<span class="hljs-keyword">self</span> <span class="hljs-keyword">class</span>], sel, (IMP) dynamicMethodIMP, <span class="hljs-string">&quot;v@:&quot;</span>);<br>          <span class="hljs-keyword">return</span> <span class="hljs-literal">YES</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> [<span class="hljs-keyword">super</span> resolveInstanceMethod:sel];<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这样我们再次调用lookUpImpOrForward方法是就可以查找到对应的方法和实现IMP了。</p>
<p>但是如果我们并没有实现resolveInstanceMethod这个方法那么接下来就走到了方法转发的流程。我们看到在lookUpImpOrForward方法的最后 如果没有做动态解析，那么我们就会走到下面这段代码中</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">//如果没找到resolveInstanceMethod 和resolveClassMethod，</span><br><span class="hljs-comment">//	进行消息转发 阶段</span><br>    imp = (IMP)_objc_msgForward_impcache;<br>	<span class="hljs-comment">//填充 cache</span><br>    cache_fill(cls, sel, imp, inst);<br></code></pre></td></tr></table></figure>
<p>我们看到 直接返回了一个固定的IMP_objc_msgForward_impcache 然后将其放到子类的缓存中。</p>
<h5 id="objc-msgForward-impcache"><a href="#objc-msgForward-impcache" class="headerlink" title="_objc_msgForward_impcache"></a>_objc_msgForward_impcache</h5><p>我们先来看下_objc_msgForward_impcache的调用位置</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">STATIC_ENTRY __objc_msgForward_impcache <span class="hljs-comment">//进入 _objc_msgForward_impcache</span><br>	<span class="hljs-comment">// Method cache version</span><br><br>	<span class="hljs-comment">// 这是一个不能调用的c函数</span><br>	<span class="hljs-comment">// Out-of-band Z is 0 (EQ) for normal, 1 (NE) for stret</span><br><br>	beq	__objc_msgForward <span class="hljs-comment">// 标志寄存器中Z标志位等于零时, 跳转到BEQ后标签__objc_msgForward处</span><br>	b	__objc_msgForward_stret <span class="hljs-comment">//否则跳转  __objc_msgForward_stret</span><br>	<br>	END_ENTRY __objc_msgForward_impcache <span class="hljs-comment">//结束 _objc_msgForward_impcache</span><br>	<br><br>	ENTRY __objc_msgForward<br>	<span class="hljs-comment">// Non-stret version</span><br><br>	MI_GET_EXTERN(r12, __objc_forward_handler)<br>	ldr	r12, [r12]<br>	bx	r12<br><br>	END_ENTRY __objc_msgForward<br><br><br>	ENTRY __objc_msgForward_stret	<br></code></pre></td></tr></table></figure>

<p>这也是通过汇编进行调用的，从上面我们看出实际上是调用的__objc_msgForward或者__objc_msgForward_stret方法，而这两个方法实际都是调用了__objc_forward_handler方法，下面我们重点看下这个方法</p>
<h6 id="objc-forward-handler"><a href="#objc-forward-handler" class="headerlink" title="__objc_forward_handler"></a>__objc_forward_handler</h6><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">__attribute__((noreturn)) <span class="hljs-keyword">struct</span> stret <br>objc_defaultForwardStretHandler(<span class="hljs-keyword">id</span> <span class="hljs-keyword">self</span>, SEL sel)<br>&#123;<br>    objc_defaultForwardHandler(<span class="hljs-keyword">self</span>, sel);<br>&#125;<br><span class="hljs-keyword">void</span> *_objc_forward_stret_handler = (<span class="hljs-keyword">void</span>*)objc_defaultForwardStretHandler;<br></code></pre></td></tr></table></figure>

<p>进而我们在看下objc_defaultForwardHandler方法的实现：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">__attribute__((noreturn)) <span class="hljs-keyword">void</span> <br>objc_defaultForwardHandler(<span class="hljs-keyword">id</span> <span class="hljs-keyword">self</span>, SEL sel)<br>&#123;<br>    _objc_fatal(<span class="hljs-string">&quot;%c[%s %s]: unrecognized selector sent to instance %p &quot;</span><br>                <span class="hljs-string">&quot;(no message forward handler is installed)&quot;</span>, <br>                class_isMetaClass(object_getClass(<span class="hljs-keyword">self</span>)) ? <span class="hljs-string">&#x27;+&#x27;</span> : <span class="hljs-string">&#x27;-&#x27;</span>, <br>                object_getClassName(<span class="hljs-keyword">self</span>), sel_getName(sel), <span class="hljs-keyword">self</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>看到这里我们一脸懵逼，因为我们知道后续是有一个消息转发的过程的 为何在这里我们只是看到了_objc_forward_stret_handler的实现 且实现为objc_defaultForwardHandler。消息转发的过程是如何被触发的呢？</p>
<p>我们看到在objc-runtime.mm类中实际上下面这个方法：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">void</span> objc_setForwardHandler(<span class="hljs-keyword">void</span> *fwd, <span class="hljs-keyword">void</span> *fwd_stret)<br>&#123;<br>    _objc_forward_handler = fwd;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> SUPPORT_STRET</span><br>    _objc_forward_stret_handler = fwd_stret;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>也就是说 实际上系统给我们提供了一个默认的实现方法，但是这个方法是可以改变的，因此这里我猜想可能是因为系统在其他位置重新设置了_objc_forward_handler的值所以我们在调用的时候才有转发的流程。</p>
<h4 id="消息转发"><a href="#消息转发" class="headerlink" title="消息转发"></a>消息转发</h4><p>这里我们先来看下如果我调用了一个不存在的方法时错误的堆栈的样子：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-number">2020</span><span class="hljs-number">-11</span><span class="hljs-number">-15</span> <span class="hljs-number">00</span>:<span class="hljs-number">14</span>:<span class="hljs-number">55.738458</span>+<span class="hljs-number">0800</span> Runtime_MsgSend[<span class="hljs-number">72610</span>:<span class="hljs-number">1510129</span>] -[SubClass aaa]: unrecognized selector sent to instance <span class="hljs-number">0x6000034780a0</span><br><span class="hljs-number">2020</span><span class="hljs-number">-11</span><span class="hljs-number">-15</span> <span class="hljs-number">00</span>:<span class="hljs-number">14</span>:<span class="hljs-number">55.748137</span>+<span class="hljs-number">0800</span> Runtime_MsgSend[<span class="hljs-number">72610</span>:<span class="hljs-number">1510129</span>] *** Terminating app due to uncaught exception <span class="hljs-string">&#x27;NSInvalidArgumentException&#x27;</span>, reason: <span class="hljs-string">&#x27;-[SubClass aaa]: unrecognized selector sent to instance 0x6000034780a0&#x27;</span><br>*** First throw call stack:<br>(<br>	<span class="hljs-number">0</span>   CoreFoundation                      <span class="hljs-number">0x00007fff2043a126</span> __exceptionPreprocess + <span class="hljs-number">242</span><br>	<span class="hljs-number">1</span>   libobjc.A.dylib                     <span class="hljs-number">0x00007fff20177f78</span> objc_exception_throw + <span class="hljs-number">48</span><br>	<span class="hljs-number">2</span>   CoreFoundation                      <span class="hljs-number">0x00007fff20448c6f</span> +[<span class="hljs-built_in">NSObject</span>(<span class="hljs-built_in">NSObject</span>) instanceMethodSignatureForSelector:] + <span class="hljs-number">0</span><br>	<span class="hljs-number">3</span>   CoreFoundation                      <span class="hljs-number">0x00007fff2043e666</span> ___forwarding___ + <span class="hljs-number">1489</span><br>	<span class="hljs-number">4</span>   CoreFoundation                      <span class="hljs-number">0x00007fff20440698</span> _CF_forwarding_prep_0 + <span class="hljs-number">120</span><br></code></pre></td></tr></table></figure>

<p>从上面的log中我们看出在给出错误之前实际上是调用了<a href="https://github.com/opensource-apple/CF">CoreFoundation</a>的_CF_forwarding_prep_0和___forwarding___方法。那么这两个方法时何时被调用的呢？</p>
<p>我们打开CoreFoundation的源码发现有一个跟运行时相关的类：CFRuntime.h 但是类中我们并没法发现调用objc_setForwardHandler的位置也没有发现直接调用_CF_forwarding_prep_0或者___forwarding___的地方。</p>
<p>那么究竟在什么时机调用的这些方法呢？</p>
<p>在查找这个问题的时候我们看到有使用Hoop Disassemble反编译方法时可以看到下面的调用关系：</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gkpndkm14yj31c10u04qp.jpg"></p>
<p>图中红框圈出来的方法是__CFInitialize方法。</p>
<p>但是很显然，我们在CFRuntime.h的__CFInitialize方法中并没有找到调用图中方法的位置：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">void</span> __CFInitialize(<span class="hljs-keyword">void</span>) &#123;<br><br>    <span class="hljs-keyword">if</span> (!__CFInitialized &amp;&amp; !__CFInitializing) &#123;<br>        __CFInitializing = <span class="hljs-number">1</span>;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> DEPLOYMENT_TARGET_WINDOWS || DEPLOYMENT_TARGET_IPHONESIMULATOR</span><br>        <span class="hljs-keyword">if</span> (!pthread_main_np()) HALT;   <span class="hljs-comment">// CoreFoundation must be initialized on the main thread</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>	<span class="hljs-comment">// move this next line up into the #if above after Foundation gets off this symbol</span><br>        _CFMainPThread = pthread_self();<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> DEPLOYMENT_TARGET_WINDOWS</span><br>        <span class="hljs-comment">// Must not call any CF functions</span><br>        __CFTSDWindowsInitialize();<br><span class="hljs-meta">#<span class="hljs-meta-keyword">elif</span> DEPLOYMENT_TARGET_LINUX</span><br>        __CFTSDLinuxInitialize();<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>        <br>        __CFProphylacticAutofsAccess = <span class="hljs-literal">true</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">CFIndex</span> idx = <span class="hljs-number">0</span>; idx &lt; <span class="hljs-keyword">sizeof</span>(__CFEnv) / <span class="hljs-keyword">sizeof</span>(__CFEnv[<span class="hljs-number">0</span>]); idx++) &#123;<br>            __CFEnv[idx].value = __CFEnv[idx].name ? getenv(__CFEnv[idx].name) : <span class="hljs-literal">NULL</span>;<br>        &#125;<br>          <br>          <span class="hljs-comment">// --------------此处没有找到调用相关的方法</span><br>          <br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> !defined(kCFUseCollectableAllocator)</span><br>        kCFUseCollectableAllocator = objc_collectingEnabled();<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>        <span class="hljs-keyword">if</span> (kCFUseCollectableAllocator) &#123;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> !defined(__CFObjCIsCollectable)</span><br>            __CFObjCIsCollectable = (<span class="hljs-keyword">bool</span> (*)(<span class="hljs-keyword">void</span> *))objc_isAuto;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>        &#125;<br>        <span class="hljs-comment">//........ 省略部分代码</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>所以这里我们猜测苹果在开源时删除了这部分方法调用。</p>
<p>由于对汇编熟悉，这里我们也不再进行更加深入的解读，但是在<a href="http://www.arigrant.com/blog/2013/12/13/a-selector-left-unhandled">Hmmm, What’s that Selector?</a> 文章中作者进行了介绍并猜想___forwarding___的实现：</p>
<h6 id="forwarding"><a href="#forwarding" class="headerlink" title="forwarding"></a><strong><em>forwarding</em></strong></h6><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">int</span> __forwarding__(<span class="hljs-keyword">void</span> *frameStackPointer, <span class="hljs-keyword">int</span> isStret) &#123;<br>  <span class="hljs-keyword">id</span> receiver = *(<span class="hljs-keyword">id</span> *)frameStackPointer;<br>  SEL sel = *(SEL *)(frameStackPointer + <span class="hljs-number">8</span>);<br>  <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *selName = sel_getName(sel);<br>  Class receiverClass = object_getClass(receiver);<br><br>  <span class="hljs-comment">// 调用 forwardingTargetForSelector:</span><br>  <span class="hljs-keyword">if</span> (class_respondsToSelector(receiverClass, <span class="hljs-keyword">@selector</span>(forwardingTargetForSelector:))) &#123;<br>    <span class="hljs-keyword">id</span> forwardingTarget = [receiver forwardingTargetForSelector:sel];<br>    <span class="hljs-keyword">if</span> (forwardingTarget &amp;&amp; forwarding != receiver) &#123;<br>    	<span class="hljs-keyword">if</span> (isStret == <span class="hljs-number">1</span>) &#123;<br>    		<span class="hljs-keyword">int</span> ret;<br>    		objc_msgSend_stret(&amp;ret,forwardingTarget, sel, ...);<br>    		<span class="hljs-keyword">return</span> ret;<br>    	&#125;<br>      <span class="hljs-keyword">return</span> objc_msgSend(forwardingTarget, sel, ...);<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// 僵尸对象</span><br>  <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *className = class_getName(receiverClass);<br>  <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *zombiePrefix = <span class="hljs-string">&quot;_NSZombie_&quot;</span>;<br>  size_t prefixLen = strlen(zombiePrefix); <span class="hljs-comment">// 0xa</span><br>  <span class="hljs-keyword">if</span> (strncmp(className, zombiePrefix, prefixLen) == <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-built_in">CFLog</span>(kCFLogLevelError,<br>          <span class="hljs-string">@&quot;*** -[%s %s]: message sent to deallocated instance %p&quot;</span>,<br>          className + prefixLen,<br>          selName,<br>          receiver);<br>    &lt;breakpoint-interrupt&gt;<br>  &#125;<br><br>  <span class="hljs-comment">// 调用 methodSignatureForSelector 获取方法签名后再调用 forwardInvocation</span><br>  <span class="hljs-keyword">if</span> (class_respondsToSelector(receiverClass, <span class="hljs-keyword">@selector</span>(methodSignatureForSelector:))) &#123;<br>    <span class="hljs-built_in">NSMethodSignature</span> *methodSignature = [receiver methodSignatureForSelector:sel];<br>    <span class="hljs-keyword">if</span> (methodSignature) &#123;<br>      <span class="hljs-built_in">BOOL</span> signatureIsStret = [methodSignature _frameDescriptor]-&gt;returnArgInfo.flags.isStruct;<br>      <span class="hljs-keyword">if</span> (signatureIsStret != isStret) &#123;<br>        <span class="hljs-built_in">CFLog</span>(kCFLogLevelWarning ,<br>              <span class="hljs-string">@&quot;*** NSForwarding: warning: method signature and compiler disagree on struct-return-edness of &#x27;%s&#x27;.  Signature thinks it does%s return a struct, and compiler thinks it does%s.&quot;</span>,<br>              selName,<br>              signatureIsStret ? <span class="hljs-string">&quot;&quot;</span> : not,<br>              isStret ? <span class="hljs-string">&quot;&quot;</span> : not);<br>      &#125;<br>      <span class="hljs-keyword">if</span> (class_respondsToSelector(receiverClass, <span class="hljs-keyword">@selector</span>(forwardInvocation:))) &#123;<br>        <span class="hljs-built_in">NSInvocation</span> *invocation = [<span class="hljs-built_in">NSInvocation</span> _invocationWithMethodSignature:methodSignature frame:frameStackPointer];<br><br>        [receiver forwardInvocation:invocation];<br><br>        <span class="hljs-keyword">void</span> *returnValue = <span class="hljs-literal">NULL</span>;<br>        [invocation getReturnValue:&amp;value];<br>        <span class="hljs-keyword">return</span> returnValue;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">CFLog</span>(kCFLogLevelWarning ,<br>              <span class="hljs-string">@&quot;*** NSForwarding: warning: object %p of class &#x27;%s&#x27; does not implement forwardInvocation: -- dropping message&quot;</span>,<br>              receiver,<br>              className);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>      &#125;<br>    &#125;<br>  &#125;<br><br>  SEL *registeredSel = sel_getUid(selName);<br><br>  <span class="hljs-comment">// selector 是否已经在 Runtime 注册过</span><br>  <span class="hljs-keyword">if</span> (sel != registeredSel) &#123;<br>    <span class="hljs-built_in">CFLog</span>(kCFLogLevelWarning ,<br>          <span class="hljs-string">@&quot;*** NSForwarding: warning: selector (%p) for message &#x27;%s&#x27; does not match selector known to Objective C runtime (%p)-- abort&quot;</span>,<br>          sel,<br>          selName,<br>          registeredSel);<br>  &#125; <span class="hljs-comment">// doesNotRecognizeSelector</span><br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (class_respondsToSelector(receiverClass,<span class="hljs-keyword">@selector</span>(doesNotRecognizeSelector:))) &#123;<br>    [receiver doesNotRecognizeSelector:sel];<br>  &#125; <br>  <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-built_in">CFLog</span>(kCFLogLevelWarning ,<br>          <span class="hljs-string">@&quot;*** NSForwarding: warning: object %p of class &#x27;%s&#x27; does not implement doesNotRecognizeSelector: -- abort&quot;</span>,<br>          receiver,<br>          className);<br>  &#125;<br><br>  <span class="hljs-comment">// The point of no return.</span><br>  kill(getpid(), <span class="hljs-number">9</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面的方法实际上分了三步：</p>
<ul>
<li>先调用 forwardingTargetForSelector 方法获取新的 target 作为 receiver 重新执行 selector，如果返回的内容不合法（为 nil 或者跟旧 receiver 一样），那就进入第二步</li>
<li>调用 methodSignatureForSelector 获取方法签名后，判断返回类型信息是否正确，再调用 forwardInvocation 执行 NSInvocation 对象，并将结果返回。如果对象没实现 methodSignatureForSelector 方法，进入第三步。</li>
<li>调用 doesNotRecognizeSelector 方法。</li>
</ul>
<p>最终消息的发送就完成了。</p>
<p>下面我们来汇总下消息发送的流程：</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gkppwpitnvj30vs0u0als.jpg"></p>
<p>看完了实现原理 下面我们通过一个demo来验证下我们上面的结论：</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><h4 id="动态解析"><a href="#动态解析" class="headerlink" title="动态解析"></a>动态解析</h4><p>我们都知道，如果在类的方法列表中无法找到对应的方法，我们首先进行动态解析，即调用resolveInstanceMethod方法判断是否需要动态解析，我们可以在这个方法里动态的为这个类新增一个方法，实现可调用到对应方法的目的。</p>
<p> MessageForward.h</p>
 <figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"> <span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">MessageForward</span> : <span class="hljs-title">NSObject</span></span><br><br>- (<span class="hljs-keyword">void</span>)testMethod;<br><br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure>

<p>MessageForward.m</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">MessageForward</span></span><br><br>+ (<span class="hljs-built_in">BOOL</span>)resolveInstanceMethod:(SEL)sel &#123;<br>    <span class="hljs-keyword">if</span> ([<span class="hljs-built_in">NSStringFromSelector</span>(sel) isEqualToString:<span class="hljs-string">@&quot;testMethod&quot;</span>]) &#123;<br>        Method testmethod = class_getInstanceMethod(<span class="hljs-keyword">self</span>, <span class="hljs-keyword">@selector</span>(test));<br>        IMP testIMP = method_getImplementation(testmethod);<br>        class_addMethod(<span class="hljs-keyword">self</span>, sel, testIMP, method_getTypeEncoding(testmethod));<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">YES</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NO</span>;<br>&#125;<br><br>- (<span class="hljs-keyword">void</span>)test &#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;MessageForward %s&quot;</span>,__func__);<br>&#125;<br><br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure>

<p>当外部调用MessageForward的testMethod方法时，发现方法列表中无法找到对应的方法实现，那么就会判断是否需要动态解析，我们看到我们在resolveInstanceMethod方法中当sel为testMethod时我们返回了yes，这样就会导致方法调用位置会重新查找一次类中的方法列表，我们在返回值之前动态的通过class_addMethod方法给类添加了testMethod方法的实现。</p>
<p>这样外部在调用testMethod时，我们会动态解析为test方法进行调用。</p>
<h4 id="消息转发-1"><a href="#消息转发-1" class="headerlink" title="消息转发"></a>消息转发</h4><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">- (<span class="hljs-built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)aSelector &#123;<br>    <span class="hljs-keyword">if</span> ([<span class="hljs-built_in">NSStringFromSelector</span>(aSelector) isEqualToString:<span class="hljs-string">@&quot;testMethod&quot;</span>]) &#123;<br>        <span class="hljs-built_in">NSMethodSignature</span> *signature = [<span class="hljs-built_in">NSMethodSignature</span> signatureWithObjCTypes:<span class="hljs-string">&quot;v@:&quot;</span>];<br>        <span class="hljs-keyword">return</span> signature;<br>    &#125;<br>    <span class="hljs-keyword">return</span> [<span class="hljs-keyword">super</span> methodSignatureForSelector:aSelector];<br>&#125;<br><br>- (<span class="hljs-keyword">void</span>)forwardInvocation:(<span class="hljs-built_in">NSInvocation</span> *)anInvocation &#123;<br>    <span class="hljs-keyword">if</span> ([<span class="hljs-built_in">NSStringFromSelector</span>(anInvocation.selector) isEqualToString:<span class="hljs-string">@&quot;testMethod&quot;</span>]) &#123;<br>        [<span class="hljs-keyword">self</span> test];<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        [<span class="hljs-keyword">super</span> forwardInvocation:anInvocation];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>同样当外部调用testMethod方法时，由于我们并没有实现动态解析的方法，因此默认是走转发的逻辑，在转发的逻辑中我们实现了methodSignatureForSelector和forwardInvocation方法，如果要实现消息的转发逻辑这两个方法是必须全部实现的，在forwardInvocation方法中，我们判断如果当前调用的是testMethod方法，我们会直接调用test方法。</p>
<p>至此 消息发送和消息转发的逻辑就整理完成了，后面我们会继续看下Runtime中关联属性相关的实现逻辑。</p>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="http://www.arigrant.com/blog/2013/12/13/a-selector-left-unhandled">Hmmm, What’s that Selector?</a><br><a href="http://yulingtianxia.com/blog/2016/06/15/Objective-C-Message-Sending-and-Forwarding/">Objective-C 消息发送与转发机制原理</a></p>
]]></content>
      <categories>
        <category>Runtime</category>
      </categories>
      <tags>
        <tag>Runtime msgSend</tag>
      </tags>
  </entry>
  <entry>
    <title>RunTime解析--Category(分类)实现</title>
    <url>/2020/08/22/runtimecategory/</url>
    <content><![CDATA[<p>  在日常的开发中，我们经常用到分类，用来给一个类添加扩展，包括对象方法、类方法、当然我们还可以通过关联对象的方式给分类添属性。但是这中间的过程是如何实现的呢？下面我们来做一个详细的解释。</p>
<a id="more"></a>

<h3 id="结构category-t"><a href="#结构category-t" class="headerlink" title="结构category_t"></a>结构category_t</h3><p>我们先看下分类的结构：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">// 分类</span><br><span class="hljs-keyword">struct</span> category_t &#123;<br>    <span class="hljs-comment">// 分类名</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name;<br>    <span class="hljs-comment">// 原始类</span><br>    classref_t cls;<br>    <span class="hljs-comment">// 对象方法列表</span><br>    <span class="hljs-keyword">struct</span> method_list_t *instanceMethods;<br>    <span class="hljs-comment">// 类方法列表</span><br>    <span class="hljs-keyword">struct</span> method_list_t *classMethods;<br>    <span class="hljs-comment">// 协议列表</span><br>    <span class="hljs-keyword">struct</span> protocol_list_t *protocols;<br>    <span class="hljs-comment">// 实例属性</span><br>    <span class="hljs-keyword">struct</span> property_list_t *instanceProperties;<br>    <span class="hljs-comment">// Fields below this point are not always present on disk.</span><br>    <span class="hljs-comment">// 类属性(这个结构体以_开头命名？？？)</span><br>    <span class="hljs-keyword">struct</span> property_list_t *_classProperties;<br>    <span class="hljs-comment">// methodsForMeta 返回类方法列表或者对象方法列表</span><br>    method_list_t *methodsForMeta(<span class="hljs-keyword">bool</span> isMeta) &#123;<br>        <span class="hljs-keyword">if</span> (isMeta) <span class="hljs-keyword">return</span> classMethods;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> instanceMethods;<br>    &#125;<br>    <span class="hljs-comment">// 属性列表返回方法</span><br>    property_list_t *propertiesForMeta(<span class="hljs-keyword">bool</span> isMeta, <span class="hljs-keyword">struct</span> header_info *hi);<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>从上面我们看到，一个分类的结构体中，包含我们最关心的几个结构体：<code>instanceMethods</code>,<code>classMethods</code>,<code>protocols</code>,<code>instanceProperties</code>,而对于<code>_classProperties</code>目前好像大多数文章在讲解时都将他选择性的忽略了，我们在本篇文章结束后在继续看下这个属性到底是什么有什么作用！</p>
<p>从上面的结构我们看出：分类是独立于原始类存在的。因此对于分类来说也肯定是有一块单独的内存空间来存放分类，那么到底是怎么存放的呢？我们下面来看下</p>
<h3 id="分类的存储"><a href="#分类的存储" class="headerlink" title="分类的存储"></a>分类的存储</h3><p>我们先用CLang命令看下分类的结构和实现，我们新建一个类<code>PrimaryObject</code>以及他的分类<code>PrimaryObject (Demo)</code></p>
<p>.h</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">PrimaryObject</span> : <span class="hljs-title">NSObject</span></span><br><br>- (<span class="hljs-keyword">void</span>)test;<br><br><span class="hljs-keyword">@end</span><br><br><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">PrimaryObject</span> (<span class="hljs-title">Demo</span>)</span><br><br><span class="hljs-keyword">@end</span><br><br></code></pre></td></tr></table></figure>

<p>.m</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">PrimaryObject</span></span><br><br>- (<span class="hljs-keyword">void</span>)test &#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;PrimaryObject---test&quot;</span>);<br>&#125;<br><br><span class="hljs-keyword">@end</span><br><br><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">PrimaryObject</span> (<span class="hljs-title">Demo</span>)</span><br><br>- (<span class="hljs-keyword">void</span>)test &#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;PrimaryObject-Demo---test&quot;</span>);<br>&#125;<br><br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure>

<p>然后我们对.m文件使用clang命令看下生成的cpp结果,具体命令如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs clang">clang -rewrite-objc MyClass.m<br></code></pre></td></tr></table></figure>

<p>此时会在当前目录下生成一个<code>PrimaryObject.cpp</code>文件，我们来看下这个文件,我们可以通过我们的关键词定位到下面这段代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 对象方法列表</span><br><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> /*_<span class="hljs-title">method_list_t</span>*/ &#123;</span><br>	<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> entsize;  <span class="hljs-comment">// sizeof(struct _objc_method)</span><br>	<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> method_count;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">objc_method</span> <span class="hljs-title">method_list</span>[1];</span><br>&#125; _OBJC_$_CATEGORY_INSTANCE_METHODS_PrimaryObject_$_Demo __attribute__ ((used, section (<span class="hljs-string">&quot;__DATA,__objc_const&quot;</span>))) = &#123;<br>  <span class="hljs-comment">// 对应结构体中的entsize</span><br>	<span class="hljs-keyword">sizeof</span>(_objc_method),<br>	<span class="hljs-comment">// 对应结构体中的method_count</span><br>	<span class="hljs-number">1</span>,<br>	<span class="hljs-comment">// 对应结构中的_objc_method  方法名 参数</span><br>	&#123;&#123;(struct objc_selector *)<span class="hljs-string">&quot;test&quot;</span>, <span class="hljs-string">&quot;v16@0:8&quot;</span>, (<span class="hljs-keyword">void</span> *)_I_PrimaryObject_Demo_test&#125;&#125;<br>&#125;;<br><br><span class="hljs-comment">// 类方法列表</span><br><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> /*_<span class="hljs-title">method_list_t</span>*/ &#123;</span><br>	<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> entsize;  <span class="hljs-comment">// sizeof(struct _objc_method)</span><br>	<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> method_count;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">objc_method</span> <span class="hljs-title">method_list</span>[1];</span><br>&#125; _OBJC_$_CATEGORY_CLASS_METHODS_PrimaryObject_$_Demo __attribute__ ((used, section (<span class="hljs-string">&quot;__DATA,__objc_const&quot;</span>))) = &#123;<br>  <span class="hljs-comment">// 对应结构体中的entsize 与对象方法相同</span><br>	<span class="hljs-keyword">sizeof</span>(_objc_method),<br>	<span class="hljs-comment">// 对应结构体中的method_count</span><br>	<span class="hljs-number">1</span>,<br>  <span class="hljs-comment">// 对应结构中的_objc_method 方法名 参数</span><br>	&#123;&#123;(struct objc_selector *)<span class="hljs-string">&quot;classMethod&quot;</span>, <span class="hljs-string">&quot;v16@0:8&quot;</span>, (<span class="hljs-keyword">void</span> *)_C_PrimaryObject_Demo_classMethod&#125;&#125;<br>&#125;;<br><br><span class="hljs-comment">// 属性列表</span><br><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> /*_<span class="hljs-title">prop_list_t</span>*/ &#123;</span><br>	<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> entsize;  <span class="hljs-comment">// sizeof(struct _prop_t)</span><br>	<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> count_of_properties;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">prop_t</span> <span class="hljs-title">prop_list</span>[1];</span><br>&#125; _OBJC_$_PROP_LIST_PrimaryObject_$_Demo __attribute__ ((used, section (<span class="hljs-string">&quot;__DATA,__objc_const&quot;</span>))) = &#123;<br>   <span class="hljs-comment">// entsize</span><br>	<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">_prop_t</span>),<br>	<span class="hljs-comment">// count_of_properties</span><br>	<span class="hljs-number">1</span>,<br>	<span class="hljs-comment">// _prop_t</span><br>	&#123;&#123;<span class="hljs-string">&quot;demoCategoryArray&quot;</span>,<span class="hljs-string">&quot;T@\&quot;NSArray\&quot;,&amp;,N&quot;</span>&#125;&#125;<br>&#125;;<br><br><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> __declspec(dllexport) <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">class_t</span> <span class="hljs-title">OBJC_CLASS_</span>$_<span class="hljs-title">PrimaryObject</span>;</span><br><br><span class="hljs-comment">// 一个静态分类 结构体 名字为_OBJC_$_CATEGORY+分类名</span><br><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">category_t</span> _<span class="hljs-title">OBJC_</span>$_<span class="hljs-title">CATEGORY_PrimaryObject_</span>$_<span class="hljs-title">Demo</span> __<span class="hljs-title">attribute__</span> ((<span class="hljs-title">used</span>, <span class="hljs-title">section</span> (&quot;__<span class="hljs-title">DATA</span>,__<span class="hljs-title">objc_const</span>&quot;))) = </span><br><span class="hljs-class">&#123;</span><br><span class="hljs-comment">// 类名</span><br>	<span class="hljs-string">&quot;PrimaryObject&quot;</span>,<br>	<span class="hljs-number">0</span>, <span class="hljs-comment">// &amp;OBJC_CLASS_$_PrimaryObject,</span><br>	<span class="hljs-comment">// 对象方法列表</span><br>	(<span class="hljs-keyword">const</span> struct <span class="hljs-keyword">_method_list_t</span> *)&amp;_OBJC_$_CATEGORY_INSTANCE_METHODS_PrimaryObject_$_Demo,<br>	<span class="hljs-comment">// 类方法列表</span><br>	(<span class="hljs-keyword">const</span> struct <span class="hljs-keyword">_method_list_t</span> *)&amp;_OBJC_$_CATEGORY_CLASS_METHODS_PrimaryObject_$_Demo,<br>	<span class="hljs-number">0</span>,<br>	<span class="hljs-comment">// 属性列表</span><br>	(<span class="hljs-keyword">const</span> struct <span class="hljs-keyword">_prop_list_t</span> *)&amp;_OBJC_$_PROP_LIST_PrimaryObject_$_Demo,<br>&#125;;<br><br><span class="hljs-comment">// </span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> OBJC_CATEGORY_SETUP_$_PrimaryObject_$_Demo(<span class="hljs-keyword">void</span> ) &#123;<br>	_OBJC_$_CATEGORY_PrimaryObject_$_Demo.cls = &amp;OBJC_CLASS_$_PrimaryObject;<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> section(<span class="hljs-meta-string">&quot;.objc_inithooks$B&quot;</span>, long, read, write)</span><br><br>__declspec(allocate(<span class="hljs-string">&quot;.objc_inithooks$B&quot;</span>)) <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> *OBJC_CATEGORY_SETUP[] = &#123;<br>	(<span class="hljs-keyword">void</span> *)&amp;OBJC_CATEGORY_SETUP_$_PrimaryObject_$_Demo,<br>&#125;;<br><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">class_t</span> *<span class="hljs-title">L_OBJC_LABEL_CLASS_</span>$ [1] __<span class="hljs-title">attribute__</span>((<span class="hljs-title">used</span>, <span class="hljs-title">section</span> (&quot;__<span class="hljs-title">DATA</span>, __<span class="hljs-title">objc_classlist</span>,<span class="hljs-title">regular</span>,<span class="hljs-title">no_dead_strip</span>&quot;)))= &#123;</span><br>	&amp;OBJC_CLASS_$_PrimaryObject,<br>&#125;;<br><br><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">category_t</span> *<span class="hljs-title">L_OBJC_LABEL_CATEGORY_</span>$ [1] __<span class="hljs-title">attribute__</span>((<span class="hljs-title">used</span>, <span class="hljs-title">section</span> (&quot;__<span class="hljs-title">DATA</span>, __<span class="hljs-title">objc_catlist</span>,<span class="hljs-title">regular</span>,<span class="hljs-title">no_dead_strip</span>&quot;)))= &#123;</span><br>	&amp;_OBJC_$_CATEGORY_PrimaryObject_$_Demo,<br>&#125;;<br><br><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">IMAGE_INFO</span> &#123;</span> <span class="hljs-keyword">unsigned</span> version; <span class="hljs-keyword">unsigned</span> flag; &#125; _OBJC_IMAGE_INFO = &#123; <span class="hljs-number">0</span>, <span class="hljs-number">2</span> &#125;;<br><br></code></pre></td></tr></table></figure>

<p>首先编译器生成了实例方法列表<code>_OBJC_$_CATEGORY_INSTANCE_METHODS_PrimaryObject_$_Demo</code>和类方法列表<code>_OBJC_$_CATEGORY_CLASS_METHODS_PrimaryObject_$_Demo</code>以及属性列表<code>_OBJC_$_PROP_LIST_PrimaryObject_$_Demo</code>。三者的命名都遵循了公共前缀+类名+category名字的命名方式，而且实例方法列表和类方法列表里面填充的正是我们在Demo这个category里面写的方法<code>classMethod</code>、<code>classMethod</code>，而属性列表里面填充的也正是我们在Demo里添加的<code>demoCategoryArray</code>属性。还有一个需要注意到的事实就是category的名字用来给各种列表以及后面的category结构体本身命名，而且有static来修饰，所以在同一个编译单元里我们的category名不能重复，否则会出现编译错误。</p>
<p>其次，编译器生成了category本身<code>_OBJC_$_CATEGORY_PrimaryObject_$_Demo</code>，并用前面生成的列表来初始化category本身。</p>
<p>最后，编译器在DATA段下的<code>objc_catlist section</code>里保存了一个大小为1的<code>category_t</code>的数组L_OBJC_LABELCATEGORY$，在DATA段下的<code>__objc_classlist section</code>里保存了一个大小为1的<code>_category_t</code>数组<code>L_OBJC_LABEL_CLASS_</code>。</p>
<p>从上面Clang的代码中我们看到，分类的结构是独立于主类存在的，那么分类与主类是怎么关联的呢？分类又是如何加载的呢？</p>
<h3 id="分类的加载"><a href="#分类的加载" class="headerlink" title="分类的加载"></a>分类的加载</h3><p>我们首先看下rumtime的入口方法</p>
<h4 id="objc-init"><a href="#objc-init" class="headerlink" title="_objc_init"></a>_objc_init</h4><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">void</span> _objc_init(<span class="hljs-keyword">void</span>)<br>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> initialized = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span> (initialized) <span class="hljs-keyword">return</span>;<br>    initialized = <span class="hljs-literal">true</span>;<br>    <br>    <span class="hljs-comment">// fixme defer initialization until an objc-using image is found?</span><br><span class="hljs-comment">//	读取runtime的环境变量，如果需要则打印出来</span><br>    environ_init();<br>	<br>    tls_init();<br>	<span class="hljs-comment">//运行c++ 构造函数</span><br>    static_init();<br>	<span class="hljs-comment">//lock 初始化 暂时是空的函数</span><br>    lock_init();<br>	<span class="hljs-comment">//初始化系统异常操作</span><br>    exception_init();<br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	 仅供objc运行时使用，注册在映射、取消映射和初始化objc映像调用的处理程序。dyld将使用包含objc-image-info回调给`mapped`.</span><br><span class="hljs-comment">	 这些dylibs将自动引用计数，因此objc将不再需要调用dlopen()防止未加载。</span><br><span class="hljs-comment">	 在调用_dyld_objc_notify_register()期间，dyld将调用 `mapped` 在已经加载好 images，稍后dlopen()。</span><br><span class="hljs-comment">	 在调动init的时候也会调用`mapped`,在dyld调用的时候，也会调用init函数</span><br><span class="hljs-comment">	 </span><br><span class="hljs-comment">	 在调用任何images +load方法时候</span><br><span class="hljs-comment">	 */</span><br>    _dyld_objc_notify_register(&amp;map_images, load_images, unmap_image);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>出去上面的init方法我们看到，dyld的朱啊哟做操是调用了<code>_dyld_objc_notify_register</code>方法，我们接着看下这个方法做了什么参数有代表什么意思。</p>
<h4 id="dyld-objc-notify-register"><a href="#dyld-objc-notify-register" class="headerlink" title="_dyld_objc_notify_register"></a>_dyld_objc_notify_register</h4><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">// 仅供objc运行时使用</span><br><span class="hljs-comment">// Note: only for use by objc runtime</span><br><span class="hljs-comment">// 当objc镜像在映射、取消映射、和初始化时注册的事件会被调</span><br><span class="hljs-comment">// Register handlers to be called when objc images are mapped, unmapped, and initialized.</span><br><span class="hljs-comment">// Dyld会回调给将mapped函数一组包含objc-image-info段</span><br><span class="hljs-comment">// Dyld will call back the &quot;mapped&quot; function with an array of images that contain an objc-image-info section.</span><br><span class="hljs-comment">// 这些dylibs 将自动引用计数，因此objc将不再需要调用dlopen()防止未加载</span><br><span class="hljs-comment">// Those images that are dylibs will have the ref-counts automatically bumped, so objc will no longer need to</span><br><span class="hljs-comment">// call dlopen() on them to keep them from being unloaded.  During the call to _dyld_objc_notify_register(),</span><br><span class="hljs-comment">// 在调用_dyld_objc_notify_register()期间 dyld将调用 `mapped` 在已经加载好 images，稍后dlopen()。</span><br><span class="hljs-comment">// dyld will call the &quot;mapped&quot; function with already loaded objc images.  During any later dlopen() call,</span><br><span class="hljs-comment">// 在调动init的时候也会调用`mapped`,在dyld调用的时候，也会调用init函数</span><br><span class="hljs-comment">// dyld will also call the &quot;mapped&quot; function.  Dyld will call the &quot;init&quot; function when dyld would be called</span><br><span class="hljs-comment">// 在调用任何images +load方法时候</span><br><span class="hljs-comment">// initializers in that image.  This is when objc calls any +load methods in that image.</span><br><span class="hljs-keyword">void</span> _dyld_objc_notify_register(_dyld_objc_notify_mapped    mapped,<br>                                _dyld_objc_notify_init      init,<br>                                _dyld_objc_notify_unmapped  unmapped);<br></code></pre></td></tr></table></figure>

<p>总的来说上面这个方法的作用是:<code>向dyld注册监听Mach-O中OC相关section被加载入\载出内存的事件</code>，而具体的事件为:</p>
<ul>
<li>_dyld_objc_notify_mapped  当dyld已将images加载入内存时回调。调用map_images方法</li>
<li>_dyld_objc_notify_init 当dyld初始化image后。OC调用类的+load方法，就是在这时进行的</li>
<li>_dyld_objc_notify_unmapped 当dyld将images移除内存时。调用unmap_image方法</li>
</ul>
<p>我们先来看下第一个方法，上面我们知道这个方法会在dyld将image加到内存中后调用map_images方法：</p>
<h3 id="map-images"><a href="#map-images" class="headerlink" title="map_images"></a>map_images</h3><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">// dyld将image加到内存中后调用</span><br><span class="hljs-keyword">void</span><br>map_images(<span class="hljs-keyword">unsigned</span> count, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * <span class="hljs-keyword">const</span> paths[],<br>           <span class="hljs-keyword">const</span> <span class="hljs-keyword">struct</span> mach_header * <span class="hljs-keyword">const</span> mhdrs[])<br>&#123;<br>    mutex_locker_t lock(runtimeLock);<br>    <span class="hljs-keyword">return</span> map_images_nolock(count, paths, mhdrs);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>我们重点看下<code>map_images_nolock</code>方法,因为这里我们主要关注的是分类的加载因此与分类加载无关的代码我们暂时先屏蔽不看</p>
<h4 id="map-images-nolock"><a href="#map-images-nolock" class="headerlink" title="map_images_nolock"></a>map_images_nolock</h4><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">void</span> <br>map_images_nolock(<span class="hljs-keyword">unsigned</span> mhCount, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * <span class="hljs-keyword">const</span> mhPaths[],<br>                  <span class="hljs-keyword">const</span> <span class="hljs-keyword">struct</span> mach_header * <span class="hljs-keyword">const</span> mhdrs[])<br>&#123;   <br>    <span class="hljs-comment">// 当头文件个数大于0调用_read_images方法</span><br>    <span class="hljs-keyword">if</span> (hCount &gt; <span class="hljs-number">0</span>) &#123;<br>        _read_images(hList, hCount, totalClasses, unoptimizedTotalClasses);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>map_images_nolock</code>方法中主要是调用了<code>_read_images</code>方法 我们来深入的看下这个方法</p>
<h4 id="read-images"><a href="#read-images" class="headerlink" title="_read_images"></a>_read_images</h4><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">// </span><br><span class="hljs-keyword">void</span> _read_images(header_info **hList, uint32_t hCount, <span class="hljs-keyword">int</span> totalClasses, <span class="hljs-keyword">int</span> unoptimizedTotalClasses)<br>&#123;<br>    header_info *hi;<br>    uint32_t hIndex;<br>    size_t count;<br>    size_t i;<br>    Class *resolvedFutureClasses = <span class="hljs-literal">nil</span>;<br>    size_t resolvedFutureClassCount = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> doneOnce;<br>    TimeLogger ts(PrintImageTimes);<br><br>    runtimeLock.assertLocked();<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> EACH_HEADER \</span><br>    hIndex = <span class="hljs-number">0</span>;         \<br>    hIndex &lt; hCount &amp;&amp; (hi = hList[hIndex]); \<br>    hIndex++<br><br>    <span class="hljs-keyword">if</span> (!doneOnce) &#123;<br>        doneOnce = <span class="hljs-literal">YES</span>;<br><br>        <span class="hljs-keyword">if</span> (DisableTaggedPointers) &#123;<br>            disableTaggedPointers();<br>        &#125;<br>        <br>        initializeTaggedPointerObfuscator();<br><br>        <span class="hljs-keyword">if</span> (PrintConnecting) &#123;<br>            _objc_inform(<span class="hljs-string">&quot;CLASS: found %d classes during launch&quot;</span>, totalClasses);<br>        &#125;<br><br>        <span class="hljs-comment">// namedClasses</span><br>        <span class="hljs-comment">// Preoptimized classes don&#x27;t go in this table.</span><br>        <span class="hljs-comment">// 4/3 is NXMapTable&#x27;s load factor</span><br>        <span class="hljs-keyword">int</span> namedClassesSize = <br>            (isPreoptimized() ? unoptimizedTotalClasses : totalClasses) * <span class="hljs-number">4</span> / <span class="hljs-number">3</span>;<br>        gdb_objc_realized_classes =<br>            NXCreateMapTable(NXStrValueMapPrototype, namedClassesSize);<br>        <br>        allocatedClasses = NXCreateHashTable(NXPtrPrototype, <span class="hljs-number">0</span>, <span class="hljs-literal">nil</span>);<br>        <br>        ts.log(<span class="hljs-string">&quot;IMAGE TIMES: first time tasks&quot;</span>);<br>    &#125;<br><br><br>    <span class="hljs-comment">// Discover classes. Fix up unresolved future classes. Mark bundle classes.</span><br><br>    <span class="hljs-keyword">for</span> (EACH_HEADER) &#123;<br>        classref_t *classlist = _getObjc2ClassList(hi, &amp;count);<br>        <br>        <span class="hljs-keyword">if</span> (! mustReadClasses(hi)) &#123;<br>            <span class="hljs-comment">// Image is sufficiently optimized that we need not call readClass()</span><br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">bool</span> headerIsBundle = hi-&gt;isBundle();<br>        <span class="hljs-keyword">bool</span> headerIsPreoptimized = hi-&gt;isPreoptimized();<br><br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; count; i++) &#123;<br>            Class cls = (Class)classlist[i];<br>            Class newCls = readClass(cls, headerIsBundle, headerIsPreoptimized);<br><br>            <span class="hljs-keyword">if</span> (newCls != cls  &amp;&amp;  newCls) &#123;<br>                <span class="hljs-comment">// Class was moved but not deleted. Currently this occurs </span><br>                <span class="hljs-comment">// only when the new class resolved a future class.</span><br>                <span class="hljs-comment">// Non-lazily realize the class below.</span><br>                resolvedFutureClasses = (Class *)<br>                    realloc(resolvedFutureClasses, <br>                            (resolvedFutureClassCount+<span class="hljs-number">1</span>) * <span class="hljs-keyword">sizeof</span>(Class));<br>                resolvedFutureClasses[resolvedFutureClassCount++] = newCls;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    ts.log(<span class="hljs-string">&quot;IMAGE TIMES: discover classes&quot;</span>);<br><br>    <span class="hljs-comment">// Fix up remapped classes</span><br>    <span class="hljs-comment">// Class list and nonlazy class list remain unremapped.</span><br>    <span class="hljs-comment">// Class refs and super refs are remapped for message dispatching.</span><br>    <br>    <span class="hljs-keyword">if</span> (!noClassesRemapped()) &#123;<br>        <span class="hljs-keyword">for</span> (EACH_HEADER) &#123;<br>            Class *classrefs = _getObjc2ClassRefs(hi, &amp;count);<br>            <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; count; i++) &#123;<br>                remapClassRef(&amp;classrefs[i]);<br>            &#125;<br>            <span class="hljs-comment">// fixme why doesn&#x27;t test future1 catch the absence of this?</span><br>            classrefs = _getObjc2SuperRefs(hi, &amp;count);<br>            <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; count; i++) &#123;<br>                remapClassRef(&amp;classrefs[i]);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    ts.log(<span class="hljs-string">&quot;IMAGE TIMES: remap classes&quot;</span>);<br><br>    <span class="hljs-comment">// Fix up @selector references</span><br>    <span class="hljs-keyword">static</span> size_t UnfixedSelectors;<br>    &#123;<br>        mutex_locker_t lock(selLock);<br>        <span class="hljs-keyword">for</span> (EACH_HEADER) &#123;<br>            <span class="hljs-keyword">if</span> (hi-&gt;isPreoptimized()) <span class="hljs-keyword">continue</span>;<br>            <br>            <span class="hljs-keyword">bool</span> isBundle = hi-&gt;isBundle();<br>            SEL *sels = _getObjc2SelectorRefs(hi, &amp;count);<br>            UnfixedSelectors += count;<br>            <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; count; i++) &#123;<br>                <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name = sel_cname(sels[i]);<br>                sels[i] = sel_registerNameNoLock(name, isBundle);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    ts.log(<span class="hljs-string">&quot;IMAGE TIMES: fix up selector references&quot;</span>);<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> SUPPORT_FIXUP</span><br>    <span class="hljs-comment">// Fix up old objc_msgSend_fixup call sites</span><br>    <span class="hljs-keyword">for</span> (EACH_HEADER) &#123;<br>        message_ref_t *refs = _getObjc2MessageRefs(hi, &amp;count);<br>        <span class="hljs-keyword">if</span> (count == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br><br>        <span class="hljs-keyword">if</span> (PrintVtables) &#123;<br>            _objc_inform(<span class="hljs-string">&quot;VTABLES: repairing %zu unsupported vtable dispatch &quot;</span><br>                         <span class="hljs-string">&quot;call sites in %s&quot;</span>, count, hi-&gt;fname());<br>        &#125;<br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; count; i++) &#123;<br>            fixupMessageRef(refs+i);<br>        &#125;<br>    &#125;<br><br>    ts.log(<span class="hljs-string">&quot;IMAGE TIMES: fix up objc_msgSend_fixup&quot;</span>);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><br>    <span class="hljs-comment">// Discover protocols. Fix up protocol refs.</span><br>    <span class="hljs-keyword">for</span> (EACH_HEADER) &#123;<br>        <span class="hljs-keyword">extern</span> objc_class OBJC_CLASS_$_Protocol;<br>        Class cls = (Class)&amp;OBJC_CLASS_$_Protocol;<br>        assert(cls);<br>        NXMapTable *protocol_map = protocols();<br>        <span class="hljs-keyword">bool</span> isPreoptimized = hi-&gt;isPreoptimized();<br>        <span class="hljs-keyword">bool</span> isBundle = hi-&gt;isBundle();<br><br>        protocol_t **protolist = _getObjc2ProtocolList(hi, &amp;count);<br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; count; i++) &#123;<br>            readProtocol(protolist[i], cls, protocol_map, <br>                         isPreoptimized, isBundle);<br>        &#125;<br>    &#125;<br><br>    ts.log(<span class="hljs-string">&quot;IMAGE TIMES: discover protocols&quot;</span>);<br><br>    <span class="hljs-comment">// Fix up @protocol references</span><br>    <span class="hljs-comment">// Preoptimized images may have the right </span><br>    <span class="hljs-comment">// answer already but we don&#x27;t know for sure.</span><br>    <span class="hljs-keyword">for</span> (EACH_HEADER) &#123;<br>        protocol_t **protolist = _getObjc2ProtocolRefs(hi, &amp;count);<br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; count; i++) &#123;<br>            remapProtocolRef(&amp;protolist[i]);<br>        &#125;<br>    &#125;<br><br>    ts.log(<span class="hljs-string">&quot;IMAGE TIMES: fix up @protocol references&quot;</span>);<br><br>    <span class="hljs-comment">// Realize non-lazy classes (for +load methods and static instances)</span><br>    <span class="hljs-keyword">for</span> (EACH_HEADER) &#123;<br>        classref_t *classlist = <br>            _getObjc2NonlazyClassList(hi, &amp;count);<br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; count; i++) &#123;<br>            Class cls = remapClass(classlist[i]);<br>            <span class="hljs-keyword">if</span> (!cls) <span class="hljs-keyword">continue</span>;<br><br>            <span class="hljs-comment">// hack for class __ARCLite__, which didn&#x27;t get this above</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> TARGET_OS_SIMULATOR</span><br>            <span class="hljs-keyword">if</span> (cls-&gt;cache._buckets == (<span class="hljs-keyword">void</span>*)&amp;_objc_empty_cache  &amp;&amp;  <br>                (cls-&gt;cache._mask  ||  cls-&gt;cache._occupied)) <br>            &#123;<br>                cls-&gt;cache._mask = <span class="hljs-number">0</span>;<br>                cls-&gt;cache._occupied = <span class="hljs-number">0</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (cls-&gt;ISA()-&gt;cache._buckets == (<span class="hljs-keyword">void</span>*)&amp;_objc_empty_cache  &amp;&amp;  <br>                (cls-&gt;ISA()-&gt;cache._mask  ||  cls-&gt;ISA()-&gt;cache._occupied)) <br>            &#123;<br>                cls-&gt;ISA()-&gt;cache._mask = <span class="hljs-number">0</span>;<br>                cls-&gt;ISA()-&gt;cache._occupied = <span class="hljs-number">0</span>;<br>            &#125;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>            <br>            addClassTableEntry(cls);<br>            realizeClass(cls);<br>        &#125;<br>    &#125;<br><br>    ts.log(<span class="hljs-string">&quot;IMAGE TIMES: realize non-lazy classes&quot;</span>);<br><br>    <span class="hljs-comment">// Realize newly-resolved future classes, in case CF manipulates them</span><br>    <span class="hljs-keyword">if</span> (resolvedFutureClasses) &#123;<br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; resolvedFutureClassCount; i++) &#123;<br>            realizeClass(resolvedFutureClasses[i]);<br>            resolvedFutureClasses[i]-&gt;setInstancesRequireRawIsa(<span class="hljs-literal">false</span><span class="hljs-comment">/*inherited*/</span>);<br>        &#125;<br>        free(resolvedFutureClasses);<br>    &#125;    <br><br>    ts.log(<span class="hljs-string">&quot;IMAGE TIMES: realize future classes&quot;</span>);<br><br>    <span class="hljs-comment">// Discover categories.</span><br>    <span class="hljs-comment">// #define EACH_HEADER hIndex = 0; hIndex &lt; hCount &amp;&amp; (hi = hList[hIndex]); hIndex++</span><br>    <span class="hljs-keyword">for</span> (EACH_HEADER) &#123;<br>        <span class="hljs-comment">//GETSECT(_getObjc2CategoryList,        category_t *,    &quot;__objc_catlist&quot;);</span><br>        <span class="hljs-comment">// 从__objc_catlist获取方法列表</span><br>        category_t **catlist = <br>            _getObjc2CategoryList(hi, &amp;count);<br>        <span class="hljs-comment">// 是否有分类添加的属性</span><br>        <span class="hljs-keyword">bool</span> hasClassProperties = hi-&gt;info()-&gt;hasCategoryClassProperties();<br>        <span class="hljs-comment">// 遍历所有分类</span><br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; count; i++) &#123;<br>            <span class="hljs-comment">// 取出每一个分类</span><br>            category_t *cat = catlist[i];<br>            <span class="hljs-comment">//</span><br>            Class cls = remapClass(cat-&gt;cls);<br><br>            <span class="hljs-keyword">if</span> (!cls) &#123;<br>                <span class="hljs-comment">// Category&#x27;s target class is missing (probably weak-linked).</span><br>                <span class="hljs-comment">// Disavow any knowledge of this category.</span><br>                catlist[i] = <span class="hljs-literal">nil</span>;<br>                <span class="hljs-keyword">if</span> (PrintConnecting) &#123;<br>                    _objc_inform(<span class="hljs-string">&quot;CLASS: IGNORING category \?\?\?(%s) %p with &quot;</span><br>                                 <span class="hljs-string">&quot;missing weak-linked target class&quot;</span>, <br>                                 cat-&gt;name, cat);<br>                &#125;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            <span class="hljs-comment">// Process this category. </span><br>            <span class="hljs-comment">// First, register the category with its target class. </span><br>            <span class="hljs-comment">// Then, rebuild the class&#x27;s method lists (etc) if </span><br>            <span class="hljs-comment">// the class is realized.</span><br><br>            <span class="hljs-keyword">bool</span> classExists = <span class="hljs-literal">NO</span>;<br>            <span class="hljs-comment">// 如果这个类的instanceMethods、protocols、instanceProperties有值</span><br>            <span class="hljs-keyword">if</span> (cat-&gt;instanceMethods ||  cat-&gt;protocols  <br>                ||  cat-&gt;instanceProperties) <br>            &#123;<br>                <span class="hljs-comment">//</span><br>                addUnattachedCategoryForClass(cat, cls, hi);<br><br>                <span class="hljs-keyword">if</span> (cls-&gt;isRealized()) &#123;<br>                    remethodizeClass(cls);<br>                    classExists = <span class="hljs-literal">YES</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (PrintConnecting) &#123;<br>                    _objc_inform(<span class="hljs-string">&quot;CLASS: found category -%s(%s) %s&quot;</span>, <br>                                 cls-&gt;nameForLogging(), cat-&gt;name, <br>                                 classExists ? <span class="hljs-string">&quot;on existing class&quot;</span> : <span class="hljs-string">&quot;&quot;</span>);<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (cat-&gt;classMethods  ||  cat-&gt;protocols  <br>                ||  (hasClassProperties &amp;&amp; cat-&gt;_classProperties)) <br>            &#123;<br>                addUnattachedCategoryForClass(cat, cls-&gt;ISA(), hi);<br>                <span class="hljs-keyword">if</span> (cls-&gt;ISA()-&gt;isRealized()) &#123;<br>                    remethodizeClass(cls-&gt;ISA());<br>                &#125;<br>                <span class="hljs-keyword">if</span> (PrintConnecting) &#123;<br>                    _objc_inform(<span class="hljs-string">&quot;CLASS: found category +%s(%s)&quot;</span>, <br>                                 cls-&gt;nameForLogging(), cat-&gt;name);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    ts.log(<span class="hljs-string">&quot;IMAGE TIMES: discover categories&quot;</span>);<br><br>    <span class="hljs-comment">// Category discovery MUST BE LAST to avoid potential races </span><br>    <span class="hljs-comment">// when other threads call the new category code before </span><br>    <span class="hljs-comment">// this thread finishes its fixups.</span><br><br>    <span class="hljs-comment">// +load handled by prepare_load_methods()</span><br><br>    <span class="hljs-keyword">if</span> (DebugNonFragileIvars) &#123;<br>        realizeAllClasses();<br>    &#125;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">undef</span> EACH_HEADER</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>在这段代码中出现频次比较高的是<code>EACH_HEADER</code>显然这是一个for循环中的条件，我们来看下每次循环都做了什么</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">for</span> (EACH_HEADER) &#123;<br>        classref_t *classlist = _getObjc2ClassList(hi, &amp;count);<br>&#125;<br><br><span class="hljs-keyword">for</span> (EACH_HEADER) &#123;<br>            Class *classrefs = _getObjc2ClassRefs(hi, &amp;count);<br>&#125;<br> <br><span class="hljs-keyword">for</span> (EACH_HEADER) &#123;<br>    SEL *sels = _getObjc2SelectorRefs(hi, &amp;count);<br>&#125;<br><br><span class="hljs-keyword">for</span> (EACH_HEADER) &#123;<br>        message_ref_t *refs = _getObjc2MessageRefs(hi, &amp;count);<br>&#125;<br><span class="hljs-keyword">for</span> (EACH_HEADER) &#123;<br>        protocol_t **protolist = _getObjc2ProtocolList(hi, &amp;count);<br>&#125;<br><br><span class="hljs-keyword">for</span> (EACH_HEADER) &#123;<br>        protocol_t **protolist = _getObjc2ProtocolRefs(hi, &amp;count);<br>&#125;<br><span class="hljs-keyword">for</span> (EACH_HEADER) &#123;<br>        classref_t *classlist = <br>            _getObjc2NonlazyClassList(hi, &amp;count);<br>&#125;<br><span class="hljs-keyword">for</span> (EACH_HEADER) &#123;<br>        category_t **catlist = <br>            _getObjc2CategoryList(hi, &amp;count);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>经过这样的简化后，我们在通过这些循环中调用的方法来判断这些循环中到底做了什么,在找这些方法的时候我们发现这些方法实际上在runtime中有单独的定义的地方</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">//      function name                 content type     section name</span><br>GETSECT(_getObjc2SelectorRefs,        SEL,             <span class="hljs-string">&quot;__objc_selrefs&quot;</span>); <br>GETSECT(_getObjc2MessageRefs,         message_ref_t,   <span class="hljs-string">&quot;__objc_msgrefs&quot;</span>); <br>GETSECT(_getObjc2ClassRefs,           Class,           <span class="hljs-string">&quot;__objc_classrefs&quot;</span>);<br>GETSECT(_getObjc2SuperRefs,           Class,           <span class="hljs-string">&quot;__objc_superrefs&quot;</span>);<br>GETSECT(_getObjc2ClassList,           classref_t,      <span class="hljs-string">&quot;__objc_classlist&quot;</span>);<br>GETSECT(_getObjc2NonlazyClassList,    classref_t,      <span class="hljs-string">&quot;__objc_nlclslist&quot;</span>);<br>GETSECT(_getObjc2CategoryList,        category_t *,    <span class="hljs-string">&quot;__objc_catlist&quot;</span>);<br>GETSECT(_getObjc2NonlazyCategoryList, category_t *,    <span class="hljs-string">&quot;__objc_nlcatlist&quot;</span>);<br>GETSECT(_getObjc2ProtocolList,        protocol_t *,    <span class="hljs-string">&quot;__objc_protolist&quot;</span>);<br>GETSECT(_getObjc2ProtocolRefs,        protocol_t *,    <span class="hljs-string">&quot;__objc_protorefs&quot;</span>);<br>GETSECT(getLibobjcInitializers,       UnsignedInitializer, <span class="hljs-string">&quot;__objc_init_func&quot;</span>);<br></code></pre></td></tr></table></figure>
<p>这实际上是rumtime是根据Mach-O各个section的信息来初始化其自身，结合上面我们说过分类的结构体和分类中的对象方法被添加到<code>__DATA__</code>下的<code>__objc_catlist</code>中，类方法被添加到<code>__objc_classlist</code>中，而属性则是被添加到<code>__objc_const</code>中。</p>
<p>下面我们先来看下<code>__objc_catlist</code>,同时我们定位到对应的for循环</p>
<h4 id="objc-catlist"><a href="#objc-catlist" class="headerlink" title="__objc_catlist"></a>__objc_catlist</h4><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">    <span class="hljs-comment">// 遍历所有分类</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; count; i++) &#123;<br>        <span class="hljs-comment">// 取出每一个分类</span><br>        category_t *cat = catlist[i];<br>        <span class="hljs-comment">// 调用remapClass(cat-&gt;cls)，并返回一个objc_class *对象cls。这一步的目的在于找到到category对应的类对象cls</span><br>        Class cls = remapClass(cat-&gt;cls);<br><br>        <span class="hljs-keyword">if</span> (!cls) &#123;<br>            <span class="hljs-comment">// Category&#x27;s target class is missing (probably weak-linked).</span><br>            <span class="hljs-comment">// Disavow any knowledge of this category.</span><br>            catlist[i] = <span class="hljs-literal">nil</span>;<br>            <span class="hljs-keyword">if</span> (PrintConnecting) &#123;<br>                _objc_inform(<span class="hljs-string">&quot;CLASS: IGNORING category \?\?\?(%s) %p with &quot;</span><br>                             <span class="hljs-string">&quot;missing weak-linked target class&quot;</span>, <br>                             cat-&gt;name, cat);<br>            &#125;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">bool</span> classExists = <span class="hljs-literal">NO</span>;<br>        <span class="hljs-comment">// 如果这个类的instanceMethods、protocols、instanceProperties有值</span><br>        <span class="hljs-comment">// 如果Category中有实例方法，协议，实例属性，会改写target class的结构</span><br>        <span class="hljs-keyword">if</span> (cat-&gt;instanceMethods ||  cat-&gt;protocols  <br>            ||  cat-&gt;instanceProperties) <br>        &#123;<br>            <span class="hljs-comment">//</span><br>            addUnattachedCategoryForClass(cat, cls, hi);<br>            <span class="hljs-comment">//修改class的method list结构</span><br>            <span class="hljs-keyword">if</span> (cls-&gt;isRealized()) &#123;<br>                remethodizeClass(cls);<br>                classExists = <span class="hljs-literal">YES</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (PrintConnecting) &#123;<br>                _objc_inform(<span class="hljs-string">&quot;CLASS: found category -%s(%s) %s&quot;</span>, <br>                             cls-&gt;nameForLogging(), cat-&gt;name, <br>                             classExists ? <span class="hljs-string">&quot;on existing class&quot;</span> : <span class="hljs-string">&quot;&quot;</span>);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 如果category中有类方法，协议，或类属性(目前OC版本不支持类属性), 会改写target class的元类结构</span><br>        <span class="hljs-keyword">if</span> (cat-&gt;classMethods  ||  cat-&gt;protocols  <br>            ||  (hasClassProperties &amp;&amp; cat-&gt;_classProperties)) <br>        &#123;<br>            addUnattachedCategoryForClass(cat, cls-&gt;ISA(), hi);<br><br>            <span class="hljs-comment">// 修改class的method list结构</span><br>            <span class="hljs-keyword">if</span> (cls-&gt;ISA()-&gt;isRealized()) &#123;<br>                remethodizeClass(cls-&gt;ISA());<br>            &#125;<br>            <span class="hljs-keyword">if</span> (PrintConnecting) &#123;<br>                _objc_inform(<span class="hljs-string">&quot;CLASS: found category +%s(%s)&quot;</span>, <br>                             cls-&gt;nameForLogging(), cat-&gt;name);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>不管是在分类中添加的是对象方法还是类方法，我们发现实际上调用的都是<code>addUnattachedCategoryForClass</code>方法，那么我们看下这个方法是如何实现的呢？</p>
<h4 id="addUnattachedCategoryForClass"><a href="#addUnattachedCategoryForClass" class="headerlink" title="addUnattachedCategoryForClass"></a>addUnattachedCategoryForClass</h4><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">// 把类和category做一个关联映射</span><br><span class="hljs-comment">//  category_t *cat 分类</span><br><span class="hljs-comment">//  Class cls 原始类</span><br><span class="hljs-comment">//  header_info *catHeader 分类头信息</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> addUnattachedCategoryForClass(category_t *cat, Class cls, <br>                                          header_info *catHeader)<br>&#123;<br>    runtimeLock.assertLocked();<br><br>    <span class="hljs-comment">// DO NOT use cat-&gt;cls! cls may be cat-&gt;cls-&gt;isa instead</span><br>    <span class="hljs-comment">// 初始化一个分类表(这里是一个table)</span><br>    NXMapTable *cats = unattachedCategories();<br>    <span class="hljs-comment">// 分类list</span><br>    category_list *list;<br>    <span class="hljs-comment">// 获取原始类cls元有的分类表</span><br>    list = (category_list *)NXMapGet(cats, cls);<br>    <span class="hljs-comment">// 如果之前没有 那么新建</span><br>    <span class="hljs-keyword">if</span> (!list) &#123;<br>        list = (category_list *)<br>            calloc(<span class="hljs-keyword">sizeof</span>(*list) + <span class="hljs-keyword">sizeof</span>(list-&gt;list[<span class="hljs-number">0</span>]), <span class="hljs-number">1</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 如果之前已经有了 那么扩容list-&gt;count + 1</span><br>        list = (category_list *)<br>            realloc(list, <span class="hljs-keyword">sizeof</span>(*list) + <span class="hljs-keyword">sizeof</span>(list-&gt;list[<span class="hljs-number">0</span>]) * (list-&gt;count + <span class="hljs-number">1</span>));<br>    &#125;<br>    <span class="hljs-comment">// 将这个分类的信息放到与原始类相关的表中</span><br>    list-&gt;list[list-&gt;count++] = (locstamped_category_t)&#123;cat, catHeader&#125;;<br><br>    NXMapInsert(cats, cls, list);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>将分类与原始类做了映射后，都调用<code>remethodizeClass</code>方法，我们看下这个方法做了什么</p>
<h4 id="remethodizeClass"><a href="#remethodizeClass" class="headerlink" title="remethodizeClass"></a>remethodizeClass</h4><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> remethodizeClass(Class cls)<br>&#123;<br>    category_list *cats;<br>    <span class="hljs-keyword">bool</span> isMeta;<br><br>    runtimeLock.assertLocked();<br><br>    isMeta = cls-&gt;isMetaClass();<br><br>    <span class="hljs-comment">// 取出还未被附加到class上的category list</span><br>    <span class="hljs-keyword">if</span> ((cats = unattachedCategoriesForClass(cls, <span class="hljs-literal">false</span><span class="hljs-comment">/*not realizing*/</span>))) &#123;<br>        <span class="hljs-keyword">if</span> (PrintConnecting) &#123;<br>            _objc_inform(<span class="hljs-string">&quot;CLASS: attaching categories to class &#x27;%s&#x27; %s&quot;</span>, <br>                         cls-&gt;nameForLogging(), isMeta ? <span class="hljs-string">&quot;(meta)&quot;</span> : <span class="hljs-string">&quot;&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">// 将category附加到class上</span><br>        attachCategories(cls, cats, <span class="hljs-literal">true</span> <span class="hljs-comment">/*flush caches*/</span>);        <br>        free(cats);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面这个方法，我们看到runtime会首先通过unattachedCategoriesForClass 取出还未被附加到class上的category list，然后调用attachCategories将这些category附加到class上。</p>
<p>所以主要的逻辑在<code>attachCategories</code>中，我们来看下这个方法</p>
<h4 id="attachCategories"><a href="#attachCategories" class="headerlink" title="attachCategories"></a>attachCategories</h4><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">// 链接 分类中的 方法列表 属性和协议 到类中</span><br><span class="hljs-comment">// Class cls  原始类</span><br><span class="hljs-comment">// category_list *cats 分类列表</span><br><span class="hljs-comment">// bool flush_caches 是否需要刷新缓存</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <br>attachCategories(Class cls, category_list *cats, <span class="hljs-keyword">bool</span> flush_caches)<br>&#123;<br>    <span class="hljs-keyword">if</span> (!cats) <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-keyword">if</span> (PrintReplacedMethods) printReplacements(cls, cats);<br><br>    <span class="hljs-keyword">bool</span> isMeta = cls-&gt;isMetaClass();<br><br>    <span class="hljs-comment">// fixme rearrange to remove these intermediate allocations</span><br>    <span class="hljs-comment">// 首先分配method_list_t *， property_list_t *， protocol_list_t *的数组空间，数组大小等于category的个数</span><br>    <span class="hljs-comment">//方法数组 二维数组 每个分类的方法是数组中的一个元素 每个分类可能有多个方法</span><br>    method_list_t **mlists = (method_list_t **)<br>        malloc(cats-&gt;count * <span class="hljs-keyword">sizeof</span>(*mlists));<br>	<span class="hljs-comment">//属性数组</span><br>    property_list_t **proplists = (property_list_t **)<br>        malloc(cats-&gt;count * <span class="hljs-keyword">sizeof</span>(*proplists));<br>	<span class="hljs-comment">//协议数组</span><br>    protocol_list_t **protolists = (protocol_list_t **)<br>        malloc(cats-&gt;count * <span class="hljs-keyword">sizeof</span>(*protolists));<br><br>    <span class="hljs-comment">// Count backwards through cats to get newest categories first</span><br>    <span class="hljs-keyword">int</span> mcount = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> propcount = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> protocount = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// i表示分类的个数</span><br>    <span class="hljs-keyword">int</span> i = cats-&gt;count;<br>    <span class="hljs-keyword">bool</span> fromBundle = <span class="hljs-literal">NO</span>;<br>    <span class="hljs-comment">//依次读取每一个category，将其methods，property，protocol添加到mlists，proplist，protolist中存储</span><br>    <span class="hljs-keyword">while</span> (i--) &#123;<br>		<span class="hljs-comment">//取出某个分类</span><br>        auto&amp; entry = cats-&gt;list[i];<br>        <span class="hljs-comment">//取出分类 的 对象方法或者类方法</span><br>        method_list_t *mlist = entry.cat-&gt;methodsForMeta(isMeta);<br>        <span class="hljs-comment">// 将方法列表加入都mlists中(注意mlist本身也是个数组) 因此mlists是一个二维数组</span><br>        <span class="hljs-keyword">if</span> (mlist) &#123;<br>            mlists[mcount++] = mlist; <span class="hljs-comment">//mlists 接受所有分类方法</span><br>            fromBundle |= entry.hi-&gt;isBundle();<br>        &#125;<br>        <span class="hljs-comment">//proplist 所有分类属性</span><br>        property_list_t *proplist = <br>            entry.cat-&gt;propertiesForMeta(isMeta, entry.hi);<br><br>        <span class="hljs-keyword">if</span> (proplist) &#123;<br>            proplists[propcount++] = proplist;<br>        &#125;<br><br>        <span class="hljs-comment">//proplist 所有协议方法</span><br>        protocol_list_t *protolist = entry.cat-&gt;protocols;<br>        <span class="hljs-keyword">if</span> (protolist) &#123;<br>            protolists[protocount++] = protolist;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 取出class的data()数据，其实是class_rw_t * 指针，其对应结构体实例存储了class的基本信息</span><br>    auto rw = cls-&gt;data();<br><br>    prepareMethodLists(cls, mlists, mcount, <span class="hljs-literal">NO</span>, fromBundle);<br>	<span class="hljs-comment">//将category中的method 添加到class中</span><br>    rw-&gt;methods.attachLists(mlists, mcount);<br>	<span class="hljs-comment">//释放数组</span><br>    free(mlists);<br><br>	<span class="hljs-comment">// 如果需要，同时刷新class的method list cache</span><br>    <span class="hljs-keyword">if</span> (flush_caches  &amp;&amp;  mcount &gt; <span class="hljs-number">0</span>) flushCaches(cls);<br><br>    <span class="hljs-comment">// 将category的property添加到class中</span><br>    rw-&gt;properties.attachLists(proplists, propcount);<br>    <span class="hljs-comment">//释放数组</span><br>    free(proplists);<br><br><br>    <span class="hljs-comment">// 将category的protocol添加到class中</span><br>    rw-&gt;protocols.attachLists(protolists, protocount);<br>    <span class="hljs-comment">//释放数组</span><br>    free(protolists);<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>attachCategories</code>对类和元类都生效，即不论我们是向类对象中添加对象方法还是向元类中添加类方法都是调用<code>attachCategories</code>方法，在方法中我们明确的看到<code>方法</code>，<code>属性</code>，<code>协议</code>分别添加到原始类的列表中，当然我们还发现不管是方法属性还是协议我们调用的都是<code>attachLists</code>方法，下面我们来进一步看看这个方法。</p>
<p>在分析<code>attachLists</code>方法之前我们先看下<code>方法</code>，<code>属性</code>，<code>协议</code>对应的类型：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><br><span class="hljs-keyword">struct</span> class_rw_t &#123;<br>    method_array_t methods;<span class="hljs-comment">//方法列表</span><br>    property_array_t properties;<span class="hljs-comment">//属性列表</span><br>    protocol_array_t protocols;<span class="hljs-comment">//协议列表</span><br></code></pre></td></tr></table></figure>

<p>但实际上<code>method_array_t</code>,<code>property_array_t</code>,<code>protocol_array_t</code>都是对<code>list_array_tt</code>类型的包装。而<code>attachLists</code>刚好是<code>list_array_tt</code>中的方法。</p>
<h4 id="attachLists"><a href="#attachLists" class="headerlink" title="attachLists"></a>attachLists</h4><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"> <span class="hljs-comment">// 要添加的list 要添加的个数</span><br>    <span class="hljs-keyword">void</span> attachLists(List* <span class="hljs-keyword">const</span> * addedLists, uint32_t addedCount) &#123;<br>        <span class="hljs-keyword">if</span> (addedCount == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<br>        <br>        <span class="hljs-keyword">if</span> (hasArray()) &#123;<br>            <span class="hljs-comment">// 就list的个数</span><br>            uint32_t oldCount = array()-&gt;count;<br>			<span class="hljs-comment">// 添加后list的个数</span><br>            uint32_t newCount = oldCount + addedCount;<br>			<span class="hljs-comment">//分配内存 内存不够用了，需要扩容</span><br>            setArray((array_t *)realloc(array(), array_t::byteSize(newCount)));<br>			<span class="hljs-comment">//赋值count</span><br>            array()-&gt;count = newCount;<br><br>			<span class="hljs-comment">// array()-&gt;lists：原来的方法列表向后移动 oldCount * sizeof(array()-&gt;lists[0]个长度</span><br>            memmove(array()-&gt;lists + addedCount<span class="hljs-comment">/*数组末尾*/</span>, array()-&gt;lists<span class="hljs-comment">/*数组*/</span>,<br>                    oldCount * <span class="hljs-keyword">sizeof</span>(array()-&gt;lists[<span class="hljs-number">0</span>])<span class="hljs-comment">/*移动的大小*/</span>);<br><br>			<span class="hljs-comment">//空出来的 内存使用addedLists拷贝过去 大小是:addedCount * sizeof(array()-&gt;lists[0])</span><br>            memcpy(array()-&gt;lists, addedLists, <br>                   addedCount * <span class="hljs-keyword">sizeof</span>(array()-&gt;lists[<span class="hljs-number">0</span>]));<br>        &#125;<br>        <span class="hljs-comment">// 如果list为空 且要添加的个数为1 那么直接设置</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!list  &amp;&amp;  addedCount == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-comment">// 0 lists -&gt; 1 list</span><br>            list = addedLists[<span class="hljs-number">0</span>];<br>        &#125; <br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 如果要添加的个数大于1个</span><br>            List* oldList = list;<br>            <span class="hljs-comment">// 就数据个数</span><br>            uint32_t oldCount = oldList ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>            <span class="hljs-comment">// 更新后的数组元素个数</span><br>            uint32_t newCount = oldCount + addedCount;<br>            <span class="hljs-comment">// 分配内存空间 这时候空间所有数据为空</span><br>            setArray((array_t *)malloc(array_t::byteSize(newCount)));<br>            <span class="hljs-comment">// 更新数据个数</span><br>            array()-&gt;count = newCount;<br>            <span class="hljs-comment">// 如果有旧的</span><br>            <span class="hljs-keyword">if</span> (oldList)<br>                <span class="hljs-comment">// 将旧的数据放在了数组的addedCount的位置</span><br>                <span class="hljs-comment">// 前面addedCount个位置是为了给addedLists保留</span><br>                array()-&gt;lists[addedCount] = oldList;<br><br>            <span class="hljs-comment">// 将addedLists拷贝到数组的0-addedCount的位置</span><br>            memcpy(array()-&gt;lists, addedLists, <br>                   addedCount * <span class="hljs-keyword">sizeof</span>(array()-&gt;lists[<span class="hljs-number">0</span>]));<br>        &#125;<br>    &#125;<br>    <br><span class="hljs-comment">// memmove ：内存移动。</span><br><span class="hljs-comment">/*  __dst : 移动内存的目的地</span><br><span class="hljs-comment">*   __src : 被移动的内存首地址</span><br><span class="hljs-comment">*   __len : 被移动的内存长度</span><br><span class="hljs-comment">*   将__src的内存移动__len块内存到__dst中</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">void</span>    *memmove(<span class="hljs-keyword">void</span> *__dst, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *__src, size_t __len);<br><br><span class="hljs-comment">// memcpy ：内存拷贝。</span><br><span class="hljs-comment">/*  __dst : 拷贝内存的拷贝目的地</span><br><span class="hljs-comment">*   __src : 被拷贝的内存首地址</span><br><span class="hljs-comment">*   __n : 被移动的内存长度</span><br><span class="hljs-comment">*   将__src的内存移动__n块内存到__dst中</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">void</span>    *memcpy(<span class="hljs-keyword">void</span> *__dst, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *__src, size_t __n);<br></code></pre></td></tr></table></figure>

<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gi0viqko2dj30os09pgm9.jpg"></p>
<p>结合上图，我们发现将新的list插入到原有list的方式是：<code>头部插入</code>，结合方法调用的时候查找元类或者类对象的方法列表来调用，我们知道，分类的方法是会覆盖原始类的方法。这也从侧面证实了这一点。</p>
<p>上面的代码我们看到，无论是方法列表还是属性列表或者是协议列表我们都会添加到原始类对应的列表中，但是在实际使用中，我们都知道分类是无法添加属性的,这又是为什么呢？</p>
<p><code>注意</code>:上面的这句描述实际上是有问题的，准确的描述应该是分类可以添加属性但是系统不会为这个属性动态添加setter和getter方法(以及创建一个以_开头的实例变量)。</p>
<h3 id="AssociatedObject"><a href="#AssociatedObject" class="headerlink" title="AssociatedObject"></a>AssociatedObject</h3><p>不过runtime还是提供了关联属性的方法，让我们可以在分类中添加属性(实例变量+getter+setter),下面我们来看下关联属性的实现：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">id</span> objc_getAssociatedObject(<span class="hljs-keyword">id</span> object, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *key) &#123;<br>    <span class="hljs-keyword">return</span> _object_get_associative_reference(object, (<span class="hljs-keyword">void</span> *)key);<br>&#125;<br><br><br><span class="hljs-keyword">void</span> objc_setAssociatedObject(<span class="hljs-keyword">id</span> object, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *key, <span class="hljs-keyword">id</span> value, objc_AssociationPolicy policy) &#123;<br>    _object_set_associative_reference(object, (<span class="hljs-keyword">void</span> *)key, value, policy);<br>&#125;<br><br><br><span class="hljs-keyword">void</span> objc_removeAssociatedObjects(<span class="hljs-keyword">id</span> object) <br>&#123;<br>    <span class="hljs-keyword">if</span> (object &amp;&amp; object-&gt;hasAssociatedObjects()) &#123;<br>        _object_remove_assocations(object);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>在看这几个方法的具体实现之前，我们先看下<code>policy</code>参数的值</p>
<h4 id="objc-AssociationPolicy"><a href="#objc-AssociationPolicy" class="headerlink" title="objc_AssociationPolicy"></a>objc_AssociationPolicy</h4><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">typedef</span> OBJC_ENUM(uintptr_t, objc_AssociationPolicy) &#123;<br>    <span class="hljs-comment">/**&lt; Specifies a weak reference to the associated object. */</span><br>    OBJC_ASSOCIATION_ASSIGN = <span class="hljs-number">0</span>,           <br>    <span class="hljs-comment">/**&lt; Specifies a strong reference to the associated object. </span><br><span class="hljs-comment">    *   The association is not made atomically. */</span><br>    OBJC_ASSOCIATION_RETAIN_NONATOMIC = <span class="hljs-number">1</span>, <br>    <span class="hljs-comment">/**&lt; Specifies that the associated object is copied. </span><br><span class="hljs-comment">    *   The association is not made atomically. */</span><br>    OBJC_ASSOCIATION_COPY_NONATOMIC = <span class="hljs-number">3</span>,<br>    <span class="hljs-comment">/**&lt; Specifies a strong reference to the associated object.</span><br><span class="hljs-comment">    *   The association is made atomically. */</span><br>    OBJC_ASSOCIATION_RETAIN = <span class="hljs-number">01401</span>,    <br>    <span class="hljs-comment">/**&lt; Specifies that the associated object is copied.</span><br><span class="hljs-comment">    *   The association is made atomically. */</span>   <br>    OBJC_ASSOCIATION_COPY = <span class="hljs-number">01403</span>          <br>&#125;;<br></code></pre></td></tr></table></figure>

<p>下面我们依次看下这三个方法，首先<code>_object_set_associative_reference</code>设置关联属性。</p>
<h4 id="object-set-associative-reference"><a href="#object-set-associative-reference" class="headerlink" title="_object_set_associative_reference"></a>_object_set_associative_reference</h4><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">// 设置关联对象的值</span><br><span class="hljs-comment">// object 目标对象</span><br><span class="hljs-comment">// 关联对象的key</span><br><span class="hljs-comment">// 关联对象的值</span><br><span class="hljs-comment">// 关联策略</span><br><span class="hljs-keyword">void</span> _object_set_associative_reference(<span class="hljs-keyword">id</span> object, <span class="hljs-keyword">void</span> *key, <span class="hljs-keyword">id</span> value, uintptr_t policy) &#123;<br>    <span class="hljs-comment">// retain the new value (if any) outside the lock.</span><br>    ObjcAssociation old_association(<span class="hljs-number">0</span>, <span class="hljs-literal">nil</span>);<br>	<span class="hljs-comment">//获取new_value的值</span><br>    <span class="hljs-comment">// acquireValue根据policy== OBJC_ASSOCIATION_SETTER_COPY 或者OBJC_ASSOCIATION_SETTER_RETAIN</span><br>    <span class="hljs-comment">// 判断是要进行retain操作还是copy操作</span><br>    <span class="hljs-keyword">id</span> new_value = value ? acquireValue(value, policy) : <span class="hljs-literal">nil</span>;<br>    &#123;<br>        AssociationsManager manager;<br>		<span class="hljs-comment">//生成一个全局的 HashMap</span><br>        AssociationsHashMap &amp;associations(manager.associations());<br>        disguised_ptr_t disguised_object = DISGUISE(object);<br>		<span class="hljs-comment">//newValue存在 需要更新</span><br>        <span class="hljs-keyword">if</span> (new_value) &#123;<br>            <span class="hljs-comment">// 遍历 hashMap是否有该obj</span><br>            AssociationsHashMap::iterator i = associations.find(disguised_object);<br>            <span class="hljs-comment">// 遍历</span><br>            <span class="hljs-keyword">if</span> (i != associations.end()) &#123;<br>				<span class="hljs-comment">//这个对象有关联对象 注意这里取出的并不是某个对象 而是一个哈希表</span><br>                ObjectAssociationMap *refs = i-&gt;second;<br>                <span class="hljs-comment">// 根据key找到对应的关联对象</span><br>                ObjectAssociationMap::iterator j = refs-&gt;find(key);<br>                <span class="hljs-comment">// 遍历根据key的查找结果</span><br>                <span class="hljs-keyword">if</span> (j != refs-&gt;end()) &#123;<br>                    <span class="hljs-comment">// 如果找到了 更新值</span><br>                    old_association = j-&gt;second;<br>                    j-&gt;second = ObjcAssociation(policy, new_value);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// 如果找到最后仍然没有找到 那么新增插入</span><br>                    (*refs)[key] = ObjcAssociation(policy, new_value);<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>				<span class="hljs-comment">//如果这个对象之前就没有关联对象 那么新建</span><br>                ObjectAssociationMap *refs = new ObjectAssociationMap;<br>                associations[disguised_object] = refs;<br>                (*refs)[key] = ObjcAssociation(policy, new_value);<br>                object-&gt;setHasAssociatedObjects();<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 如果传入的关联对象值为nil，则断开关联</span><br>            AssociationsHashMap::iterator i = associations.find(disguised_object);<br>            <span class="hljs-keyword">if</span> (i !=  associations.end()) &#123;<br>                ObjectAssociationMap *refs = i-&gt;second;<br>                ObjectAssociationMap::iterator j = refs-&gt;find(key);<br>                <span class="hljs-keyword">if</span> (j != refs-&gt;end()) &#123;<br>                    old_association = j-&gt;second;<br>                    refs-&gt;erase(j);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 释放旧值</span><br>    <span class="hljs-keyword">if</span> (old_association.hasValue()) ReleaseValue()(old_association);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>大概的流程是:</p>
<ul>
<li>根据关联的policy，调用id new_value = value ? acquireValue(value, policy) : nil; ，acquireValue 方法会根据poilcy是retain或copy，对value做引用+1操作或copy操作，并返回对应的new_value。（如果传入的value为nil，则返回nil，不做任何操作）</li>
<li>获取到new_value 后，根据是否有new_value的值。如果 new_value 存在，则对象与目标对象关联。实质是存入到全局单例 AssociationsManager manager 的对象关联表中。 如果new_value 不存在，则释放掉之前目标对象及关联 key所存储的关联对象。实质是在 AssociationsManager 中删除掉关联对象。</li>
<li>最后，释放掉之前以同样key存储的关联对象</li>
</ul>
<p>从上面的代码中我们看到所有对象的关联属性实际上都存放在一个全局的静态哈希表中<code> static AssociationsHashMap *_map;</code> 然后分别根据对象地址取出对象所有的关联属性，进而根据key去获取对应的关联对象。大致结构如下图：</p>
<p><img src="http://vanney9.com/lionheart/1706/association.png"></p>
<p>接着我们在来看下获取的方法即<code>_object_get_associative_reference</code>方法：</p>
<h4 id="object-get-associative-reference"><a href="#object-get-associative-reference" class="headerlink" title="_object_get_associative_reference"></a>_object_get_associative_reference</h4><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">// 获取一个已关联的对象</span><br><span class="hljs-keyword">id</span> _object_get_associative_reference(<span class="hljs-keyword">id</span> object, <span class="hljs-keyword">void</span> *key) &#123;<br>    <span class="hljs-keyword">id</span> value = <span class="hljs-literal">nil</span>;<br>    uintptr_t policy = OBJC_ASSOCIATION_ASSIGN;<br>    &#123;<br>        <span class="hljs-comment">// 可以把manager理解为一个单例 实际上是一个静态变量</span><br>        AssociationsManager manager;<br>		<span class="hljs-comment">//初始化 _map = AssociationsHashMap</span><br>        AssociationsHashMap &amp;associations(manager.associations());<br>        <span class="hljs-comment">// 取反object 地址 作为accociative key</span><br>        disguised_ptr_t disguised_object = DISGUISE(object);<br>        <span class="hljs-comment">// 在关联对象海西表中 找到与disguised_object关联的所有对象</span><br>        AssociationsHashMap::iterator i = associations.find(disguised_object);<br><br>        <span class="hljs-comment">// 遍历这个哈希表</span><br>        <span class="hljs-keyword">if</span> (i != associations.end()) &#123;<br>            <span class="hljs-comment">// 取出当前的这个关联对象</span><br>            ObjectAssociationMap *refs = i-&gt;second;<br>            <span class="hljs-comment">// 根据key查找对应的关联对象 有可能存在多个</span><br>            ObjectAssociationMap::iterator j = refs-&gt;find(key);<br>            <span class="hljs-comment">// 遍历查找结果</span><br>            <span class="hljs-keyword">if</span> (j != refs-&gt;end()) &#123;<br>                <span class="hljs-comment">// 取出关联实体</span><br>                ObjcAssociation &amp;entry = j-&gt;second;<br>                value = entry.value();<br>                policy = entry.policy();<br>                <span class="hljs-keyword">if</span> (policy &amp; OBJC_ASSOCIATION_GETTER_RETAIN) &#123;<br>                    objc_retain(value);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 如果policy = OBJC_ASSOCIATION_GETTER_AUTORELEASE</span><br>    <span class="hljs-keyword">if</span> (value &amp;&amp; (policy &amp; OBJC_ASSOCIATION_GETTER_AUTORELEASE)) &#123;<br>        objc_autorelease(value);<br>    &#125;<br>    <span class="hljs-keyword">return</span> value;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>结合上面图中的存储结构，get方法的流程为：</p>
<ul>
<li><p>根据对象地址获取该对象所有的关联属性<br>  AssociationsHashMap::iterator i = associations.find(disguised_object);</p>
</li>
<li><p>根据关联对象的key获取到具体的关联对象并返回 同时根据该关联对象的策略 判断是否需要retain</p>
</li>
</ul>
<p>紧接着我们再来看下释放的方法<code>objc_removeAssociatedObjects</code>,首先我们先搜索一下这个方法的调用时机，</p>
<h4 id="objc-destructInstance"><a href="#objc-destructInstance" class="headerlink" title="objc_destructInstance"></a>objc_destructInstance</h4><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">void</span> *objc_destructInstance(<span class="hljs-keyword">id</span> obj) <br>&#123;<br>    <span class="hljs-keyword">if</span> (obj) &#123;<br>        Class isa = obj-&gt;getIsa();<br><br>        <span class="hljs-keyword">if</span> (isa-&gt;hasCxxDtor()) &#123;<br>            object_cxxDestruct(obj);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (isa-&gt;instancesHaveAssociatedObjects()) &#123;<br>            _object_remove_assocations(obj);<br>        &#125;<br><br>        objc_clear_deallocating(obj);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> obj;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>objc_destructInstance方法是对象在被释放时调用的，那么<code>objc_removeAssociatedObjects</code>的时机就是在对象被释放时，如果发现这个对象有关联对象那么就去释放这个对象的关联对象。</p>
<p>具体的释放方法如下:</p>
<h4 id="object-remove-assocations"><a href="#object-remove-assocations" class="headerlink" title="_object_remove_assocations"></a>_object_remove_assocations</h4><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">// 对象释放时移除所有的关联属性</span><br><span class="hljs-keyword">void</span> _object_remove_assocations(<span class="hljs-keyword">id</span> object) &#123;<br>    vector&lt; ObjcAssociation,ObjcAllocator&lt;ObjcAssociation&gt; &gt; elements;<br>    &#123;<br>        AssociationsManager manager;<br>        AssociationsHashMap &amp;associations(manager.associations());<br><br>        <span class="hljs-keyword">if</span> (associations.size() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<br><br>        disguised_ptr_t disguised_object = DISGUISE(object);<br>        <span class="hljs-comment">// 根据对象地址取出所有的关联对象</span><br>        AssociationsHashMap::iterator i = associations.find(disguised_object);<br>        <span class="hljs-keyword">if</span> (i != associations.end()) &#123;<br>            <span class="hljs-comment">// 拷贝所有的关联关系</span><br>            ObjectAssociationMap *refs = i-&gt;second;<br>            <span class="hljs-keyword">for</span> (ObjectAssociationMap::iterator j = refs-&gt;begin(), end = refs-&gt;end(); j != end; ++j) &#123;<br>                <span class="hljs-comment">// 记录所有的关联对象到elements</span><br>                elements.push_back(j-&gt;second);<br>            &#125;<br>            <span class="hljs-comment">// 删除refs 删除这个对象的所有关联对象</span><br>            delete refs;<br>            <span class="hljs-comment">// 清除关联关系</span><br>            associations.erase(i);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// elements数组中的所有元素执行ReleaseValue操作</span><br>    for_each(elements.begin(), elements.end(), ReleaseValue());<br>&#125;<br></code></pre></td></tr></table></figure>
<p>删除关联对象的时候，我们实际上是将某个对象的所有关联对象放到一个数组中，先清除关联关系和，然后在对数组中的所有元素执行release操作。</p>
<p>通过上面的讲述，我们知道了分类方法是如何被添加到原始类的方法列表、属性列表、协议列表中的。而且添加的时机为<code>map_images</code>(参考前面讲述的_objc_init方法)。</p>
<p>那么我们接着看<code>map_images</code>方法执行后会继续执行<code>load_images</code>,<code>unmap_image</code>方法，</p>
<h3 id="load-images"><a href="#load-images" class="headerlink" title="load_images"></a>load_images</h3><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">void</span><br>load_images(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *path __unused, <span class="hljs-keyword">const</span> <span class="hljs-keyword">struct</span> mach_header *mh)<br>&#123;<br>    <span class="hljs-comment">// Return without taking locks if there are no +load methods here.</span><br>    <span class="hljs-keyword">if</span> (!hasLoadMethods((<span class="hljs-keyword">const</span> headerType *)mh)) <span class="hljs-keyword">return</span>;<br><br>    recursive_mutex_locker_t lock(loadMethodLock);<br><br>    <span class="hljs-comment">// Discover load methods</span><br>    &#123;<br>        mutex_locker_t lock2(runtimeLock);<br>        <span class="hljs-comment">//加载 class+load 和category+load方法</span><br>        prepare_load_methods((<span class="hljs-keyword">const</span> headerType *)mh);<br>    &#125;<br><br>    <span class="hljs-comment">// Call +load methods (without runtimeLock - re-entrant)</span><br>    <span class="hljs-comment">//执行 class+load 和category+load方法</span><br>    call_load_methods();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们看到<code>load_images</code>方法中主要是执行了<code>call_load_methods</code>方法，这也侧面证明在+load方法中我们可以使用关联对象，因为对应的属性和方法列表已经被添加到类中。</p>
<p>而对于<code>call_load_methods</code>方法：</p>
<h4 id="call-load-methods"><a href="#call-load-methods" class="headerlink" title="call_load_methods"></a>call_load_methods</h4><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">// 执行+load方法</span><br><span class="hljs-keyword">void</span> call_load_methods(<span class="hljs-keyword">void</span>)<br>&#123;<br>    <span class="hljs-keyword">do</span> &#123;<br>        <span class="hljs-comment">//执行class+load直到完成</span><br>        <span class="hljs-keyword">while</span> (loadable_classes_used &gt; <span class="hljs-number">0</span>) &#123;<br>            call_class_loads();<br>        &#125;<br>        <span class="hljs-comment">// 执行Category +load 一次</span><br>        more_categories = call_category_loads();<br><br>        <span class="hljs-comment">// 3. Run more +loads if there are classes OR more untried categories</span><br>    &#125; <span class="hljs-keyword">while</span> (loadable_classes_used &gt; <span class="hljs-number">0</span>  ||  more_categories);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>我们也看到，+load方法是先调用了原始类中的+load方法，再调用分类中的load方法。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这篇文章我们主要介绍了分类的结构和分类是如何与主类关联的，同时分析了关联对象方法的具体实现。同时在介绍<code>load_images</code>方法时，我们又验证了+load方法的调用时机以及与分类方法链接到主类的执行顺序。</p>
]]></content>
      <categories>
        <category>Runtime</category>
      </categories>
      <tags>
        <tag>Runtime Category</tag>
      </tags>
  </entry>
  <entry>
    <title>SideTable结构</title>
    <url>/2020/08/16/sidetablestructure/</url>
    <content><![CDATA[<p>  iOS开发者都知道，当一个对象被释放时，所有对这个对象弱引用的指针都会释放并置为nil，那么系统是如何存储这些弱引用对象的呢？又是如何在一个对象释放时，将这些指向即将释放对象的弱引用的指针置为nil的呢？下面我们通过分析<code>SideTable</code>的结构来进一步了解内存管理的弱引用存储细节。</p>
<a id="more"></a>

<h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p>在runtime中，有四个数据结构非常重要，分别是<code>SideTables</code>，<code>SideTable</code>，<code>weak_table_t</code>和<code>weak_entry_t</code>。它们和对象的引用计数，以及weak引用相关。</p>
<h4 id="SideTables"><a href="#SideTables" class="headerlink" title="SideTables"></a>SideTables</h4><p>下面我们看下SideTables的结构：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">static</span> StripedMap&lt;SideTable&gt;&amp; SideTables() &#123;<br>    <span class="hljs-keyword">return</span> *reinterpret_cast&lt;StripedMap&lt;SideTable&gt;*&gt;(SideTableBuf);<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>reinterpret_cast</code>，是C++里的强制类型转换符,我们看下<code>SideTableBuf</code>的定义。上面代码，我们看到StripedMap实际上返回的是一个SideTableBuf对象，那么我们来看下SideTableBuf对象：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">//alignas 字节对齐</span><br><span class="hljs-comment">// SideTableBuf 静态全局变量</span><br><span class="hljs-comment">// sizeof(StripedMap&lt;SideTable&gt;) = 4096</span><br><span class="hljs-comment">//alignas (StripedMap&lt;SideTable&gt;) 是字节对齐的意思，表示让数组中每一个元素的起始位置对齐到4096的倍数</span><br><span class="hljs-comment">// 因此下面这句话可以翻译为 static uint8_t SideTableBuf[4096]</span><br>alignas(StripedMap&lt;SideTable&gt;) <span class="hljs-keyword">static</span> uint8_t <br>    SideTableBuf[<span class="hljs-keyword">sizeof</span>(StripedMap&lt;SideTable&gt;)];<br></code></pre></td></tr></table></figure>
<p><code>SideTableBuf</code>是一个外部不可见的静态内存区块，存储<code>StripedMap&lt;SideTable&gt;</code>对象。它是内存管理的基础。</p>
<p>我们接下来在看下<code>StripedMap</code>的结构</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">enum</span> &#123; CacheLineSize = <span class="hljs-number">64</span> &#125;;<br><span class="hljs-comment">// StripedMap&lt;T&gt; 是一个模板类，根据传递的实际参数决定其中 array 成员存储的元素类型</span><br><span class="hljs-comment">// 能通过对象的地址，运算出 Hash 值，通过该 hash 值找到对应的 value</span><br>template&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> StripedMap &#123;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> TARGET_OS_IPHONE &amp;&amp; !TARGET_OS_SIMULATOR</span><br>    <span class="hljs-keyword">enum</span> &#123; StripeCount = <span class="hljs-number">8</span> &#125;;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><br>    <span class="hljs-keyword">enum</span> &#123; StripeCount = <span class="hljs-number">64</span> &#125;;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>    <span class="hljs-comment">// PaddedT 为一个结构体</span><br>    <span class="hljs-keyword">struct</span> PaddedT &#123;<br>        T value alignas(CacheLineSize);<br>    &#125;;<br><br>    <span class="hljs-comment">// array 中存放着8个sidetable</span><br>    PaddedT array[StripeCount];<br>    <span class="hljs-comment">//取得p的哈希值，p就是实例对象的地址</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> indexForPointer(<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *p) &#123;<br>        uintptr_t addr = reinterpret_cast&lt;uintptr_t&gt;(p);<br>        <span class="hljs-comment">// 这里根据对象的地址经过左移和异或操作 最终结果 模 8 得到一个0-7的值</span><br>        <span class="hljs-comment">// 即对应该地址对应array中下标的sidetable中</span><br>        <span class="hljs-keyword">return</span> ((addr &gt;&gt; <span class="hljs-number">4</span>) ^ (addr &gt;&gt; <span class="hljs-number">9</span>)) % StripeCount;<br>    &#125;<br><br> public:<br>    <span class="hljs-comment">// 重写了[]方法 即通过下标获取数组中对应下标的值</span><br>    <span class="hljs-comment">// array[index] = array[indexForPointer(p)].value</span><br>    T&amp; operator[] (<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *p) &#123; <br>        <span class="hljs-keyword">return</span> array[indexForPointer(p)].value; <br>    &#125;<br><br>    <span class="hljs-keyword">const</span> T&amp; operator[] (<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *p) <span class="hljs-keyword">const</span> &#123; <br>        <span class="hljs-keyword">return</span> const_cast&lt;StripedMap&lt;T&gt;&gt;(<span class="hljs-keyword">this</span>)[p]; <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><code>StripedMap</code> 是一个以<code>void *</code>为hash key， T为vaule的hash 表。<code>StripedMap</code>的所有T类型数据都被封装到array中。</p>
<p>综上我们得出<code>SideTables</code>的机构实际是下图所示:<br><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghsmzzzthcj30tu05b0t8.jpg"></p>
<h4 id="SideTable"><a href="#SideTable" class="headerlink" title="SideTable"></a>SideTable</h4><p>下面来看下<code>sideTable</code>的结构</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">struct</span> SideTable &#123;<br>    <span class="hljs-comment">// 保证原子操作的自旋锁</span><br>    spinlock_t slock;<br>    <span class="hljs-comment">// 引用计数的 hash 表</span><br>    RefcountMap refcnts;<br>    <span class="hljs-comment">// weak 引用全局 hash 表</span><br>    weak_table_t weak_table;<br><br>    SideTable() &#123;<br>        memset(&amp;weak_table, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(weak_table));<br>    &#125;<br><br><br>    ~SideTable() &#123;<br>        _objc_fatal(<span class="hljs-string">&quot;Do not delete SideTable.&quot;</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghszonn7i6j308d08g74f.jpg"></p>
<p>上面是我们简化后的<code>SideTable</code>结构体，包含了:</p>
<ul>
<li>保证原子属性的自旋锁<code>spinlock_t</code></li>
<li>记录引用计数值的<code>RefcountMap</code></li>
<li>用于存储对象弱引用的哈希表 <code>weak_table_t</code></li>
</ul>
<p>自旋锁(slock)我们这里就不做过多介绍了,我们先来看下RefcountMap，看下<code>RefcountMap</code>结构</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">// RefcountMap 是一个模板类</span><br><span class="hljs-comment">// key,DisguisedPtr&lt;objc_object&gt;类型</span><br><span class="hljs-comment">// value，size_t类型</span><br><span class="hljs-comment">// 是否清除为vlaue==0的数据，true</span><br><span class="hljs-keyword">typedef</span> objc::DenseMap&lt;DisguisedPtr&lt;objc_object&gt;,size_t,<span class="hljs-literal">true</span>&gt; RefcountMap;<br></code></pre></td></tr></table></figure>

<p>DenseMap是llvm库中的类，是一个简单的二次探测哈希表，擅长支持小的键和值。<code>RefcountMap</code>是一个hash map，其key是obj的<code>DisguisedPtr&lt;objc_object&gt;</code>，而value，则是obj对象的<code>引用计数</code>,同时，这个map还有个加强版功能，当引用计数为0时，会自动将对象数据清除。</p>
<p>上面我们知道了，refcnts是用来存放引用计数的，那么我们如何获取一个对象的引用计数呢？</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">// 获取一个对象的retainCount</span><br><span class="hljs-keyword">inline</span> uintptr_t <br>objc_object::rootRetainCount()<br>&#123;<br>	<span class="hljs-comment">//优化指针 直接返回</span><br>    <span class="hljs-keyword">if</span> (isTaggedPointer()) <span class="hljs-keyword">return</span> (uintptr_t)<span class="hljs-keyword">this</span>;<br>    <span class="hljs-comment">//没优化则 到SideTable 读取</span><br>    sidetable_lock();<br>	<span class="hljs-comment">//isa指针</span><br>    isa_t bits = LoadExclusive(&amp;isa.bits);<br>    ClearExclusive(&amp;isa.bits);<span class="hljs-comment">//啥都没做</span><br>    <span class="hljs-keyword">if</span> (bits.nonpointer) &#123;<span class="hljs-comment">//优化过 isa 指针</span><br>        uintptr_t rc = <span class="hljs-number">1</span> + bits.extra_rc;<span class="hljs-comment">//计数数量</span><br>        <span class="hljs-keyword">if</span> (bits.has_sidetable_rc) &#123;<br>        <span class="hljs-comment">//bits.has_sidetable_rc标志位为1 表明有存放在sidetable中的引用计数</span><br>			<span class="hljs-comment">//读取table的值 相加</span><br>            rc += sidetable_getExtraRC_nolock();<br>        &#125;<br>		<span class="hljs-comment">//解锁</span><br>        sidetable_unlock();<br>        <span class="hljs-keyword">return</span> rc;<br>    &#125;<br><br>    sidetable_unlock();<br>	<span class="hljs-comment">//：如果没采用优化的isa指针，则直接返回sidetable中的值</span><br>    <span class="hljs-keyword">return</span> sidetable_retainCount();<br>&#125;<br></code></pre></td></tr></table></figure>
<p>从上面的代码我们可以得出:<code>retainCount = isa.extra_rc + sidetable_getExtraRC_nolock</code>,即引用计数=isa指针中存储的引用计数+sidetable中存储的引用计数</p>
<p>那么<code>sidetable_getExtraRC_nolock</code>是如何从sideTable中获取<code>retainCount</code>的呢？<br>下面我们来看下这个方法的实现。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">size_t <br>objc_object::sidetable_getExtraRC_nolock()<br>&#123;<br>	<span class="hljs-comment">//</span><br>    assert(isa.nonpointer);<br>	<span class="hljs-comment">//key是 this，存储了每个对象的table</span><br>    SideTable&amp; table = SideTables()[<span class="hljs-keyword">this</span>];<br>	<span class="hljs-comment">//找到 it 否则返回0</span><br>    RefcountMap::iterator it = table.refcnts.find(<span class="hljs-keyword">this</span>);<br>    <span class="hljs-comment">// 这里返回的it是RefcountMap类型 it == table.refcnts.end() </span><br>    <span class="hljs-comment">// 表示在sidetable中没有找到this对应的引用计数则直接返回0</span><br>    <span class="hljs-keyword">if</span> (it == table.refcnts.end()) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// RefcountMap 结构的second值为引用计数值 </span><br>    <span class="hljs-comment">// DenseMap&lt;DisguisedPtr&lt;objc_object&gt;,size_t,true&gt; RefcountMap;</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> it-&gt;second &gt;&gt; SIDE_TABLE_RC_SHIFT;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>了解了SideTable的RefcountMap，下面我们接着看另外一个属性weak_table</p>
<h4 id="weak-table"><a href="#weak-table" class="headerlink" title="weak_table"></a>weak_table</h4><p>我们都知道weak_table是对象弱引用map，它记录了所有弱引用对象的集合。</p>
<p>我们先来看下<code>weak_table_t</code>的定义：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">// 全局的弱引用表</span><br><span class="hljs-keyword">struct</span> weak_table_t &#123;<br>    <span class="hljs-comment">// hash数组，用来存储弱引用对象的相关信息weak_entry_t</span><br>    weak_entry_t *weak_entries;<br>    <span class="hljs-comment">// hash数组中的元素个数</span><br>    size_t    num_entries;<br>    <span class="hljs-comment">// hash数组长度-1，会参与hash计算。</span><br>    <span class="hljs-comment">//（注意，这里是hash数组的长度，而不是元素个数。比如，数组长度可能是64，而元素个数仅存了2个）</span><br>    uintptr_t mask;<br>    <span class="hljs-comment">// 最大哈希偏移值</span><br>    uintptr_t max_hash_displacement;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghszyu1ay9j30ae0af0tc.jpg"></p>
<p><code>weak_entries</code>实质上是一个hash数组，数组中存储<code>weak_entry_t</code>类型的元素。weak_entry_t的定义如下</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * The internal structure stored in the weak references table. </span><br><span class="hljs-comment"> * It maintains and stores</span><br><span class="hljs-comment"> * a hash set of weak references pointing to an object.</span><br><span class="hljs-comment"> * If out_of_line_ness != REFERRERS_OUT_OF_LINE then the set</span><br><span class="hljs-comment"> * is instead a small inline array.</span><br><span class="hljs-comment"> */</span><br> <span class="hljs-comment">//inline_referrers数组中可以存放元素的最大个数 如果超过了这个个数就会使用referrers 存放</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> WEAK_INLINE_COUNT 4</span><br><span class="hljs-comment">// out_of_line_ness field overlaps with the low two bits of inline_referrers[1].</span><br><span class="hljs-comment">// inline_referrers[1] is a DisguisedPtr of a pointer-aligned address.</span><br><span class="hljs-comment">// The low two bits of a pointer-aligned DisguisedPtr will always be 0b00</span><br><span class="hljs-comment">// (disguised nil or 0x80..00) or 0b11 (any other address).</span><br><span class="hljs-comment">// Therefore out_of_line_ness == 0b10 is used to mark the out-of-line state.</span><br><span class="hljs-comment">// DisguisedPtr方法返回的hash值得最低2个字节应该是0b00或0b11，因此可以用out_of_line_ness </span><br><span class="hljs-comment">// == 0b10来表明当前是否在使用数组或动态数组来保存引用该对象的列表。</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> REFERRERS_OUT_OF_LINE 2</span><br><span class="hljs-keyword">struct</span> weak_entry_t &#123;<br>    <span class="hljs-comment">// 被弱引用的对象</span><br>    DisguisedPtr&lt;objc_object&gt; referent;<br>    <span class="hljs-comment">// 联合结构 两种结构共同占用一块内存空间 两种结构互斥</span><br>    <span class="hljs-keyword">union</span> &#123;<br>        <span class="hljs-comment">// 弱引用 被弱引用对象的列表</span><br>        <span class="hljs-keyword">struct</span> &#123;<br>            <span class="hljs-comment">// 弱引用该对象的对象列表的动态数组</span><br>            weak_referrer_t *referrers;<br>            <span class="hljs-comment">// 是否使用动态数组标记位</span><br>            uintptr_t        out_of_line_ness : <span class="hljs-number">2</span>;<br>            <span class="hljs-comment">// 动态数组中元素的个数</span><br>            uintptr_t        num_refs : PTR_MINUS_2;<br>            <span class="hljs-comment">// 用于hash确定动态数组index，值实际上是动态数组空间长度-1（它和num_refs不一样，</span><br>            <span class="hljs-comment">// 这里是记录的是数组中位置的个数，而不是数组中实际存储的元素个数）。</span><br>            uintptr_t        mask;<br>            <span class="hljs-comment">// 最大哈希偏移值</span><br>            uintptr_t        max_hash_displacement;<br>        &#125;;<br>        <span class="hljs-keyword">struct</span> &#123;<br>            <span class="hljs-comment">// inline_referrers 数组 当不使用动态数组时使用 最大个数为4</span><br>            weak_referrer_t  inline_referrers[WEAK_INLINE_COUNT];<br>        &#125;;<br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>从上面的介绍我们可以总结<code>SideTables</code>和<code>SideTable</code>以及<code>weak_table_t</code>在层级上的关系图如下：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ght18747k1j31bi0oqn0t.jpg"></p>
<p>上图是从数据结构的角度来看弱引用的保存,下面我们来看下从垂直方向来看</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ght1vuy3uqj30x909g3z3.jpg"></p>
<p>从上面的总结中我们可以看到，弱引用的存储实际上一个三级的哈希表，通过一层层的索引找到或者存储对应的弱引用。那当向<code>weak_table_t</code>中插入或查找某个元素时是如何操作的呢？算法是什么样的呢？</p>
<h4 id="weak-entry-for-referent"><a href="#weak-entry-for-referent" class="headerlink" title="weak_entry_for_referent"></a>weak_entry_for_referent</h4><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">/ 在weak_table中查找所有弱引用referent的对象<br><span class="hljs-keyword">static</span> weak_entry_t *<br>weak_entry_for_referent(weak_table_t *weak_table, objc_object *referent)<br>&#123;<br>    assert(referent);<br>    <span class="hljs-comment">//获取这个weak_table_t中所有的弱引用对象</span><br>    weak_entry_t *weak_entries = weak_table-&gt;weak_entries;<br><br>    <span class="hljs-keyword">if</span> (!weak_entries) <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>;<br>    <span class="hljs-comment">//hash_pointer 哈希函数 传入的是 objc_object *key</span><br>    <span class="hljs-comment">// weak_table-&gt;mask = weaktable的容量-1</span><br>    size_t begin = hash_pointer(referent) &amp; weak_table-&gt;mask;<br>    size_t index = begin;<br>    <span class="hljs-comment">// 哈希冲突次数</span><br>    size_t hash_displacement = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 判断根据index获取到的弱引用对象数组中对应的weak_entry_t的弱引用对象是否为</span><br>    <span class="hljs-comment">// 外部传入的对象</span><br>    <span class="hljs-keyword">while</span> (weak_table-&gt;weak_entries[index].referent != referent) &#123;<br>        <span class="hljs-comment">// 开放地址法解决哈希冲突</span><br>        <span class="hljs-comment">// &amp; weak_table-&gt;mask 是为了在下一个地址仍然没有找到外部传入对象时回到第一个对比的位置</span><br>        index = (index+<span class="hljs-number">1</span>) &amp; weak_table-&gt;mask;<br>        <span class="hljs-keyword">if</span> (index == begin)<br>            <span class="hljs-comment">// 对比了所有数据 仍没有找到 直接报错</span><br>            bad_weak_table(weak_table-&gt;weak_entries);<br>        <span class="hljs-comment">// 哈希冲突次数++</span><br>        hash_displacement++;<br>        <span class="hljs-comment">// 最大哈希偏移值 表示已经遍历了数组中所有的元素</span><br>        <span class="hljs-comment">// 没有找到那么直接返回nil</span><br>        <span class="hljs-keyword">if</span> (hash_displacement &gt; weak_table-&gt;max_hash_displacement) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 直接返回被弱引用的对象</span><br>    <span class="hljs-keyword">return</span> &amp;weak_table-&gt;weak_entries[index];<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面就是根据对象地址获取所有弱引用该对象的的数组，基本逻辑都比较清晰，我们在遍历<code>weak_table-&gt;weak_entries</code>中的时候发现判断是否遍历完一遍的时候使用的方法</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">index = (index+<span class="hljs-number">1</span>) &amp; weak_table-&gt;mask;<br></code></pre></td></tr></table></figure>

<p>假设当前数组长度8，下标分别是0-7，上面<code>weak_table-&gt;mask</code>= 7 = 0111。</p>
<table>
<thead>
<tr>
<th>下标</th>
<th>计算后结果</th>
</tr>
</thead>
<tbody><tr>
<td>index = 0</td>
<td>index &amp; mask = 0000 &amp; 0111 = 0000 = 0</td>
</tr>
<tr>
<td>index = 1</td>
<td>index &amp; mask = 0001 &amp; 0111 = 0001 = 1</td>
</tr>
<tr>
<td>index = 2</td>
<td>index &amp; mask = 0010 &amp; 0111 = 0010 = 2</td>
</tr>
<tr>
<td>index = 3</td>
<td>index &amp; mask = 0011 &amp; 0111 = 0011 = 3</td>
</tr>
<tr>
<td>index = 4</td>
<td>index &amp; mask = 0100 &amp; 0111 = 0100 = 4</td>
</tr>
<tr>
<td>index = 5</td>
<td>index &amp; mask = 0101 &amp; 0111 = 0101 = 5</td>
</tr>
<tr>
<td>index = 6</td>
<td>index &amp; mask = 0110 &amp; 0111 = 0110 = 6</td>
</tr>
<tr>
<td>index = 7</td>
<td>index &amp; mask = 0111 &amp; 0111 = 0111 = 7</td>
</tr>
<tr>
<td>index = 8</td>
<td>index &amp; mask = 1000 &amp; 0111 = 0000 = 0</td>
</tr>
</tbody></table>
<p>看完上面的计算相信大家都明白了这么做的真是意图了：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">if</span> (index == begin)<br></code></pre></td></tr></table></figure>
<p>可以理解为：数组遍历完成，已经和数组中所有的元素做了对比。</p>
<p>随着某个对象被越来越多的对象弱引用，那么这个存放弱引用该对象的所有对象的数组也会越来越大。</p>
<h4 id="hash表自动扩容"><a href="#hash表自动扩容" class="headerlink" title="hash表自动扩容"></a>hash表自动扩容</h4><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">//weak_table_t扩容</span><br><span class="hljs-comment">// 参数 weak_table 要扩容的table new_size 目标大小</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> weak_resize(weak_table_t *weak_table, size_t new_size)<br>&#123;<br>    <span class="hljs-comment">//weak_table的容量</span><br>    size_t old_size = TABLE_SIZE(weak_table);<br><br>    <span class="hljs-comment">// 取出weak_table中存放的所有实体</span><br>    weak_entry_t *old_entries = weak_table-&gt;weak_entries;<br>    <span class="hljs-comment">// 新创建一个weak_entry_t类型的数组</span><br>    <span class="hljs-comment">// 数组的大小是new_size * sizeof(weak_entry_t)</span><br>    weak_entry_t *new_entries = (weak_entry_t *)<br>        calloc(new_size, <span class="hljs-keyword">sizeof</span>(weak_entry_t));<br><br>    <span class="hljs-comment">// 重置weak_table的mask的值</span><br>    weak_table-&gt;mask = new_size - <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 将weak_table-&gt;weak_entries指向新创建的内存区域 注意 此时weak_table中没有任何数据</span><br>    weak_table-&gt;weak_entries = new_entries;<br>    <span class="hljs-comment">// 最大哈希偏移值重置为0</span><br>    weak_table-&gt;max_hash_displacement = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//weak_table 中存储实体个数为0</span><br>    weak_table-&gt;num_entries = <span class="hljs-number">0</span>;  <span class="hljs-comment">// restored by weak_entry_insert below</span><br><br>    <span class="hljs-comment">// 旧数据的搬迁</span><br>    <span class="hljs-keyword">if</span> (old_entries) &#123;<br>        weak_entry_t *entry;<br>        <span class="hljs-comment">//old_entries看做数组中第一个元素的地址 由于数组是连续的存储空间 那么old_entries + old_size = 数组最后一个元素的地址</span><br>        weak_entry_t *end = old_entries + old_size;<br>        <span class="hljs-comment">// 遍历这些旧数据</span><br>        <span class="hljs-keyword">for</span> (entry = old_entries; entry &lt; end; entry++) &#123;<br>            <span class="hljs-comment">//weak_entry_t的referent(referent是指被弱引用的对象)</span><br>            <span class="hljs-keyword">if</span> (entry-&gt;referent) &#123;<br>                <span class="hljs-comment">// 将旧数据搬移到新的结构中</span><br>                weak_entry_insert(weak_table, entry);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 释放所有的旧数据</span><br>        free(old_entries);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>从上面的代码中我们可以看到，哈希表的扩容主要分为下面几个步骤:</p>
<ul>
<li>创建一个局部变量保存当前哈希表中保存的所有弱引用实体</li>
<li>新建一个容量是旧哈希表大小2倍的哈希表，同时重置<code>num_entries</code>、<code>max_hash_displacement</code>、<code>weak_entries</code>、<code>mask</code></li>
<li>遍历之前保存的旧的数据 将数据按照顺序依次重新插入的新建的哈希表中</li>
<li>释放旧数据</li>
</ul>
<p>我们看到将旧数据插入新数据的主要方法是<code>weak_entry_insert</code>，下面我们来仔细介绍下它：</p>
<h4 id="weak-entry-insert"><a href="#weak-entry-insert" class="headerlink" title="weak_entry_insert"></a>weak_entry_insert</h4><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">// 向指定的weak_table_t中插入某个对象</span><br><span class="hljs-comment">// weak_table_t 目标 table</span><br><span class="hljs-comment">// new_entry 被弱引用的对象</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> weak_entry_insert(weak_table_t *weak_table, weak_entry_t *new_entry)<br>&#123;<br>    <span class="hljs-comment">// 取出weak_table中所有弱引用的对象</span><br>    weak_entry_t *weak_entries = weak_table-&gt;weak_entries;<br>    assert(weak_entries != <span class="hljs-literal">nil</span>);<br><br>    <span class="hljs-comment">// 根据new_entry中被弱引用对象地址通过哈希算法 算出 弱引用new_entry-&gt;referent的对象存放的index</span><br>    size_t begin = hash_pointer(new_entry-&gt;referent) &amp; (weak_table-&gt;mask);<br>    size_t index = begin;<br>    size_t hash_displacement = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// weak_entries[index].referent 如果不为空 表示已经有</span><br>    <span class="hljs-keyword">while</span> (weak_entries[index].referent != <span class="hljs-literal">nil</span>) &#123;<br>        <span class="hljs-comment">// 计算下一个要遍历的index</span><br>        index = (index+<span class="hljs-number">1</span>) &amp; weak_table-&gt;mask;<br>        <span class="hljs-comment">// 遍历了所有元素发现weak_entries[index].referent 都不为nil</span><br>        <span class="hljs-keyword">if</span> (index == begin)<br>            <span class="hljs-comment">// 直接报错</span><br>            bad_weak_table(weak_entries);<br>        <span class="hljs-comment">// 哈希冲突次数++</span><br>        hash_displacement++;<br>    &#125;<br><br>    <span class="hljs-comment">// 如果走到这里 表明index位置的元素referent=nil</span><br>    <span class="hljs-comment">// 直接插入</span><br>    weak_entries[index] = *new_entry;<br>    <span class="hljs-comment">// 实体个数++</span><br>    weak_table-&gt;num_entries++;<br><br>    <span class="hljs-comment">// 最大哈希偏移值大于之前的记录</span><br>    <span class="hljs-keyword">if</span> (hash_displacement &gt; weak_table-&gt;max_hash_displacement) &#123;<br>        <span class="hljs-comment">// 更新最大哈希偏移值</span><br>        weak_table-&gt;max_hash_displacement = hash_displacement;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>插入操作也很简单，主要分为下面几个步骤:</p>
<ul>
<li>取出哈希表中所有弱引用对象的数据</li>
<li>遍历第一步取出的所有数据，找到第一个空位置</li>
<li>将要插入的实体插入到这个位置，同时更新当前<code>weak_table</code>中弱引用实体个数</li>
<li>重置<code>weak_table</code>中最大哈希冲突次数的值</li>
</ul>
<p>插入的主要逻辑实际上并不复杂，但是我们发现最后一步</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">// 如果本次哈希偏移值大于之前记录的最大偏移值 则更新 </span><br><span class="hljs-keyword">if</span> (hash_displacement &gt; weak_table-&gt;max_hash_displacement) &#123;<br>    <span class="hljs-comment">// 修改最大哈希偏移值</span><br>    weak_table-&gt;max_hash_displacement = hash_displacement;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>通过上面的代码我们发现，假设<code>weak_table</code>的<code>weak_entries</code>最大容量为8,当前存放了3个被弱引用的对象且分别存放在下标为[0,1,2]中，同时要插入的对象<code>new_entry</code>不再<code>weak_entries</code>中，那么经过while循环，<code>hash_displacement = 3</code>。实际上如果在没有哈希冲突的情况下我们通过<code>hash_pointer</code>得到的index就应该是用来存放<code>new_entry</code>的，但是因为存在哈希冲突，所以后移了3位后才找到合适的位置来存放<code>new_entry</code>，因此<code>hash_displacement</code>也被理解为，本应存放的位置距离实际存放位置的差值。</p>
<p>综上，我们分析了哈希表中获取所有弱引用某个对象的对象数组，哈希表扩容方法，以及如何在哈希表中插入一个弱引用对象。</p>
<p>下面我们来看下新增和释放弱引用对象的方法</p>
<h4 id="objc-initWeak"><a href="#objc-initWeak" class="headerlink" title="objc_initWeak"></a>objc_initWeak</h4><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">// 初始化一个weak 弱引用</span><br><span class="hljs-comment">// 参数location weak指针的地址  newObj weak指针指向的对象</span><br><span class="hljs-keyword">id</span><br>objc_initWeak(<span class="hljs-keyword">id</span> *location, <span class="hljs-keyword">id</span> newObj)<br>&#123;<br>    <span class="hljs-comment">// 如果弱引用对象为空</span><br>    <span class="hljs-keyword">if</span> (!newObj) &#123;<br>        *location = <span class="hljs-literal">nil</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>;<br>    &#125;<br>    <span class="hljs-comment">// 调用storeWeak</span><br>    <span class="hljs-keyword">return</span> storeWeak&lt;DontHaveOld, DoHaveNew, DoCrashIfDeallocating&gt;<br>        (location, (objc_object*)newObj);<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><p>id *location ：__weak指针的地址，即weak指针取地址： &amp;weakObj 。它是一个指针的地址。之所以要存储指针的地址，是因为最后我们要讲__weak指针指向的内容置为nil，如果仅存储指针的话，是不能够完成这个功能的。</p>
</li>
<li><p>id newObj ：所引用的对象。即例子中的obj 。</p>
</li>
</ul>
<p>从上面我们看出<code>objc_initWeak</code>实际上是调用了<code>storeWeak</code>方法，且方法调用我们可以翻译为</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">storeWeak&lt;<span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>, <span class="hljs-literal">true</span>&gt;<br>        (location, (objc_object*)newObj)<br></code></pre></td></tr></table></figure>

<h4 id="storeWeak"><a href="#storeWeak" class="headerlink" title="storeWeak"></a>storeWeak</h4><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">enum</span> CrashIfDeallocating &#123;<br>    DontCrashIfDeallocating = <span class="hljs-literal">false</span>, DoCrashIfDeallocating = <span class="hljs-literal">true</span><br>&#125;;<br>template &lt;HaveOld haveOld, HaveNew haveNew,<br>          CrashIfDeallocating crashIfDeallocating&gt;<br><span class="hljs-comment">// HaveOld= true weak ptr之前是否已经指向了一个弱引用</span><br><span class="hljs-comment">// haveNew = true weak ptr是否需要指向一个新引用</span><br><span class="hljs-comment">// crashIfDeallocating = true 如果被弱引用的对象正在析构，此时再弱引用该对象，是否应该crash</span><br><span class="hljs-comment">// crashIfDeallocating = false 将存储的数据置为nil</span><br><span class="hljs-comment">// *location 代表weak 指针的地址</span><br><span class="hljs-comment">// newObj 被weak引用的对象。</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">id</span> <br>storeWeak(<span class="hljs-keyword">id</span> *location, objc_object *newObj)<br>&#123;<br>    assert(haveOld  ||  haveNew);<br>    <span class="hljs-comment">// 如果没有新值赋值 判断newObj 是否为空 否则断言</span><br>    <span class="hljs-keyword">if</span> (!haveNew)<br>        assert(newObj == <span class="hljs-literal">nil</span>);<br><br>    Class previouslyInitializedClass = <span class="hljs-literal">nil</span>;<br>    <span class="hljs-keyword">id</span> oldObj;<br><br>    SideTable *oldTable;<br>    SideTable *newTable;<br><br><br> retry:<br>    <span class="hljs-comment">// 如果weak ptr之前弱引用过一个obj，则将这个obj所对应的SideTable取出，赋值给oldTable</span><br>    <span class="hljs-keyword">if</span> (haveOld) &#123;<br>        <span class="hljs-comment">// 根据传入的地址获取到旧的值</span><br>        oldObj = *location;<br>        <span class="hljs-comment">// 根据旧值的地址获取到旧值所存在的SideTable</span><br>        oldTable = &amp;SideTables()[oldObj];<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 如果weak ptr之前没有弱引用过一个obj，则oldTable = nil</span><br>        oldTable = <span class="hljs-literal">nil</span>;<br>    &#125;<br>    <span class="hljs-comment">// 是否有新值 如果有</span><br>    <span class="hljs-keyword">if</span> (haveNew) &#123;<br>        <span class="hljs-comment">// 如果weak ptr要weak引用一个新的obj，则将该obj对应的SideTable取出，赋值给newTable</span><br>        newTable = &amp;SideTables()[newObj];<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 如果weak ptr不需要引用一个新obj，则newTable = nil</span><br>        newTable = <span class="hljs-literal">nil</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 加锁管理一对 side tables，防止多线程中竞争冲突</span><br>    SideTable::lockTwo&lt;haveOld, haveNew&gt;(oldTable, newTable);<br><br>    <span class="hljs-comment">// location 应该与 oldObj 保持一致，如果不同，说明当前的 location 已经处理过 oldObj 可是又被其他线程所修改</span><br>    <span class="hljs-keyword">if</span> (haveOld  &amp;&amp;  *location != oldObj) &#123;<br>        <span class="hljs-comment">// 解锁后重试</span><br>        SideTable::unlockTwo&lt;haveOld, haveNew&gt;(oldTable, newTable);<br>        <span class="hljs-keyword">goto</span> retry;<br>    &#125;<br><br>    <span class="hljs-comment">// 保证弱引用对象的 isa 都被初始化，防止弱引用和 +initialize 之间发生死锁，</span><br>    <span class="hljs-comment">// 也就是避免 +initialize 中调用了 storeWeak 方法，而在 storeWeak 方法中 weak_register_no_lock</span><br>    <span class="hljs-comment">// 方法中用到对象的 isa 还没有初始化完成的情况</span><br>    <span class="hljs-keyword">if</span> (haveNew  &amp;&amp;  newObj) &#123;<br>        Class cls = newObj-&gt;getIsa();<br>        <span class="hljs-comment">// 如果cls还没有初始化，先初始化，再尝试设置weak</span><br>        <span class="hljs-keyword">if</span> (cls != previouslyInitializedClass  &amp;&amp;  <br>            !((objc_class *)cls)-&gt;isInitialized()) <br>        &#123;<br>            SideTable::unlockTwo&lt;haveOld, haveNew&gt;(oldTable, newTable);<br>            <span class="hljs-comment">// 发送 +initialize 消息到未初始化的类</span><br>            _class_initialize(_class_getNonMetaClass(cls, (<span class="hljs-keyword">id</span>)newObj));<br><br>            <span class="hljs-comment">// 如果该类还没有初始化完成，例如在 +initialize 中调用了 storeWeak 方法，</span><br>            <span class="hljs-comment">// 也就是会进入这里面，进而设置  previouslyInitializedClass  以在重试时识别它</span><br>            <span class="hljs-comment">// 这里记录一下previouslyInitializedClass， 防止改if分支再次进入</span><br>            previouslyInitializedClass = cls;<br>            <span class="hljs-comment">// 重新获取一遍newObj，这时的newObj应该已经初始化过了</span><br>            <span class="hljs-keyword">goto</span> retry;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 如果weak_ptr之前弱引用过别的对象oldObj，则调用weak_unregister_no_lock，在oldObj的weak_entry_t中移除该weak_ptr地址</span><br>    <span class="hljs-keyword">if</span> (haveOld) &#123;<br>        weak_unregister_no_lock(&amp;oldTable-&gt;weak_table, oldObj, location);<br>    &#125;<br><br>    <span class="hljs-comment">// 如果weak_ptr需要弱引用新的对象newObj</span><br>    <span class="hljs-keyword">if</span> (haveNew) &#123;<br>        <span class="hljs-comment">// (1) 调用weak_register_no_lock方法，将weak ptr的地址记录到newObj对应的weak_entry_t中</span><br>        newObj = (objc_object *)<br>            weak_register_no_lock(&amp;newTable-&gt;weak_table, (<span class="hljs-keyword">id</span>)newObj, location, <br>                                  crashIfDeallocating);<br><br>        <span class="hljs-comment">// (2) 更新newObj的isa的weakly_referenced bit标志位</span><br>        <span class="hljs-keyword">if</span> (newObj  &amp;&amp;  !newObj-&gt;isTaggedPointer()) &#123;<br>            newObj-&gt;setWeaklyReferenced_nolock();<br>        &#125;<br><br>        <span class="hljs-comment">// （3）*location 赋值，也就是将weak ptr直接指向了newObj。可以看到，这里并没有将newObj的引用计数+1</span><br>        <span class="hljs-comment">// 将weak ptr指向object</span><br>        *location = (<span class="hljs-keyword">id</span>)newObj;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// No new value. The storage is not changed.</span><br>    &#125;<br>    <span class="hljs-comment">// 解锁，其他线程可以访问oldTable, newTable了</span><br>    SideTable::unlockTwo&lt;haveOld, haveNew&gt;(oldTable, newTable);<br>    <span class="hljs-comment">// 返回newObj，此时的newObj与刚传入时相比，weakly-referenced bit位置1</span><br>    <span class="hljs-keyword">return</span> (<span class="hljs-keyword">id</span>)newObj;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>storeWeak方法有点长，这也是weak引用的核心实现部分。其实核心也就实现了两个功能：</p>
<p>将weak指针的地址<code>location</code>存入到obj对应的weak_entry_t的数组（链表）中，用于在obj析构时，通过该数组（链表）找到所有其weak指针引用，并将指针指向的地址（<code>location</code>）置为nil。</p>
<p>如果启用了isa优化，则将obj的isa_t的<code>weakly_referenced</code>位置1。置位1的作用主要是为了标记obj被weak引用了，当dealloc时，runtime会根据<code>weakly_referenced</code>标志位来判断是否需要查找obj对应的weak_entry_t，并将引用置为nil。</p>
<p>上面的方法中，我们看到插入新值的方法为<code>weak_register_no_lock</code>,清除旧值的方法为<code>weak_unregister_no_lock</code>,下面我们来看下这两个方法：</p>
<h4 id="weak-register-no-lock"><a href="#weak-register-no-lock" class="headerlink" title="weak_register_no_lock"></a>weak_register_no_lock</h4><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">/ 添加对某个对象的新的弱引用指针<br><span class="hljs-comment">// weak_table 目标被弱引用对象所存储的表</span><br><span class="hljs-comment">// referent_id 被所引用的对象</span><br><span class="hljs-comment">// referrer_id 要被添加的弱引用指针</span><br><span class="hljs-comment">// crashIfDeallocating 如果对象正在被释放时是否崩溃</span><br><span class="hljs-keyword">id</span> <br>weak_register_no_lock(weak_table_t *weak_table, <span class="hljs-keyword">id</span> referent_id, <br>                      <span class="hljs-keyword">id</span> *referrer_id, <span class="hljs-keyword">bool</span> crashIfDeallocating)<br>&#123;<br>    <span class="hljs-comment">// 被弱引用的对象</span><br>    objc_object *referent = (objc_object *)referent_id;<br>    <span class="hljs-comment">// 要添加的指向弱引用指针的对象</span><br>    objc_object **referrer = (objc_object **)referrer_id;<br><br>    <span class="hljs-comment">// 如果referent为nil 或 referent 采用了TaggedPointer计数方式，直接返回，不做任何操作</span><br>    <span class="hljs-keyword">if</span> (!referent  ||  referent-&gt;isTaggedPointer()) <span class="hljs-keyword">return</span> referent_id;<br><br>    <span class="hljs-comment">// 确保被引用的对象可用（没有在析构，同时应该支持weak引用）</span><br>    <span class="hljs-keyword">bool</span> deallocating;<br>    <span class="hljs-comment">// referent 是否有自定义的释放方法</span><br>    <span class="hljs-keyword">if</span> (!referent-&gt;ISA()-&gt;hasCustomRR()) &#123;<br>        deallocating = referent-&gt;rootIsDeallocating();<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// referent是否支持weak引用</span><br>        <span class="hljs-built_in">BOOL</span> (*allowsWeakReference)(objc_object *, SEL) = <br>            (<span class="hljs-built_in">BOOL</span>(*)(objc_object *, SEL))<br>            object_getMethodImplementation((<span class="hljs-keyword">id</span>)referent, <br>                                           SEL_allowsWeakReference);<br>        <span class="hljs-comment">// 如果referent不能够被weak引用，则直接返回nil</span><br>        <span class="hljs-keyword">if</span> ((IMP)allowsWeakReference == _objc_msgForward) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>;<br>        &#125;<br>        <span class="hljs-comment">// 调用referent的SEL_allowsWeakReference方法来判断是否正在被释放</span><br>        deallocating =<br>            ! (*allowsWeakReference)(referent, SEL_allowsWeakReference);<br>    &#125;<br><br>    <span class="hljs-comment">// 正在析构的对象，不能够被弱引用</span><br>    <span class="hljs-keyword">if</span> (deallocating) &#123;<br>        <span class="hljs-comment">// 判断是否需要崩溃 如果需要则崩溃</span><br>        <span class="hljs-keyword">if</span> (crashIfDeallocating) &#123;<br>            _objc_fatal(<span class="hljs-string">&quot;Cannot form weak reference to instance (%p) of &quot;</span><br>                        <span class="hljs-string">&quot;class %s. It is possible that this object was &quot;</span><br>                        <span class="hljs-string">&quot;over-released, or is in the process of deallocation.&quot;</span>,<br>                        (<span class="hljs-keyword">void</span>*)referent, object_getClassName((<span class="hljs-keyword">id</span>)referent));<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 对象没有被正在释放</span><br>    weak_entry_t *entry;<br>    <span class="hljs-comment">// 在 weak_table中找到referent对应的weak_entry,并将referrer加入到weak_entry中</span><br>    <span class="hljs-comment">// 如果能找到weak_entry,则讲referrer插入到weak_entry中</span><br>    <span class="hljs-keyword">if</span> ((entry = weak_entry_for_referent(weak_table, referent))) &#123;<br>        <span class="hljs-comment">// 将referrer插入到weak_entry_t的引用数组中</span><br>        append_referrer(entry, referrer);<br>    &#125; <br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 创建一个新的weak_entry_t ，并将referrer插入到weak_entry_t的引用数组中</span><br>        weak_entry_t new_entry(referent, referrer);<br>        <span class="hljs-comment">// weak_table的weak_entry_t 数组是否需要动态增长，若需要，则会扩容一倍</span><br>        weak_grow_maybe(weak_table);<br>        <span class="hljs-comment">// 将weak_entry_t插入到weak_table中</span><br>        weak_entry_insert(weak_table, &amp;new_entry);<br>    &#125;<br><br>    <span class="hljs-comment">// Do not set *referrer. objc_storeWeak() requires that the </span><br>    <span class="hljs-comment">// value not change.</span><br><br>    <span class="hljs-keyword">return</span> referent_id;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面方法主要功能是：添加对某个对象的新的弱引用指针</p>
<ul>
<li>过滤掉<code>isTaggedPointer</code>和弱引用对象正在被释放这两种情况后(这里需要判断是否有自定义的释放方法)，然后根据<code>crashIfDeallocating</code>参数确定是崩溃还是返回nil</li>
<li>如果对象没有正在被释放，那么从<code>weak_table</code>中取出指向<code>referent</code>的弱引用指针实体，如果<code>weak_table</code>中存在指向<code>referent</code>的指针数组那么在这个数组中添加要新增的指针</li>
<li>如果<code>weak_table</code>没有找到指向<code>referent</code>的弱指针数组，那么新建一个<code>weak_entry_t</code>对象，将这个对象拆入到<code>weak_table</code>中(需要判断weak_table是否需要扩容)</li>
</ul>
<p>下面我们来看下具体的插入方法：</p>
<h4 id="append-referrer追加"><a href="#append-referrer追加" class="headerlink" title="append_referrer追加"></a>append_referrer追加</h4><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">// 在entry对象的弱引用数组中追加一个新的弱引用指针new_referrer</span><br><span class="hljs-comment">// entry 被弱引用的对象</span><br><span class="hljs-comment">// new_referrer 弱引用entry的指针</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> append_referrer(weak_entry_t *entry, objc_object **new_referrer)<br>&#123;<br>    <span class="hljs-comment">// 如果entry中弱引用指针没有超过了4个 表示弱引用指针存放在inline_referrers中</span><br>    <span class="hljs-comment">// weak_entry 尚未使用动态数组</span><br>    <span class="hljs-keyword">if</span> (! entry-&gt;out_of_line()) &#123;<br>        <span class="hljs-comment">// 遍历inline_referrers数组找到第一个为空的位置 将目标指针插入 尾部追加</span><br>        <span class="hljs-keyword">for</span> (size_t i = <span class="hljs-number">0</span>; i &lt; WEAK_INLINE_COUNT; i++) &#123;<br>            <span class="hljs-keyword">if</span> (entry-&gt;inline_referrers[i] == <span class="hljs-literal">nil</span>) &#123;<br>                entry-&gt;inline_referrers[i] = new_referrer;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 如果entry中弱引用指针==4个</span><br>        <span class="hljs-comment">// 新创建一个weak_referrer_t数组 大小为4(WEAK_INLINE_COUNT)</span><br>        <span class="hljs-comment">// 如果inline_referrers的位置已经存满了，则要转型为referrers，做动态数组。</span><br>        weak_referrer_t *new_referrers = (weak_referrer_t *)<br>            calloc(WEAK_INLINE_COUNT, <span class="hljs-keyword">sizeof</span>(weak_referrer_t));<br>        <span class="hljs-comment">// 遍历inline_referrers 将数据放在新创建的临时数组中</span><br>        <span class="hljs-keyword">for</span> (size_t i = <span class="hljs-number">0</span>; i &lt; WEAK_INLINE_COUNT; i++) &#123;<br>            new_referrers[i] = entry-&gt;inline_referrers[i];<br>        &#125;<br>        <span class="hljs-comment">// 弱引用指针的存储改为存放到entry-&gt;referrers(entry-&gt;inline_referrers -&gt; entry-&gt;referrers)</span><br>        entry-&gt;referrers = new_referrers;<br>        <span class="hljs-comment">// 更新弱引用个数</span><br>        entry-&gt;num_refs = WEAK_INLINE_COUNT;<br>        <span class="hljs-comment">//更新是否使用动态数组标记位</span><br>        entry-&gt;out_of_line_ness = REFERRERS_OUT_OF_LINE;<br>        <span class="hljs-comment">// 更新mask和最大哈希偏移值</span><br>        entry-&gt;mask = WEAK_INLINE_COUNT<span class="hljs-number">-1</span>;<br>        entry-&gt;max_hash_displacement = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    assert(entry-&gt;out_of_line());<br><br>    <span class="hljs-comment">// 如果只想entry的弱引用个数大于4</span><br>    <span class="hljs-comment">// 弱引用个数是否已超过数组容量的3/4</span><br>    <span class="hljs-keyword">if</span> (entry-&gt;num_refs &gt;= TABLE_SIZE(entry) * <span class="hljs-number">3</span>/<span class="hljs-number">4</span>) &#123;<br>        <span class="hljs-comment">// 如果已超过 那么先扩容在插入</span><br>        <span class="hljs-keyword">return</span> grow_refs_and_insert(entry, new_referrer);<br>    &#125;<br><br>    <span class="hljs-comment">// 如果不需要扩容，直接插入到weak_entry中</span><br>    <span class="hljs-comment">// 注意，weak_entry是一个哈希表，key：w_hash_pointer(new_referrer) value: new_referrer</span><br>    size_t begin = w_hash_pointer(new_referrer) &amp; (entry-&gt;mask);<br>    size_t index = begin;<br>    size_t hash_displacement = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 由低到高遍历entry-&gt;referrers 找到第一个空位置</span><br>    <span class="hljs-keyword">while</span> (entry-&gt;referrers[index] != <span class="hljs-literal">nil</span>) &#123;<br>        hash_displacement++;<br>        index = (index+<span class="hljs-number">1</span>) &amp; entry-&gt;mask;<br>        <span class="hljs-comment">// 如果遍历了所有元素后都没有找到 那么报错</span><br>        <span class="hljs-keyword">if</span> (index == begin)<br>            bad_weak_table(entry);<br>    &#125;<br>    <span class="hljs-comment">// 更新最大哈希偏移值</span><br>    <span class="hljs-keyword">if</span> (hash_displacement &gt; entry-&gt;max_hash_displacement) &#123;<br>        entry-&gt;max_hash_displacement = hash_displacement;<br>    &#125;<br>    <span class="hljs-comment">// 将new_referrer插入到数组的第index个位置</span><br>    weak_referrer_t &amp;ref = entry-&gt;referrers[index];<br>    ref = new_referrer;<br>    <span class="hljs-comment">// 弱引用计个数+1</span><br>    entry-&gt;num_refs++;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>插入的过程主要分下面三种情况:</p>
<ul>
<li>如果<code>inline_referrers</code>没有存储满，直接存储到<code>inline_referrers</code>中</li>
<li>如果<code>inline_referrers</code>个数是4个了，在插入，就需要将<code>inline_referrers</code>拷贝到<code>referrers</code>，然后进入第三步。</li>
<li>如果<code>inline_referrers</code>存储满了，判断是否需要扩容，然后将数据存储到<code>referrers</code>中。</li>
</ul>
<p>下面我们来看下扩容的方法:</p>
<h4 id="grow-refs-and-insert"><a href="#grow-refs-and-insert" class="headerlink" title="grow_refs_and_insert"></a>grow_refs_and_insert</h4><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">// entry 中存放弱引用指针数组 扩容</span><br><span class="hljs-comment">// weak_entry_t 要扩容的对象</span><br><span class="hljs-comment">// new_referrer 要插入的指向entry-&gt;referent弱引用指针</span><br>__attribute__((noinline, used))<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> grow_refs_and_insert(weak_entry_t *entry, <br>                                 objc_object **new_referrer)<br>&#123;<br>    assert(entry-&gt;out_of_line());<br>    <span class="hljs-comment">// 获取entry当前的大小</span><br>    size_t old_size = TABLE_SIZE(entry);<br>    <span class="hljs-comment">// 新的大小为旧的大小的2倍</span><br>    size_t new_size = old_size ? old_size * <span class="hljs-number">2</span> : <span class="hljs-number">8</span>;<br><br>    <span class="hljs-comment">// 获取weak_entry_t中存储的弱引用指针个数</span><br>    size_t num_refs = entry-&gt;num_refs;<br>    <span class="hljs-comment">//获取entry中旧的引用数组</span><br>    weak_referrer_t *old_refs = entry-&gt;referrers;<br>    <span class="hljs-comment">// 更新entry-&gt;mask 这里是为了后续申请内存空间使用</span><br>    entry-&gt;mask = new_size - <span class="hljs-number">1</span>;<br><br>    <span class="hljs-comment">// 创建一个新的entry-&gt;referrers数组</span><br>    <span class="hljs-comment">// #define TABLE_SIZE(entry) (entry-&gt;mask ? entry-&gt;mask + 1 : 0)</span><br>    <span class="hljs-comment">// TABLE_SIZE 获取的数组大小是 mask+1 = new_size</span><br>    entry-&gt;referrers = (weak_referrer_t *)<br>        calloc(TABLE_SIZE(entry), <span class="hljs-keyword">sizeof</span>(weak_referrer_t));<br>    <span class="hljs-comment">// 重置num_refs和max_hash_displacement</span><br>    entry-&gt;num_refs = <span class="hljs-number">0</span>;<br>    entry-&gt;max_hash_displacement = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// 将old_refs中的数据重新插入到新创建entry-&gt;referrers中</span><br>    <span class="hljs-keyword">for</span> (size_t i = <span class="hljs-number">0</span>; i &lt; old_size &amp;&amp; num_refs &gt; <span class="hljs-number">0</span>; i++) &#123;<br>        <span class="hljs-keyword">if</span> (old_refs[i] != <span class="hljs-literal">nil</span>) &#123;<br>            append_referrer(entry, old_refs[i]);<br>            num_refs--;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 将new_referrer插入到扩容后的entry中</span><br>    append_referrer(entry, new_referrer);<br>    <span class="hljs-keyword">if</span> (old_refs) free(old_refs);<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>看完了新增弱引用指针的操作，接下来我们看下如何删除弱引用指针即<code>weak_unregister_no_lock</code></p>
<h4 id="weak-unregister-no-lock"><a href="#weak-unregister-no-lock" class="headerlink" title="weak_unregister_no_lock"></a>weak_unregister_no_lock</h4><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">// 将 weak ptr地址 从obj的weak_entry_t中移除</span><br><span class="hljs-comment">// 参数weak_table 全局弱引用表</span><br><span class="hljs-comment">// referent_id 弱引用所指向的对象</span><br><span class="hljs-comment">// referrer_id 弱引用指针地址</span><br><span class="hljs-keyword">void</span><br>weak_unregister_no_lock(weak_table_t *weak_table, <span class="hljs-keyword">id</span> referent_id, <br>                        <span class="hljs-keyword">id</span> *referrer_id)<br>&#123;<br>    <span class="hljs-comment">// 被弱引用的对象</span><br>    objc_object *referent = (objc_object *)referent_id;<br>    <span class="hljs-comment">// 指向被弱引用对象的指针的地址</span><br>    objc_object **referrer = (objc_object **)referrer_id;<br><br>    weak_entry_t *entry;<br><br>    <span class="hljs-keyword">if</span> (!referent) <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-comment">// 找到weak_table中指向被弱引用对象的所有指针 类型为 weak_entry_t</span><br>    <span class="hljs-keyword">if</span> ((entry = weak_entry_for_referent(weak_table, referent))) &#123;<br>        <span class="hljs-comment">// 从数组中删除当前这个弱引用指针</span><br>        remove_referrer(entry, referrer);<br>        <span class="hljs-keyword">bool</span> empty = <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">// 弱引用referent对象的弱引用指针是否为空</span><br>        <span class="hljs-keyword">if</span> (entry-&gt;out_of_line()  &amp;&amp;  entry-&gt;num_refs != <span class="hljs-number">0</span>) &#123;<br>            empty = <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 如果referrer数组中为空 那么判断inline_referrers中是否为空 如果为空empty=true</span><br>            <span class="hljs-keyword">for</span> (size_t i = <span class="hljs-number">0</span>; i &lt; WEAK_INLINE_COUNT; i++) &#123;<br>                <span class="hljs-keyword">if</span> (entry-&gt;inline_referrers[i]) &#123;<br>                    empty = <span class="hljs-literal">false</span>; <br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 如果为空 则证明没有其他指针指向这个被所引用的对象</span><br>        <span class="hljs-keyword">if</span> (empty) &#123;<br>            <span class="hljs-comment">// 将这个实体从weak_table中移除</span><br>            weak_entry_remove(weak_table, entry);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// Do not set *referrer = nil. objc_storeWeak() requires that the </span><br>    <span class="hljs-comment">// value not change.</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>weak_unregister_no_lock</code>的实现逻辑比较简单,其实主要的操作为:</p>
<ul>
<li>首先，它会在<code>weak_table</code>中找出<code>referent</code>对应的<code>weak_entry_t</code></li>
<li>在<code>weak_entry_t</code>中移除<code>referrer</code></li>
<li>移除元素后，判断此时<code>weak_entry_t</code>中是否还有元素 <code>（empty==true？）</code></li>
<li>如果此时<code>weak_entry_t</code>已经没有元素了，则需要将<code>weak_entry_t从weak_table</code>中移除</li>
</ul>
<p>而对于<code>remove_referrer</code>方法，我们来简单的看下他的实现:</p>
<h4 id="remove-referrer"><a href="#remove-referrer" class="headerlink" title="remove_referrer"></a>remove_referrer</h4><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">// 删除old_referrer集合中的referrers</span><br><span class="hljs-comment">// 参数 entry 被弱引用对象</span><br><span class="hljs-comment">// 参数 old_referrer 要删除的弱引用指针</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> remove_referrer(weak_entry_t *entry, objc_object **old_referrer)<br>&#123;<br>    <span class="hljs-comment">// 指向entry的弱引用指针不超过4个</span><br>    <span class="hljs-keyword">if</span> (! entry-&gt;out_of_line()) &#123;<br>        <span class="hljs-keyword">for</span> (size_t i = <span class="hljs-number">0</span>; i &lt; WEAK_INLINE_COUNT; i++) &#123;<br>            <span class="hljs-comment">// 遍历inline_referrers数组如果找到直接置空</span><br>            <span class="hljs-keyword">if</span> (entry-&gt;inline_referrers[i] == old_referrer) &#123;<br>                entry-&gt;inline_referrers[i] = <span class="hljs-literal">nil</span>;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 如果没有找到 则报错 弱引用指针小于4个且在inline_referrers中没有找到</span><br>        _objc_inform(<span class="hljs-string">&quot;Attempted to unregister unknown __weak variable &quot;</span><br>                     <span class="hljs-string">&quot;at %p. This is probably incorrect use of &quot;</span><br>                     <span class="hljs-string">&quot;objc_storeWeak() and objc_loadWeak(). &quot;</span><br>                     <span class="hljs-string">&quot;Break on objc_weak_error to debug.\n&quot;</span>, <br>                     old_referrer);<br>        objc_weak_error();<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 哈希函数 判断这个旧的弱引用指针存放的位置</span><br>    size_t begin = w_hash_pointer(old_referrer) &amp; (entry-&gt;mask);<br>    size_t index = begin;<br>    size_t hash_displacement = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 遍历entry-&gt;referrers数组查找old_referrer</span><br>    <span class="hljs-keyword">while</span> (entry-&gt;referrers[index] != old_referrer) &#123;<br>        <span class="hljs-comment">// 如果没有在指定index找到 那么取下一个位置的值比较</span><br>        index = (index+<span class="hljs-number">1</span>) &amp; entry-&gt;mask;<br>        <span class="hljs-comment">// 如果找了一圈仍然没有找到 那么报错</span><br>        <span class="hljs-keyword">if</span> (index == begin)<br>            bad_weak_table(entry);<br>        <span class="hljs-comment">// 更新最大哈希偏移值</span><br>        hash_displacement++;<br>        <span class="hljs-comment">// 如果最大哈希偏移值 超过了预定的限制 那么报错</span><br>        <span class="hljs-keyword">if</span> (hash_displacement &gt; entry-&gt;max_hash_displacement) &#123;<br>            _objc_inform(<span class="hljs-string">&quot;Attempted to unregister unknown __weak variable &quot;</span><br>                         <span class="hljs-string">&quot;at %p. This is probably incorrect use of &quot;</span><br>                         <span class="hljs-string">&quot;objc_storeWeak() and objc_loadWeak(). &quot;</span><br>                         <span class="hljs-string">&quot;Break on objc_weak_error to debug.\n&quot;</span>, <br>                         old_referrer);<br>            objc_weak_error();<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 走到这一步说明在entry-&gt;referrers中的index位置找到了值为old_referrer的引用</span><br>    <span class="hljs-comment">// 将数组的这个位置置空</span><br>    entry-&gt;referrers[index] = <span class="hljs-literal">nil</span>;<br>    <span class="hljs-comment">// 弱引用个数-1</span><br>    entry-&gt;num_refs--;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面的描述也很简单，大概的流程为：</p>
<ul>
<li>在<code>entry-&gt;inline_referrers</code>中一次查找值为<code>old_referrer</code>的指针 如果找到就清空如果没找到报错</li>
<li>在<code>entry-&gt;referrers</code>中查找值为<code>old_referrer</code>的指针，如果找到则置空同时<code>entry-&gt;num_refs</code>做-1操作(使用<code>inline_referrers</code>存储时不会更新<code>num_refs</code>值因此移除也不用-1)</li>
</ul>
<p>我们在删除指向某个对象的某个弱引用指针之后，还会对存储指向该对象的弱引用指针数组做判空操作，如果发现数组为空，那表示目前没有弱引用指针指向这个对象，那我们需要将这个对象从<code>weak_table</code>中移除。下面我们来看下移除方法<code>weak_entry_remove</code>。</p>
<h4 id="weak-entry-remove"><a href="#weak-entry-remove" class="headerlink" title="weak_entry_remove"></a>weak_entry_remove</h4><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">//从weak_table中移除entry (指向entry的弱引用指针数为0)</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> weak_entry_remove(weak_table_t *weak_table, weak_entry_t *entry)<br>&#123;<br>    <span class="hljs-comment">// 如果弱引用指针超过4个(弱引用指针存放在entry-&gt;referrers中)</span><br>    <span class="hljs-keyword">if</span> (entry-&gt;out_of_line())<br>        <span class="hljs-comment">// 释放entry-&gt;referrers中所有数据</span><br>        free(entry-&gt;referrers);<br>    bzero(entry, <span class="hljs-keyword">sizeof</span>(*entry));<br>    <span class="hljs-comment">//num_entries-1</span><br>    weak_table-&gt;num_entries--;<br>    <span class="hljs-comment">//weak_table是否需要锁绒</span><br>    weak_compact_maybe(weak_table);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面方法的主要操作为:</p>
<ul>
<li>将没有弱引用的对象从全局的<code>weak_table</code>中移除</li>
<li>减少<code>weak_table</code>中存储的弱引用对象个数</li>
<li>判断<code>weak_table</code>是否需要缩小容量</li>
</ul>
<p>上面的所有就是当我们将一个obj作weak引用时，所发生的事情。那么，当obj释放时，所有weak引用它的指针又是如何自动设置为nil的呢？接下来我们来看一下obj释放时，所发生的事情。</p>
<h3 id="Dealloc"><a href="#Dealloc" class="headerlink" title="Dealloc"></a>Dealloc</h3><p>当对象引用计数为0时，runtime会调用_objc_rootDealloc方法来析构对象，实现如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">- (<span class="hljs-keyword">void</span>)dealloc &#123;<br>    _objc_rootDealloc(<span class="hljs-keyword">self</span>);<br>&#125;<br><br><span class="hljs-keyword">void</span><br>_objc_rootDealloc(<span class="hljs-keyword">id</span> obj)<br>&#123;<br>    assert(obj);<br><br>    obj-&gt;rootDealloc();<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>_objc_rootDealloc</code>又会调用objc_object的<code>rootDealloc</code>方法</p>
<h4 id="rootDealloc"><a href="#rootDealloc" class="headerlink" title="rootDealloc"></a>rootDealloc</h4><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span><br>objc_object::rootDealloc()<br>&#123;<br><span class="hljs-comment">//    判断object是否采用了Tagged Pointer计数，如果是，则不进行任何析构操作。</span><br>    <span class="hljs-keyword">if</span> (isTaggedPointer()) <span class="hljs-keyword">return</span>;  <span class="hljs-comment">// fixme necessary?</span><br><br>    <span class="hljs-comment">//接下来判断对象是否采用了优化的isa计数方式（isa.nonpointer）</span><br>    <span class="hljs-comment">// 对象没有被weak引用!isa.weakly_referenced</span><br>    <span class="hljs-comment">// 没有关联对象!isa.has_assoc</span><br>    <span class="hljs-comment">// 没有自定义的C++析构方法!isa.has_cxx_dtor</span><br>    <span class="hljs-comment">// 没有用到sideTable来做引用计数 !isa.has_sidetable_rc</span><br>    <span class="hljs-comment">// 如果满足条件 则可以快速释放</span><br>    <span class="hljs-keyword">if</span> (fastpath(isa.nonpointer  &amp;&amp;  <br>                 !isa.weakly_referenced  &amp;&amp;  <br>                 !isa.has_assoc  &amp;&amp;  <br>                 !isa.has_cxx_dtor  &amp;&amp;  <br>                 !isa.has_sidetable_rc))<br>    &#123;<br>        assert(!sidetable_present());<br>        free(<span class="hljs-keyword">this</span>);<br>    &#125; <br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 慢速释放</span><br>        object_dispose((<span class="hljs-keyword">id</span>)<span class="hljs-keyword">this</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>因此根据上面代码判断，如果obj被weak引用了，应该进入<code>object_dispose((id)this)</code>分支，下面我们来看下<code>object_dispose</code>方法：</p>
<h4 id="object-dispose"><a href="#object-dispose" class="headerlink" title="object_dispose"></a>object_dispose</h4><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">id</span> <br>object_dispose(<span class="hljs-keyword">id</span> obj)<br>&#123;<br>    <span class="hljs-keyword">if</span> (!obj) <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>;<br>    <span class="hljs-comment">// 析构obj</span><br>    objc_destructInstance(obj);<br>    <span class="hljs-comment">// 释放内存</span><br>    free(obj);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>析构obj主要是看<code>objc_destructInstance</code>方法，下面我们来看下这个方法的实现</p>
<h4 id="objc-destructInstance"><a href="#objc-destructInstance" class="headerlink" title="objc_destructInstance"></a>objc_destructInstance</h4><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">void</span> *objc_destructInstance(<span class="hljs-keyword">id</span> obj) <br>&#123;<br>    <span class="hljs-keyword">if</span> (obj) &#123;<br>        <span class="hljs-comment">// Read all of the flags at once for performance.</span><br>		<span class="hljs-comment">//c++析构函数</span><br>        <span class="hljs-keyword">bool</span> cxx = obj-&gt;hasCxxDtor();<br>		<span class="hljs-comment">//关联函数</span><br>        <span class="hljs-keyword">bool</span> assoc = obj-&gt;hasAssociatedObjects();<br><br>        <span class="hljs-comment">// 如果有c++析构函数 则调用c++析构函数.</span><br>        <span class="hljs-keyword">if</span> (cxx)<br>            object_cxxDestruct(obj);<br><br>        <span class="hljs-comment">// 如果有关联对象则移除关联对象</span><br>        <span class="hljs-keyword">if</span> (assoc)<br>            _object_remove_assocations(obj);<br>        <span class="hljs-comment">// 清理相关的引用</span><br>        obj-&gt;clearDeallocating();<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> obj;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>清理相关引用方法主要是在<code>clearDeallocating</code>中实现的，下面我们再来看下这个方法：</p>
<h4 id="clearDeallocating"><a href="#clearDeallocating" class="headerlink" title="clearDeallocating"></a>clearDeallocating</h4><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">//正在清除side table 和weakly referenced</span><br><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <br>objc_object::clearDeallocating()<br>&#123;<br>    <span class="hljs-comment">// obj是否采用了优化isa引用计数</span><br>    <span class="hljs-keyword">if</span> (slowpath(!isa.nonpointer)) &#123;<br>		<span class="hljs-comment">//没有采用优化isa引用计数 清理obj存储在sideTable中的引用计数等信息</span><br>        sidetable_clearDeallocating();<br>    &#125;<br>    <span class="hljs-comment">// 启用了isa优化，则判断是否使用了sideTable</span><br>    <span class="hljs-comment">// 使用的原因是因为做了weak引用（isa.weakly_referenced ） 或 使用了sideTable的辅助引用计数（isa.has_sidetable_rc）</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (slowpath(isa.weakly_referenced  ||  isa.has_sidetable_rc)) &#123;<br>        <span class="hljs-comment">// Slow path for non-pointer isa with weak refs and/or side table data.</span><br>		<span class="hljs-comment">//释放weak 和引用计数</span><br>        clearDeallocating_slow();<br>    &#125;<br><br>    assert(!sidetable_present());<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这里的清理方法有两个分别为<code>sidetable_clearDeallocating</code>和<code>clearDeallocating_slow</code>,</p>
<p>我们先来看下<code>clearDeallocating_slow</code>：</p>
<h4 id="clearDeallocating-slow"><a href="#clearDeallocating-slow" class="headerlink" title="clearDeallocating_slow"></a>clearDeallocating_slow</h4><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">NEVER_INLINE <span class="hljs-keyword">void</span><br>objc_object::clearDeallocating_slow()<br>&#123;<br>    assert(isa.nonpointer  &amp;&amp;  (isa.weakly_referenced || isa.has_sidetable_rc));<br><br>    <span class="hljs-comment">// 在全局的SideTables中，以this指针为key，找到对应的SideTable</span><br>    SideTable&amp; table = SideTables()[<span class="hljs-keyword">this</span>];<br>    table.lock();<br>    	<span class="hljs-comment">//// 如果obj被弱引用</span><br>    <span class="hljs-keyword">if</span> (isa.weakly_referenced) &#123;<br>		<span class="hljs-comment">//// 在SideTable的weak_table中对this进行清理工作</span><br>        weak_clear_no_lock(&amp;table.weak_table, (<span class="hljs-keyword">id</span>)<span class="hljs-keyword">this</span>);<br>    &#125;<br>	<span class="hljs-comment">// 如果采用了SideTable做引用计数</span><br>    <span class="hljs-keyword">if</span> (isa.has_sidetable_rc) &#123;<br>		<span class="hljs-comment">//在SideTable的引用计数中移除this</span><br>        table.refcnts.erase(<span class="hljs-keyword">this</span>);<br>    &#125;<br>    table.unlock();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这里调用了<code>weak_clear_no_lock</code>来做<code>weak_table</code>的清理工作，同时将所有weak引用该对象的ptr置为nil。</p>
<h4 id="weak-clear-no-lock"><a href="#weak-clear-no-lock" class="headerlink" title="weak_clear_no_lock"></a>weak_clear_no_lock</h4><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">//清理weak_table，同时将所有weak引用该对象的ptr置为nil</span><br><span class="hljs-keyword">void</span> <br>weak_clear_no_lock(weak_table_t *weak_table, <span class="hljs-keyword">id</span> referent_id) <br>&#123;<br>    objc_object *referent = (objc_object *)referent_id;<br><br>    <span class="hljs-comment">// 找到referent在weak_table中对应的weak_entry_t</span><br>    weak_entry_t *entry = weak_entry_for_referent(weak_table, referent);<br><br>    <span class="hljs-keyword">if</span> (entry == <span class="hljs-literal">nil</span>) &#123;<br>        <span class="hljs-comment">/// XXX shouldn&#x27;t happen, but does with mismatched CF/objc</span><br>        <span class="hljs-comment">//printf(&quot;XXX no entry for clear deallocating %p\n&quot;, referent);</span><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 找出weak引用referent的weak 指针地址数组以及数组长度</span><br>    weak_referrer_t *referrers;<br>    size_t count;<br>    <span class="hljs-comment">// 是否使用动态数组</span><br>    <span class="hljs-keyword">if</span> (entry-&gt;out_of_line()) &#123;<br>        referrers = entry-&gt;referrers;<br>        count = TABLE_SIZE(entry);<br>    &#125; <br>    <span class="hljs-keyword">else</span> &#123;<br>        referrers = entry-&gt;inline_referrers;<br>        count = WEAK_INLINE_COUNT;<br>    &#125;<br><br>    <span class="hljs-comment">// 遍历所有的所引用weak指针</span><br>    <span class="hljs-keyword">for</span> (size_t i = <span class="hljs-number">0</span>; i &lt; count; ++i) &#123;<br>        <span class="hljs-comment">// 取出每个weak ptr的地址</span><br>        objc_object **referrer = referrers[i];<br><br>        <span class="hljs-keyword">if</span> (referrer) &#123;<br>            <span class="hljs-comment">// 如果weak ptr确实weak引用了referent，则将weak ptr设置为nil，这也就是为什么weak 指针会自动设置为nil的原因</span><br>            <span class="hljs-keyword">if</span> (*referrer == referent) &#123;<br>                *referrer = <span class="hljs-literal">nil</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (*referrer) &#123;<br>                <span class="hljs-comment">// 如果所存储的weak ptr没有weak 引用referent，这可能是由于runtime代码的逻辑错误引起的，报错</span><br>                _objc_inform(<span class="hljs-string">&quot;__weak variable at %p holds %p instead of %p. &quot;</span><br>                             <span class="hljs-string">&quot;This is probably incorrect use of &quot;</span><br>                             <span class="hljs-string">&quot;objc_storeWeak() and objc_loadWeak(). &quot;</span><br>                             <span class="hljs-string">&quot;Break on objc_weak_error to debug.\n&quot;</span>, <br>                             referrer, (<span class="hljs-keyword">void</span>*)*referrer, (<span class="hljs-keyword">void</span>*)referent);<br>                objc_weak_error();<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 由于referent要被释放了，因此referent的weak_entry_t也要移除出weak_table</span><br>    weak_entry_remove(weak_table, entry);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面就是为什么当对象析构时，所有弱引用该对象的指针都会被设置为nil的原因。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>综上我们讲述了SideTable的结构，以及如何使用SideTable存储和清除对象和指向这些对象的指针地址。从而在侧面验证了弱引用的存储方式以及在对象释放时如何将弱引用的指针置空。读完这篇文章相信你对于SideTable结构和弱引用已经有了一个比较全面的认识。</p>
]]></content>
      <categories>
        <category>Runtime</category>
      </categories>
      <tags>
        <tag>Runtime SideTable</tag>
      </tags>
  </entry>
  <entry>
    <title>应用启动-Main函数之前的那些事儿</title>
    <url>/2020/09/13/applaunchbeforemain/</url>
    <content><![CDATA[<p>在<a href="http://www.leewong.cn/2020/08/30/Mach-O/">上一篇文章</a>中我们介绍了应用启动在objc_init方法执行前的调用堆栈，根据这个堆栈我们可以看出在main函数之前实际上系统内核以及dyld还做了很多的操作，那么这篇文章我们来详细的看一下在这个过程中到底做了哪些事情。</p>
<a id="more"></a>

<p>我们在来看下这这张图：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gip6q2kpiwj30nw0le4oi.jpg"></p>
<p>从上图中我们看一看到应用启动的入口实际是_dyld_start函数,我们从<a href="https://opensource.apple.com/source/xnu/xnu-6153.141.1/">XNU源码</a><code>dyldStartup.s</code>中找到了这个方法：</p>
<h3 id="dyld-start"><a href="#dyld-start" class="headerlink" title="__dyld_start"></a>__dyld_start</h3><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">__dyld_start:<br>	<span class="hljs-comment">//..........省略掉汇编代码</span><br>	<span class="hljs-comment">// call dyldbootstrap::start(app_mh, argc, argv, slide, dyld_mh, &amp;startGlue)</span><br>	bl	__ZN13dyldbootstrap5startEPK12macho_headeriPPKclS2_Pm<br>  <span class="hljs-comment">//..........省略掉汇编代码</span><br><br></code></pre></td></tr></table></figure>
<p><code>__dyld_start</code>是一个汇编方法(看不懂😢),不过我们也可以看出这个方法里实际上是调用了<code>dyldbootstrap::start</code>方法，恰好也验证了我们截图中的调用堆栈。</p>
<h3 id="dyldbootstrap-start"><a href="#dyldbootstrap-start" class="headerlink" title="dyldbootstrap::start"></a>dyldbootstrap::start</h3><p><code>dyldbootstrap::start(...)</code>, 首先bootstrapping dyld, 然后调用dyld::_main核心方法</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// appsMachHeader 即mach-o文件的header字段</span><br><span class="hljs-comment">// argc 即 argument count 即程序运行的参数个数</span><br><span class="hljs-comment">// argv[] 即 argument value 是一个字符串数组 用来存放指向你的字符串参数的指针数组，每一个元素指向一个参数</span><br><span class="hljs-comment">// slide 偏移量</span><br><span class="hljs-function"><span class="hljs-keyword">uintptr_t</span> <span class="hljs-title">start</span><span class="hljs-params">(<span class="hljs-keyword">const</span> struct macho_header* appsMachHeader, <span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* argv[], </span></span><br><span class="hljs-function"><span class="hljs-params">				<span class="hljs-keyword">intptr_t</span> slide, <span class="hljs-keyword">const</span> struct macho_header* dyldsMachHeader,</span></span><br><span class="hljs-function"><span class="hljs-params">				<span class="hljs-keyword">uintptr_t</span>* startGlue)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-comment">// if kernel had to slide dyld, we need to fix up load sensitive locations</span><br>	<span class="hljs-comment">// we have to do this before using any global variables</span><br>	<span class="hljs-comment">// 如果slide dyld, 我们必须 fixeup dyly中的内容</span><br>	<span class="hljs-keyword">if</span> ( slide != <span class="hljs-number">0</span> ) &#123;<br>		<span class="hljs-comment">// 重新设定dyld</span><br>		rebaseDyld(dyldsMachHeader, slide);<br>	&#125;<br><br>	<span class="hljs-comment">// allow dyld to use mach messaging</span><br>	<span class="hljs-comment">// 允许dyld使用mach消息传递</span><br>	mach_init();<br><br>	<span class="hljs-comment">// kernel sets up env pointer to be just past end of agv array</span><br>	<span class="hljs-comment">// 内核设置的env pointers, 也就是环境参数</span><br>	<span class="hljs-comment">// envp = environment pointer</span><br>	<span class="hljs-comment">// 取出argv的第argc条数据 但是实际上argv 只有argc个参数</span><br>	<span class="hljs-comment">// 因此 envp 默认是紧挨着argv存储的</span><br>	<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>** envp = &amp;argv[argc+<span class="hljs-number">1</span>];<br>	<br>	<span class="hljs-comment">// kernel sets up apple pointer to be just past end of envp array</span><br>	<span class="hljs-comment">// kernel将apple指针设置为刚好超出envp数组的末尾</span><br>	<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>** apple = envp;<br>	<span class="hljs-keyword">while</span>(*apple != <span class="hljs-literal">NULL</span>) &#123; ++apple; &#125;<br>	++apple;<br><br>	<span class="hljs-comment">// set up random value for stack canary</span><br>	<span class="hljs-comment">// 栈溢出保护</span><br>	__guard_setup(apple);<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> DYLD_INITIALIZER_SUPPORT</span><br>	<span class="hljs-comment">// run all C++ initializers inside dyld</span><br>	<span class="hljs-comment">// 在dyld中运行所有C初始化程序</span><br>	runDyldInitializers(dyldsMachHeader, slide, argc, argv, envp, apple);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><br>	<span class="hljs-comment">// now that we are done bootstrapping dyld, call dyld&#x27;s main</span><br>	<span class="hljs-comment">// 调用dyld的main</span><br>	<span class="hljs-keyword">uintptr_t</span> appsSlide = slideOfMainExecutable(appsMachHeader);<br>	<span class="hljs-keyword">return</span> dyld::_main(appsMachHeader, appsSlide, argc, argv, envp, apple, startGlue);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这里附上<code>start</code>方法的重要参数<code>macho_header</code>的结构体：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mach_header_64</span> &#123;</span><br>    <span class="hljs-keyword">uint32_t</span>    magic;      <span class="hljs-comment">/* 区分系统架构版本 */</span><br>    <span class="hljs-keyword">cpu_type_t</span>  cputype;    <span class="hljs-comment">/*CPU类型 */</span><br>    <span class="hljs-keyword">cpu_subtype_t</span>   cpusubtype; <span class="hljs-comment">/* CPU具体类型 */</span><br>    <span class="hljs-keyword">uint32_t</span>    filetype;   <span class="hljs-comment">/* 文件类型 */</span><br>    <span class="hljs-keyword">uint32_t</span>    ncmds;      <span class="hljs-comment">/* loadcommands 条数，即依赖库数量*/</span><br>    <span class="hljs-keyword">uint32_t</span>    sizeofcmds; <span class="hljs-comment">/* 依赖库大小 */</span><br>    <span class="hljs-keyword">uint32_t</span>    flags;      <span class="hljs-comment">/* 标志位 */</span><br>    <span class="hljs-keyword">uint32_t</span>    reserved;   <span class="hljs-comment">/* 保留字段，暂没有用到*/</span><br>&#125;;<br></code></pre></td></tr></table></figure>
<p><code>start</code>方法的主要作用就是：先读取Mach-O文件的头部信息，设置虚拟地址偏移，这里的偏移主要用于重定向。接下来就是初始化Mach-O文件，用于后续加载库文件和DATA数据，再运行C++的初始化器，最后进入dyly的主函数。</p>
<h3 id="dyld-main"><a href="#dyld-main" class="headerlink" title="dyld::_main"></a>dyld::_main</h3><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// dyld的main函数 dyld的入口方法kernel加载dyld并设置设置一些寄存器并调用此函数,之后跳转到__dyld_start</span><br><span class="hljs-comment">// mainExecutableSlide 主程序的slider,用于做重定向 会在main方法中被赋值</span><br><span class="hljs-comment">// mainExecutableMH 主程序MachO的header</span><br><span class="hljs-comment">// argc 表示main函数参数个数</span><br><span class="hljs-comment">// argv 表示main函数的参数值 argv[argc] 可以获取到参数值</span><br><span class="hljs-comment">// envp[] 表示以设置好的环境变量</span><br><span class="hljs-comment">// apple 是从envp开始获取到第一个值为NULL的指针地址</span><br><span class="hljs-keyword">uintptr_t</span><br>_main(<span class="hljs-keyword">const</span> macho_header* mainExecutableMH, <span class="hljs-keyword">uintptr_t</span> mainExecutableSlide, <br>		<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* argv[], <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* envp[], <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* apple[], <br>		<span class="hljs-keyword">uintptr_t</span>* startGlue)<br>&#123;<br>	<span class="hljs-keyword">uintptr_t</span> result = <span class="hljs-number">0</span>;<br>	<span class="hljs-comment">// 1 设置运行环境，处理环境变量 mainExecutableMH为macho_header类型</span><br>	<span class="hljs-comment">// 表示的是当前主程序的Mach-O头部信息, 有了头部信息, 加载器就可以从头开始, 遍历整个Mach-O文件的信息</span><br>	sMainExecutableMachHeader = mainExecutableMH;<br><br>	CRSetCrashLogMessage(<span class="hljs-string">&quot;dyld: launch started&quot;</span>);<br><br>	<span class="hljs-comment">// 设置上下文  包括一些回调函数, 参数与标志设置信息</span><br>	setContext(mainExecutableMH, argc, argv, envp, apple);<br><br>	<span class="hljs-comment">// Pickup the pointer to the exec path.</span><br>	<span class="hljs-comment">// 获取指向exec路径的指针 执行exec相关指令 apple是一个数组 所以apple表示数组首元素的地址</span><br>	<span class="hljs-comment">// _simple_getenv 方法可以理解为从apple中获取&quot;executable_path&quot;对应的值</span><br>	sExecPath = _simple_getenv(apple, <span class="hljs-string">&quot;executable_path&quot;</span>);<br><br>	<span class="hljs-comment">// &lt;rdar://problem/13868260&gt; Remove interim apple[0] transition code from dyld</span><br>	<span class="hljs-keyword">if</span> (!sExecPath) sExecPath = apple[<span class="hljs-number">0</span>];<br><br>	<span class="hljs-comment">// 将可执行文件的路径由相对路径转化成绝对路径</span><br>	<span class="hljs-keyword">bool</span> ignoreEnvironmentVariables = <span class="hljs-literal">false</span>;<br>	<span class="hljs-comment">// 判断是否是相对路径的条件</span><br>	<span class="hljs-keyword">if</span> ( sExecPath[<span class="hljs-number">0</span>] != <span class="hljs-string">&#x27;/&#x27;</span> ) &#123;<br>		<span class="hljs-comment">// have relative path, use cwd to make absolute</span><br>		<span class="hljs-comment">// 相对路径--&gt;绝对路径</span><br>		<span class="hljs-keyword">char</span> cwdbuff[MAXPATHLEN];<br>		<span class="hljs-comment">//</span><br>	    <span class="hljs-keyword">if</span> ( getcwd(cwdbuff, MAXPATHLEN) != <span class="hljs-literal">NULL</span> ) &#123;<br>			<span class="hljs-comment">// maybe use static buffer to avoid calling malloc so early...</span><br>			<span class="hljs-keyword">char</span>* s = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[<span class="hljs-built_in">strlen</span>(cwdbuff) + <span class="hljs-built_in">strlen</span>(sExecPath) + <span class="hljs-number">2</span>];<br>			<span class="hljs-built_in">strcpy</span>(s, cwdbuff);<br>			<span class="hljs-built_in">strcat</span>(s, <span class="hljs-string">&quot;/&quot;</span>);<br>			<span class="hljs-built_in">strcat</span>(s, sExecPath);<br>			sExecPath = s;<br>		&#125;<br>	&#125;<br>	<span class="hljs-comment">// Remember short name of process for later logging</span><br>	<span class="hljs-comment">//  获取可执行文件去除前面的路径, 获取它的name</span><br>	<span class="hljs-comment">// strrchr:在参数 sExecPath 所指向的字符串中搜索最后一次出现字符 &#x27;/&#x27;的位置</span><br>	sExecShortName = ::<span class="hljs-built_in">strrchr</span>(sExecPath, <span class="hljs-string">&#x27;/&#x27;</span>);<br>	<span class="hljs-comment">// 如果获取到了文件名的位置</span><br>	<span class="hljs-keyword">if</span> ( sExecShortName != <span class="hljs-literal">NULL</span> )<br>		<span class="hljs-comment">// 文件名真正的起始位置</span><br>		++sExecShortName;<br>	<span class="hljs-keyword">else</span><br>		<span class="hljs-comment">// 文件名起始位置就是绝对路径</span><br>		sExecShortName = sExecPath;<br><br>	<span class="hljs-comment">// 配置进程是否受到限制</span><br>    sProcessIsRestricted = processRestricted(mainExecutableMH, &amp;ignoreEnvironmentVariables, &amp;sProcessRequiresLibraryValidation);<br>	<span class="hljs-comment">// 如果进程受限</span><br>    <span class="hljs-keyword">if</span> ( sProcessIsRestricted ) &#123;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> SUPPORT_LC_DYLD_ENVIRONMENT</span><br>		<span class="hljs-comment">// 检查加载命令环境变量</span><br>		<span class="hljs-comment">// 遍历Mach-O中所有的LC_DYLD_ENVIRONMENT加载命令, 然后调用processDyldEnvironmentVariable()对不同的环境变量做相应的处理</span><br>		checkLoadCommandEnvironmentVariables();<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>		<span class="hljs-comment">// 删除进程的LD_LIBRARY_PATH与所有以DYLD_开头的环境变量, 这样以后创建的子进程就不包含这些环境变量了</span><br>		pruneEnvironmentVariables(envp, &amp;apple);<br>		<span class="hljs-comment">// set again because envp and apple may have changed or moved</span><br>		<span class="hljs-comment">// 重新设置链接上下文。这一步执行的主要目的是由于环境变量发生变化了, 需要更新进程的envp与apple参数</span><br>		setContext(mainExecutableMH, argc, argv, envp, apple);<br>	&#125;<br>	<span class="hljs-keyword">else</span> &#123;<br>		<span class="hljs-keyword">if</span> ( !ignoreEnvironmentVariables )<br>			<span class="hljs-comment">// 检查环境变量</span><br>			checkEnvironmentVariables(envp);<br>		defaultUninitializedFallbackPaths(envp);<br>	&#125;<br><br>	<span class="hljs-comment">// 打印信息 不需要关注</span><br>	<span class="hljs-keyword">if</span> ( sEnv.DYLD_PRINT_OPTS )<br>		printOptions(argv);<br>	<span class="hljs-keyword">if</span> ( sEnv.DYLD_PRINT_ENV ) <br>		printEnvironmentVariables(envp);<br><br>	<span class="hljs-comment">// 获取当前设备的CPU架构信息</span><br>	getHostInfo(mainExecutableMH, mainExecutableSlide);<br><br>	<span class="hljs-comment">// install gdb notifier</span><br>	<span class="hljs-comment">// 注册gdb的监听者, 用于调试</span><br>	stateToHandlers(dyld_image_state_dependents_mapped, sBatchHandlers)-&gt;push_back(notifyGDB);<br>	stateToHandlers(dyld_image_state_mapped, sSingleHandlers)-&gt;push_back(updateAllImages);<br>	<span class="hljs-comment">// make initial allocations large enough that it is unlikely to need to be re-alloced</span><br>	sAllImages.reserve(INITIAL_IMAGE_COUNT);<br>	sImageRoots.reserve(<span class="hljs-number">16</span>);<br>	sAddImageCallbacks.reserve(<span class="hljs-number">4</span>);<br>	sRemoveImageCallbacks.reserve(<span class="hljs-number">4</span>);<br>	sImageFilesNeedingTermination.reserve(<span class="hljs-number">16</span>);<br>	sImageFilesNeedingDOFUnregistration.reserve(<span class="hljs-number">8</span>);<br>	<br>	<br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> WAIT_FOR_SYSTEM_ORDER_HANDSHAKE</span><br>	<span class="hljs-comment">// &lt;rdar://problem/6849505&gt; Add gating mechanism to dyld support system order file generation process</span><br>	WAIT_FOR_SYSTEM_ORDER_HANDSHAKE(dyld::gProcessInfo-&gt;systemOrderFlag);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>	<br>	<span class="hljs-comment">//2 初始化主程序</span><br>	<span class="hljs-keyword">try</span> &#123;<br>		<span class="hljs-comment">// add dyld itself to UUID list</span><br>		<span class="hljs-comment">// 将dyld添加到UUIDlist中</span><br>		addDyldImageToUUIDList();<br><br>		CRSetCrashLogMessage(sLoadingCrashMessage);<br>		<span class="hljs-comment">// instantiate ImageLoader for main executable</span><br>		<span class="hljs-comment">//  加载sExecPath路径下的可执行文件, 实例化一个ImageLoader对象</span><br>		sMainExecutable = instantiateFromLoadedImage(mainExecutableMH, mainExecutableSlide, sExecPath);<br>		<span class="hljs-comment">// 设置上下文, 将MainExecutable 这个 ImageLoader设置给链接上下文, 配置链接上下文其他变量</span><br>		gLinkContext.mainExecutable = sMainExecutable;<br>		gLinkContext.processIsRestricted = sProcessIsRestricted;<br>		gLinkContext.processRequiresLibraryValidation = sProcessRequiresLibraryValidation;<br>		gLinkContext.mainExecutableCodeSigned = hasCodeSignatureLoadCommand(mainExecutableMH);<br><br>		<span class="hljs-comment">// load shared cache</span><br>		<span class="hljs-comment">// 3 加载共享缓存</span><br>		checkSharedRegionDisable();<br>	<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> DYLD_SHARED_CACHE_SUPPORT</span><br>		<span class="hljs-keyword">if</span> ( gLinkContext.sharedRegionMode != ImageLoader::kDontUseSharedRegion )<br>			<span class="hljs-comment">// 映射共享缓存</span><br>			mapSharedCache();<br>	<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><br>		<span class="hljs-comment">// Now that shared cache is loaded, setup an versioned dylib overrides</span><br>	<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> SUPPORT_VERSIONED_PATHS</span><br>		checkVersionedPaths();<br>	<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><br>		<span class="hljs-comment">// load any inserted libraries</span><br>		<span class="hljs-comment">// 4 加载插入的动态库</span><br>		<span class="hljs-comment">// 变量 `DYLD_INSERT_LIBRARIES` 环境变量, 调用`loadInsertedDylib`方法加载所有要插入的库,</span><br>		<span class="hljs-comment">// 这些库都被加入到`sAllImages`数组中</span><br>		<span class="hljs-keyword">if</span>	( sEnv.DYLD_INSERT_LIBRARIES != <span class="hljs-literal">NULL</span> ) &#123;<br>			<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* <span class="hljs-keyword">const</span>* lib = sEnv.DYLD_INSERT_LIBRARIES; *lib != <span class="hljs-literal">NULL</span>; ++lib) <br>				loadInsertedDylib(*lib);<br>		&#125;<br>		<span class="hljs-comment">// record count of inserted libraries so that a flat search will look at </span><br>		<span class="hljs-comment">// inserted libraries, then main, then others.</span><br>		<span class="hljs-comment">// 记录插入的库的数量，以便进行统一搜索插入的库，然后是main，然后是其他</span><br>		sInsertedDylibCount = sAllImages.size()<span class="hljs-number">-1</span>;<br><br>		<span class="hljs-comment">// link main executable</span><br>		<span class="hljs-comment">// 5 链接主程序</span><br>		<span class="hljs-comment">// 开始链接主程序, 此时主程序已经被加载到gLinkContext.mainExecutable中,</span><br>		<span class="hljs-comment">// 调用 link 链接主程序。内核调用的是ImageLoader::link 函数。</span><br>		gLinkContext.linkingMainExecutable = <span class="hljs-literal">true</span>;<br>		<span class="hljs-comment">// link方法</span><br>		link(sMainExecutable, sEnv.DYLD_BIND_AT_LAUNCH, <span class="hljs-literal">true</span>, ImageLoader::RPathChain(<span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>));<br>		<span class="hljs-comment">// 设置永不递归卸载</span><br>		sMainExecutable-&gt;setNeverUnloadRecursive();<br>		<span class="hljs-comment">// mach-o header中的MH_FORCE_FLAT</span><br>		<span class="hljs-keyword">if</span> ( sMainExecutable-&gt;forceFlat() ) &#123;<br>			gLinkContext.bindFlat = <span class="hljs-literal">true</span>;<br>			gLinkContext.prebindUsage = ImageLoader::kUseNoPrebinding;<br>		&#125;<br><br>		<span class="hljs-comment">// link any inserted libraries</span><br>		<span class="hljs-comment">// 6 链接插入的动态库</span><br>		<span class="hljs-comment">// do this after linking main executable so that any dylibs pulled in by inserted </span><br>		<span class="hljs-comment">// dylibs (e.g. libSystem) will not be in front of dylibs the program uses</span><br>		<span class="hljs-comment">// 对 sAllimages （除了主程序的Image外）中的库调用link进行链接，</span><br>		<span class="hljs-comment">// 然后调用 registerInterposing 注册符号插入, 例如是libSystem就是此时加入的</span><br>		<span class="hljs-keyword">if</span> ( sInsertedDylibCount &gt; <span class="hljs-number">0</span> ) &#123;<br>			<span class="hljs-keyword">for</span>(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i &lt; sInsertedDylibCount; ++i) &#123;<br>				ImageLoader* image = sAllImages[i+<span class="hljs-number">1</span>];<br>				<span class="hljs-comment">// link</span><br>				link(image, sEnv.DYLD_BIND_AT_LAUNCH, <span class="hljs-literal">true</span>, ImageLoader::RPathChain(<span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>));<br>				image-&gt;setNeverUnloadRecursive();<br>			&#125;<br>			<span class="hljs-comment">// only INSERTED libraries can interpose</span><br>			<span class="hljs-comment">// register interposing info after all inserted libraries are bound so chaining works</span><br>			<span class="hljs-keyword">for</span>(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i &lt; sInsertedDylibCount; ++i) &#123;<br>				ImageLoader* image = sAllImages[i+<span class="hljs-number">1</span>];<br>				<span class="hljs-comment">// 注册符号插入,Interposition, 是通过编写与函数库同名的函数来取代函数库的行为.</span><br>				image-&gt;registerInterposing();<br>			&#125;<br>		&#125;<br><br>		<span class="hljs-comment">// &lt;rdar://problem/19315404&gt; dyld should support interposition even without DYLD_INSERT_LIBRARIES</span><br>		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=sInsertedDylibCount+<span class="hljs-number">1</span>; i &lt; sAllImages.size(); ++i) &#123;<br>			ImageLoader* image = sAllImages[i];<br>			<span class="hljs-keyword">if</span> ( image-&gt;inSharedCache() )<br>				<span class="hljs-keyword">continue</span>;<br>			image-&gt;registerInterposing();<br>		&#125;<br><br>		<span class="hljs-comment">// apply interposing to initial set of images</span><br>		<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i &lt; sImageRoots.size(); ++i) &#123;<br>			sImageRoots[i]-&gt;applyInterposing(gLinkContext);<br>		&#125;<br>		gLinkContext.linkingMainExecutable = <span class="hljs-literal">false</span>;<br>		<br>		<span class="hljs-comment">// &lt;rdar://problem/12186933&gt; do weak binding only after all inserted images linked</span><br>		<span class="hljs-comment">// 7 执行弱符号绑定</span><br>		sMainExecutable-&gt;weakBind(gLinkContext);<br>		<br>		CRSetCrashLogMessage(<span class="hljs-string">&quot;dyld: launch, running initializers&quot;</span>);<br>	<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> SUPPORT_OLD_CRT_INITIALIZATION</span><br>		<span class="hljs-comment">// Old way is to run initializers via a callback from crt1.o</span><br>		<span class="hljs-keyword">if</span> ( ! gRunInitializersOldWay ) <br>			initializeMainExecutable(); <br>	<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><br>		<span class="hljs-comment">// run all initializers</span><br>		<span class="hljs-comment">// 8 执行初始化方法</span><br>		<span class="hljs-comment">// 执行初始化方法, 其中`+load` 和constructor方法就是在这里执行,</span><br>		<span class="hljs-comment">// `initializeMainExecutable`方法先是内部调用动态库的初始化方法, 然后调用主程序的初始化方法</span><br>		initializeMainExecutable(); <br>	<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>		<span class="hljs-comment">// find entry point for main executable</span><br>		<span class="hljs-comment">// 9 查找APP入口点并返回</span><br>		result = (<span class="hljs-keyword">uintptr_t</span>)sMainExecutable-&gt;getThreadPC();<br>		<span class="hljs-keyword">if</span> ( result != <span class="hljs-number">0</span> ) &#123;<br>			<span class="hljs-comment">// main executable uses LC_MAIN, needs to return to glue in libdyld.dylib</span><br>			<span class="hljs-keyword">if</span> ( (gLibSystemHelpers != <span class="hljs-literal">NULL</span>) &amp;&amp; (gLibSystemHelpers-&gt;version &gt;= <span class="hljs-number">9</span>) )<br>				*startGlue = (<span class="hljs-keyword">uintptr_t</span>)gLibSystemHelpers-&gt;startGlueToCallExit;<br>			<span class="hljs-keyword">else</span><br>				halt(<span class="hljs-string">&quot;libdyld.dylib support not present for LC_MAIN&quot;</span>);<br>		&#125;<br>		<span class="hljs-keyword">else</span> &#123;<br>			<span class="hljs-comment">// main executable uses LC_UNIXTHREAD, dyld needs to let &quot;start&quot; in program set up for main()</span><br>			result = (<span class="hljs-keyword">uintptr_t</span>)sMainExecutable-&gt;getMain();<br>			*startGlue = <span class="hljs-number">0</span>;<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">catch</span>(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* message) &#123;<br>		syncAllImages();<br>		halt(message);<br>	&#125;<br>	<span class="hljs-keyword">catch</span>(...) &#123;<br>		dyld::<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;dyld: launch failed\n&quot;</span>);<br>	&#125;<br><br>	CRSetCrashLogMessage(<span class="hljs-literal">NULL</span>);<br>	<br>	<span class="hljs-keyword">return</span> result;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>下面我们对<code>main</code>函数进行拆分讲解</p>
<h4 id="1-设置运行环境，处理环境变量"><a href="#1-设置运行环境，处理环境变量" class="headerlink" title="1 设置运行环境，处理环境变量"></a>1 设置运行环境，处理环境变量</h4><p>这一步我们主要关注<code>sExecPath</code>,<code>processRestricted</code>,<code>getHostInfo</code>这几个方法。</p>
<h5 id="sExecPath"><a href="#sExecPath" class="headerlink" title="sExecPath"></a>sExecPath</h5><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">sExecPath = _simple_getenv(apple, <span class="hljs-string">&quot;executable_path&quot;</span>);<br></code></pre></td></tr></table></figure>
<p>我们在介绍参数的时候介绍到 apple 实际上存储这应用的环境变量的数组，<code>executable_path</code>就表示执行路径，而_simple_getenv方法就是从apple中获取<code>executable_path</code>对应的值。不过这里获取到的可能是一个相对路径，而dyld判断是否为相对路径的条件：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> ( sExecPath[<span class="hljs-number">0</span>] != <span class="hljs-string">&#x27;/&#x27;</span> ) &#123;<br>    <span class="hljs-comment">// 相对路径</span><br>    <span class="hljs-keyword">if</span> ( getcwd(cwdbuff, MAXPATHLEN) != <span class="hljs-literal">NULL</span> ) &#123;<br>			<span class="hljs-comment">// maybe use static buffer to avoid calling malloc so early...</span><br>			<span class="hljs-keyword">char</span>* s = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[<span class="hljs-built_in">strlen</span>(cwdbuff) + <span class="hljs-built_in">strlen</span>(sExecPath) + <span class="hljs-number">2</span>];<br>			<span class="hljs-comment">// 拷贝</span><br>			<span class="hljs-built_in">strcpy</span>(s, cwdbuff);<br>			<span class="hljs-comment">// 拼接</span><br>			<span class="hljs-built_in">strcat</span>(s, <span class="hljs-string">&quot;/&quot;</span>);<br>			<span class="hljs-built_in">strcat</span>(s, sExecPath);<br>			<span class="hljs-comment">// 重新赋值</span><br>			sExecPath = s;<br>		&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这样我们就可以获取到执行文件的绝对路径。在获取到绝对路径后，我们可以根据绝对路径获取到执行文件的文件名：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">sExecShortName = ::<span class="hljs-built_in">strrchr</span>(sExecPath, <span class="hljs-string">&#x27;/&#x27;</span>);<br></code></pre></td></tr></table></figure>
<p>strrchr方法的功能为:<code>在参数 sExecPath 所指向的字符串中搜索最后一次出现字符 &#39;/&#39;的位置</code>。</p>
<h5 id="processRestricted"><a href="#processRestricted" class="headerlink" title="processRestricted"></a>processRestricted</h5><p>进程是否受限，这里我们主要关注下Mach-O相关的一个判断：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 进程受限</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">processRestricted</span><span class="hljs-params">(<span class="hljs-keyword">const</span> macho_header* mainExecutableMH, <span class="hljs-keyword">bool</span>* ignoreEnvVars, <span class="hljs-keyword">bool</span>* processRequiresLibraryValidation)</span></span><br><span class="hljs-function"></span>&#123;			<br>	<span class="hljs-comment">// &lt;rdar://problem/13158444&amp;13245742&gt; Respect __RESTRICT,__restrict section for root processes</span><br>	<span class="hljs-comment">// 段名受限。当Mach-O包含一个__RESTRICT/__restrict段时，进程会被设置成受限</span><br>	<span class="hljs-keyword">if</span> ( hasRestrictedSegment(mainExecutableMH) ) &#123;<br>		<span class="hljs-comment">// existence of __RESTRICT/__restrict section make process restricted</span><br>		sRestrictedReason = restrictedBySegment;<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>	&#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>hasRestrictedSegment方法的实现如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//dyld::log(&quot;seg name: %s\n&quot;, seg-&gt;segname);</span><br>				<span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(seg-&gt;segname, <span class="hljs-string">&quot;__RESTRICT&quot;</span>) == <span class="hljs-number">0</span>) &#123;<br>					<span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">macho_section</span>* <span class="hljs-title">const</span> <span class="hljs-title">sectionsStart</span> = (<span class="hljs-title">struct</span> <span class="hljs-title">macho_section</span>*)((<span class="hljs-title">char</span>*)<span class="hljs-title">seg</span> + <span class="hljs-title">sizeof</span>(<span class="hljs-title">struct</span> <span class="hljs-title">macho_segment_command</span>));</span><br>					<span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">macho_section</span>* <span class="hljs-title">const</span> <span class="hljs-title">sectionsEnd</span> = &amp;<span class="hljs-title">sectionsStart</span>[<span class="hljs-title">seg</span>-&gt;<span class="hljs-title">nsects</span>];</span><br>					<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> struct macho_section* sect=sectionsStart; sect &lt; sectionsEnd; ++sect) &#123;<br>						<span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(sect-&gt;sectname, <span class="hljs-string">&quot;__restrict&quot;</span>) == <span class="hljs-number">0</span>) <br>							<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>					&#125;<br>				&#125;<br></code></pre></td></tr></table></figure>
<p>实际上是从Mach-O文件中依次读取所有的segment，判断segment-&gt;segname是否包含__RESTRICT字符串来判断是否受限。</p>
<h5 id="getHostInfo"><a href="#getHostInfo" class="headerlink" title="getHostInfo"></a>getHostInfo</h5><p>getHostInfo是用来获取当前设备的CPU架构信息。</p>
<p>我们来简单看下这个方法的实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getHostInfo</span><span class="hljs-params">(<span class="hljs-keyword">const</span> macho_header* mainExecutableMH, <span class="hljs-keyword">uintptr_t</span> mainExecutableSlide)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> CPU_SUBTYPES_SUPPORTED</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> __ARM_ARCH_7K__</span><br>	sHostCPU		= CPU_TYPE_ARM;<br>	sHostCPUsubtype = CPU_SUBTYPE_ARM_V7K;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">elif</span> __ARM_ARCH_7A__</span><br>	sHostCPU		= CPU_TYPE_ARM;<br>	sHostCPUsubtype = CPU_SUBTYPE_ARM_V7;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">elif</span> __ARM_ARCH_6K__</span><br>	sHostCPU		= CPU_TYPE_ARM;<br>	sHostCPUsubtype = CPU_SUBTYPE_ARM_V6;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">elif</span> __ARM_ARCH_7F__</span><br>	sHostCPU		= CPU_TYPE_ARM;<br>	sHostCPUsubtype = CPU_SUBTYPE_ARM_V7F;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">elif</span> __ARM_ARCH_7S__</span><br>	sHostCPU		= CPU_TYPE_ARM;<br>	sHostCPUsubtype = CPU_SUBTYPE_ARM_V7S;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">host_basic_info</span> <span class="hljs-title">info</span>;</span><br>	<span class="hljs-keyword">mach_msg_type_number_t</span> count = HOST_BASIC_INFO_COUNT;<br>	<span class="hljs-keyword">mach_port_t</span> hostPort = mach_host_self();<br>	<span class="hljs-keyword">kern_return_t</span> result = host_info(hostPort, HOST_BASIC_INFO, (<span class="hljs-keyword">host_info_t</span>)&amp;info, &amp;count);<br>	<span class="hljs-keyword">if</span> ( result != KERN_SUCCESS )<br>		<span class="hljs-keyword">throw</span> <span class="hljs-string">&quot;host_info() failed&quot;</span>;<br>	sHostCPU		= info.cpu_type;<br>	sHostCPUsubtype = info.cpu_subtype;<br>	mach_port_deallocate(mach_task_self(), hostPort);<br>  <span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> __x86_64__</span><br>	<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> TARGET_IPHONE_SIMULATOR</span><br>	  sHaswell = <span class="hljs-literal">false</span>;<br>	<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><br>	  sHaswell = (sHostCPUsubtype == CPU_SUBTYPE_X86_64_H);<br>	  <span class="hljs-comment">// &lt;rdar://problem/18528074&gt; x86_64h: Fall back to the x86_64 slice if an app requires GC.</span><br>	  <span class="hljs-keyword">if</span> ( sHaswell ) &#123;<br>		<span class="hljs-keyword">if</span> ( isGCProgram(mainExecutableMH, mainExecutableSlide) ) &#123;<br>			<span class="hljs-comment">// When running a GC program on a haswell machine, don&#x27;t use and &#x27;h slices</span><br>			sHostCPUsubtype = CPU_SUBTYPE_X86_64_ALL;<br>			sHaswell = <span class="hljs-literal">false</span>;<br>			gLinkContext.sharedRegionMode = ImageLoader::kDontUseSharedRegion;<br>		&#125;<br>	  &#125;<br>	<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>  <span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>设置环境变量完成且获取了CPU信息后，dyld就开始准备初始化主程序了，下面我们看下main函数的下一步初始化主程序。</p>
<h4 id="2-初始化主程序"><a href="#2-初始化主程序" class="headerlink" title="2 初始化主程序"></a>2 初始化主程序</h4><p>初始化主程序主要做了两件事：</p>
<ul>
<li>将dyld添加到UUIDlist中</li>
<li>加载可执行文件 实例化ImageLoader对象</li>
</ul>
<p>下面我们来详细看下这两步分别都做了什么</p>
<h5 id="addDyldImageToUUIDList"><a href="#addDyldImageToUUIDList" class="headerlink" title="addDyldImageToUUIDList"></a>addDyldImageToUUIDList</h5><p>addDyldImageToUUIDList方法是加载DYLD到UUID list中,我们来看下这个方法的实现:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// &lt;rdar://problem/10583252&gt; Add dyld to uuidArray to enable symbolication of stackshots</span><br><span class="hljs-comment">// 将dyld添加到uuidArray以启用符号堆叠</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addDyldImageToUUIDList</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">macho_header</span>* <span class="hljs-title">mh</span> = (<span class="hljs-title">macho_header</span>*)&amp;__<span class="hljs-title">dso_handle</span>;</span><br>	<span class="hljs-keyword">const</span> <span class="hljs-keyword">uint32_t</span> cmd_count = mh-&gt;ncmds;<br>	<span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">load_command</span>* <span class="hljs-title">const</span> <span class="hljs-title">cmds</span> = (<span class="hljs-title">struct</span> <span class="hljs-title">load_command</span>*)((<span class="hljs-title">char</span>*)<span class="hljs-title">mh</span> + <span class="hljs-title">sizeof</span>(<span class="hljs-title">macho_header</span>));</span><br>	<span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">load_command</span>* <span class="hljs-title">cmd</span> = <span class="hljs-title">cmds</span>;</span><br>	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">uint32_t</span> i = <span class="hljs-number">0</span>; i &lt; cmd_count; ++i) &#123;<br>		<span class="hljs-keyword">switch</span> (cmd-&gt;cmd) &#123;<br>			<span class="hljs-keyword">case</span> LC_UUID: &#123;<br>				uuid_command* uc = (uuid_command*)cmd;<br>				<span class="hljs-comment">// 新建一个dyld_uuid_info</span><br>				dyld_uuid_info info;<br>				<span class="hljs-comment">// 给新建的info imageLoadAddress 字段赋值</span><br>				info.imageLoadAddress = (mach_header*)mh;<br>				<span class="hljs-comment">// 复制uc-&gt;uuid的16个字节给info.imageUUID</span><br>				<span class="hljs-built_in">memcpy</span>(info.imageUUID, uc-&gt;uuid, <span class="hljs-number">16</span>);<br>				<span class="hljs-comment">// 利用组装好的info给dyld的gProcessInfo的uuidArray和uuidArrayCount赋值</span><br>				addNonSharedCacheImageUUID(info);<br>				<span class="hljs-keyword">return</span>;<br>			&#125;<br>		&#125;<br>		cmd = (<span class="hljs-keyword">const</span> struct load_command*)(((<span class="hljs-keyword">char</span>*)cmd)+cmd-&gt;cmdsize);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>从代码中我们可以看出，这个方法是遍历了<code>Mach-O</code>中的<code>load_command</code>并将<code>cmd-&gt;cmd</code>值为<code>LC_UUID</code>的添加到<code>dyld::gProcessInfo-&gt;uuidArray</code>中并更新个数。</p>
<p>我们可以通过addNonSharedCacheImageUUID的实现进一步确认：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 将info中的uuidArray添加到dyld::gProcessInfo中</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addNonSharedCacheImageUUID</span><span class="hljs-params">(<span class="hljs-keyword">const</span> dyld_uuid_info&amp; info)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-comment">// set uuidArray to NULL to denote it is in-use</span><br>	<span class="hljs-comment">// 将uuidArray设置为NULL 表示这个字段正在使用中</span><br>	dyld::gProcessInfo-&gt;uuidArray = <span class="hljs-literal">NULL</span>;<br>	<br>	<span class="hljs-comment">// append all new images</span><br>	<span class="hljs-comment">// 追加外部传入的info到sImageUUIDs中</span><br>	sImageUUIDs.push_back(info);<br>	<span class="hljs-comment">// 重新设置追加后uuidArrayCount</span><br>	dyld::gProcessInfo-&gt;uuidArrayCount = sImageUUIDs.size();<br>	<br>	<span class="hljs-comment">// set uuidArray back to base address of vector (other process can now read)</span><br>	<span class="hljs-comment">// 更新追加后的uuidArray</span><br>	dyld::gProcessInfo-&gt;uuidArray = &amp;sImageUUIDs[<span class="hljs-number">0</span>];<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="instantiateFromLoadedImage"><a href="#instantiateFromLoadedImage" class="headerlink" title="instantiateFromLoadedImage"></a>instantiateFromLoadedImage</h5><p>从方法名中我们就可以看到这个方法是实例化一个ImageLoader,下面我们来详细了解下这个方法：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// mh 即 Mach-O文件的header</span><br><span class="hljs-comment">// slide 表示偏移量</span><br><span class="hljs-comment">// path 表示可执行文件地址</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> ImageLoader* <span class="hljs-title">instantiateFromLoadedImage</span><span class="hljs-params">(<span class="hljs-keyword">const</span> macho_header* mh, <span class="hljs-keyword">uintptr_t</span> slide, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* path)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-comment">// try mach-o loader</span><br>	<span class="hljs-comment">// 检查mach-o的subtype是否是当前cpu可以支持</span><br>	<span class="hljs-keyword">if</span> ( isCompatibleMachO((<span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span>*)mh, path) ) &#123;<br>		<span class="hljs-comment">// 根据传入的参数实例化一个ImageLoaderMachO类型的ImageLoader</span><br>		ImageLoader* image = ImageLoaderMachO::instantiateMainExecutable(mh, slide, path, gLinkContext);<br>		<span class="hljs-comment">// 将主程序添加到全局主列表sAllImages中, </span><br>		<span class="hljs-comment">// 最后调用addMappedRange()申请内存, 更新主程序映像映射的内存区</span><br>		addImage(image);<br>		<span class="hljs-keyword">return</span> image;<br>	&#125;<br>	<br>	<span class="hljs-keyword">throw</span> <span class="hljs-string">&quot;main executable not a known format&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>实例化一个ImageLoaderMachO后，我们将第一步获取到的一些变量设置给我们刚创建的ImageLoader：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">gLinkContext.mainExecutable = sMainExecutable;<br>		gLinkContext.processIsRestricted = sProcessIsRestricted;<br>		gLinkContext.processRequiresLibraryValidation = sProcessRequiresLibraryValidation;<br>		gLinkContext.mainExecutableCodeSigned = hasCodeSignatureLoadCommand(mainExecutableMH);<br></code></pre></td></tr></table></figure>

<h4 id="3-加载共享缓存"><a href="#3-加载共享缓存" class="headerlink" title="3 加载共享缓存"></a>3 加载共享缓存</h4><p>何为共享缓存，比如我们都知道iOS开发中会依赖系统的UIKit以及Foundation库，那么iOS系统中安装很多应用每个应用都要有自己独立加载UIKit吗？当然不是，所有的App会共用一份UIKit库，而这份UIKit库就存放在共享缓存中。</p>
<p>这一步我们重点关注:<code>checkSharedRegionDisable</code>,<code>mapSharedCache</code>,<code>checkVersionedPaths</code>这几个方法：</p>
<h5 id="checkSharedRegionDisable"><a href="#checkSharedRegionDisable" class="headerlink" title="checkSharedRegionDisable"></a>checkSharedRegionDisable</h5><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">checkSharedRegionDisable</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-comment">// iPhoneOS cannot run without shared region</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>这个方法中包含了一些Mac OS的判断不过在方法的最后，系统的注释: iOS如果没有共享库将无法运行。所以这个方法我们也不需要多做解读</p>
<h5 id="mapSharedCache"><a href="#mapSharedCache" class="headerlink" title="mapSharedCache"></a>mapSharedCache</h5><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">mapSharedCache</span><span class="hljs-params">()</span> </span>&#123;<br>	<span class="hljs-comment">// 快速检查缓存是否已经被加载到共享缓存中了  如果没有返回-1</span><br>	<span class="hljs-keyword">if</span> ( _shared_region_check_np(&amp;cacheBaseAddress) == <span class="hljs-number">0</span> ) &#123;<br>		<span class="hljs-keyword">if</span> ( (header-&gt;mappingOffset &gt;= <span class="hljs-number">0x48</span>) &amp;&amp; (header-&gt;slideInfoSize != <span class="hljs-number">0</span>) ) &#123;<br>			<span class="hljs-comment">// solve for slide by comparing loaded address to address of first region</span><br>			<span class="hljs-comment">// 通过比较加载的地址和第一个区域的地址来解决偏移问题</span><br>			<span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span>* loadedAddress = (<span class="hljs-keyword">uint8_t</span>*)sSharedCache;<br>			<span class="hljs-keyword">const</span> dyld_cache_mapping_info* <span class="hljs-keyword">const</span> mappings = (dyld_cache_mapping_info*)(loadedAddress+header-&gt;mappingOffset);<br>			<span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span>* preferedLoadAddress = (<span class="hljs-keyword">uint8_t</span>*)(<span class="hljs-keyword">long</span>)(mappings[<span class="hljs-number">0</span>].address);<br>			<span class="hljs-comment">//加载的地址 - 第一个区域的地址</span><br>			<span class="hljs-comment">// 更新偏移量</span><br>			sSharedCacheSlide = loadedAddress - preferedLoadAddress;<br>			dyld::gProcessInfo-&gt;sharedCacheSlide = sSharedCacheSlide;<br>		&#125;<br>		<span class="hljs-comment">// if cache has a uuid, copy it</span><br>		<span class="hljs-comment">// 更新UUID</span><br>		<span class="hljs-keyword">if</span> ( header-&gt;mappingOffset &gt;= <span class="hljs-number">0x68</span> ) &#123;<br>			<span class="hljs-built_in">memcpy</span>(dyld::gProcessInfo-&gt;sharedCacheUUID, header-&gt;uuid, <span class="hljs-number">16</span>);<br>		&#125;<br>	&#125; <span class="hljs-keyword">else</span> &#123;<br>		<span class="hljs-keyword">if</span> ( (sysctlbyname(<span class="hljs-string">&quot;kern.safeboot&quot;</span>, &amp;safeBootValue, &amp;safeBootValueSize, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>) == <span class="hljs-number">0</span>) &amp;&amp; (safeBootValue != <span class="hljs-number">0</span>) ) &#123;<br>			<span class="hljs-comment">// 安全模式下</span><br>			::unlink(MACOSX_DYLD_SHARED_CACHE_DIR DYLD_SHARED_CACHE_BASE_NAME ARCH_NAME);<br>			<span class="hljs-comment">// 设置sharedRegionMode = kDontUseSharedRegion</span><br>			gLinkContext.sharedRegionMode = ImageLoader::kDontUseSharedRegion;<br>			<span class="hljs-keyword">return</span>;<br>		&#125; <span class="hljs-keyword">else</span> &#123;<br>			<span class="hljs-comment">// map in shared cache to shared region</span><br>			<span class="hljs-keyword">int</span> fd = openSharedCacheFile();<br>			<span class="hljs-keyword">if</span> ( fd != <span class="hljs-number">-1</span> ) &#123;<br>				<span class="hljs-keyword">uint8_t</span> firstPages[<span class="hljs-number">8192</span>];<br>				<span class="hljs-keyword">if</span> ( ::read(fd, firstPages, <span class="hljs-number">8192</span>) == <span class="hljs-number">8192</span> ) &#123;<br>					dyld_cache_header* header = (dyld_cache_header*)firstPages;<br>					<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> dyld_cache_mapping_info* p = fileMappingsStart; p &lt; fileMappingsEnd; ++p, ++i) &#123;<br>						mappings[i].sfm_address		= p-&gt;address;<br>						mappings[i].sfm_size		= p-&gt;size;<br>						mappings[i].sfm_file_offset	= p-&gt;fileOffset;<br>						mappings[i].sfm_max_prot	= p-&gt;maxProt;<br>						mappings[i].sfm_init_prot	= p-&gt;initProt;<br>						<span class="hljs-comment">// rdar://problem/5694507 old update_dyld_shared_cache tool could make a cache file</span><br>						<span class="hljs-comment">// that is not page aligned, but otherwise ok.</span><br>						<span class="hljs-keyword">if</span> ( p-&gt;fileOffset+p-&gt;size &gt; (<span class="hljs-keyword">uint64_t</span>)(stat_buf.st_size+<span class="hljs-number">4095</span> &amp; (<span class="hljs-number">-4096</span>)) ) &#123;<br>							dyld::<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;dyld: shared cached file is corrupt: %s&quot;</span> DYLD_SHARED_CACHE_BASE_NAME ARCH_NAME <span class="hljs-string">&quot;\n&quot;</span>, sSharedCacheDir);<br>							goodCache = <span class="hljs-literal">false</span>;<br>						&#125;<br>						<span class="hljs-keyword">if</span> ( (mappings[i].sfm_init_prot &amp; (VM_PROT_READ|VM_PROT_WRITE)) == (VM_PROT_READ|VM_PROT_WRITE) ) &#123;<br>							readWriteMappingIndex = i;<br>						&#125;<br>						<span class="hljs-keyword">if</span> ( mappings[i].sfm_init_prot == VM_PROT_READ ) &#123;<br>							readOnlyMappingIndex = i;<br>						&#125;<br>						<span class="hljs-keyword">if</span> ( gLinkContext.verboseMapping ) &#123;<br>							dyld::<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;dyld: calling _shared_region_map_and_slide_np() with regions:\n&quot;</span>);<br>							<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i &lt; mappingCount; ++i) &#123;<br>								dyld::<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;   address=0x%08llX, size=0x%08llX, fileOffset=0x%08llX\n&quot;</span>, mappings[i].sfm_address, mappings[i].sfm_size, mappings[i].sfm_file_offset);<br>							&#125;<br>						&#125;<br>						<span class="hljs-keyword">if</span> (_shared_region_map_and_slide_np(fd, mappingCount, mappings, codeSignatureMappingIndex, cacheSlide, slideInfo, slideInfoSize) == <span class="hljs-number">0</span>) &#123;<br>							<span class="hljs-comment">// successfully mapped cache into shared region</span><br>							sSharedCache = (dyld_cache_header*)mappings[<span class="hljs-number">0</span>].sfm_address;<br>							sSharedCacheSlide = cacheSlide;<br>							dyld::gProcessInfo-&gt;sharedCacheSlide = cacheSlide;<br>							<span class="hljs-comment">//dyld::log(&quot;sSharedCache=%p sSharedCacheSlide=0x%08lX\n&quot;, sSharedCache, sSharedCacheSlide);</span><br>							<span class="hljs-comment">// if cache has a uuid, copy it</span><br>							<span class="hljs-keyword">if</span> ( header-&gt;mappingOffset &gt;= <span class="hljs-number">0x68</span> ) &#123;<br>								<span class="hljs-built_in">memcpy</span>(dyld::gProcessInfo-&gt;sharedCacheUUID, header-&gt;uuid, <span class="hljs-number">16</span>);<br>							&#125;<br>						&#125;<br>					&#125;<br>				&#125;<br>			&#125;<br><br>		&#125;<br><br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这一步先通过<code>mapSharedCache()</code>方法来映射共享缓存, 该函数先通过_shared_region_check_np()来检查缓存是否已经映射到了共享区域了, 如果已经映射了, 就更新缓存的slide与UUID, 然后返回；<br>如果有没有映射 判断系统是否处于安全启动模式（safe-boot mode）下,如果是就删除缓存文件并返回, 如果非安全启动模式, 接下来调用openSharedCacheFile()打开缓存文件, 该函数在sSharedCacheDir路径下, 打开与系统当前cpu架构匹配的缓存文件，也就是/var/db/dyld/dyld_shared_cache_x86_64h, 接着读取缓存文件的前8192字节, 解析缓存头dyld_cache_header的信息, 将解析好的缓存信息存入mappings变量, 最后调用_shared_region_map_and_slide_np()完成真正的映射工作。</p>
<h5 id="checkVersionedPaths"><a href="#checkVersionedPaths" class="headerlink" title="checkVersionedPaths"></a>checkVersionedPaths</h5><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">checkVersionedPaths</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-comment">// search DYLD_VERSIONED_LIBRARY_PATH directories for dylibs and check if they are newer</span><br>	<span class="hljs-comment">// 读取DYLD_VERSIONED_LIBRARY_PATH环境变量 </span><br>	<span class="hljs-keyword">if</span> ( sEnv.DYLD_VERSIONED_LIBRARY_PATH != <span class="hljs-literal">NULL</span> ) &#123;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* <span class="hljs-keyword">const</span>* lp = sEnv.DYLD_VERSIONED_LIBRARY_PATH; *lp != <span class="hljs-literal">NULL</span>; ++lp) &#123;<br>			<span class="hljs-comment">// 判断是否需要覆盖当前目录下的库</span><br>			checkDylibOverridesInDir(*lp);<br>		&#125;<br>	&#125;<br>	<span class="hljs-comment">// 读取DYLD_VERSIONED_FRAMEWORK_PATH环境变量</span><br>	<span class="hljs-comment">// search DYLD_VERSIONED_FRAMEWORK_PATH directories for dylibs and check if they are newer</span><br>	<span class="hljs-keyword">if</span> ( sEnv.DYLD_VERSIONED_FRAMEWORK_PATH != <span class="hljs-literal">NULL</span> ) &#123;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* <span class="hljs-keyword">const</span>* fp = sEnv.DYLD_VERSIONED_FRAMEWORK_PATH; *fp != <span class="hljs-literal">NULL</span>; ++fp) &#123;<br>			<span class="hljs-comment">// 判断是否需要覆盖当前目录下的库</span><br>			checkFrameworkOverridesInDir(*fp);<br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="4、加载插入的动态库"><a href="#4、加载插入的动态库" class="headerlink" title="4、加载插入的动态库"></a>4、加载插入的动态库</h4><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 遍历 `DYLD_INSERT_LIBRARIES` 环境变量, 调用`loadInsertedDylib`方法加载所有要插入的库,</span><br><span class="hljs-comment">// 这些库都被加入到`sAllImages`数组中</span><br><span class="hljs-keyword">if</span>	( sEnv.DYLD_INSERT_LIBRARIES != <span class="hljs-literal">NULL</span> ) &#123;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* <span class="hljs-keyword">const</span>* lib = sEnv.DYLD_INSERT_LIBRARIES; *lib != <span class="hljs-literal">NULL</span>; ++lib) <br>	 <span class="hljs-comment">// 这里传入的是每个lib的path</span><br>		loadInsertedDylib(*lib);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>上面的这段代码主要是：遍历sEnv.DYLD_INSERT_LIBRARIES所有要拆入的库(地址连续所以使用++获取地址)，然后调用了<code>loadInsertedDylib</code>方法进行加载插入的库。</p>
<p>下面我们来详细看下这个方法：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">loadInsertedDylib</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* path)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-comment">// 创建一个imageloader</span><br>	ImageLoader* image = <span class="hljs-literal">NULL</span>;<br>	<span class="hljs-keyword">try</span> &#123;<br>		LoadContext context;<br>		context.useSearchPaths		= <span class="hljs-literal">false</span>;<br>		context.useFallbackPaths	= <span class="hljs-literal">false</span>;<br>		context.useLdLibraryPath	= <span class="hljs-literal">false</span>;<br>		context.implicitRPath		= <span class="hljs-literal">false</span>;<br>		context.matchByInstallName	= <span class="hljs-literal">false</span>;<br>		context.dontLoad			= <span class="hljs-literal">false</span>;<br>		context.mustBeBundle		= <span class="hljs-literal">false</span>;<br>		context.mustBeDylib			= <span class="hljs-literal">true</span>;<br>		context.canBePIE			= <span class="hljs-literal">false</span>;<br>		context.origin				= <span class="hljs-literal">NULL</span>;	<span class="hljs-comment">// can&#x27;t use @loader_path with DYLD_INSERT_LIBRARIES</span><br>		context.rpath				= <span class="hljs-literal">NULL</span>;<br>		<span class="hljs-comment">// 根据外部传入的path和新建的context构造一个ImageLoader</span><br>		image = load(path, context);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>load</code>方法会先调用<code>loadPhase0</code>方法方式从文件加载，而<code>loadPhase0</code>又会调用<code>loadPhase1</code>或<code>loadPhase2</code>去加载，实际上调用层次没加一层都是在对应<code>load</code>方法的path参数后拼接了一层，是不断的完善path路径的过程：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1giw40xwfyuj31ai0e6766.jpg"></p>
<p>加载拆入的库后，还需要更新<code>sInsertedDylibCount</code>:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">sInsertedDylibCount = sAllImages.size()<span class="hljs-number">-1</span>;<br></code></pre></td></tr></table></figure>
<p>这里的-1操作实际上是排除主程序之外</p>
<h4 id="5、链接主程序"><a href="#5、链接主程序" class="headerlink" title="5、链接主程序"></a>5、链接主程序</h4><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 开始链接主程序, 此时主程序已经被加载到gLinkContext.mainExecutable中,</span><br>		<span class="hljs-comment">// 调用 link 链接主程序。内核调用的是ImageLoader::link 函数。</span><br>		gLinkContext.linkingMainExecutable = <span class="hljs-literal">true</span>;<br>		<span class="hljs-comment">// link方法</span><br>		link(sMainExecutable, sEnv.DYLD_BIND_AT_LAUNCH, <span class="hljs-literal">true</span>, ImageLoader::RPathChain(<span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>));<br>		<span class="hljs-comment">// 设置永不递归卸载</span><br>		sMainExecutable-&gt;setNeverUnloadRecursive();<br>		<span class="hljs-comment">// mach-o header中的MH_FORCE_FLAT</span><br>		<span class="hljs-keyword">if</span> ( sMainExecutable-&gt;forceFlat() ) &#123;<br>			gLinkContext.bindFlat = <span class="hljs-literal">true</span>;<br>			gLinkContext.prebindUsage = ImageLoader::kUseNoPrebinding;<br>		&#125;<br><br></code></pre></td></tr></table></figure>

<p>这一步就是将加载进来的二进制变为可用状态的过程：<code>rebase</code> =&gt; <code>binding</code></p>
<p><code>rebase</code>就是针对 “mach-o在加载到内存中不是固定的首地址” 这一现象做数据修正的过程。<br><code>binding</code>就是将这个二进制调用的外部符号进行绑定的过程。<br><code>lazyBinding</code>就是在加载动态库的时候不会立即binding, 当时当第一次调用这个方法的时候再实施binding。</p>
<p>例如我们objc代码中需要使用到NSObject, 即符号_OBJC_CLASS_$_NSObject，但是这个符号又不在我们的二进制中，在系统库 Foundation.framework中，因此就需要binding这个操作将对应关系绑定到一起。</p>
<h5 id="Link"><a href="#Link" class="headerlink" title="Link"></a>Link</h5><p>这一步我们主要是看<code>link</code>方法(简化版)：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ImageLoader::link</span><span class="hljs-params">(<span class="hljs-keyword">const</span> LinkContext&amp; context, <span class="hljs-keyword">bool</span> forceLazysBound, <span class="hljs-keyword">bool</span> preflightOnly, <span class="hljs-keyword">bool</span> neverUnload, <span class="hljs-keyword">const</span> RPathChain&amp; loaderRPaths)</span></span><br><span class="hljs-function"></span>&#123;<br>   <span class="hljs-comment">// 递归加载库</span><br>	<span class="hljs-keyword">this</span>-&gt;recursiveLoadLibraries(context, preflightOnly, loaderRPaths);<br>	context.notifyBatch(dyld_image_state_dependents_mapped);<br>  <span class="hljs-comment">// 递归rebase</span><br> 	<span class="hljs-keyword">this</span>-&gt;recursiveRebase(context);<br>	context.notifyBatch(dyld_image_state_rebased);<br>  <span class="hljs-comment">// 递归bind</span><br> 	<span class="hljs-keyword">this</span>-&gt;recursiveBind(context, forceLazysBound, neverUnload);<br>   <br>	<span class="hljs-keyword">if</span> ( !context.linkingMainExecutable )<br>	   <span class="hljs-comment">// weakBind </span><br>		<span class="hljs-keyword">this</span>-&gt;weakBind(context);<br><br>	context.notifyBatch(dyld_image_state_bound);<br><br>	<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;DOFInfo&gt; dofs;<br>	<span class="hljs-comment">// 递归获取DOFSection</span><br>	<span class="hljs-keyword">this</span>-&gt;recursiveGetDOFSections(context, dofs);<br>	context.registerDOFs(dofs);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>经过link操作后主程序达到了一个可用的状态。</p>
<h4 id="6、链接插入的动态库"><a href="#6、链接插入的动态库" class="headerlink" title="6、链接插入的动态库"></a>6、链接插入的动态库</h4><p>在链接主程序后链接插入的动态库，因此所有插入的动态库都会在系统使用的动态库后面。</p>
<p>与链接主程序相同，拆入的动态库也是通过调用link方法进行链接：</p>
<h5 id="link"><a href="#link" class="headerlink" title="link"></a>link</h5><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// sInsertedDylibCount 插入动态库的个数</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i &lt; sInsertedDylibCount; ++i) &#123;<br>				ImageLoader* image = sAllImages[i+<span class="hljs-number">1</span>];<br>				<span class="hljs-comment">// 链接</span><br>				link(image, sEnv.DYLD_BIND_AT_LAUNCH, <span class="hljs-literal">true</span>, ImageLoader::RPathChain(<span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>));<br>				<span class="hljs-comment">// </span><br>				image-&gt;setNeverUnloadRecursive();<br>			&#125;<br></code></pre></td></tr></table></figure>
<p>sInsertedDylibCount表示前期通过调用addImage方法插入到sAllImages的动态库的个数，遍历每一个拆入的动态库<code>注意</code>：这里sAllImages的下标是从1开始的，因为第0个位置存放的是主程序。</p>
<h5 id="registerInterposing"><a href="#registerInterposing" class="headerlink" title="registerInterposing"></a>registerInterposing</h5><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ImageLoaderMachO::registerInterposing</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-comment">// mach-o files advertise interposing by having a __DATA __interpose section</span><br>	<span class="hljs-comment">// 这个方法是要操作 Mach-O文件的__DATA__区</span><br>	<span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">load_command</span>* <span class="hljs-title">const</span> <span class="hljs-title">cmds</span> = (<span class="hljs-title">struct</span> <span class="hljs-title">load_command</span>*)&amp;<span class="hljs-title">fMachOData</span>[<span class="hljs-title">sizeof</span>(<span class="hljs-title">macho_header</span>)];</span><br>	<span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">load_command</span>* <span class="hljs-title">cmd</span> = <span class="hljs-title">cmds</span>;</span><br>	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">uint32_t</span> i = <span class="hljs-number">0</span>; i &lt; cmd_count; ++i) &#123;<br>		<span class="hljs-keyword">switch</span> (cmd-&gt;cmd) &#123;<br>			<span class="hljs-comment">// 找到load_commands中的LC_SEGMENT_COMMAND</span><br>			<span class="hljs-keyword">case</span> LC_SEGMENT_COMMAND:<br>				&#123;<br><br>					<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> struct macho_section* sect=sectionsStart; sect &lt; sectionsEnd; ++sect) &#123;<br>						<span class="hljs-comment">// 查找__DATA段的__interpose节区</span><br>						<span class="hljs-keyword">if</span> ( ((sect-&gt;flags &amp; SECTION_TYPE) == S_INTERPOSING) || ((<span class="hljs-built_in">strcmp</span>(sect-&gt;sectname, <span class="hljs-string">&quot;__interpose&quot;</span>) == <span class="hljs-number">0</span>) &amp;&amp; (<span class="hljs-built_in">strcmp</span>(seg-&gt;segname, <span class="hljs-string">&quot;__DATA&quot;</span>) == <span class="hljs-number">0</span>)) ) &#123;<br><br>							<span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i=<span class="hljs-number">0</span>; i &lt; count; ++i) &#123;<br><br>								<span class="hljs-comment">// 找到需要应用插入操作(也可以叫作符号地址替换)的数据</span><br>								<span class="hljs-keyword">if</span> ( <span class="hljs-keyword">this</span>-&gt;containsAddress((<span class="hljs-keyword">void</span>*)tuple.replacement) ) &#123;<br><br>									<span class="hljs-comment">// 将要替换的符号与被替换的符号信息存入fgInterposingTuples列表中, 供以后具体符号替换时查询</span><br>									ImageLoader::fgInterposingTuples.push_back(tuple);<br>								&#125;<br>							&#125;<br>						&#125;<br>					&#125;<br>				&#125;<br>				<span class="hljs-keyword">break</span>;<br>		&#125;<br>		cmd = (<span class="hljs-keyword">const</span> struct load_command*)(((<span class="hljs-keyword">char</span>*)cmd)+cmd-&gt;cmdsize);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>registerInterposing()查找__DATA段的__interpose节区, 找到需要应用插入操作(也可以叫作符号地址替换)的数据, 然后做一些检查后, 将要替换的符号与被替换的符号信息存入fgInterposingTuples列表中, 供以后具体符号替换时查询(applyInterposing中会用到)。</p>
<h5 id="applyInterposing"><a href="#applyInterposing" class="headerlink" title="applyInterposing"></a>applyInterposing</h5><p><code>applyInterposing()</code> -&gt; <code>recursiveApplyInterposing()</code> -&gt; <code>doInterpose()</code> -&gt; <code>eachBind()</code> -&gt; <code>interposeAt()</code></p>
<p>下面看下<code>interposeAt</code>方法：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">uintptr_t</span> <span class="hljs-title">ImageLoaderMachOCompressed::interposeAt</span><span class="hljs-params">(<span class="hljs-keyword">const</span> LinkContext&amp; context, <span class="hljs-keyword">uintptr_t</span> addr, <span class="hljs-keyword">uint8_t</span> type, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>*, </span></span><br><span class="hljs-function"><span class="hljs-params">												<span class="hljs-keyword">uint8_t</span>, <span class="hljs-keyword">intptr_t</span>, <span class="hljs-keyword">long</span>, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>*, LastLookup*, <span class="hljs-keyword">bool</span> runResolver)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">if</span> ( type == BIND_TYPE_POINTER ) &#123;<br>		<span class="hljs-keyword">uintptr_t</span>* fixupLocation = (<span class="hljs-keyword">uintptr_t</span>*)addr;<br>		<span class="hljs-keyword">uintptr_t</span> curValue = *fixupLocation;<br>		<span class="hljs-keyword">uintptr_t</span> newValue = interposedAddress(context, curValue, <span class="hljs-keyword">this</span>);<br>		<span class="hljs-keyword">if</span> ( newValue != curValue)<br>			*fixupLocation = newValue;<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这个方法的实现很简单就是对比了新值和旧值 如果不同就将对应地址的值改为新值。</p>
<h4 id="7-执行弱符号绑定"><a href="#7-执行弱符号绑定" class="headerlink" title="7 执行弱符号绑定"></a>7 执行弱符号绑定</h4><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ImageLoader::weakBind</span><span class="hljs-params">(<span class="hljs-keyword">const</span> LinkContext&amp; context)</span></span><br><span class="hljs-function"></span>&#123;<br>	ImageLoader* imagesNeedingCoalescing[fgImagesRequiringCoalescing];<br>	<span class="hljs-comment">// 将sAllImages中所有含有弱符号的映像合并成一个列表</span><br>	<span class="hljs-keyword">int</span> count = context.getCoalescedImages(imagesNeedingCoalescing);<br>	<span class="hljs-comment">// don&#x27;t need to do any coalescing if only one image has overrides, or all have already been done</span><br>	<span class="hljs-comment">// 如果进行weakbind的镜像个数&gt;0</span><br>	<span class="hljs-keyword">if</span> ( (countOfImagesWithWeakDefinitionsNotInSharedCache &gt; <span class="hljs-number">0</span>) &amp;&amp; (countNotYetWeakBound &gt; <span class="hljs-number">0</span>) ) &#123;<br>		<span class="hljs-comment">// make symbol iterators for each</span><br>		ImageLoader::CoalIterator iterators[count];<br>		ImageLoader::CoalIterator* sortedIts[count];<br>		<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i &lt; count; ++i) &#123;<br>			<span class="hljs-comment">// 对镜像进行排序</span><br>			imagesNeedingCoalescing[i]-&gt;initializeCoalIterator(iterators[i], i);<br>			sortedIts[i] = &amp;iterators[i];<br>		&#125;<br><br>		<span class="hljs-keyword">int</span> doneCount = <span class="hljs-number">0</span>;<br>		<span class="hljs-keyword">while</span> ( doneCount != count ) &#123;<br>			<span class="hljs-comment">// 收集需要进行绑定的弱符号</span><br>			<span class="hljs-comment">// 该函数读取映像动态链接信息的weak_bind_off与weak_bind_size来确定弱符号的数据偏移与大小,然后挨个计算它们的地址信息</span><br>			<span class="hljs-keyword">if</span> ( sortedIts[<span class="hljs-number">0</span>]-&gt;image-&gt;incrementCoalIterator(*sortedIts[<span class="hljs-number">0</span>]) )<br>				++doneCount;<br>			<span class="hljs-comment">// process all matching symbols just before incrementing the lowest one that matches</span><br>			<span class="hljs-keyword">if</span> ( sortedIts[<span class="hljs-number">0</span>]-&gt;symbolMatches &amp;&amp; !sortedIts[<span class="hljs-number">0</span>]-&gt;done ) &#123;<br><br>				ImageLoader* targetImage = <span class="hljs-literal">NULL</span>;<br>				<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i &lt; count; ++i) &#123;<br>					<span class="hljs-keyword">if</span> ( <span class="hljs-built_in">strcmp</span>(iterators[i].symbolName, nameToCoalesce) == <span class="hljs-number">0</span> ) &#123;<br>						<span class="hljs-keyword">if</span> ( iterators[i].weakSymbol ) &#123;<br>							<span class="hljs-keyword">if</span> ( targetAddr == <span class="hljs-number">0</span> ) &#123;<br>								<span class="hljs-comment">// 按照映像的加载顺序在导出表中查找符号的地址</span><br>								targetAddr = iterators[i].image-&gt;getAddressCoalIterator(iterators[i], context);<br>								<span class="hljs-keyword">if</span> ( targetAddr != <span class="hljs-number">0</span> )<br>									targetImage = iterators[i].image;<br>							&#125;<br>						&#125;<br>						<span class="hljs-keyword">else</span> &#123;<br>							targetAddr = iterators[i].image-&gt;getAddressCoalIterator(iterators[i], context);<br>							<span class="hljs-keyword">if</span> ( targetAddr != <span class="hljs-number">0</span> ) &#123;<br>								targetImage = iterators[i].image;<br>								<span class="hljs-comment">// strong implementation found, stop searching</span><br>								<span class="hljs-keyword">break</span>;<br>							&#125;<br>						&#125;<br>					&#125;<br>				&#125;<br><br>				<span class="hljs-comment">// tell each to bind to this symbol (unless already bound)</span><br>				<span class="hljs-keyword">if</span> ( targetAddr != <span class="hljs-number">0</span> ) &#123;<br>					<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i &lt; count; ++i) &#123;<br>						<span class="hljs-keyword">if</span> ( <span class="hljs-built_in">strcmp</span>(iterators[i].symbolName, nameToCoalesce) == <span class="hljs-number">0</span> ) &#123;<br>							<span class="hljs-comment">// 绑定操作</span><br>							<span class="hljs-comment">// 内部执行绑定的是bindLocation()</span><br>							iterators[i].image-&gt;updateUsesCoalIterator(iterators[i], targetAddr, targetImage, context);<br>					&#125;<br>				&#125;<br>				<br>			&#125;<br>		&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="8、执行初始化方法"><a href="#8、执行初始化方法" class="headerlink" title="8、执行初始化方法"></a>8、执行初始化方法</h4><p> 执行初始化方法, 其中<code>+load</code> 和constructor方法就是在这里执行。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// initializeMainExecutable 执行初始化方法，其中 +load 和 constructor 方法就是在这里执行。</span><br><span class="hljs-comment">// initializeMainExecutable 内部先调用了动态库的初始化方法，后调用主程序的初始化方法。</span><br><span class="hljs-comment">// 初始化主程序</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initializeMainExecutable</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-comment">// record that we&#x27;ve reached this step</span><br>	gLinkContext.startedInitializingMainExecutable = <span class="hljs-literal">true</span>;<br><br>	<span class="hljs-comment">// run initialzers for any inserted dylibs</span><br>	<span class="hljs-comment">// 给被插入的所有的 dylibs 进行初始化 -- 调用 initialzers</span><br>	ImageLoader::InitializerTimingList initializerTimes[sAllImages.size()];<br><br>	initializerTimes[<span class="hljs-number">0</span>].count = <span class="hljs-number">0</span>;<br><br>	<span class="hljs-keyword">const</span> <span class="hljs-keyword">size_t</span> rootCount = sImageRoots.size();<br>	<span class="hljs-keyword">if</span> ( rootCount &gt; <span class="hljs-number">1</span> ) &#123;<br>		<span class="hljs-comment">// 这里是下标1开始 排除掉了主程序的初始化</span><br>		<span class="hljs-keyword">for</span>(<span class="hljs-keyword">size_t</span> i=<span class="hljs-number">1</span>; i &lt; rootCount; ++i) &#123;<br>			<span class="hljs-comment">// 执行镜像的初始化方法</span><br>			<span class="hljs-comment">// 从 sImageRoots 中的第一个变量是 MainExcutable image, </span><br>			<span class="hljs-comment">// 因此这里初始化的时候需要跳过第一个数据, 对其他后面插入的dylib进行调用</span><br>			<span class="hljs-comment">// ImageLoader::runInitializers进行初始化</span><br>			sImageRoots[i]-&gt;runInitializers(gLinkContext, initializerTimes[<span class="hljs-number">0</span>]);<br>		&#125;<br>	&#125;<br>	<br>	<span class="hljs-comment">// run initializers for main executable and everything it brings up</span><br>	<span class="hljs-comment">// 调用主程序的初始化方法</span><br>	<span class="hljs-comment">// 单独对 main executable调用ImageLoader::runInitializers进行初始化</span><br>	sMainExecutable-&gt;runInitializers(gLinkContext, initializerTimes[<span class="hljs-number">0</span>]);<br>	<br>	<span class="hljs-comment">// register cxa_atexit() handler to run static terminators in all loaded images when this process exits</span><br>	<span class="hljs-keyword">if</span> ( gLibSystemHelpers != <span class="hljs-literal">NULL</span> ) <br>		(*gLibSystemHelpers-&gt;cxa_atexit)(&amp;runAllStaticTerminators, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);<br><br>	<span class="hljs-comment">// dump info if requested</span><br>	<span class="hljs-keyword">if</span> ( sEnv.DYLD_PRINT_STATISTICS )<br>		ImageLoaderMachO::printStatistics((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>)sAllImages.size(), initializerTimes[<span class="hljs-number">0</span>]);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这个方法主要是执行了ImageLoader的runInitializers方法，下面我看下这个方法的实现：</p>
<h5 id="runInitializers"><a href="#runInitializers" class="headerlink" title="runInitializers"></a>runInitializers</h5><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ImageLoader::runInitializers</span><span class="hljs-params">(<span class="hljs-keyword">const</span> LinkContext&amp; context, InitializerTimingList&amp; timingInfo)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">// 初始化当前 imageLoader 中的 image镜像的实际调用方法 ImageLoader::processInitializers</span><br>	processInitializers(context, thisThread, timingInfo, up);<br>	context.notifyBatch(dyld_image_state_initialized);<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="processInitializers"><a href="#processInitializers" class="headerlink" title="processInitializers"></a>processInitializers</h5><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ImageLoader::processInitializers</span><span class="hljs-params">(<span class="hljs-keyword">const</span> LinkContext&amp; context, <span class="hljs-keyword">mach_port_t</span> thisThread,</span></span><br><span class="hljs-function"><span class="hljs-params">									 InitializerTimingList&amp; timingInfo, ImageLoader::UninitedUpwards&amp; images)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 处理当前image依赖 dylib动态库, 调用 recursiveInitialization 方法!!!</span><br>	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">uintptr_t</span> i=<span class="hljs-number">0</span>; i &lt; images.count; ++i) &#123;<br>		images.images[i]-&gt;recursiveInitialization(context, thisThread, timingInfo, ups);<br>	&#125;<br>	<span class="hljs-comment">// If any upward dependencies remain, init them.</span><br>	<span class="hljs-keyword">if</span> ( ups.count &gt; <span class="hljs-number">0</span> )<br>		processInitializers(context, thisThread, timingInfo, ups);<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="recursiveInitialization"><a href="#recursiveInitialization" class="headerlink" title="recursiveInitialization"></a>recursiveInitialization</h5><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 递归调用 image 进行初始化, 先调用image依赖的image进行初始化. 直到自己</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ImageLoader::recursiveInitialization</span><span class="hljs-params">(<span class="hljs-keyword">const</span> LinkContext&amp; context, <span class="hljs-keyword">mach_port_t</span> this_thread,</span></span><br><span class="hljs-function"><span class="hljs-params">										  InitializerTimingList&amp; timingInfo, UninitedUpwards&amp; uninitUps)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 当前ImageLoader依赖的Image还没有初始化完, 进入if中, 如果执行完成, 直接返回</span><br>	<span class="hljs-keyword">if</span> ( fState &lt; dyld_image_state_dependents_initialized<span class="hljs-number">-1</span> ) &#123;<br>		<span class="hljs-keyword">uint8_t</span> oldState = fState;<br>		<span class="hljs-comment">// break cycles</span><br>		<span class="hljs-comment">// break cycles -&gt; 这是设置当前imageLoader的state接近依赖初始化.</span><br>		fState = dyld_image_state_dependents_initialized<span class="hljs-number">-1</span>;<br>		<span class="hljs-keyword">try</span> &#123;<br>			<span class="hljs-comment">// initialize lower level libraries first</span><br>			<span class="hljs-comment">// 首先初始化image底层的依赖库</span><br>			<span class="hljs-keyword">for</span>(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i &lt; libraryCount(); ++i) &#123;<br>				ImageLoader* dependentImage = libImage(i);<br>				<span class="hljs-keyword">if</span> ( dependentImage != <span class="hljs-literal">NULL</span> ) &#123;<br>					<span class="hljs-comment">// don&#x27;t try to initialize stuff &quot;above&quot; me yet</span><br>					<span class="hljs-keyword">if</span> ( libIsUpward(i) ) &#123;<br>						uninitUps.images[uninitUps.count] = dependentImage;<br>						uninitUps.count++;<br>					&#125;<br>					<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( dependentImage-&gt;fDepth &gt;= fDepth ) &#123;<br>					   <span class="hljs-comment">// 递归调用</span><br>						dependentImage-&gt;recursiveInitialization(context, this_thread, timingInfo, uninitUps);<br>					&#125;<br>                &#125;<br>			&#125;<br>			<br>			<span class="hljs-comment">// 到这里image底层的依赖库都递归调用, 初始化完成.</span><br>			<br>			<span class="hljs-comment">// let objc know we are about to initialize this image</span><br>			<span class="hljs-keyword">uint64_t</span> t1 = mach_absolute_time();<br>			fState = dyld_image_state_dependents_initialized;<br>			oldState = fState;<br>			<span class="hljs-comment">// 通知 runtime, 当前状态发生变化 -- image的依赖已经完全加载. </span><br>			<span class="hljs-comment">// 注意这里可能在runtime中注册了状态监听, 注册了callback函数, 当状态发送变化时,</span><br>			<span class="hljs-comment">// 会触发回调函数.</span><br>			context.notifySingle(dyld_image_state_dependents_initialized, <span class="hljs-keyword">this</span>);<br>			<br>			<span class="hljs-comment">// initialize this image</span><br>			<span class="hljs-comment">// 初始化当前image, `ImageLoaderMachO::doInitialization`方法内部会调用image  </span><br>			<span class="hljs-comment">// 的&quot;Initializer&quot;, 这是一个函数指针, 实际是image的初始化方法. 例如 </span><br>			<span class="hljs-comment">// `libSystem.dylib`, 它的初始化方法就比较特殊, 我们可以参考libSystem的init.c源</span><br>			<span class="hljs-comment">// 码, 内部的`libsystem_initializer`函数就是初始化真正调用的函数</span><br>			<br>			 <span class="hljs-comment">// _init_objc方法!!!!</span><br>			<span class="hljs-keyword">bool</span> hasInitializers = <span class="hljs-keyword">this</span>-&gt;doInitialization(context);<br><br>			<span class="hljs-comment">// let anyone know we finished initializing this image</span><br>			fState = dyld_image_state_initialized;<br>			oldState = fState;<br>			<span class="hljs-comment">//通知runtime, 档期那状态发送变化 -- image自己已经完成初始化!!!!</span><br>			context.notifySingle(dyld_image_state_initialized, <span class="hljs-keyword">this</span>);<br>			<br>			<span class="hljs-keyword">if</span> ( hasInitializers ) &#123;<br>				<span class="hljs-keyword">uint64_t</span> t2 = mach_absolute_time();<br>				timingInfo.images[timingInfo.count].image = <span class="hljs-keyword">this</span>;<br>				timingInfo.images[timingInfo.count].initTime = (t2-t1);<br>				timingInfo.count++;<br>			&#125;<br><br>		&#125;<br>		<span class="hljs-keyword">catch</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* msg) &#123;<br>			<span class="hljs-comment">// this image is not initialized</span><br>			fState = oldState;<br>			recursiveSpinUnLock();<br>			<span class="hljs-keyword">throw</span>;<br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="doInitialization"><a href="#doInitialization" class="headerlink" title="doInitialization"></a>doInitialization</h5><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">ImageLoaderMachO::doInitialization</span><span class="hljs-params">(<span class="hljs-keyword">const</span> LinkContext&amp; context)</span></span><br><span class="hljs-function"></span>&#123;<br>	CRSetCrashLogMessage2(<span class="hljs-keyword">this</span>-&gt;getPath());<br><br>	<span class="hljs-comment">// mach-o has -init and static initializers</span><br>	<span class="hljs-comment">// 调用Mach-O的 init 和  static initializers方法</span><br>	doImageInit(context);<br>	doModInitFunctions(context);<br>	<br>	CRSetCrashLogMessage2(<span class="hljs-literal">NULL</span>);<br>	<br>	<span class="hljs-keyword">return</span> (fHasDashInit || fHasInitializers);<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="doImageInit"><a href="#doImageInit" class="headerlink" title="doImageInit"></a>doImageInit</h5><p>获取mach-o的init方法的地址并调用</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ImageLoaderMachO::doImageInit</span><span class="hljs-params">(<span class="hljs-keyword">const</span> LinkContext&amp; context)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">if</span> ( fHasDashInit ) &#123;<br>		<span class="hljs-comment">// mach-o文件中指令的个数</span><br>		<span class="hljs-keyword">const</span> <span class="hljs-keyword">uint32_t</span> cmd_count = ((macho_header*)fMachOData)-&gt;ncmds;<br>		<span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">load_command</span>* <span class="hljs-title">const</span> <span class="hljs-title">cmds</span> = (<span class="hljs-title">struct</span> <span class="hljs-title">load_command</span>*)&amp;<span class="hljs-title">fMachOData</span>[<span class="hljs-title">sizeof</span>(<span class="hljs-title">macho_header</span>)];</span><br>		<span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">load_command</span>* <span class="hljs-title">cmd</span> = <span class="hljs-title">cmds</span>;</span><br>		<span class="hljs-comment">// 遍历指令</span><br>		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">uint32_t</span> i = <span class="hljs-number">0</span>; i &lt; cmd_count; ++i) &#123;<br>			<span class="hljs-keyword">switch</span> (cmd-&gt;cmd) &#123;<br>				<span class="hljs-keyword">case</span> LC_ROUTINES_COMMAND:<br>					<span class="hljs-comment">// 获取macho_routines_command的init_address</span><br>					Initializer func = (Initializer)(((struct macho_routines_command*)cmd)-&gt;init_address + fSlide);<br>					<span class="hljs-comment">// &lt;rdar://problem/8543820&amp;9228031&gt; verify initializers are in image</span><br>					<span class="hljs-keyword">if</span> ( ! <span class="hljs-keyword">this</span>-&gt;containsAddress((<span class="hljs-keyword">void</span>*)func) ) &#123;<br>						dyld::throwf(<span class="hljs-string">&quot;initializer function %p not in mapped image for %s\n&quot;</span>, func, <span class="hljs-keyword">this</span>-&gt;getPath());<br>					&#125;<br>					<span class="hljs-keyword">if</span> ( context.verboseInit )<br>						dyld::<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;dyld: calling -init function %p in %s\n&quot;</span>, func, <span class="hljs-keyword">this</span>-&gt;getPath());<br>					<span class="hljs-comment">// 执行-init方法</span><br>					func(context.argc, context.argv, context.envp, context.apple, &amp;context.programVars);<br>					<span class="hljs-keyword">break</span>;<br>			&#125;<br>			<span class="hljs-comment">// 计算下一个指令((char*)cmd)+cmd-&gt;cmdsize</span><br>			cmd = (<span class="hljs-keyword">const</span> struct load_command*)(((<span class="hljs-keyword">char</span>*)cmd)+cmd-&gt;cmdsize);<br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="doModInitFunctions"><a href="#doModInitFunctions" class="headerlink" title="doModInitFunctions"></a>doModInitFunctions</h5><p>获取mach-o的static initializer的地址并调用</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ImageLoaderMachO::doModInitFunctions</span><span class="hljs-params">(<span class="hljs-keyword">const</span> LinkContext&amp; context)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">if</span> ( fHasInitializers ) &#123;<br>		<span class="hljs-comment">// mach-o文件中指令的个数</span><br>		<span class="hljs-keyword">const</span> <span class="hljs-keyword">uint32_t</span> cmd_count = ((macho_header*)fMachOData)-&gt;ncmds;<br>		<span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">load_command</span>* <span class="hljs-title">const</span> <span class="hljs-title">cmds</span> = (<span class="hljs-title">struct</span> <span class="hljs-title">load_command</span>*)&amp;<span class="hljs-title">fMachOData</span>[<span class="hljs-title">sizeof</span>(<span class="hljs-title">macho_header</span>)];</span><br>		<span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">load_command</span>* <span class="hljs-title">cmd</span> = <span class="hljs-title">cmds</span>;</span><br>		<span class="hljs-comment">// 遍历所有的指令</span><br>		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">uint32_t</span> i = <span class="hljs-number">0</span>; i &lt; cmd_count; ++i) &#123;<br>			 <span class="hljs-comment">// 如果指令是Mach-o中的LC_SEGMENT_COMMAND</span><br>			<span class="hljs-keyword">if</span> ( cmd-&gt;cmd == LC_SEGMENT_COMMAND ) &#123;<br>				<span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">macho_segment_command</span>* <span class="hljs-title">seg</span> = (<span class="hljs-title">struct</span> <span class="hljs-title">macho_segment_command</span>*)<span class="hljs-title">cmd</span>;</span><br>				<span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">macho_section</span>* <span class="hljs-title">const</span> <span class="hljs-title">sectionsStart</span> = (<span class="hljs-title">struct</span> <span class="hljs-title">macho_section</span>*)((<span class="hljs-title">char</span>*)<span class="hljs-title">seg</span> + <span class="hljs-title">sizeof</span>(<span class="hljs-title">struct</span> <span class="hljs-title">macho_segment_command</span>));</span><br>				<span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">macho_section</span>* <span class="hljs-title">const</span> <span class="hljs-title">sectionsEnd</span> = &amp;<span class="hljs-title">sectionsStart</span>[<span class="hljs-title">seg</span>-&gt;<span class="hljs-title">nsects</span>];</span><br>				<span class="hljs-comment">// 从sectionsStart到sectionsEnd遍历所有的macho_section</span><br>				<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> struct macho_section* sect=sectionsStart; sect &lt; sectionsEnd; ++sect) &#123;<br>					<span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> type = sect-&gt;flags &amp; SECTION_TYPE;<br>					<span class="hljs-comment">//</span><br>					<span class="hljs-keyword">if</span> ( type == S_MOD_INIT_FUNC_POINTERS ) &#123;<br>						Initializer* inits = (Initializer*)(sect-&gt;addr + fSlide);<br>						<span class="hljs-keyword">const</span> <span class="hljs-keyword">size_t</span> count = sect-&gt;size / <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">uintptr_t</span>);<br>						<span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i=<span class="hljs-number">0</span>; i &lt; count; ++i) &#123;<br>							<span class="hljs-comment">// 获取到Initializer方法</span><br>							Initializer func = inits[i];<br>							<span class="hljs-comment">// &lt;rdar://problem/8543820&amp;9228031&gt; verify initializers are in image</span><br>							<span class="hljs-keyword">if</span> ( ! <span class="hljs-keyword">this</span>-&gt;containsAddress((<span class="hljs-keyword">void</span>*)func) ) &#123;<br>								dyld::throwf(<span class="hljs-string">&quot;initializer function %p not in mapped image for %s\n&quot;</span>, func, <span class="hljs-keyword">this</span>-&gt;getPath());<br>							&#125;<br>							<span class="hljs-keyword">if</span> ( context.verboseInit )<br>								dyld::<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;dyld: calling initializer function %p in %s\n&quot;</span>, func, <span class="hljs-keyword">this</span>-&gt;getPath());<br>							<span class="hljs-comment">// 执行initializer方法</span><br>							func(context.argc, context.argv, context.envp, context.apple, &amp;context.programVars);<br>						&#125;<br>					&#125;<br>				&#125;<br>			&#125;<br>			<span class="hljs-comment">// 根据指令的地址+指令大小获取到下一个指令</span><br>			cmd = (<span class="hljs-keyword">const</span> struct load_command*)(((<span class="hljs-keyword">char</span>*)cmd)+cmd-&gt;cmdsize);<br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>


<h4 id="9、查找APP入口点并返回"><a href="#9、查找APP入口点并返回" class="headerlink" title="9、查找APP入口点并返回"></a>9、查找APP入口点并返回</h4><p>这一步也是最后一步主要功能为：<br>查找到main函数的地址，并返回。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 9 查找APP入口点并返回</span><br>		result = (<span class="hljs-keyword">uintptr_t</span>)sMainExecutable-&gt;getThreadPC();<br>		<span class="hljs-keyword">if</span> ( result != <span class="hljs-number">0</span> ) &#123;<br>			<span class="hljs-comment">// main executable uses LC_MAIN, needs to return to glue in libdyld.dylib</span><br>			<span class="hljs-keyword">if</span> ( (gLibSystemHelpers != <span class="hljs-literal">NULL</span>) &amp;&amp; (gLibSystemHelpers-&gt;version &gt;= <span class="hljs-number">9</span>) )<br>				*startGlue = (<span class="hljs-keyword">uintptr_t</span>)gLibSystemHelpers-&gt;startGlueToCallExit;<br>			<span class="hljs-keyword">else</span><br>				halt(<span class="hljs-string">&quot;libdyld.dylib support not present for LC_MAIN&quot;</span>);<br>		&#125;<br>		<span class="hljs-keyword">else</span> &#123;<br>			<span class="hljs-comment">// main executable uses LC_UNIXTHREAD, dyld needs to let &quot;start&quot; in program set up for main()</span><br>			result = (<span class="hljs-keyword">uintptr_t</span>)sMainExecutable-&gt;getMain();<br>			*startGlue = <span class="hljs-number">0</span>;<br>		&#125;<br></code></pre></td></tr></table></figure>

<h5 id="getThreadPC"><a href="#getThreadPC" class="headerlink" title="getThreadPC"></a>getThreadPC</h5><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 查找主程序的LC_MAIN加载命令获取程序的入口点,</span><br><span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-title">ImageLoaderMachO::getThreadPC</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">const</span> <span class="hljs-keyword">uint32_t</span> cmd_count = ((macho_header*)fMachOData)-&gt;ncmds;<br>	<span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">load_command</span>* <span class="hljs-title">const</span> <span class="hljs-title">cmds</span> = (<span class="hljs-title">struct</span> <span class="hljs-title">load_command</span>*)&amp;<span class="hljs-title">fMachOData</span>[<span class="hljs-title">sizeof</span>(<span class="hljs-title">macho_header</span>)];</span><br>	<span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">load_command</span>* <span class="hljs-title">cmd</span> = <span class="hljs-title">cmds</span>;</span><br>	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">uint32_t</span> i = <span class="hljs-number">0</span>; i &lt; cmd_count; ++i) &#123;<br>		<span class="hljs-keyword">if</span> ( cmd-&gt;cmd == LC_MAIN ) &#123;<br>			entry_point_command* mainCmd = (entry_point_command*)cmd;<br>			<span class="hljs-keyword">void</span>* entry = (<span class="hljs-keyword">void</span>*)(mainCmd-&gt;entryoff + (<span class="hljs-keyword">char</span>*)fMachOData);<br>			<span class="hljs-comment">// &lt;rdar://problem/8543820&amp;9228031&gt; verify entry point is in image</span><br>			<span class="hljs-keyword">if</span> ( <span class="hljs-keyword">this</span>-&gt;containsAddress(entry) )<br>				<span class="hljs-keyword">return</span> entry;<br>			<span class="hljs-keyword">else</span><br>				<span class="hljs-keyword">throw</span> <span class="hljs-string">&quot;LC_MAIN entryoff is out of range&quot;</span>;<br>		&#125;<br>		cmd = (<span class="hljs-keyword">const</span> struct load_command*)(((<span class="hljs-keyword">char</span>*)cmd)+cmd-&gt;cmdsize);<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>该方法遍历了Load Commands 找到LC_MAIN命令的入口点地址返回，这个地址就是main函数的地址</p>
<h5 id="getMain"><a href="#getMain" class="headerlink" title="getMain"></a>getMain</h5><p>如果getThreadPC没有找到LC_MAIN的入口地址</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 在LC_UNIXTHREAD加载命令中去找, 找到后就跳到入口点指定的地址</span><br><span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-title">ImageLoaderMachO::getMain</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">const</span> <span class="hljs-keyword">uint32_t</span> cmd_count = ((macho_header*)fMachOData)-&gt;ncmds;<br>	<span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">load_command</span>* <span class="hljs-title">const</span> <span class="hljs-title">cmds</span> = (<span class="hljs-title">struct</span> <span class="hljs-title">load_command</span>*)&amp;<span class="hljs-title">fMachOData</span>[<span class="hljs-title">sizeof</span>(<span class="hljs-title">macho_header</span>)];</span><br>	<span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">load_command</span>* <span class="hljs-title">cmd</span> = <span class="hljs-title">cmds</span>;</span><br>	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">uint32_t</span> i = <span class="hljs-number">0</span>; i &lt; cmd_count; ++i) &#123;<br>		<span class="hljs-keyword">switch</span> (cmd-&gt;cmd) &#123;<br>			<span class="hljs-keyword">case</span> LC_UNIXTHREAD:<br>			&#123;<br>			<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> __i386__</span><br>				<span class="hljs-keyword">const</span> <span class="hljs-keyword">i386_thread_state_t</span>* registers = (<span class="hljs-keyword">i386_thread_state_t</span>*)(((<span class="hljs-keyword">char</span>*)cmd) + <span class="hljs-number">16</span>);<br>				<span class="hljs-keyword">void</span>* entry = (<span class="hljs-keyword">void</span>*)(registers-&gt;eip + fSlide);<br>			<span class="hljs-meta">#<span class="hljs-meta-keyword">elif</span> __x86_64__</span><br>				<span class="hljs-keyword">const</span> <span class="hljs-keyword">x86_thread_state64_t</span>* registers = (<span class="hljs-keyword">x86_thread_state64_t</span>*)(((<span class="hljs-keyword">char</span>*)cmd) + <span class="hljs-number">16</span>);<br>				<span class="hljs-keyword">void</span>* entry = (<span class="hljs-keyword">void</span>*)(registers-&gt;rip + fSlide);<br>			<span class="hljs-meta">#<span class="hljs-meta-keyword">elif</span> __arm__</span><br>				<span class="hljs-keyword">const</span> <span class="hljs-keyword">arm_thread_state_t</span>* registers = (<span class="hljs-keyword">arm_thread_state_t</span>*)(((<span class="hljs-keyword">char</span>*)cmd) + <span class="hljs-number">16</span>);<br>				<span class="hljs-keyword">void</span>* entry = (<span class="hljs-keyword">void</span>*)(registers-&gt;__pc + fSlide);<br>			<span class="hljs-meta">#<span class="hljs-meta-keyword">elif</span> __arm64__</span><br>				<span class="hljs-keyword">const</span> <span class="hljs-keyword">arm_thread_state64_t</span>* registers = (<span class="hljs-keyword">arm_thread_state64_t</span>*)(((<span class="hljs-keyword">char</span>*)cmd) + <span class="hljs-number">16</span>);<br>				<span class="hljs-keyword">void</span>* entry = (<span class="hljs-keyword">void</span>*)(registers-&gt;__pc + fSlide);<br>			<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><br>				<span class="hljs-meta">#<span class="hljs-meta-keyword">warning</span> need processor specific code</span><br>			<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>				<span class="hljs-comment">// &lt;rdar://problem/8543820&amp;9228031&gt; verify entry point is in image</span><br>				<span class="hljs-keyword">if</span> ( <span class="hljs-keyword">this</span>-&gt;containsAddress(entry) ) &#123;<br>					<span class="hljs-keyword">return</span> entry;<br>				&#125;<br>			&#125;<br>			<span class="hljs-keyword">break</span>;<br>		&#125;<br>		cmd = (<span class="hljs-keyword">const</span> struct load_command*)(((<span class="hljs-keyword">char</span>*)cmd)+cmd-&gt;cmdsize);<br>	&#125;<br>	<span class="hljs-keyword">throw</span> <span class="hljs-string">&quot;no valid entry point&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="objc-init"><a href="#objc-init" class="headerlink" title="objc_init"></a>objc_init</h3><p>从上面的步骤描述中我们知道实际上objc_init是在<code>ImageLoaderMachO::doModInitFunctions</code>时就被调用了，我们先来看代码</p>
<h4 id="doModInitFunctions-1"><a href="#doModInitFunctions-1" class="headerlink" title="doModInitFunctions"></a>doModInitFunctions</h4><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// doModInitFunctions方法部分代码</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ImageLoaderMachO::doModInitFunctions</span><span class="hljs-params">(<span class="hljs-keyword">const</span> LinkContext&amp; context)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i=<span class="hljs-number">0</span>; i &lt; count; ++i) &#123;<br>		<span class="hljs-comment">// 获取到Initializer方法</span><br>		Initializer func = inits[i];<br>		<span class="hljs-comment">// &lt;rdar://problem/8543820&amp;9228031&gt; verify initializers are in image</span><br>		<span class="hljs-keyword">if</span> ( ! <span class="hljs-keyword">this</span>-&gt;containsAddress((<span class="hljs-keyword">void</span>*)func) ) &#123;<br>			dyld::throwf(<span class="hljs-string">&quot;initializer function %p not in mapped image for %s\n&quot;</span>, func, <span class="hljs-keyword">this</span>-&gt;getPath());<br>		&#125;<br>		<span class="hljs-keyword">if</span> ( context.verboseInit )<br>			dyld::<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;dyld: calling initializer function %p in %s\n&quot;</span>, func, <span class="hljs-keyword">this</span>-&gt;getPath());<br>		<span class="hljs-comment">// 执行initializer方法</span><br>		func(context.argc, context.argv, context.envp, context.apple, &amp;context.programVars);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>doModInitFunctions</code>方法实际上调用了<code>Initializer</code>方法，对对一个动态库进行初始化是通过<code>_libdispatch_init</code>方法进行的 我们来看下这个方法：</p>
<h4 id="libdispatch-init"><a href="#libdispatch-init" class="headerlink" title="_libdispatch_init"></a>_libdispatch_init</h4><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">void</span><br>libdispatch_init(<span class="hljs-keyword">void</span>)<br>&#123;<br><br>	_dispatch_hw_config_init();<br>	_dispatch_time_init();<br>	_dispatch_vtable_init();<br>	_os_object_init();<br>	_voucher_init();<br>	_dispatch_introspection_init();<br>&#125;<br></code></pre></td></tr></table></figure>
<p>上面的方法我们看到，其中调用了<code>_os_object_init</code>方法，然后我们在看下这个方法的实现：</p>
<h4 id="os-object-init"><a href="#os-object-init" class="headerlink" title="_os_object_init"></a>_os_object_init</h4><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">void</span><br>_os_object_init(<span class="hljs-keyword">void</span>)<br>&#123;<br>   <span class="hljs-comment">// 省略....</span><br>	_objc_init();<br>	<span class="hljs-comment">// 省略....</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>从上面的代码中我们看到，在<code>_os_object_init</code>方法中调用了我们熟知的<code>_objc_init</code>方法，至此运行时就开始。</p>
<h4 id="objc-init-1"><a href="#objc-init-1" class="headerlink" title="_objc_init"></a>_objc_init</h4><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">void</span> _objc_init(<span class="hljs-keyword">void</span>)<br>&#123;<br>  <span class="hljs-comment">// 省略代码...</span><br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	 仅供objc运行时使用，注册在映射、取消映射和初始化objc映像调用的处理程序。dyld将使用包含objc-image-info回调给`mapped`.</span><br><span class="hljs-comment">	 这些dylibs将自动引用计数，因此objc将不再需要调用dlopen()防止未加载。</span><br><span class="hljs-comment">	 在调用_dyld_objc_notify_register()期间，dyld将调用 `mapped` 在已经加载好 images，稍后dlopen()。</span><br><span class="hljs-comment">	 在调动init的时候也会调用`mapped`,在dyld调用的时候，也会调用init函数</span><br><span class="hljs-comment">	 </span><br><span class="hljs-comment">	 在调用任何images +load方法时候</span><br><span class="hljs-comment">	 */</span><br>    _dyld_objc_notify_register(&amp;map_images, load_images, unmap_image);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这个方法中，主要是注册了<code>map_images</code>，<code>load_images</code>方法.</p>
<h4 id="map-images"><a href="#map-images" class="headerlink" title="map_images"></a>map_images</h4><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">void</span> <br>map_images_nolock(<span class="hljs-keyword">unsigned</span> mhCount, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * <span class="hljs-keyword">const</span> mhPaths[],<br>                  <span class="hljs-keyword">const</span> struct mach_header * <span class="hljs-keyword">const</span> mhdrs[])<br>&#123;<br>    <span class="hljs-keyword">if</span> (hCount &gt; <span class="hljs-number">0</span>) &#123;<br>        _read_images(hList, hCount, totalClasses, unoptimizedTotalClasses);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="load-images"><a href="#load-images" class="headerlink" title="load_images"></a>load_images</h4><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">void</span><br>load_images(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *path __unused, <span class="hljs-keyword">const</span> struct mach_header *mh)<br>&#123;<br><br>    <span class="hljs-comment">// Discover load methods</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">mutex_locker_t</span> <span class="hljs-title">lock2</span><span class="hljs-params">(runtimeLock)</span></span>;<br>        <span class="hljs-comment">//加载 class+load 和category+load方法</span><br>        prepare_load_methods((<span class="hljs-keyword">const</span> headerType *)mh);<br>    &#125;<br><br>    <span class="hljs-comment">// Call +load methods (without runtimeLock - re-entrant)</span><br>    <span class="hljs-comment">//执行 class+load 和category+load方法</span><br>    call_load_methods();<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1giwwqno0z4j30u00uiqe5.jpg"></p>
<p>总结上述的整个过程便是在主工程的main函数开始执行之前系统做的所有操作，其中有一些步骤和环境我也不是太清楚，因此需要进一步的完善和梳理。</p>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://opensource.apple.com/tarballs/libdispatch/">libdispatch源码</a><br><a href="https://blog.cnbluebox.com/blog/2017/06/20/dyldyu-objc/">dyld与ObjC</a><br><a href="https://www.jianshu.com/p/d2eeb4085af5">iOS App启动时发生了什么?</a><br><a href="https://www.jianshu.com/p/d2eeb4085af5">dyld加载应用启动原理详解</a></p>
]]></content>
      <categories>
        <category>MACH-O</category>
      </categories>
      <tags>
        <tag>mach-o</tag>
      </tags>
  </entry>
  <entry>
    <title>ios网络基础与多线程</title>
    <url>/2018/03/26/ios%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<p>本文分为两个部分 第一部分将着重讲述跟网络有关的基础知识，包含但不止于网络模型、Socket、HTTP以及HTTPS基础知识。第二部分着重于iOS相关的多线程的基础内容GCD,NSOperation等</p>
<a id="more"></a>

<h2 id="常见名词"><a href="#常见名词" class="headerlink" title="常见名词"></a>常见名词</h2><ul>
<li><p>TCP/IP：网络上使用的网络协议簇，TCP是应用程序之间的通信，IP是计算机之间的通信</p>
</li>
<li><p>逻辑地址：协议软件配置的网络地址</p>
</li>
<li><p>物理地址：网络硬件相关的地址</p>
</li>
<li><p>IP地址：定位计算机设备的逻辑地址</p>
</li>
<li><p>端口：内部通道或地址，它在TCP/IP传输层和应用程序之间提供了一个接口</p>
</li>
<li><p>域名：与IP地址相关联的名字</p>
</li>
<li><p>路由器：通过逻辑地址转发数据的网络设备</p>
</li>
<li><p>局域网：LAN，小型网络</p>
</li>
<li><p>网关：连接LAN到大型网络的路由器</p>
</li>
<li><p>TCP：传输层中可靠的、面向连接的协议</p>
</li>
<li><p>UDP：传输层中不可靠、非面向连接协议</p>
</li>
<li><p>Socket：套接字</p>
</li>
<li><p>IPv4：TCP/IP协议簇中网络层协议IP的版本4（IP version 4），32位</p>
</li>
<li><p>IPv6：IPv4的下一个版本，号称可以为全世界的每一粒沙子编上一个网址，解决IPv4的网络资源地址有限问题，128位</p>
</li>
<li><p>IPv6-Only网络：运营商逐渐部署IPv6 DNS64/NAT64网络之后，设备被分配的地址变成IPv6的地址，依然可以通过此网络获取IPv4地址提供的内容。</p>
</li>
</ul>
<h2 id="网络模型"><a href="#网络模型" class="headerlink" title="网络模型"></a>网络模型</h2><h3 id="七层-OSI模型"><a href="#七层-OSI模型" class="headerlink" title="七层 OSI模型"></a>七层 OSI模型</h3><p><img src="https://www.processon.com/chart_image/5874486ce4b09f680a444685.png" alt="OSI"></p>
<h3 id="TCP-IP模型"><a href="#TCP-IP模型" class="headerlink" title="TCP/IP模型"></a>TCP/IP模型</h3><p><img src="https://www.processon.com/chart_image/58744d35e4b09f680a44d98b.png" alt="TCP/IP"></p>
<h3 id="TCP-IP模型层次结构"><a href="#TCP-IP模型层次结构" class="headerlink" title="TCP/IP模型层次结构"></a>TCP/IP模型层次结构</h3><p><img src="https://www.processon.com/chart_image/587450f3e4b09f680a45538f.png" alt="层次结构"></p>
<h3 id="工作流"><a href="#工作流" class="headerlink" title="工作流"></a>工作流</h3><p><img src="https://www.processon.com/chart_image/58744865e4b09f680a4445b9.png" alt="工作流"></p>
<h3 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h3><p>每个TCP、UDP数据段中都包含源端口和目标端口，有时我们把一个IP地址和一个端口号合称为一个套接字，一个套接字可唯一确定网络中每个TCP连接的双方(客户IP地址、客户端口号、服务器IP地址、服务器端口号)</p>
<p><img src="https://www.processon.com/chart_image/58745474e4b09f680a45ce9b.png" alt="socket"></p>
<blockquote>
<p>不同的应用层协议可能基于不同传输层协议，比如TCP<br>有的应用层协议可能占用了两个端口号，比如FTP<br>有的应用层协议使用了不同的传输层协议提供服务，比如DNS</p>
</blockquote>
<h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p>TCP会话通过三次握手初始化，目标是使数据段的发送和接收同步。</p>
<p><img src="https://www.processon.com/chart_image/5874600be4b087b19d58e611.png" alt="三次握手"></p>
<ul>
<li><p>第一次握手：主机A发送位码为syn＝1,随机产生seq number=1234567的数据包到服务器，主机B由SYN=1知道，A要求建立联机；</p>
</li>
<li><p>第二次握手：主机B收到请求后要确认联机信息，向A发送ack number=(主机A的seq+1),syn=1,ack=1,随机产生seq=7654321的包</p>
</li>
<li><p>第三次握手：主机A收到后检查ack number是否正确，即第一次发送的seq number+1,以及位码ack是否为1，若正确，主机A会再发送ack number=(主机B的seq+1),ack=1，主机B收到后确认seq值与ack=1则连接建立成功。</p>
</li>
</ul>
<h3 id="IPV6-Only"><a href="#IPV6-Only" class="headerlink" title="IPV6-Only"></a>IPV6-Only</h3><p><img src="https://www.processon.com/chart_image/5875f622e4b07c7a98ad1030.png" alt="IPV6-Only"></p>
<p><code>如果DNS判断IPV6地址不存在，那么会在去查询IPV4对应的地址是否存在</code></p>
<h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><p><img src="https://www.processon.com/chart_image/587470f4e4b09f680a47af4c.png" alt="HTTP"></p>
<h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><p><img src="https://camo.githubusercontent.com/746827a43b810029d15952adc33e62811e91bc58/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f323730323634362d633666313538623564346164343630322e6a70673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f363438" alt="HTTPS"></p>
<ul>
<li>1、就是用户发起请求，服务器响应后返回一个证书，证书中包含一些基本信息和公钥。</li>
<li>2、用户拿到证书后，去验证这个证书是否合法，不合法，则请求终止。</li>
<li>3、合法则生成一个随机数，作为对称加密的密钥，用服务器返回的公钥对这个随机数加密。然后返回给服务器。</li>
<li>4、服务器拿到加密后的随机数，利用私钥解密，然后再用解密后的随机数（对称密钥），把需要返回的数据加密，加密完成后数据传输给用户。</li>
<li>5、最后用户拿到加密的数据，用一开始的那个随机数（对称密钥），进行数据解密。整个过程完成。</li>
</ul>
<h2 id="HTTP-VS-HTTPS"><a href="#HTTP-VS-HTTPS" class="headerlink" title="HTTP VS HTTPS"></a>HTTP VS HTTPS</h2><p>HTTPS需要到CA申请证书，需要交费<br>HTTP信息是明文传输，HTTPS有SSL加密传输协议<br>HTTP端口是80，HTTPS端口是443<br>HTTPS协议握手阶段比较费时，页面加载时间增加50%，好点增加10-20%</p>
<h2 id="Socket-1"><a href="#Socket-1" class="headerlink" title="Socket"></a>Socket</h2><p>Socket是在应用层和传输层之间的一个抽象层，它把TCP/IP层复杂的操作抽象为几个简单的接口供应用层调用实现进程在网络中通信。</p>
<p><img src="https://www.processon.com/chart_image/5874775fe4b087b19d5a3de9.png" alt="Socket"></p>
<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><h3 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h3><p>进程（process），指的是一个正在运行中的可执行文件。每一个进程都拥有独立的虚拟内存空间和系统资源，包括端口权限等，且至少包含一个主线程和任意数量的辅助线程。另外，当一个进程的主线程退出时，这个进程就结束了；<br>线程（thread），指的是一个独立的代码执行路径，也就是说线程是代码执行路径的最小分支。在 iOS 中，线程的底层实现是基于 POSIX threads API 的，也就是我们常说的 pthreads ；<br>任务（task），指的是我们需要执行的工作，是一个抽象的概念，用通俗的话说，就是一段代码。</p>
<h2 id="Pthreads"><a href="#Pthreads" class="headerlink" title="Pthreads"></a>Pthreads</h2><p>基于C语言，移植性强</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#import <span class="hljs-meta-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-keyword">pthread_t</span> thread;<br>pthread_create(&amp;thread, <span class="hljs-literal">NULL</span>, start, <span class="hljs-literal">NULL</span>);<br></code></pre></td></tr></table></figure>

<h2 id="NSThread"><a href="#NSThread" class="headerlink" title="NSThread"></a>NSThread</h2><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-built_in">NSThread</span> *thread = [[<span class="hljs-built_in">NSThread</span> alloc] initWithTarget:<span class="hljs-keyword">self</span> selector:<span class="hljs-keyword">@selector</span>(run:) object:<span class="hljs-literal">nil</span>];<br>[thread start];<br></code></pre></td></tr></table></figure>

<h2 id="GCD"><a href="#GCD" class="headerlink" title="GCD"></a>GCD</h2><p>异步和同步最大的区别在于异步不会阻塞当前线程，是否等待block完成后返回</p>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><h4 id="1、系统标准两个队列"><a href="#1、系统标准两个队列" class="headerlink" title="1、系统标准两个队列"></a>1、系统标准两个队列</h4><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">//全局队列，一个并行的队列</span><br>dispatch_get_global_queue<br><span class="hljs-comment">//主队列，主线程中的唯一队列，一个串行队列</span><br>dispatch_get_main_queue<br></code></pre></td></tr></table></figure>

<h4 id="2、自定义队列"><a href="#2、自定义队列" class="headerlink" title="2、自定义队列"></a>2、自定义队列</h4><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">//串行队列</span><br>dispatch_queue_create(<span class="hljs-string">&quot;com.starming.serialqueue&quot;</span>, DISPATCH_QUEUE_SERIAL)<br><span class="hljs-comment">//并行队列</span><br>dispatch_queue_create(<span class="hljs-string">&quot;com.starming.concurrentqueue&quot;</span>, DISPATCH_QUEUE_CONCURRENT)<br></code></pre></td></tr></table></figure>

<h4 id="3、同步异步线程创建"><a href="#3、同步异步线程创建" class="headerlink" title="3、同步异步线程创建"></a>3、同步异步线程创建</h4><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">//同步线程</span><br><span class="hljs-built_in">dispatch_sync</span>(..., ^(block))<br><span class="hljs-comment">//异步线程</span><br><span class="hljs-built_in">dispatch_async</span>(..., ^(block))<br></code></pre></td></tr></table></figure>

<h3 id="队列（dispatch-queue）"><a href="#队列（dispatch-queue）" class="headerlink" title="队列（dispatch queue）"></a>队列（dispatch queue）</h3><p>Serial(串行队列)：又叫private dispatch queues，同时只执行一个任务。Serial queue常用于同步访问特定的资源或数据。当你创建多个Serial queue时，虽然各自是同步，但serial queue之间是并发执行。<br>Main dispatch queue(主队列)：全局可用的serial queue，在应用程序主线程上执行任务。<br>Concurrent(全局队列)：又叫global dispatch queue，可以并发的执行多个任务，但执行完成顺序是随机的。系统提供四个全局并发队列，这四个队列有这对应的优先级，用户是不能够创建全局队列的，只能获取。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">dipatch_queue_t queue;<br>queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH,<span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure>

<p>User create queue：创建自己定义的队列，可以用dispatch_queue_create函数，函数有两个参数，第一个自定义的队列名，第二个参数是队列类型，默认NULL或者DISPATCH_QUEUE_SERIAL的是串行，参数为DISPATCH_QUEUE_CONCURRENT为并行队列。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-built_in">dispatch_queue_t</span> queue<br>queue = dispatch_queue_create(<span class="hljs-string">&quot;com.starming.gcddemo.concurrentqueue&quot;</span>, DISPATCH_QUEUE_CONCURRENT);<br></code></pre></td></tr></table></figure>

<h4 id="自定义队列优先级"><a href="#自定义队列优先级" class="headerlink" title="自定义队列优先级"></a>自定义队列优先级</h4><p><code>dispatch_set_target_queue(dispatch_object_t object, dispatch_queue_t queue);</code></p>
<p><code>dispatch_set_target_queue</code> 函数有两个作用：</p>
<ul>
<li>第一，变更队列的执行优先级；</li>
<li>第二，目标队列可以成为原队列的执行阶层。<pre><code>  第一个参数是要执行变更的队列（不能指定主队列和全局队列）
  第二个参数是目标队列（指定全局队列）</code></pre>
</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">//优先级变更的串行队列，初始是默认优先级 NULL 默认是串行队列</span><br>    <span class="hljs-built_in">dispatch_queue_t</span> serialQueue = dispatch_queue_create(<span class="hljs-string">&quot;com.gcd.setTargetQueue.serialQueue&quot;</span>, <span class="hljs-literal">NULL</span>);<br>    <br>    <span class="hljs-comment">//优先级不变的串行队列（参照），初始是默认优先级</span><br>    <span class="hljs-built_in">dispatch_queue_t</span> serialDefaultQueue = dispatch_queue_create(<span class="hljs-string">&quot;com.gcd.setTargetQueue.serialDefaultQueue&quot;</span>, <span class="hljs-literal">NULL</span>);<br>    <br>    <span class="hljs-comment">//变更前</span><br>    <span class="hljs-built_in">dispatch_async</span>(serialQueue, ^&#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;1&quot;</span>);<br>    &#125;);<br>    <span class="hljs-built_in">dispatch_async</span>(serialDefaultQueue, ^&#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;2&quot;</span>);<br>    &#125;);<br>    <br>    <span class="hljs-comment">//获取优先级为后台优先级的全局队列</span><br>    <span class="hljs-built_in">dispatch_queue_t</span> globalDefaultQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, <span class="hljs-number">0</span>);<br>    <span class="hljs-comment">//变更优先级</span><br>    dispatch_set_target_queue(serialQueue, globalDefaultQueue);<br>    <br>    <span class="hljs-comment">//变更后 serialQueue 最低的优先级</span><br>    <span class="hljs-built_in">dispatch_async</span>(serialQueue, ^&#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;1&quot;</span>);<br>    &#125;);<br>    <span class="hljs-built_in">dispatch_async</span>(serialDefaultQueue, ^&#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;2&quot;</span>);<br>    &#125;);<br></code></pre></td></tr></table></figure>

<p>执行结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">2018-03-27 14:53:33.911110+0800 GCDTest[63921:39078159] 2<br>2018-03-27 14:53:33.911110+0800 GCDTest[63921:39078155] 1<br>2018-03-27 14:53:33.911240+0800 GCDTest[63921:39078159] 2<br>2018-03-27 14:53:33.911266+0800 GCDTest[63921:39078158] 1<br></code></pre></td></tr></table></figure>

<h3 id="队列类型"><a href="#队列类型" class="headerlink" title="队列类型"></a>队列类型</h3><p>5种队列，主队列（main queue）,四种通用调度队列，自己定制的队列。四种通用调度队列为</p>
<ul>
<li>QOS_CLASS_USER_INTERACTIVE：user interactive等级表示任务需要被立即执行提供好的体验，用来更新UI，响应事件等。这个等级最好保持小规模。</li>
<li>QOS_CLASS_USER_INITIATED：user initiated等级表示任务由UI发起异步执行。适用场景是需要及时结果同时又可以继续交互的时候。</li>
<li>QOS_CLASS_UTILITY：utility等级表示需要长时间运行的任务，伴有用户可见进度指示器。经常会用来做计算，I/O，网络，持续的数据填充等任务。这个任务节能。</li>
<li>QOS_CLASS_BACKGROUND：background等级表示用户不会察觉的任务，使用它来处理预加载，或者不需要用户交互和对时间不敏感的任务。</li>
</ul>
<h3 id="dispatch-once用法"><a href="#dispatch-once用法" class="headerlink" title="dispatch_once用法"></a>dispatch_once用法</h3><p>dispatch_once_t要是全局或static变量，保证dispatch_once_t只有一份实例</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">+ (<span class="hljs-keyword">instancetype</span>)shared<br>&#123;<br>    <span class="hljs-keyword">static</span> WMPayService *shared;<br>    <span class="hljs-keyword">static</span> <span class="hljs-built_in">dispatch_once_t</span> onceToken;<br>    <span class="hljs-built_in">dispatch_once</span>(&amp;onceToken, ^&#123;<br>        shared = [[<span class="hljs-keyword">self</span> alloc] init];<br>    &#125;);<br>    <span class="hljs-keyword">return</span> shared;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>最好可以做到手写单例</code></p>
<h3 id="dispatch-async"><a href="#dispatch-async" class="headerlink" title="dispatch_async"></a>dispatch_async</h3><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">//代码框架</span><br><span class="hljs-built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="hljs-number">0</span>), ^&#123;<br>     <span class="hljs-comment">// 耗时的操作</span><br>     <span class="hljs-built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;<br>          <span class="hljs-comment">// 更新界面</span><br>     &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure>

<h3 id="dispatch-after延后执行"><a href="#dispatch-after延后执行" class="headerlink" title="dispatch_after延后执行"></a>dispatch_after延后执行</h3><p><code>dispatch_after只是延时提交block，不是延时立刻执行。</code></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">- (<span class="hljs-keyword">void</span>)foo<br>&#123;<br>     <span class="hljs-keyword">double</span> delayInSeconds = <span class="hljs-number">2.0</span>;<br>     dispatch_time_t popTime = dispatch_time(DISPATCH_TIME_NOW, (int64_t) (delayInSeconds * <span class="hljs-built_in">NSEC_PER_SEC</span>));<br>     dispatch_after(popTime, dispatch_get_main_queue(), ^(<span class="hljs-keyword">void</span>)&#123;<br>          [<span class="hljs-keyword">self</span> bar];<br>     &#125;);<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="dispatch-apply进行快速迭代"><a href="#dispatch-apply进行快速迭代" class="headerlink" title="dispatch_apply进行快速迭代"></a>dispatch_apply进行快速迭代</h3><p>类似for循环，但是在并发队列的情况下dispatch_apply会并发执行block任务。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">- (void)applyTest<br>&#123;<br>    for (size_t y &#x3D; 0; y &lt; 10; ++y) &#123;<br>        for (size_t x &#x3D; 0; x &lt; 10; ++x) &#123;<br>            &#x2F;&#x2F; Do something with x and y here<br>        &#125;<br>    &#125;<br>    &#x2F;&#x2F;因为可以并行执行，所以使用dispatch_apply可以运行的更快<br>    dispatch_queue_t concurrentQueue &#x3D; dispatch_queue_create(&quot;com.starming.gcddemo.concurrentqueue&quot;, DISPATCH_QUEUE_CONCURRENT);<br>    dispatch_apply(10, concurrentQueue, ^(size_t i) &#123;<br>        NSLog(@&quot;%zu&quot;,i);<br>    &#125;);<br>    NSLog(@&quot;The end&quot;); &#x2F;&#x2F;这里有个需要注意的是，dispatch_apply这个是会阻塞主线程的。这个log打印会在dispatch_apply都结束后才开始执行<br>&#125;<br></code></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">2018-03-27 15:38:35.550890+0800 GCDTest[71235:39254293] 2<br>2018-03-27 15:38:35.550895+0800 GCDTest[71235:39254387] 6<br>2018-03-27 15:38:35.550892+0800 GCDTest[71235:39254375] 1<br>2018-03-27 15:38:35.550893+0800 GCDTest[71235:39254377] 5<br>2018-03-27 15:38:35.550892+0800 GCDTest[71235:39254376] 0<br>2018-03-27 15:38:35.550892+0800 GCDTest[71235:39254378] 3<br>2018-03-27 15:38:35.550893+0800 GCDTest[71235:39254379] 4<br>2018-03-27 15:38:35.550950+0800 GCDTest[71235:39254388] 7<br>2018-03-27 15:38:35.551024+0800 GCDTest[71235:39254293] 8<br>2018-03-27 15:38:35.551029+0800 GCDTest[71235:39254387] 9<br>2018-03-27 15:38:35.551520+0800 GCDTest[71235:39254293] The end<br></code></pre></td></tr></table></figure>


<h3 id="dispatch-group-t"><a href="#dispatch-group-t" class="headerlink" title="dispatch_group_t"></a>dispatch_group_t</h3><p>dispatch groups是专门用来监视多个异步任务。dispatch_group_t实例用来追踪不同队列中的不同任务</p>
<p>当group里所有事件都完成GCD API有两种方式发送通知，第一种是dispatch_group_wait，会阻塞当前进程，等所有任务都完成或等待超时。第二种方法是使用dispatch_group_notify，异步执行闭包，不会阻塞。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">- (<span class="hljs-keyword">void</span>)dispatchGroupWaitDemo &#123;<br>    <span class="hljs-built_in">dispatch_queue_t</span> concurrentQueue = dispatch_queue_create(<span class="hljs-string">&quot;com.starming.gcddemo.concurrentqueue&quot;</span>,DISPATCH_QUEUE_CONCURRENT);<br>    dispatch_group_t group = dispatch_group_create();<br>    <span class="hljs-comment">//在group中添加队列的block</span><br>    dispatch_group_async(group, concurrentQueue, ^&#123;<br>        [<span class="hljs-built_in">NSThread</span> sleepForTimeInterval:<span class="hljs-number">2.</span>f];<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;1&quot;</span>);<br>    &#125;);<br>    dispatch_group_async(group, concurrentQueue, ^&#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;2&quot;</span>);<br>    &#125;);<br>    <br>    dispatch_time_t time = dispatch_time(DISPATCH_TIME_NOW, <span class="hljs-number">2</span>*USEC_PER_SEC);<br>    dispatch_group_wait(group, time);<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;go on&quot;</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>输出结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">2018-03-27 16:14:44.160150+0800 GCDTest[72371:39397292] 2<br>2018-03-27 16:14:44.162394+0800 GCDTest[72371:39396970] go on<br>2018-03-27 16:14:46.163427+0800 GCDTest[72371:39397294] 1<br></code></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&#x2F;&#x2F;dispatch_group_notify<br>- (void)dispatchGroupNotifyDemo &#123;<br>    dispatch_queue_t concurrentQueue &#x3D; dispatch_queue_create(&quot;com.starming.gcddemo.concurrentqueue&quot;,DISPATCH_QUEUE_CONCURRENT);<br>    dispatch_group_t group &#x3D; dispatch_group_create();<br>    dispatch_group_async(group, concurrentQueue, ^&#123;<br>        sleep(2);<br>        NSLog(@&quot;1&quot;);<br>    &#125;);<br>    dispatch_group_async(group, concurrentQueue, ^&#123;<br>        NSLog(@&quot;2&quot;);<br>    &#125;);<br>    dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;<br>        NSLog(@&quot;end&quot;);<br>    &#125;);<br>    NSLog(@&quot;can continue&quot;);<br>    <br>&#125;<br></code></pre></td></tr></table></figure>

<p>输出结果:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">2018-03-27 16:13:58.912264+0800 GCDTest[72343:39394024] can continue<br>2018-03-27 16:13:58.912264+0800 GCDTest[72343:39394093] 2<br>2018-03-27 16:14:00.913552+0800 GCDTest[72343:39394099] 1<br>2018-03-27 16:14:00.913930+0800 GCDTest[72343:39394024] end<br></code></pre></td></tr></table></figure>

<h3 id="dispatch-block-cancel"><a href="#dispatch-block-cancel" class="headerlink" title="dispatch_block_cancel"></a>dispatch_block_cancel</h3><p>iOS8后GCD支持对dispatch block的取消</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">- (<span class="hljs-keyword">void</span>)dispatchBlockCancel &#123;<br>    <span class="hljs-built_in">dispatch_queue_t</span> serialQueue = dispatch_queue_create(<span class="hljs-string">&quot;com.starming.gcddemo.serialqueue&quot;</span>, DISPATCH_QUEUE_SERIAL);<br>    dispatch_block_t firstBlock = dispatch_block_create(<span class="hljs-number">0</span>, ^&#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;first block start&quot;</span>);<br>        [<span class="hljs-built_in">NSThread</span> sleepForTimeInterval:<span class="hljs-number">2.</span>f];<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;first block end&quot;</span>);<br>    &#125;);<br>    dispatch_block_t secondBlock = dispatch_block_create(<span class="hljs-number">0</span>, ^&#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;second block run&quot;</span>);<br>    &#125;);<br>    <span class="hljs-built_in">dispatch_async</span>(serialQueue, firstBlock);<br>    <span class="hljs-built_in">dispatch_async</span>(serialQueue, secondBlock);<br>    <span class="hljs-comment">//取消secondBlock</span><br>    dispatch_block_cancel(secondBlock);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">2018-03-27 16:13:24.401008+0800 GCDTest[72320:39391634] first block start<br>2018-03-27 16:13:26.403986+0800 GCDTest[72320:39391634] first block end<br></code></pre></td></tr></table></figure>

<h3 id="信号量-Dispatch-Semaphore"><a href="#信号量-Dispatch-Semaphore" class="headerlink" title="信号量(Dispatch Semaphore)"></a>信号量(Dispatch Semaphore)</h3><p>dispatch_semaphore_create：创建一个信号量（semaphore）<br>dispatch_semaphore_signal：信号通知，即让信号量+1<br>dispatch_semaphore_wait：等待，直到信号量大于0时，即可操作，同时将信号量-1</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">- (<span class="hljs-keyword">void</span>)semaphorTest &#123;<br>    <span class="hljs-comment">//crate的value表示，最多几个资源可访问</span><br>    dispatch_semaphore_t semaphore = dispatch_semaphore_create(<span class="hljs-number">2</span>);<br>    <span class="hljs-built_in">dispatch_queue_t</span> quene = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="hljs-number">0</span>);<br>    <br>    <span class="hljs-comment">//任务1</span><br>    <span class="hljs-built_in">dispatch_async</span>(quene, ^&#123;<br>        dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;run task 1&quot;</span>);<br>        sleep(<span class="hljs-number">2</span>);<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;complete task 1&quot;</span>);<br>        dispatch_semaphore_signal(semaphore);<br>    &#125;);<br>    <span class="hljs-comment">//任务2</span><br>    <span class="hljs-built_in">dispatch_async</span>(quene, ^&#123;<br>        dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;run task 2&quot;</span>);<br>        sleep(<span class="hljs-number">3</span>);<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;complete task 2&quot;</span>);<br>        dispatch_semaphore_signal(semaphore);<br>    &#125;);<br>    <span class="hljs-comment">//任务3</span><br>    <span class="hljs-built_in">dispatch_async</span>(quene, ^&#123;<br>        dispatch_semaphore_wait(semaphore, <span class="hljs-number">2</span>);<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;run task 3&quot;</span>);<br>        sleep(<span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;complete task 3&quot;</span>);<br>        dispatch_semaphore_signal(semaphore);<br>    &#125;);<br>    <br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;end&quot;</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">2018-03-27 16:12:41.938609+0800 GCDTest[72293:39388442] run task 2<br>2018-03-27 16:12:41.938612+0800 GCDTest[72293:39388438] run task 3<br>2018-03-27 16:12:41.938609+0800 GCDTest[72293:39388391] end<br>2018-03-27 16:12:41.938610+0800 GCDTest[72293:39388439] run task 1<br>2018-03-27 16:12:42.942686+0800 GCDTest[72293:39388438] complete task 3<br>2018-03-27 16:12:43.943696+0800 GCDTest[72293:39388439] complete task 1<br>2018-03-27 16:12:44.942998+0800 GCDTest[72293:39388442] complete task 2<br></code></pre></td></tr></table></figure>

<h3 id="dispatch-time-t"><a href="#dispatch-time-t" class="headerlink" title="dispatch_time_t"></a>dispatch_time_t</h3><p>用dispatch_after的时候就会用到dispatch_time_t变量，但是如何创建合适的时间呢？答案就是用dispatch_time函数，其原型如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">dispatch_time_t dispatch_time ( dispatch_time_t when, int64_t delta );<br></code></pre></td></tr></table></figure>
<blockquote>
<p>第一个参数一般是DISPATCH_TIME_NOW，表示从现在开始。<br>那么第二个参数就是真正的延时的具体时间</p>
</blockquote>
<p>这里要特别注意的是，delta参数是“纳秒！”，就是说，延时1秒的话，delta应该是“1000000000”=。=，太长了，所以理所当然系统提供了常量，如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> NSEC_PER_SEC 1000000000ull 纳秒</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> USEC_PER_SEC 1000000ull 微妙</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> NSEC_PER_USEC 1000ull 秒</span><br></code></pre></td></tr></table></figure>

<p>所以要延时一秒可以写成:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">dispatch_time(DISPATCH_TIME_NOW, <span class="hljs-number">1</span> * <span class="hljs-built_in">NSEC_PER_SEC</span>);<br>dispatch_time(DISPATCH_TIME_NOW, <span class="hljs-number">1000</span> * USEC_PER_SEC);<br>dispatch_time(DISPATCH_TIME_NOW, USEC_PER_SEC * <span class="hljs-built_in">NSEC_PER_USEC</span>);<br></code></pre></td></tr></table></figure>

<h3 id="dispatch-suspend-dispatch-resume"><a href="#dispatch-suspend-dispatch-resume" class="headerlink" title="dispatch_suspend dispatch_resume"></a>dispatch_suspend dispatch_resume</h3><p><code>dispatch_suspend != 立即停止队列的运行</code><br><code>dispatch_suspend</code>，<code>dispatch_resume</code>提供了“挂起、恢复”队列的功能，简单来说，就是可以暂停、恢复队列上的任务。但是这里的“挂起”，并不能保证可以立即停止队列上正在运行的block，看如下例子</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">- (<span class="hljs-keyword">void</span>)dispatch_suspendTest<br>&#123;<br>    <span class="hljs-built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="hljs-string">&quot;me.tutuge.test.gcd&quot;</span>, DISPATCH_QUEUE_SERIAL);<br>    <span class="hljs-comment">//提交第一个block，延时5秒打印。</span><br>    <span class="hljs-built_in">dispatch_async</span>(queue, ^&#123;<br>        [<span class="hljs-built_in">NSThread</span> sleepForTimeInterval:<span class="hljs-number">5</span>];<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;After 5 seconds...&quot;</span>);<br>    &#125;);<br>    <span class="hljs-comment">//提交第二个block，也是延时5秒打印</span><br>    <span class="hljs-built_in">dispatch_async</span>(queue, ^&#123;<br>        [<span class="hljs-built_in">NSThread</span> sleepForTimeInterval:<span class="hljs-number">5</span>];<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;After 5 seconds again...&quot;</span>);<br>    &#125;);<br>    <span class="hljs-comment">//延时一秒</span><br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;sleep 1 second...&quot;</span>);<br>    [<span class="hljs-built_in">NSThread</span> sleepForTimeInterval:<span class="hljs-number">1</span>];<br>    <span class="hljs-comment">//挂起队列</span><br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;suspend...&quot;</span>);<br>    dispatch_suspend(queue);<br>    <span class="hljs-comment">//延时10秒</span><br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;sleep 10 second...&quot;</span>);<br>    [<span class="hljs-built_in">NSThread</span> sleepForTimeInterval:<span class="hljs-number">10</span>];<br>    <span class="hljs-comment">//恢复队列</span><br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;resume...&quot;</span>);<br>    dispatch_resume(queue);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">2018-03-27 16:38:38.979600+0800 GCDTest[73048:39489499] sleep 1 second...<br>2018-03-27 16:38:39.980863+0800 GCDTest[73048:39489499] suspend...<br>2018-03-27 16:38:39.981146+0800 GCDTest[73048:39489499] sleep 10 second...<br>2018-03-27 16:38:43.984071+0800 GCDTest[73048:39489555] After 5 seconds...<br>2018-03-27 16:38:49.981099+0800 GCDTest[73048:39489499] resume...<br>2018-03-27 16:38:54.985417+0800 GCDTest[73048:39489554] After 5 seconds again...<br></code></pre></td></tr></table></figure>
<p><code>dispatch_suspend</code>并不会立即暂停正在运行的block，而是在当前block执行完成后，暂停后续的block执行</p>
<h3 id="GCD死锁"><a href="#GCD死锁" class="headerlink" title="GCD死锁"></a>GCD死锁</h3><p>当前串行队列里面同步执行当前串行队列就会死锁，解决的方法就是将同步的串行队列放到另外一个线程就能够解决。</p>
<h4 id="主队列的同步线程"><a href="#主队列的同步线程" class="headerlink" title="主队列的同步线程"></a>主队列的同步线程</h4><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">- (<span class="hljs-keyword">void</span>)deadLockCase1 &#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;1&quot;</span>);<br>    <span class="hljs-comment">//主队列的同步线程，按照FIFO的原则（先入先出），2排在3后面会等3执行完，但因为同步线程，3又要等2执行完，相互等待成为死锁。</span><br>    <span class="hljs-built_in">dispatch_sync</span>(dispatch_get_main_queue(), ^&#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;2&quot;</span>);<br>    &#125;);<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;3&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="http://og0h689k8.bkt.clouddn.com/18-3-27/81353906.jpg" alt="结果"></p>
<p>解决：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">- (<span class="hljs-keyword">void</span>)deadLockCase2 &#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;1&quot;</span>);<br>    <span class="hljs-comment">//3会等2，因为2在全局并行队列里，不需要等待3，这样2执行完回到主队列，3就开始执行</span><br>    <span class="hljs-built_in">dispatch_sync</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, <span class="hljs-number">0</span>), ^&#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;2&quot;</span>);<br>    &#125;);<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;3&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">2018-03-27 16:28:50.688138+0800 GCDTest[72824:39450961] 1<br>2018-03-27 16:28:50.688254+0800 GCDTest[72824:39450961] 2<br>2018-03-27 16:28:50.688336+0800 GCDTest[72824:39450961] 3<br></code></pre></td></tr></table></figure>

<h4 id="串行队列中同步执行"><a href="#串行队列中同步执行" class="headerlink" title="串行队列中同步执行"></a>串行队列中同步执行</h4><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">- (<span class="hljs-keyword">void</span>)deadLockCase3 &#123;<br>    <span class="hljs-built_in">dispatch_queue_t</span> serialQueue = dispatch_queue_create(<span class="hljs-string">&quot;com.starming.gcddemo.serialqueue&quot;</span>, DISPATCH_QUEUE_SERIAL);<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;1&quot;</span>);<br>    <span class="hljs-built_in">dispatch_async</span>(serialQueue, ^&#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;2&quot;</span>);<br>        <span class="hljs-comment">//串行队列里面同步一个串行队列就会死锁</span><br>        <span class="hljs-built_in">dispatch_sync</span>(serialQueue, ^&#123;<br>            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;3&quot;</span>);<br>        &#125;);<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;4&quot;</span>);<br>    &#125;);<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;5&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>结果也是死锁 解决方法如下</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">- (<span class="hljs-keyword">void</span>)deadLockCase4 &#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;1&quot;</span>);<br>    <span class="hljs-built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>), ^&#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;2&quot;</span>);<br>        <span class="hljs-comment">//将同步的串行队列放到另外一个线程就能够解决</span><br>        <span class="hljs-built_in">dispatch_sync</span>(dispatch_get_main_queue(), ^&#123;<br>            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;3&quot;</span>);<br>        &#125;);<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;4&quot;</span>);<br>    &#125;);<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;5&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="主线程被占用"><a href="#主线程被占用" class="headerlink" title="主线程被占用"></a>主线程被占用</h4><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><br>- (<span class="hljs-keyword">void</span>)deadLockCase5 &#123;<br>    <span class="hljs-built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>), ^&#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;1&quot;</span>);<br>        <span class="hljs-comment">//回到主线程发现死循环后面就没法执行了</span><br>        <span class="hljs-built_in">dispatch_sync</span>(dispatch_get_main_queue(), ^&#123;<br>            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;2&quot;</span>);<br>        &#125;);<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;3&quot;</span>);<br>    &#125;);<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;4&quot;</span>);<br>    <span class="hljs-comment">//死循环</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-comment">//</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="dispatch-barrier-async"><a href="#dispatch-barrier-async" class="headerlink" title="dispatch_barrier_async"></a>dispatch_barrier_async</h3><p>dispatch_barrier_async函数的作用与barrier的意思相同,在进程管理中起到一个栅栏的作用,它等待所有位于barrier函数之前的操作执行完毕后执行,并且在barrier函数执行之后,barrier函数之后的操作才会得到执行,该函数需要同dispatch_queue_create函数生成的concurrent Dispatch Queue队列一起使用</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">- (<span class="hljs-keyword">void</span>)barrier<br>&#123;<br>　　<span class="hljs-comment">//同dispatch_queue_create函数生成的concurrent Dispatch Queue队列一起使用</span><br>    <span class="hljs-built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="hljs-string">&quot;12312312&quot;</span>, DISPATCH_QUEUE_CONCURRENT);<br>    <br>    <span class="hljs-built_in">dispatch_async</span>(queue, ^&#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;----1-----%@&quot;</span>, [<span class="hljs-built_in">NSThread</span> currentThread]);<br>    &#125;);<br>    <span class="hljs-built_in">dispatch_async</span>(queue, ^&#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;----2-----%@&quot;</span>, [<span class="hljs-built_in">NSThread</span> currentThread]);<br>    &#125;);<br>    <br>    dispatch_barrier_async(queue, ^&#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;----barrier-----%@&quot;</span>, [<span class="hljs-built_in">NSThread</span> currentThread]);<br>    &#125;);<br>    <br>    <span class="hljs-built_in">dispatch_async</span>(queue, ^&#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;----3-----%@&quot;</span>, [<span class="hljs-built_in">NSThread</span> currentThread]);<br>    &#125;);<br>    <span class="hljs-built_in">dispatch_async</span>(queue, ^&#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;----4-----%@&quot;</span>, [<span class="hljs-built_in">NSThread</span> currentThread]);<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>打印结果:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-number">2018</span><span class="hljs-number">-05</span><span class="hljs-number">-24</span> <span class="hljs-number">18</span>:<span class="hljs-number">19</span>:<span class="hljs-number">13.234432</span>+<span class="hljs-number">0800</span> Test[<span class="hljs-number">8324</span>:<span class="hljs-number">8295580</span>] ---<span class="hljs-number">-1</span>-----&lt;NSThread: <span class="hljs-number">0x600000279d00</span>&gt;&#123;number = <span class="hljs-number">3</span>, name = (null)&#125;<br><span class="hljs-number">2018</span><span class="hljs-number">-05</span><span class="hljs-number">-24</span> <span class="hljs-number">18</span>:<span class="hljs-number">19</span>:<span class="hljs-number">13.234434</span>+<span class="hljs-number">0800</span> Test[<span class="hljs-number">8324</span>:<span class="hljs-number">8295577</span>] ---<span class="hljs-number">-2</span>-----&lt;NSThread: <span class="hljs-number">0x60800027ba00</span>&gt;&#123;number = <span class="hljs-number">4</span>, name = (null)&#125;<br><span class="hljs-number">2018</span><span class="hljs-number">-05</span><span class="hljs-number">-24</span> <span class="hljs-number">18</span>:<span class="hljs-number">19</span>:<span class="hljs-number">13.234607</span>+<span class="hljs-number">0800</span> Test[<span class="hljs-number">8324</span>:<span class="hljs-number">8295580</span>] ----barrier-----&lt;NSThread: <span class="hljs-number">0x600000279d00</span>&gt;&#123;number = <span class="hljs-number">3</span>, name = (null)&#125;<br><span class="hljs-number">2018</span><span class="hljs-number">-05</span><span class="hljs-number">-24</span> <span class="hljs-number">18</span>:<span class="hljs-number">19</span>:<span class="hljs-number">13.234733</span>+<span class="hljs-number">0800</span> Test[<span class="hljs-number">8324</span>:<span class="hljs-number">8295577</span>] ---<span class="hljs-number">-4</span>-----&lt;NSThread: <span class="hljs-number">0x60800027ba00</span>&gt;&#123;number = <span class="hljs-number">4</span>, name = (null)&#125;<br><span class="hljs-number">2018</span><span class="hljs-number">-05</span><span class="hljs-number">-24</span> <span class="hljs-number">18</span>:<span class="hljs-number">19</span>:<span class="hljs-number">13.234739</span>+<span class="hljs-number">0800</span> Test[<span class="hljs-number">8324</span>:<span class="hljs-number">8295580</span>] ---<span class="hljs-number">-3</span>-----&lt;NSThread: <span class="hljs-number">0x600000279d00</span>&gt;&#123;number = <span class="hljs-number">3</span>, name = (null)&#125;<br></code></pre></td></tr></table></figure>

<h3 id="dispatch-queue-set-specific-dispatch-get-specific"><a href="#dispatch-queue-set-specific-dispatch-get-specific" class="headerlink" title="dispatch_queue_set_specific dispatch_get_specific"></a>dispatch_queue_set_specific dispatch_get_specific</h3><p>FMDB如何使用dispatch_queue_set_specific和dispatch_get_specific来防止死锁</p>
<p>作用类似objc_setAssociatedObject跟objc_getAssociatedObject</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> * <span class="hljs-keyword">const</span> kDispatchQueueSpecificKey = &amp;kDispatchQueueSpecificKey;<br><span class="hljs-comment">//创建串行队列，所有数据库的操作都在这个队列里</span><br>_queue = dispatch_queue_create([[<span class="hljs-built_in">NSString</span> stringWithFormat:<span class="hljs-string">@&quot;fmdb.%@&quot;</span>, <span class="hljs-keyword">self</span>] UTF8String], <span class="hljs-literal">NULL</span>);<br><span class="hljs-comment">//标记队列</span><br>dispatch_queue_set_specific(_queue, kDispatchQueueSpecificKey, (__bridge <span class="hljs-keyword">void</span> *)<span class="hljs-keyword">self</span>, <span class="hljs-literal">NULL</span>);<br><br><span class="hljs-comment">//检查是否是同一个队列来避免死锁的方法</span><br>- (<span class="hljs-keyword">void</span>)inDatabase:(<span class="hljs-keyword">void</span> (^)(FMDatabase *db))block &#123;<br>    FMDatabaseQueue *currentSyncQueue = (__bridge <span class="hljs-keyword">id</span>)dispatch_get_specific(kDispatchQueueSpecificKey);<br>    assert(currentSyncQueue != <span class="hljs-keyword">self</span> &amp;&amp; <span class="hljs-string">&quot;inDatabase: was called reentrantly on the same queue, which would lead to a deadlock&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>


<h1 id="NSOperation"><a href="#NSOperation" class="headerlink" title="NSOperation"></a>NSOperation</h1><h3 id="Operation-Queues-vs-Grand-Central-Dispatch-GCD"><a href="#Operation-Queues-vs-Grand-Central-Dispatch-GCD" class="headerlink" title="Operation Queues vs. Grand Central Dispatch (GCD)"></a>Operation Queues vs. Grand Central Dispatch (GCD)</h3><p>简单来说，<code>GCD</code> 是苹果基于 C 语言开发的，一个用于多核编程的解决方案，主要用于优化应用程序以支持多核处理器以及其他对称多处理系统。而<code>Operation Queues</code> 则是一个建立在 <code>GCD</code> 的基础之上的，面向对象的解决方案。它使用起来比 <code>GCD</code> 更加灵活，功能也更加强大。下面简单地介绍了 <code>Operation Queues</code> 和 <code>GCD</code> 各自的使用场景：</p>
<p><code>Operation Queues</code> ：相对 GCD 来说，使用 Operation Queues 会增加一点点额外的开销，但是我们却换来了非常强大的灵活性和功能，我们可以给 operation 之间添加依赖关系、取消一个正在执行的 operation 、暂停和恢复 operation queue 等；</p>
<p><code>GCD</code> ：则是一种更轻量级的，以 <code>FIFO</code> 的顺序执行并发任务的方式，使用 GCD 时我们并不关心任务的调度情况，而让系统帮我们自动处理。但是 GCD 的短板也是非常明显的，比如我们想要给任务之间添加依赖关系、取消或者暂停一个正在执行的任务时就会变得非常棘手。</p>
<h3 id="Operation对象"><a href="#Operation对象" class="headerlink" title="Operation对象"></a>Operation对象</h3><p>NSOperation 本身是一个抽象类，不能直接实例化，因此，如果我们想要使用它来执行具体任务的话，就必须创建自己的子类或者使用系统预定义的两个子类，NSInvocationOperation 和 NSBlockOperation 。</p>
<ul>
<li><code>NSInvocationOperation</code> ：我们可以通过一个 <code>object</code> 和 <code>selector</code> 非常方便地创建一个 <code>NSInvocationOperation</code> ，这是一种非常动态和灵活的方式。假设我们已经有了一个现成的方法，这个方法中的代码正好就是我们需要执行的任务，那么我们就可以在不修改任何现有代码的情况下，通过方法所在的对象和这个现有方法直接创建一个 <code>NSInvocationOperation</code> 。</li>
<li><code>NSBlockOperation</code> ：我们可以使用 <code>NSBlockOperation</code> 来并发执行一个或多个 block ，只有当一个 <code>NSBlockOperation</code> 所关联的所有 block 都执行完毕时，这个 NSBlockOperation 才算执行完成，有点类似于 <code>dispatch_group</code> 的概念。</li>
</ul>
<h4 id="Operation对象还支持下面的特性"><a href="#Operation对象还支持下面的特性" class="headerlink" title="Operation对象还支持下面的特性"></a>Operation对象还支持下面的特性</h4><ul>
<li>支持在 operation 之间建立依赖关系，只有当一个 operation 所依赖的所有 operation 都执行完成时，这个 operation 才能开始执行；</li>
<li>支持一个可选的 <code>completion block</code> ，这个 block 将会在 operation 的主任务执行完成时被调用；</li>
<li>支持通过 <code>KVO</code> 来观察 operation 执行状态的变化；</li>
<li>支持设置执行的优先级，从而影响 operation 之间的相对执行顺序；</li>
<li>支持<code>取消操作</code>，可以允许我们停止正在执行的 operation 。</li>
</ul>
<h3 id="并发-vs-非并发-Operation"><a href="#并发-vs-非并发-Operation" class="headerlink" title="并发 vs. 非并发 Operation"></a>并发 vs. 非并发 Operation</h3><p>通常来说，我们都是通过将 operation 添加到一个 operation queue 的方式来执行 operation 的，然而这并不是必须的。</p>
<p>我们也可以直接通过调用 start 方法来执行一个 operation ，但是这种方式并不能保证 operation 是异步执行的。NSOperation 类的 <code>isConcurrent</code> 方法的返回值标识了一个 operation 相对于调用它的 <code>start</code> 方法的线程来说是否是异步执行的。在默认情况下，<code>isConcurrent</code> 方法的返回值是 <code>NO</code> ，也就是说会阻塞调用它的 start 方法的线程。</p>
<p>如果我们想要自定义一个并发执行的 operation ，那么我们就必须要编写一些额外的代码来让这个 operation 异步执行。比如，为这个 operation 创建新的线程、调用系统的异步方法或者其他任何方式来确保 start 方法在开始执行任务后立即返回。</p>
<h3 id="创建-NSInvocationOperation-对象"><a href="#创建-NSInvocationOperation-对象" class="headerlink" title="创建 NSInvocationOperation 对象"></a>创建 NSInvocationOperation 对象</h3><p>NSInvocationOperation 是 NSOperation 类的一个子类，当一个 NSInvocationOperation 开始执行时，它会调用我们指定的 object 的 selector 方法</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">- (<span class="hljs-built_in">NSInvocationOperation</span> *)invocationOperationWithData:(<span class="hljs-keyword">id</span>)data &#123;<br>    <span class="hljs-keyword">return</span> [[<span class="hljs-built_in">NSInvocationOperation</span> alloc] initWithTarget:<span class="hljs-keyword">self</span> selector:<span class="hljs-keyword">@selector</span>(myTaskMethod1:) object:data];<br>&#125;<br></code></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">2018-03-28 11:16:41.061212+0800 NSOperationDemo[2314:40962438] Start executing myTaskMethod1: with data: 111, mainThread: &lt;NSThread: 0x60800007b280&gt;&#123;number &#x3D; 1, name &#x3D; main&#125;, currentThread: &lt;NSThread: 0x60800007b280&gt;&#123;number &#x3D; 1, name &#x3D; main&#125;<br>2018-03-28 11:16:44.062435+0800 NSOperationDemo[2314:40962438] Finish executing myTaskMethod1:<br></code></pre></td></tr></table></figure>

<h3 id="创建-NSBlockOperation-对象"><a href="#创建-NSBlockOperation-对象" class="headerlink" title="创建 NSBlockOperation 对象"></a>创建 NSBlockOperation 对象</h3><p>NSBlockOperation 是 NSOperation 类的另外一个系统预定义的子类，我们可以用它来封装一个或多个 block </p>
<p>什么情况下会优先使用NSBlockOperation：</p>
<blockquote>
<p>当我们在应用中已经使用了 Operation Queues 且不想创建 Dispatch Queues 时，<br>    NSBlockOperation 类可以为我们的应用提供一个面向对象的封装；<br>我们需要用到 Dispatch Queues 不具备的功能时，比如需要设置 operation 之间的依赖关系、使<br>    用 KVO 观察 operation 的状态变化等。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">- (NSBlockOperation *)blockOperation &#123;<br>    NSBlockOperation *blockOperation &#x3D; [NSBlockOperation blockOperationWithBlock:^&#123;<br>        NSLog(@&quot;Start executing block1, mainThread: %@, currentThread: %@&quot;, [NSThread mainThread], [NSThread currentThread]);<br>        sleep(3);<br>        NSLog(@&quot;Finish executing block1&quot;);<br>    &#125;];<br>    <br>    [blockOperation addExecutionBlock:^&#123;<br>        NSLog(@&quot;Start executing block2, mainThread: %@, currentThread: %@&quot;, [NSThread mainThread], [NSThread currentThread]);<br>        sleep(3);<br>        NSLog(@&quot;Finish executing block2&quot;);<br>    &#125;];<br>    <br>    [blockOperation addExecutionBlock:^&#123;<br>        NSLog(@&quot;Start executing block3, mainThread: %@, currentThread: %@&quot;, [NSThread mainThread], [NSThread currentThread]);<br>        sleep(3);<br>        NSLog(@&quot;Finish executing block3&quot;);<br>    &#125;];<br>    <br>    return blockOperation;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">2018-03-28 11:16:44.063438+0800 NSOperationDemo[2314:40962438] Start executing block1, mainThread: &lt;NSThread: 0x60800007b280&gt;&#123;number &#x3D; 1, name &#x3D; main&#125;, currentThread: &lt;NSThread: 0x60800007b280&gt;&#123;number &#x3D; 1, name &#x3D; main&#125;<br>2018-03-28 11:16:44.063491+0800 NSOperationDemo[2314:40962523] Start executing block3, mainThread: &lt;NSThread: 0x60800007b280&gt;&#123;number &#x3D; 1, name &#x3D; (null)&#125;, currentThread: &lt;NSThread: 0x60000027b940&gt;&#123;number &#x3D; 4, name &#x3D; (null)&#125;<br>2018-03-28 11:16:44.063500+0800 NSOperationDemo[2314:40962525] Start executing block2, mainThread: &lt;NSThread: 0x60800007b280&gt;&#123;number &#x3D; 1, name &#x3D; (null)&#125;, currentThread: &lt;NSThread: 0x604000273140&gt;&#123;number &#x3D; 3, name &#x3D; (null)&#125;<br>2018-03-28 11:16:47.063715+0800 NSOperationDemo[2314:40962438] Finish executing block1<br>2018-03-28 11:16:47.063714+0800 NSOperationDemo[2314:40962525] Finish executing block2<br>2018-03-28 11:16:47.063714+0800 NSOperationDemo[2314:40962523] Finish executing block3<br></code></pre></td></tr></table></figure>


<h3 id="自定义-Operation-对象"><a href="#自定义-Operation-对象" class="headerlink" title="自定义 Operation 对象"></a>自定义 Operation 对象</h3><p>当系统预定义的两个子类 NSInvocationOperation 和 NSBlockOperation 不能很好的满足我们的需求时，我们可以自定义自己的 NSOperation 子类，添加我们想要的功能。目前，我们可以自定义非并发和并发两种不同类型的 NSOperation 子类</p>
<h4 id="非并发的NSOperation"><a href="#非并发的NSOperation" class="headerlink" title="非并发的NSOperation"></a>非并发的NSOperation</h4><p>对于一个非并发的 operation ，我们需要做的就只是执行 main 方法中的任务以及能够正常响应取消事件就可以了，其它的复杂工作比如依赖配置、KVO 通知等 NSOperation 类都已经帮我们处理好了。</p>
<h5 id="执行主任务"><a href="#执行主任务" class="headerlink" title="执行主任务"></a>执行主任务</h5><p>从最低限度上来说，每一个 operation 都应该至少实现以下两个方法：</p>
<blockquote>
<p>一个自定义的初始化方法；<br>main 方法。</p>
</blockquote>
<h5 id="响应取消事件"><a href="#响应取消事件" class="headerlink" title="响应取消事件"></a>响应取消事件</h5><p>当一个 operation 开始执行后，它会一直执行它的任务直到完成或被取消为止。我们可以在任意时间点取消一个 operation ，甚至是在它还未开始执行之前。为了让我们自定义的 operation 能够支持取消事件，我们需要在代码中定期地检查 <code>isCancelled</code> 方法的返回值，一旦检查到这个方法返回 YES ，我们就需要立即停止执行接下来的任务。根据苹果官方的说法，<code>isCancelled</code> 方法本身是足够轻量的，所以就算是频繁地调用它也不会给系统带来太大的负担。</p>
<blockquote>
<p>The isCancelled method itself is very lightweight and can be called<br>  frequently without any significant performance penalty.</p>
</blockquote>
<p>通常来说，当我们自定义一个 operation 类时，我们需要考虑在以下几个关键点检查 isCancelled 方法的返回值：</p>
<ul>
<li>在真正开始执行任务之前；</li>
<li>至少在每次循环中检查一次，而如果一次循环的时间本身就比较长的话，则需要检查得更加频繁；</li>
<li>在任何相对来说比较容易中止 operation 的地方。</li>
</ul>
<p>看到这里，我想你应该可以意识到一点，那就是尽管 <code>operation</code> 是支持取消操作的，但却并不是立即取消的，而是在你调用了 <code>operation</code> 的 <code>cancel</code> 方法之后的下一个 <code>isCancelled</code> 的检查点取消的</p>
<p>示例 一个支持取消操作Operation</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">NonConcurrentOperation</span> ()</span><br><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">strong</span>, <span class="hljs-keyword">nonatomic</span>) <span class="hljs-keyword">id</span> data;<br><br><span class="hljs-keyword">@end</span><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">NonConcurrentOperation</span></span><br>- (<span class="hljs-keyword">id</span>)initWithData:(<span class="hljs-keyword">id</span>)data &#123;<br>    <span class="hljs-keyword">self</span> = [<span class="hljs-keyword">super</span> init];<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-keyword">self</span>.data = data;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>;<br>&#125;<br><br><span class="hljs-comment">/// 支持取消操作</span><br>- (<span class="hljs-keyword">void</span>)main &#123;<br>    <span class="hljs-keyword">@try</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>.isCancelled) <span class="hljs-keyword">return</span>;<br>        <br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;Start executing %@ with data: %@, mainThread: %@, currentThread: %@&quot;</span>, <span class="hljs-built_in">NSStringFromSelector</span>(_cmd), <span class="hljs-keyword">self</span>.data, [<span class="hljs-built_in">NSThread</span> mainThread], [<span class="hljs-built_in">NSThread</span> currentThread]);<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">NSUInteger</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>.isCancelled) <span class="hljs-keyword">return</span>;<br>            <br>            sleep(<span class="hljs-number">1</span>);<br>            <br>            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;Loop %@&quot;</span>, @(i + <span class="hljs-number">1</span>));<br>        &#125;<br>        <br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;Finish executing %@&quot;</span>, <span class="hljs-built_in">NSStringFromSelector</span>(_cmd));<br>    &#125;<br>    <span class="hljs-keyword">@catch</span>(<span class="hljs-built_in">NSException</span> *exception) &#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;Exception: %@&quot;</span>, exception);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>注意</code>:operation的取消操作需要自己在block或者selector中加isCancelled的判断</p>
<h4 id="配置并发执行的-Operation"><a href="#配置并发执行的-Operation" class="headerlink" title="配置并发执行的 Operation"></a>配置并发执行的 Operation</h4><p>在默认情况下，<code>operation</code> 是同步执行的，也就是说在调用它的 <code>start</code> 方法的线程中执行它们的任务。而在 <code>operation</code> 和 <code>operation queue</code> 结合使用时，<code>operation queue</code> 可以为非并发的 <code>operation</code> 提供线程，因此，大部分的 operation 仍然可以异步执行</p>
<p>如果你想要手动地执行一个 operation ，又想这个 operation 能够异步执行的话，你需要做一些额外的配置来让你的 operation 支持并发执行。</p>
<p>需要重写的方法：</p>
<p><code>start</code> ：<code>必须的</code>，所有并发执行的 operation 都必须要重写这个方法，替换掉 NSOperation 类中的默认实现。start 方法是一个 operation 的起点，我们可以在这里配置任务执行的线程或者一些其它的执行环境。另外，需要特别注意的是，在我们重写的 start 方法中<code>一定不要调用父类的实现</code>；</p>
<p><code>main</code> ：<code>可选的</code>，通常这个方法就是专门用来实现与该 operation 相关联的任务的。尽管我们可以直接在 start 方法中执行我们的任务，但是用 main 方法来实现我们的任务可以使设置代码和任务代码得到分离，从而使 operation 的结构更清晰；</p>
<p><code>isExecuting</code> 和 <code>isFinished</code> ：<code>必须的</code>，并发执行的 operation 需要负责配置它们的执行环境，并且向外界客户报告执行环境的状态。因此，一个并发执行的 operation 必须要维护一些状态信息，用来记录它的任务是否正在执行，是否已经完成执行等。此外，当这两个方法所代表的值发生变化时，我们需要生成相应的 KVO 通知，以便外界能够观察到这些状态的变化；</p>
<p><code>isConcurrent</code> ：<code>必须的</code>，这个方法的返回值用来标识一个 operation 是否是并发的 operation ，我们需要重写这个方法并返回 YES 。</p>
<p>示例：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">ConcurrentOperation</span></span><br><span class="hljs-comment">//用 @synthesize 关键字手动合成了两个实例变量 _executing 和 _finished ，</span><br><span class="hljs-comment">//然后分别在重写的 isExecuting 和 isFinished 方法中返回了这两个实例变量</span><br><span class="hljs-comment">//通过查看 NSOperation 类的头文件可以发现，executing 和 finished 属性都被声明成了只读的 readonly 。</span><br><span class="hljs-comment">//所以我们在 NSOperation 子类中就没有办法直接通过 setter 方法来自动触发 KVO 通知，</span><br><span class="hljs-comment">//这也是为什么我们需要在接下来的代码中手动触发 KVO 通知的原因。</span><br><span class="hljs-keyword">@synthesize</span> executing = _executing;<br><span class="hljs-keyword">@synthesize</span> finished  = _finished;<br><br>- (<span class="hljs-keyword">id</span>)init &#123;<br>    <span class="hljs-keyword">self</span> = [<span class="hljs-keyword">super</span> init];<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>) &#123;<br>        _executing = <span class="hljs-literal">NO</span>;<br>        _finished  = <span class="hljs-literal">NO</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>;<br>&#125;<br><br><span class="hljs-comment">//是否为并发</span><br>- (<span class="hljs-built_in">BOOL</span>)isConcurrent &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">YES</span>;<br>&#125;<br><br><span class="hljs-comment">//是否正在执行</span><br>- (<span class="hljs-built_in">BOOL</span>)isExecuting &#123;<br>    <span class="hljs-keyword">return</span> _executing;<br>&#125;<br><br><span class="hljs-comment">// 是否完成</span><br>- (<span class="hljs-built_in">BOOL</span>)isFinished &#123;<br>    <span class="hljs-keyword">return</span> _finished;<br>&#125;<br><br>- (<span class="hljs-keyword">void</span>)start &#123;<br><span class="hljs-comment">//    在真正开始执行任务前，我们通过检查 isCancelled 方法的返回值来判断 operation 是否已经被 cancel ，如果是就直接返回了</span><br><span class="hljs-comment">//    即使一个 operation 是被 cancel 掉了，我们仍然需要手动触发 isFinished 的 KVO 通知。</span><br><span class="hljs-comment">//    因为当一个 operation 依赖其他 operation 时，它会观察所有其他 operation 的 isFinished 的值的变化，</span><br><span class="hljs-comment">//    只有当它依赖的所有 operation 的 isFinished 的值为 YES 时，这个 operation 才能够开始执行。</span><br><span class="hljs-comment">//    因此，如果一个我们自定义的 operation 被取消了但却没有手动触发 isFinished 的 KVO 通知的话，</span><br><span class="hljs-comment">//    那么所有依赖它的 operation 都不会执行</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>.isCancelled) &#123;<br>        [<span class="hljs-keyword">self</span> willChangeValueForKey:<span class="hljs-string">@&quot;isFinished&quot;</span>];<br>        _finished = <span class="hljs-literal">YES</span>;<br>        [<span class="hljs-keyword">self</span> didChangeValueForKey:<span class="hljs-string">@&quot;isFinished&quot;</span>];<br>        <br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <br>    [<span class="hljs-keyword">self</span> willChangeValueForKey:<span class="hljs-string">@&quot;isExecuting&quot;</span>];<br><span class="hljs-comment">//    为 main 方法分离了一个新的线程 这是 operation 能够并发执行的关键所在</span><br>    [<span class="hljs-built_in">NSThread</span> detachNewThreadSelector:<span class="hljs-keyword">@selector</span>(main) toTarget:<span class="hljs-keyword">self</span> withObject:<span class="hljs-literal">nil</span>];<br>    _executing = <span class="hljs-literal">YES</span>;<br>    <br>    [<span class="hljs-keyword">self</span> didChangeValueForKey:<span class="hljs-string">@&quot;isExecuting&quot;</span>];<br>&#125;<br><br><span class="hljs-comment">//在任务执行完毕后，我们需要手动触动 isExecuting 和 isFinished 的 KVO 通知。</span><br>- (<span class="hljs-keyword">void</span>)main &#123;<br>    <span class="hljs-keyword">@try</span> &#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;Start executing %@, mainThread: %@, currentThread: %@&quot;</span>, <span class="hljs-built_in">NSStringFromSelector</span>(_cmd), [<span class="hljs-built_in">NSThread</span> mainThread], [<span class="hljs-built_in">NSThread</span> currentThread]);<br>        <br>        sleep(<span class="hljs-number">3</span>);<br>        <br>        [<span class="hljs-keyword">self</span> willChangeValueForKey:<span class="hljs-string">@&quot;isExecuting&quot;</span>];<br>        _executing = <span class="hljs-literal">NO</span>;<br>        [<span class="hljs-keyword">self</span> didChangeValueForKey:<span class="hljs-string">@&quot;isExecuting&quot;</span>];<br>        <br>        [<span class="hljs-keyword">self</span> willChangeValueForKey:<span class="hljs-string">@&quot;isFinished&quot;</span>];<br>        _finished  = <span class="hljs-literal">YES</span>;<br>        [<span class="hljs-keyword">self</span> didChangeValueForKey:<span class="hljs-string">@&quot;isFinished&quot;</span>];<br>        <br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;Finish executing %@&quot;</span>, <span class="hljs-built_in">NSStringFromSelector</span>(_cmd));<br>    &#125;<br>    <span class="hljs-keyword">@catch</span> (<span class="hljs-built_in">NSException</span> *exception) &#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;Exception: %@&quot;</span>, exception);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="维护-KVO-通知"><a href="#维护-KVO-通知" class="headerlink" title="维护 KVO 通知"></a>维护 KVO 通知</h3><p>NSOperation 类的以下 <code>key paths</code> 支持 KVO 通知，我们可以通过观察这些 <code>key paths</code> 非常方便地监听到一个 operation 内部状态的变化：</p>
<ul>
<li>isCancelled</li>
<li>isConcurrent</li>
<li>isExecuting</li>
<li>isFinished</li>
<li>isReady</li>
<li>dependencies</li>
<li>queuePriority</li>
<li>completionBlock</li>
</ul>
<p>与重写 main 方法不同的是，如果我们重写了 start 方法或者对 NSOperation 类做了大量定制的话，我们需要保证自定义的 operation 在这些 key paths 上仍然支持 KVO 通知。比如，当我们重写了 start 方法时，我们需要特别关注的是 <code>isExecuting</code> 和 <code>isFinished</code> 这两个 key paths ，因为这两个 key paths 最可能受重写 start 方法的影响。</p>
<h2 id="Operation-对象的执行行为"><a href="#Operation-对象的执行行为" class="headerlink" title="Operation 对象的执行行为"></a>Operation 对象的执行行为</h2><h3 id="配置依赖关系"><a href="#配置依赖关系" class="headerlink" title="配置依赖关系"></a>配置依赖关系</h3><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">- (<span class="hljs-keyword">void</span>)addDependency:(<span class="hljs-built_in">NSOperation</span> *)op;<br>- (<span class="hljs-keyword">void</span>)removeDependency:(<span class="hljs-built_in">NSOperation</span> *)op;<br></code></pre></td></tr></table></figure>

<p><code>注意</code>：</p>
<ul>
<li><p><code>addDependency: </code>方法添加的依赖关系是单向的，比如 <code>[A addDependency:B];</code> ，表示 A 依赖 B，B 并不依赖 A 。</p>
</li>
<li><p>这里的依赖关系并不局限于相同 operation queue 中的 operation 之间。</p>
</li>
<li><p>不要在 operation 之间添加循环依赖，因为这样会导致这些 operation 都不会被执行</p>
</li>
</ul>
<p>示例</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">- (<span class="hljs-keyword">void</span>)operationDependencyTest<br>&#123;<br>    <span class="hljs-built_in">NSOperationQueue</span> *queue = [[<span class="hljs-built_in">NSOperationQueue</span> alloc] init];<br><br>    <span class="hljs-built_in">NSBlockOperation</span> *op1 = [<span class="hljs-built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;op1 test&quot;</span>);<br>    &#125;];<br>    <br>    <span class="hljs-built_in">NSBlockOperation</span> *op2 = [<span class="hljs-built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;op2 test&quot;</span>);<br>    &#125;];<br>    <br>    <span class="hljs-built_in">NSBlockOperation</span> *op3 = [<span class="hljs-built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;op3 test&quot;</span>);<br>    &#125;];<br>    <br>    <span class="hljs-comment">//op1依赖于op2</span><br>    [op1 addDependency:op2];<br>    <br>    [queue addOperation:op1];<br>    [queue addOperation:op2];<br>    [queue addOperation:op3];<br>&#125;<br></code></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">2018-03-28 14:38:26.281018+0800 NSOperationDemo[5771:41445417] op2 test<br>2018-03-28 14:38:26.281019+0800 NSOperationDemo[5771:41445416] op3 test<br>2018-03-28 14:38:26.281244+0800 NSOperationDemo[5771:41445419] op1 test<br></code></pre></td></tr></table></figure>

<h3 id="修改-Operation-在队列中的优先级"><a href="#修改-Operation-在队列中的优先级" class="headerlink" title="修改 Operation 在队列中的优先级"></a>修改 Operation 在队列中的优先级</h3><p><code>setQueuePriority:</code></p>
<p>适用范围：只适用于同一个operation queue中的operation<br>但是高德优先级并不意味着可以首先被执行,因为 决定operation被执行顺序的第一要素是它们的 isReady 状态，其次是它们在队列中的优先级</p>
<p>示例：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">- (<span class="hljs-keyword">void</span>)QueuePriorityTest<br>&#123;<br>    <span class="hljs-built_in">NSOperationQueue</span> *queue = [[<span class="hljs-built_in">NSOperationQueue</span> alloc] init];<br>    <br>    <span class="hljs-built_in">NSBlockOperation</span> *op1 = [<span class="hljs-built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;op1 test&quot;</span>);<br>    &#125;];<br>    <br>    <span class="hljs-built_in">NSBlockOperation</span> *op2 = [<span class="hljs-built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;op2 test&quot;</span>);<br>    &#125;];<br>    <br>    <span class="hljs-built_in">NSBlockOperation</span> *op3 = [<span class="hljs-built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;op3 test&quot;</span>);<br>    &#125;];<br><span class="hljs-comment">//    NSOperationQueuePriorityVeryLow = -8L,</span><br><span class="hljs-comment">//    NSOperationQueuePriorityLow = -4L,</span><br><span class="hljs-comment">//    NSOperationQueuePriorityNormal = 0,</span><br><span class="hljs-comment">//    NSOperationQueuePriorityHigh = 4,</span><br><span class="hljs-comment">//    NSOperationQueuePriorityVeryHigh = 8</span><br>    [op1 setQueuePriority:<span class="hljs-built_in">NSOperationQueuePriorityHigh</span>];<br>    [op3 setQueuePriority:<span class="hljs-built_in">NSOperationQueuePriorityLow</span>];<br>    <br>    [queue addOperation:op1];<br>    [queue addOperation:op2];<br>    [queue addOperation:op3];<br>&#125;<br></code></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">2018-03-28 14:41:18.941460+0800 NSOperationDemo[5852:41457022] op1 test<br>2018-03-28 14:41:18.941460+0800 NSOperationDemo[5852:41457021] op3 test<br>2018-03-28 14:41:18.941460+0800 NSOperationDemo[5852:41457020] op2 test<br></code></pre></td></tr></table></figure>

<h3 id="设置-Completion-Block"><a href="#设置-Completion-Block" class="headerlink" title="设置 Completion Block"></a>设置 Completion Block</h3><p><code>setCompletionBlock:</code><br>一个 operation 可以在它的主任务执行完成时回调一个 completion block </p>
<ul>
<li>当一个 operation 被取消时，它的 <code>completion block</code> 仍然会执行，所以我们需要在真正执行代码前检查一下 <code>isCancelled</code> 方法的返回值</li>
<li>我们也没有办法保证 <code>completion block</code> 被回调时一定是在主线程，理论上它应该是与触发 <code>isFinished</code> 的 KVO 通知所在的线程一致的，所以如果有必要的话我们可以在 <code>completion block</code> 中使用 GCD 来保证从主线程更新 UI</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">// 设置completionBlock</span><br>- (<span class="hljs-keyword">void</span>)completionBlockTest<br>&#123;<br>    <span class="hljs-built_in">NSOperationQueue</span> *queue = [[<span class="hljs-built_in">NSOperationQueue</span> alloc] init];<br>    <br>    <span class="hljs-built_in">NSBlockOperation</span> *op1 = [<span class="hljs-built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;op1 test&quot;</span>);<br>    &#125;];<br>    <br>    <span class="hljs-built_in">NSBlockOperation</span>* op2 = [[<span class="hljs-built_in">NSBlockOperation</span> alloc] init];<br>    __<span class="hljs-keyword">weak</span> <span class="hljs-built_in">NSBlockOperation</span>* myWeakOp = op2;<br>    myWeakOp = [<span class="hljs-built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;<br>        sleep(<span class="hljs-number">5</span>);<br>        <span class="hljs-comment">// 如果要可以取消需要自己加判断</span><br>        <span class="hljs-keyword">if</span> ([myWeakOp isCancelled]) &#123;<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;op2 test&quot;</span>);<br>    &#125;];<br>    <br>    [op2 setCompletionBlock:^&#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%@&quot;</span>,[<span class="hljs-built_in">NSThread</span> currentThread]);<br>        <span class="hljs-comment">//回调的线程跟触发KVO isFinished的在一个线程不一定是主线程 如果不是主线程 而且在这个回调里</span><br>        <span class="hljs-comment">// 做了更新UI的操作需要在主线程更新</span><br>        <span class="hljs-keyword">if</span> (![<span class="hljs-built_in">NSThread</span> isMainThread]) &#123;<br>            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;not main thread update ui in main thread&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">//即使任务呗取消了 也会走CompletionBlock 只不过可以通过cancelled属性判断</span><br>        <span class="hljs-keyword">if</span> (myWeakOp.cancelled) &#123;<br>            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;op2 cancelled&quot;</span>);<br>        &#125;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;op2 complete&quot;</span>);<br>    &#125;];<br>  <br>    __<span class="hljs-keyword">weak</span> <span class="hljs-keyword">typeof</span>(op1) weakOp1 = op1;<br>    [op1 setCompletionBlock:^&#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;op1 complete&quot;</span>);<br>    &#125;];<br>    <br>    [queue addOperation:op1];<br>    [queue addOperation:op2];<br>    sleep(<span class="hljs-number">1</span>);<br>    [queue cancelAllOperations];<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;op2 cancel&quot;</span>);<br> <br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="执行-Operation-对象"><a href="#执行-Operation-对象" class="headerlink" title="执行 Operation 对象"></a>执行 Operation 对象</h3><ul>
<li>直接调用start</li>
<li>将 operation 添加到一个 operation queue 中，让 operation queue 来帮我们自动执行</li>
</ul>
<h4 id="添加-Operation-到-Operation-Queue-中"><a href="#添加-Operation-到-Operation-Queue-中" class="headerlink" title="添加 Operation 到 Operation Queue 中"></a>添加 Operation 到 Operation Queue 中</h4><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-built_in">NSOperationQueue</span> *operationQueue = [[<span class="hljs-built_in">NSOperationQueue</span> alloc] init];<br></code></pre></td></tr></table></figure>

<p>将operation添加到queue中的方法：</p>
<ul>
<li>addOperation: ，添加一个 operation 到 operation queue 中；</li>
<li>addOperations:waitUntilFinished: ，添加一组 operation 到 operation queue 中；</li>
<li>addOperationWithBlock: ，直接添加一个 block 到 operation queue 中，而不用创建一个 NSBlockOperation 对象。</li>
</ul>
<p>示例：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">- (<span class="hljs-keyword">void</span>)executeOperationUsingOperationQueue &#123;<br>    <span class="hljs-built_in">NSOperationQueue</span> *operationQueue = [[<span class="hljs-built_in">NSOperationQueue</span> alloc] init];<br>    <br>    <span class="hljs-built_in">NSInvocationOperation</span> *invocationOperation = [[<span class="hljs-built_in">NSInvocationOperation</span> alloc] initWithTarget:<span class="hljs-keyword">self</span> selector:<span class="hljs-keyword">@selector</span>(taskMethod) object:<span class="hljs-literal">nil</span>];<br>    [operationQueue addOperation:invocationOperation];<br>    <br>    <span class="hljs-built_in">NSBlockOperation</span> *blockOperation1 = [<span class="hljs-built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;<br>        sleep(<span class="hljs-number">3</span>);<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;Finish executing blockOperation1&quot;</span>);<br>    &#125;];<br>    <br>    <span class="hljs-built_in">NSBlockOperation</span> *blockOperation2 = [<span class="hljs-built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;<br>        sleep(<span class="hljs-number">3</span>);<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;Finish executing blockOperation2&quot;</span>);<br>    &#125;];<br>    <br>    [operationQueue addOperations:@[ blockOperation1, blockOperation2 ] waitUntilFinished:<span class="hljs-literal">YES</span>];<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;blockOperation1 blockOperation2 taskMethod all finished&quot;</span>);<br>    [operationQueue addOperationWithBlock:^&#123;<br>        sleep(<span class="hljs-number">3</span>);<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;Finish executing block&quot;</span>);<br>    &#125;];<br>    <br>    [operationQueue waitUntilAllOperationsAreFinished];<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;test end&quot;</span>);<br>&#125;<br><br>- (<span class="hljs-keyword">void</span>)taskMethod &#123;<br>    sleep(<span class="hljs-number">3</span>);<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;Finish executing %@&quot;</span>, <span class="hljs-built_in">NSStringFromSelector</span>(_cmd));<br>&#125;<br></code></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">2018-03-28 15:36:57.950936+0800 NSOperationDemo[7299:41666224] Finish executing blockOperation1<br>2018-03-28 15:36:57.950941+0800 NSOperationDemo[7299:41666225] Finish executing blockOperation2<br>2018-03-28 15:36:57.950964+0800 NSOperationDemo[7299:41666227] Finish executing taskMethod<br>2018-03-28 15:36:57.951320+0800 NSOperationDemo[7299:41666189] blockOperation1 blockOperation2 taskMethod all finished<br>2018-03-28 15:37:00.956712+0800 NSOperationDemo[7299:41666227] Finish executing block<br>2018-03-28 15:37:00.957116+0800 NSOperationDemo[7299:41666189] test end<br></code></pre></td></tr></table></figure>

<p><code>在将一个 operation 添加到 operation queue 后就不要再修改这个 operation 了。因为 operation 被添加到 operation queue 后随时可能会执行，这个是由系统决定的，所以再修改它的依赖关系或者所包含的数据就很有可能会造成未知的影响。</code></p>
<h4 id="手动执行-Operation"><a href="#手动执行-Operation" class="headerlink" title="手动执行 Operation"></a>手动执行 Operation</h4><p>如果要手动执行Operation 可以直接调用start方法，但是从严格意义上来说，在调用 start 方法真正开始执行一个 operation 前，我们应该要做一些防范性的判断：</p>
<ul>
<li>检查 operation 的 isReady 状态是否为 YES ，这个取决于它所依赖的 operation 是否已经执行完成</li>
<li>检查 operation 的 isCancelled 状态是否为 YES ，如果是，那么我们就根本不需要再花费不必要的开销去启动它</li>
<li>检查一下它的 isConcurrent 状态。如果它的 isConcurrent 状态为 NO ，那么我们就需要考虑一下是否可以在当前线程同步执行这个 operation ，或者是先为这个 operation 创建一个单独的线程，以供它异步执行。</li>
</ul>
<p>在默认的 start 方法中会生成一些必要的 KVO 通知，比如 isExcuting 和 isFinished ，而这些 KVO 通知正是 operation 能够正确处理好依赖关系的关键所在。</p>
<h3 id="取消-Operation"><a href="#取消-Operation" class="headerlink" title="取消 Operation"></a>取消 Operation</h3><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">[operation cancel];<br><br>[queue cancelAllOperations];<br></code></pre></td></tr></table></figure>
<p><code>注意</code>：当一个 operation 被取消后，这个 operation 的 isFinished 状态也会变成 YES ，这样处理的好处就是所有依赖它的 operation 能够接收到这个 KVO 通知，从而能够清除这个依赖关系正常执行。</p>
<h3 id="等待-Operation-执行完成"><a href="#等待-Operation-执行完成" class="headerlink" title="等待 Operation 执行完成"></a>等待 Operation 执行完成</h3><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">[operation waitUntilFinished];<br>[queue waitUntilAlloperationsAreFinished];<br></code></pre></td></tr></table></figure>

<p><code>注意</code>:当我们在等待一个 operation queue 中的所有 operation 执行完成时，其他的线程仍然可以向这个 operation queue 中添加 operation ，从而延长我们的等待时间</p>
<h3 id="暂停和恢复-Operation-Queue"><a href="#暂停和恢复-Operation-Queue" class="headerlink" title="暂停和恢复 Operation Queue"></a>暂停和恢复 Operation Queue</h3><p><code>[queue setSuspended]</code></p>
<p><code>注意</code>：暂停执行 operation queue 并不能使正在执行的 operation 暂停执行，而只是简单地暂停调度新的 operation 。另外，我们并不能单独地暂停执行一个 operation ，除非直接 cancel 掉。</p>
<h4 id="setMaxConcurrentoperationCount"><a href="#setMaxConcurrentoperationCount" class="headerlink" title="setMaxConcurrentoperationCount"></a>setMaxConcurrentoperationCount</h4><p>设置一个 operation queue 最大可并发的 operation 数.<br>可以通过将这个值设置成 1 实现让 operation queue 一次只执行一个 operation 的目的<br><font color='red' size='8'>注意</font>:</p>
<ul>
<li>1、operation 的执行顺序还是一样会受其他因素影响的，比如 operation 的 isReady 状态、operation 的队列优先级等</li>
<li>一个串行的 operation queue 与一个串行的 dispatch queue 还是有本质区别的，因为 dispatch queue 的执行顺序一直是 FIFO 的。如果 operation 的执行顺序对我们来说非常重要，那么我们就应该在将 operation 添加到 operation queue 之前就建立好它的依赖关系。</li>
</ul>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://github.com/ming1016/study/wiki/%E7%BB%86%E8%AF%B4GCD%EF%BC%88Grand-Central-Dispatch%EF%BC%89%E5%A6%82%E4%BD%95%E7%94%A8">细说GCD</a><br><a href="http://tutuge.me/2015/04/03/something-about-gcd/index.html">GCD使用经验与技巧浅谈</a><br><a href="http://yolynn.com/2015/08/10/ios_thread/">多线程基础到进阶</a><br><a href="http://blog.leichunfeng.com/blog/2015/07/29/ios-concurrency-programming-operation-queues/">iOS并发编程</a></p>
]]></content>
      <categories>
        <category>iOS基础</category>
      </categories>
      <tags>
        <tag>网络 多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>runloop 的那些事儿(转)</title>
    <url>/2018/02/28/runloop-detail/</url>
    <content><![CDATA[<p>最近在看iOS的一些基础原理,看到<a href="https://www.jianshu.com/u/14431e509ae8">涂耀辉</a>的这篇关于Runloop的,感觉原理+代码的这种讲解方式非常好,特地转过来，由于简书后半部分排版有点乱,这里特地按照我的思路重新整理一下！</p>
<a id="more"></a>

<h2 id="先看AFN的一段经典代码："><a href="#先看AFN的一段经典代码：" class="headerlink" title="先看AFN的一段经典代码："></a>先看AFN的一段经典代码：</h2><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">+ (<span class="hljs-built_in">NSThread</span> *)networkRequestThread &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-built_in">NSThread</span> *_networkRequestThread = <span class="hljs-literal">nil</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-built_in">dispatch_once_t</span> oncePredicate;<br>    <span class="hljs-built_in">dispatch_once</span>(&amp;oncePredicate, ^&#123;<br>        _networkRequestThread = [[<span class="hljs-built_in">NSThread</span> alloc] initWithTarget:<span class="hljs-keyword">self</span> selector:<span class="hljs-keyword">@selector</span>(networkRequestThreadEntryPoint:) object:<span class="hljs-literal">nil</span>];<br>        [_networkRequestThread start];<br>    &#125;);<br>    <span class="hljs-keyword">return</span> _networkRequestThread;<br>&#125;<br><br>+ (<span class="hljs-keyword">void</span>)networkRequestThreadEntryPoint:(<span class="hljs-keyword">id</span>)__unused object &#123;<br>    <span class="hljs-keyword">@autoreleasepool</span> &#123;<br>        [[<span class="hljs-built_in">NSThread</span> currentThread] setName:<span class="hljs-string">@&quot;AFNetworking&quot;</span>];<br>        <span class="hljs-built_in">NSRunLoop</span> *runLoop = [<span class="hljs-built_in">NSRunLoop</span> currentRunLoop];<br>        [runLoop addPort:[<span class="hljs-built_in">NSMachPort</span> port] forMode:<span class="hljs-built_in">NSDefaultRunLoopMode</span>];<br>        [runLoop run];<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<ul>
<li>1、首先我们要明确一个概念，线程一般都是一次执行完任务，就销毁了。</li>
<li>2、而添加了runloop，并运行起来，实际上是添加了一个do,while循环，这样这个线程的程序一直卡在这个do,while循环上，这样相当于线程的任务一直没有执行完，所以线程一直不会销毁。</li>
<li>3、所以，一旦我们添加了一个runloop，并run了，我们如果要销毁这个线程，必须停止runloop，至于停止的方式，我们接下去往下看。</li>
</ul>
<p><code>注</code>:这里创建的名为<code>AFNetworking</code>的线程,由于其被添加到Runloop上 所以除非Runloop被销毁,否则线程也不会被销毁</p>
<p>1、添加监听事件的端口</p>
<p><code>[runLoop addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode]; </code></p>
<p>2、Runloop跑起来</p>
<p><code>[runLoop run];</code></p>
<p>不过以这种方式启动Runloop后只有一种方式可以终止该Runloop：<br>移除之前添加的端口 这样Runloop中没有事件了，所以可以直接退出。<br><code>[NSRunLoop currentRunLoop]removePort:&lt;#(nonnull NSPort *)#&gt; forMode:&lt;#(nonnull NSRunLoopMode)#&gt;</code></p>
<p>因此 我们可以得出<code>AFN中并没有记录该port,所以压根就不会退出Runloop,所以这是一个常驻线程</code></p>
<h2 id="再看看AFN3-X"><a href="#再看看AFN3-X" class="headerlink" title="再看看AFN3.X"></a>再看看AFN3.X</h2><p>开启RunLoop:</p>
<p><code>CFRunLoopRun();</code></p>
<p>终止RunLoop:</p>
<p><code>CFRunLoopStop(CFRunLoopGetCurrent());</code></p>
<h2 id="RAC中的RunLoop"><a href="#RAC中的RunLoop" class="headerlink" title="RAC中的RunLoop"></a>RAC中的RunLoop</h2><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">//自己用一个Bool值done去控制runloop的运行，每次只运行这</span><br><span class="hljs-comment">//个模式的runloop，0.1秒。0.1秒后开启runloop的下一次运行</span><br><span class="hljs-keyword">do</span> &#123;<br>    [<span class="hljs-built_in">NSRunLoop</span>.mainRunLoop runMode:<span class="hljs-built_in">NSDefaultRunLoopMode</span> beforeDate:[<span class="hljs-built_in">NSDate</span> dateWithTimeIntervalSinceNow:<span class="hljs-number">0.1</span>]];<br>&#125; <span class="hljs-keyword">while</span> (!done);<br></code></pre></td></tr></table></figure>

<h2 id="RunLoop概念"><a href="#RunLoop概念" class="headerlink" title="RunLoop概念"></a>RunLoop概念</h2><p><img src="https://upload-images.jianshu.io/upload_images/2702646-08d6e834e337387d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt="RunLoop官方图"></p>
<p>Runloop，顾名思义就是跑圈，他的本质就是一个do,while循环，当有事做时做事，没事做时睡眠。至于怎么做事，怎么睡眠，这个是由系统内核来调度的，我们后面会讲到</p>
<p>每个线程都有一个Run Loop，主线程的Run Loop会在App运行时自动运行，子线程中需要手动获取运行，第一次获取时，才会去创建。</p>
<p>每个Run Loop都会以一个模式mode来运行，可以使用NSRunLoop的</p>
<p><code>-(BOOL)runMode:(NSString *)mode beforeDate:(NSDate *)limitDate  </code><br>方法来设置运行在那个特定的mode</p>
<ul>
<li><p>1 Run Loop的处理两大类事件源：<code>Timer Source</code>和<code>Input Source</code>(包括<code>performSelector***</code>方法簇,<code>Port</code>或者自定义<code>Input Source</code>)，每个事件源都会绑定在Run Loop的某个特定模式mode上，<code>而且只有RunLoop在这个模式运行的时候才会触发该Timer和Input Source</code>。</p>
</li>
<li><p>2、如果没有任何事件源添加到RunLoop上，RunLoop就会立刻exit，这也是一开始的AF例子，为什么需要绑定一个Port的原因。</p>
</li>
</ul>
<h3 id="OS下Run-Loop的主要运行模式mode有："><a href="#OS下Run-Loop的主要运行模式mode有：" class="headerlink" title="OS下Run Loop的主要运行模式mode有："></a>OS下Run Loop的主要运行模式mode有：</h3><blockquote>
<p>1、NSDefaultRunLoopMode: 默认的运行模式，除了NSConnection对象的事件。<br>2、NSRunLoopCommonModes: 是一组常用的模式集合，将一个input source关联到这个模式集合上，等于将input source关联到这个模式集合中的所有模式上。在iOS系统中NSRunLoopCommonMode包含NSDefaultRunLoopMode、NSTaskDeathCheckMode、UITrackingRunLoopMode。</p>
</blockquote>
<p>假如我有个timer要关联到这些模式上，一个个注册很麻烦，我可以用</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">[[<span class="hljs-built_in">NSRunLoop</span> currentRunLoop] addTimer:timer forMode:<span class="hljs-built_in">NSRunLoopCommonModes</span>];<br></code></pre></td></tr></table></figure>
<p>将UITrackingRunLoopMode或者其他模式添加到这个NSRunLoopCommonModes模式中，然后只需要将Timer关联到NSRunLoopCommonModes，即可以实现Run Loop运行在这个模式集合中任何一个模式时，这个Timer都可以被触发</p>
<p>当然，默认情况下NSRunLoopCommonModes包含了NSDefaultRunLoopMode和UITrackingRunLoopMode。我指的是如果有其他自定义Mode。</p>
<blockquote>
<p>3、UITrackingRunLoopMode: 用于跟踪触摸事件触发的模式（例如UIScrollView上下滚动），主线程当触摸事件触发时会设置为这个模式，可以用来在控件事件触发过程中设置Timer。<br>4、GSEventReceiveRunLoopMode: 用于接受系统事件，属于内部的Run Loop模式。<br>5、自定义Mode：可以设置自定义的运行模式Mode，你也可以用CFRunLoopAddCommonMode添加到NSRunLoopCommonModes中</p>
</blockquote>
<h3 id="总结一下："><a href="#总结一下：" class="headerlink" title="总结一下："></a>总结一下：</h3><p>Run Loop运行时只能以一种固定的模式运行，如果我们需要它切换模式，只有停掉它，再重新开启它。</p>
<p>运行时它只会监控这个模式下添加的Timer Source和Input Source，如果这个模式下没有相应的事件源，Run Loop的运行也会立刻返回的。</p>
<p>注意Run Loop不能在运行在NSRunLoopCommonModes模式，因为NSRunLoopCommonModes其实是个模式集合，而不是一个具体的模式，我可以在添加事件源的时候使用NSRunLoopCommonModes，只要Run Loop运行在NSRunLoopCommonModes中任何一个模式，这个事件源都可以被触发</p>
<h2 id="Run-Loop运行接口"><a href="#Run-Loop运行接口" class="headerlink" title="Run Loop运行接口"></a>Run Loop运行接口</h2><p>Foundation层和CoreFoundation层都有对应的接口可以操作RunLoop：</p>
<p>Foundation层对应的是NSRunLoop，Core Foundation层对应的是CFRunLoopRef；</p>
<p>两组接口差不多，不过功能上还是有许多区别的：<br>例如CF层可以添加自定义Input Source事件源、(CFRunLoopSourceRef)Run Loop观察者Observer(CFRunLoopObserverRef)，很多类似功能的接口特性也是不一样的。</p>
<h3 id="NSRunLoop的运行接口："><a href="#NSRunLoop的运行接口：" class="headerlink" title="NSRunLoop的运行接口："></a>NSRunLoop的运行接口：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&#x2F;&#x2F;运行 NSRunLoop，运行模式为默认的NSDefaultRunLoopMode模式，没有超时限制<br>- (void)run;<br><br>&#x2F;&#x2F;运行 NSRunLoop: 参数为运时间期限，运行模式为默认的NSDefaultRunLoopMode模式 <br>- (void)runUntilDate:(NSDate *)limitDate;<br><br>&#x2F;&#x2F;运行 NSRunLoop: 参数为运行模式、时间期限，返回值为YES表示是处理事件后返回的，NO表示是超时或者停止运行导致返回的<br>- (BOOL)runMode:(NSString *)mode beforeDate:(NSDate *)limitDate;<br><br></code></pre></td></tr></table></figure>

<p>CFRunLoopRef的运行接口：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&#x2F;&#x2F;运行 CFRunLoopRef<br>void CFRunLoopRun();<br><br>&#x2F;&#x2F;运行 CFRunLoopRef: 参数为运行模式、时间和是否在处理Input Source后退出标志，返回值是exit原因<br>SInt32 CFRunLoopRunInMode (mode, seconds, returnAfterSourceHandled);<br><br>&#x2F;&#x2F;停止运行 CFRunLoopRef<br>void CFRunLoopStop( CFRunLoopRef rl );<br><br>&#x2F;&#x2F;唤醒CFRunLoopRef<br>void CFRunLoopWakeUp ( CFRunLoopRef rl );<br><br></code></pre></td></tr></table></figure>

<h3 id="下面分类进行详解"><a href="#下面分类进行详解" class="headerlink" title="下面分类进行详解"></a>下面分类进行详解</h3><p><code>- (void)run; 无条件运行</code></p>
<ul>
<li>AFN2.X使用的方式</li>
<li>不建议使用，因为这个接口会导致Run Loop永久性的运行在NSDefaultRunLoopMode模式。</li>
<li>即使用CFRunLoopStop(runloopRef);也无法停止Run Loop的运行，除非能移除这个runloop上的所有事件源，包括定时器和source事件，不然这个子线程就无法停止，只能永久运行下去。</li>
</ul>
<p><code>- (void)runUntilDate:(NSDate *)limitDate;  有一个超时时间限制 </code><br>比上面的接口好点，有个超时时间，可以控制每次Run Loop的运行时间，也是运行在NSDefaultRunLoopMode模式。<br>这个方法运行Run Loop一段时间会退出给你检查运行条件的机会，如果需要可以再次运行Run Loop。<br>注意CFRunLoopStop(runloopRef),也无法停止Run Loop的运行</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">while</span> (!Done)<br>&#123;<br>    [[<span class="hljs-built_in">NSRunLoop</span> currentRunLoop] runUntilDate:[<span class="hljs-built_in">NSDate</span> dateWithTimeIntervalSinceNow:<span class="hljs-number">10</span>]];<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;exiting runloop.........:&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>注意这个Done是我们自定义的一个Bool值，用来控制是否还需要开启下一次的runloop。</p>
<p>这个例子大概做了如下的事：这个Runloop会每10秒退出一次，然后输出exiting runloop………，然后下一次根据我们的Done值来判断是否再去运行runloop</p>
<p>`//有一个超时时间限制，而且设置运行模式</p>
<ul>
<li>(BOOL)runMode:(NSString *)mode beforeDate:(NSDate *)limitDate;`</li>
</ul>
<ul>
<li><p>这种运行方式是可以被CFRunLoopStop(runloopRef)所停止的(大家可以自己写个例子试试)。</p>
</li>
<li><p>这个方法和第二个方法还有一个很大的区别就是这样去运行runloop会多一种退出方式。这里我指的退出方式是除了timer触发以外的事件，都会导致runloop退出</p>
</li>
</ul>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">- (void)testDemo1<br>&#123;<br>    dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;<br>        NSLog(@&quot;线程开始&quot;);<br>        &#x2F;&#x2F;获取到当前线程<br>        self.thread &#x3D; [NSThread currentThread];<br>        <br>        NSRunLoop *runloop &#x3D; [NSRunLoop currentRunLoop];<br>        &#x2F;&#x2F;添加一个Port，同理为了防止runloop没事干直接退出<br>        [runloop addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode];<br>        <br>        &#x2F;&#x2F;运行一个runloop，[NSDate distantFuture]：很久很久以后才让它失效<br>        [runloop runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]];<br>        <br>        NSLog(@&quot;线程结束&quot;);<br><br>    &#125;);<br>    <br>    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;<br>        &#x2F;&#x2F;在我们开启的异步线程调用方法<br>        [self performSelector:@selector(recieveMsg) onThread:self.thread withObject:nil waitUntilDone:NO];<br>    &#125;);<br>&#125;<br><br>- (void)recieveMsg<br>&#123;<br>    NSLog(@&quot;收到消息了，在这个线程：%@&quot;,[NSThread currentThread]);<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">2016-11-22 14:04:15.250 TestRunloop3[70591:1742754] 线程开始<br>2016-11-22 14:04:17.250 TestRunloop3[70591:1742754] 收到消息了，在这个线程：&lt;NSThread: 0x600000263c80&gt;&#123;number &#x3D; 3, name &#x3D; (null)&#125;<br>2016-11-22 14:04:17.250 TestRunloop3[70591:1742754] 线程结束<br><br></code></pre></td></tr></table></figure>
<p>在这里我们用了<code>performSelector: onThread...</code>这个方法去进行线程间通信，这只是其中一种最简单的方式。但是缺点也很明显，就是在去调用这个线程的时候，<code>如果线程已经不存在了</code>，程序就会<code>crash</code>。后面我们会仔细讲各种线程间的通信。</p>
<h3 id="线程为什么会结束呢？"><a href="#线程为什么会结束呢？" class="headerlink" title="线程为什么会结束呢？"></a>线程为什么会结束呢？</h3><p>我们先看一下RunLoop的源码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&#x2F;&#x2F;&#x2F; RunLoop的实现<br>int CFRunLoopRunSpecific(runloop, modeName, seconds, stopAfterHandle) &#123;<br>     <br>    &#x2F;&#x2F;&#x2F; 首先根据modeName找到对应mode<br>    CFRunLoopModeRef currentMode &#x3D; __CFRunLoopFindMode(runloop, modeName, false);<br>    &#x2F;&#x2F;&#x2F; 如果mode里没有source&#x2F;timer&#x2F;observer, 直接返回。<br>    if (__CFRunLoopModeIsEmpty(currentMode)) return;<br>     <br>    &#x2F;&#x2F;&#x2F; 1. 通知 Observers: RunLoop 即将进入 loop。<br>    __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopEntry);<br>     <br>    &#x2F;&#x2F;&#x2F; 内部函数，进入loop<br>    __CFRunLoopRun(runloop, currentMode, seconds, returnAfterSourceHandled) &#123;<br>         <br>        Boolean sourceHandledThisLoop &#x3D; NO;<br>        int retVal &#x3D; 0;<br>        do &#123;<br>  <br>            &#x2F;&#x2F;&#x2F; 2. 通知 Observers: RunLoop 即将触发 Timer 回调。<br>            __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeTimers);<br>            &#x2F;&#x2F;&#x2F; 3. 通知 Observers: RunLoop 即将触发 Source0 (非port) 回调。<br>            __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeSources);<br>            &#x2F;&#x2F;&#x2F; 执行被加入的block<br>            __CFRunLoopDoBlocks(runloop, currentMode);<br>             <br>            &#x2F;&#x2F;&#x2F; 4. RunLoop 触发 Source0 (非port) 回调。<br>            sourceHandledThisLoop &#x3D; __CFRunLoopDoSources0(runloop, currentMode, stopAfterHandle);<br>            &#x2F;&#x2F;&#x2F; 执行被加入的block<br>            __CFRunLoopDoBlocks(runloop, currentMode);<br>  <br>            &#x2F;&#x2F;&#x2F; 5. 如果有 Source1 (基于port) 处于 ready 状态，直接处理这个 Source1 然后跳转去处理消息。<br>            if (__Source0DidDispatchPortLastTime) &#123;<br>                Boolean hasMsg &#x3D; __CFRunLoopServiceMachPort(dispatchPort, &amp;msg)<br>                if (hasMsg) goto handle_msg;<br>            &#125;<br>             <br>            &#x2F;&#x2F;&#x2F; 6.通知 Observers: RunLoop 的线程即将进入休眠(sleep)。<br>            if (!sourceHandledThisLoop) &#123;<br>                __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeWaiting);<br>            &#125;<br>             <br>            &#x2F;&#x2F;&#x2F; 7. 调用 mach_msg 等待接受 mach_port 的消息。线程将进入休眠, 直到被下面某一个事件唤醒。<br>            &#x2F;&#x2F;&#x2F; ? 一个基于 port 的Source 的事件。<br>            &#x2F;&#x2F;&#x2F; ? 一个 Timer 到时间了<br>            &#x2F;&#x2F;&#x2F; ? RunLoop 自身的超时时间到了<br>            &#x2F;&#x2F;&#x2F; ? 被其他什么调用者手动唤醒<br>            __CFRunLoopServiceMachPort(waitSet, &amp;msg, sizeof(msg_buffer), &amp;livePort) &#123;<br>                mach_msg(msg, MACH_RCV_MSG, port); &#x2F;&#x2F; thread wait for receive msg<br>            &#125;<br>  <br>            &#x2F;&#x2F;&#x2F; 8. 通知 Observers: RunLoop 的线程刚刚被唤醒了。<br>            __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopAfterWaiting);<br>             <br>            &#x2F;&#x2F;&#x2F; 9.收到消息，处理消息。<br>            handle_msg:<br>  <br>            &#x2F;&#x2F;&#x2F; 10.1 如果一个 Timer 到时间了，触发这个Timer的回调。<br>            if (msg_is_timer) &#123;<br>                __CFRunLoopDoTimers(runloop, currentMode, mach_absolute_time())<br>            &#125; <br>  <br>            &#x2F;&#x2F;&#x2F; 10.2 如果有dispatch到main_queue的block，执行block。<br>            else if (msg_is_dispatch) &#123;<br>                __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg);<br>            &#125; <br>  <br>            &#x2F;&#x2F;&#x2F; 10.3 如果一个 Source1 (基于port) 发出事件了，处理这个事件<br>            else &#123;<br>                CFRunLoopSourceRef source1 &#x3D; __CFRunLoopModeFindSourceForMachPort(runloop, currentMode, livePort);<br>                sourceHandledThisLoop &#x3D; __CFRunLoopDoSource1(runloop, currentMode, source1, msg);<br>                if (sourceHandledThisLoop) &#123;<br>                    mach_msg(reply, MACH_SEND_MSG, reply);<br>                &#125;<br>            &#125;<br>             <br>            &#x2F;&#x2F;&#x2F; 执行加入到Loop的block<br>            __CFRunLoopDoBlocks(runloop, currentMode);<br>             <br>  <br>            if (sourceHandledThisLoop &amp;&amp; stopAfterHandle) &#123;<br>                &#x2F;&#x2F;&#x2F; 进入loop时参数说处理完事件就返回。<br>                retVal &#x3D; kCFRunLoopRunHandledSource;<br>            &#125; else if (timeout) &#123;<br>                &#x2F;&#x2F;&#x2F; 超出传入参数标记的超时时间了<br>                retVal &#x3D; kCFRunLoopRunTimedOut;<br>            &#125; else if (__CFRunLoopIsStopped(runloop)) &#123;<br>                &#x2F;&#x2F;&#x2F; 被外部调用者强制停止了<br>                retVal &#x3D; kCFRunLoopRunStopped;<br>            &#125; else if (__CFRunLoopModeIsEmpty(runloop, currentMode)) &#123;<br>                &#x2F;&#x2F;&#x2F; source&#x2F;timer&#x2F;observer一个都没有了<br>                retVal &#x3D; kCFRunLoopRunFinished;<br>            &#125;<br>             <br>            &#x2F;&#x2F;&#x2F; 如果没超时，mode里没空，loop也没被停止，那继续loop。<br>        &#125; while (retVal &#x3D;&#x3D; 0);<br>    &#125;<br>     <br>    &#x2F;&#x2F;&#x2F; 11. 通知 Observers: RunLoop 即将退出。<br>    __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit);<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>大概流程是这样的：</p>
<blockquote>
<p>1、函数的主体是一个do,while循环，用一个变量retVal，来控制循环的执行。默认为0，无限循环。<br>2、刚进入循环1，2，3，4，5在做一件事，就是检查是否有事件需要处理，如果有的话，就直接跳到9去处理事件。<br>3、处理完事件之后，到第10，会去判断4种是否应该跳出循环的情况，给变量retVal赋一个不为0的值，来跳出循环。<br>4、如果走到6，则判断没有事做，那么runloop就睡眠了，停在第7行，这一行</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">__CFRunLoopServiceMachPort(waitSet, &amp;msg, <span class="hljs-keyword">sizeof</span>(msg_buffer), &amp;livePort)<br> &#123; <br>      <span class="hljs-comment">// thread wait for receive msg </span><br>      mach_msg(msg, MACH_RCV_MSG, port); <br>&#125;<br><br>这一行类似sync这样的一个同步机制（其实不是，举个例子。。）<br>，把程序阻塞在这一行，直到有消息返回值，才继续往下进行。<br>这一阻塞操作是系统内核来挂起的，阻塞了当前的线程，<br>当有消息返回时，因为当前线程是被阻塞的，<br>系统内核会再开辟一个新的线程去返回这个消息。<br>然后程序继续往下进行。<br><br></code></pre></td></tr></table></figure>

<blockquote>
<p>5、走到第8、9，通知Observers，然后处理事件。<br>6、到10，去判断是否退出循环的条件，如果满足条件退出循环，runloop结束。反之，又从新开始循环，从2开始。</p>
</blockquote>
<p>那为什么执行完之后RunLoop会退出呢？</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">if</span> (sourceHandledThisLoop &amp;&amp; stopAfterHandle)<br>&#123; <br>    <span class="hljs-comment">/// 进入loop时参数说处理完事件就返回。 </span><br>    retVal = kCFRunLoopRunHandledSource; <br>&#125;<br></code></pre></td></tr></table></figure>
<p>这种形式开启的runloop, stopAfterHandle这个参数为YES，<br>而sourceHandledThisLoop这个参数在如下代码中被赋值为YES：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">/// 10.3 如果一个 Source1 (基于port) 发出事件了，处理这个事件</span><br><span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-built_in">CFRunLoopSourceRef</span> source1 = __CFRunLoopModeFindSourceForMachPort(runloop, currentMode, livePort);<br>    sourceHandledThisLoop = __CFRunLoopDoSource1(runloop, currentMode, source1, msg);<br>    <span class="hljs-keyword">if</span> (sourceHandledThisLoop) &#123;<br>        mach_msg(reply, MACH_SEND_MSG, reply);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>所以在这里我们触发了事件之后，runloop被退出了，这时候我们也明白了为什么timer并不会导致runloop的退出。</p>
<h3 id="Core-Foundation中运行runloop的接口"><a href="#Core-Foundation中运行runloop的接口" class="headerlink" title="Core Foundation中运行runloop的接口"></a>Core Foundation中运行runloop的接口</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&#x2F;&#x2F;运行 CFRunLoopRef<br>void CFRunLoopRun();<br>&#x2F;&#x2F;运行 CFRunLoopRef: 参数为运行模式、时间和是否在处理Input Source后退出标志，返回值是exit原因<br>SInt32 CFRunLoopRunInMode (mode, seconds, returnAfterSourceHandled);<br>&#x2F;&#x2F;停止运行 CFRunLoopRef<br>void CFRunLoopStop( CFRunLoopRef rl );<br>&#x2F;&#x2F;唤醒 CFRunLoopRef<br>void CFRunLoopWakeUp ( CFRunLoopRef rl );<br><br></code></pre></td></tr></table></figure>

<h4 id="下面详细介绍一下："><a href="#下面详细介绍一下：" class="headerlink" title="下面详细介绍一下："></a>下面详细介绍一下：</h4><p><code>void CFRunLoopRun();</code></p>
<ul>
<li>运行在默认的kCFRunLoopDefaultMode模式下，直到使用CFRunLoopStop接口停止这个Run Loop，或者Run Loop的所有事件源都被删除。</li>
<li>NSRunloop是基于CFRunloop来封装的，NSRunloop是线程不安全的，而CFRunloop则是线程安全的。</li>
</ul>
<p><code>注意</code>:在这里我们可以看到和上面<code>NSRunloop</code>有一个直观的区别就是，<code>CFRunLoopStop</code>能直接停止掉所有用<code>CFRunloop</code>运行起<code>runloop</code></p>
<p>现在回忆一下上面<br><code>- (BOOL)runMode:(NSString *)mode beforeDate:(NSDate *)limitDate;</code><br>这个方法也是可以用<code>CFRunLoopStop</code>来停止 其实这是因为上面的方法是依据：<br><code>SInt32 CFRunLoopRunInMode (mode, seconds, returnAfterSourceHandled); </code><br>这个方法实现的,可以明显的看出参数是一模一样的,前者默认returnAfterSourceHandled参数为YES，当触发一个非timer事件后，runloop就终止了</p>
<p><code>SInt32 CFRunLoopRunInMode (mode, seconds, returnAfterSourceHandled); </code><br>其中</p>
<ul>
<li>第一个参数是指RunLoop运行的模式（例如kCFRunLoopDefaultMode或者kCFRunLoopCommonModes），</li>
<li>第二个参数是运行时间，第三个参数是是否在处理事件后让Run Loop退出返回，NSRunloop的第三种开启runloop的方法，综上述，我们知道，实际上就是设置stopAfterHandle这个参数为YES</li>
<li>我们知道调用runloop运行，代码是停在这一行不返回的，当返回的时候runloop就结束了，所以这个返回值就是runloop结束原因的返回，为一个枚举值，具体原因如下</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">enum</span> &#123;<br>    kCFRunLoopRunFinished = <span class="hljs-number">1</span>, <span class="hljs-comment">//Run Loop结束，没有Timer或者其他Input Source</span><br>    kCFRunLoopRunStopped = <span class="hljs-number">2</span>, <span class="hljs-comment">//Run Loop被停止，使用CFRunLoopStop停止Run Loop</span><br>    kCFRunLoopRunTimedOut = <span class="hljs-number">3</span>, <span class="hljs-comment">//Run Loop超时</span><br>    kCFRunLoopRunHandledSource = <span class="hljs-number">4</span> <span class="hljs-comment">////Run Loop处理完事件，注意Timer事件的触发是不会让Run Loop退出返回的，即使CFRunLoopRunInMode的第三个参数是YES也不行</span><br>&#125;;<br><br></code></pre></td></tr></table></figure>

<p>看到这，我们发现我们忽略了NSRunloop第三种开启方式的返回值。<br><code>- (BOOL)runMode:(NSString *)mode beforeDate:(NSDate *)limitDate;</code></p>
<p>它其实就是基于<code>CFRunLoopRunInMode</code>封装的，它的返回值为一个Bool值，如果是<code>PerfromSelector***</code>事件或者其他<code>Input Source</code>事件触发处理后，<code>RunLoop</code>会退出返回YES，其他返回NO。</p>
<p>下面举个例子来验证这个问题：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">- (<span class="hljs-keyword">void</span>)testDemo2<br>&#123;<br>    <span class="hljs-built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>), ^&#123;<br>        <br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;starting thread.......&quot;</span>);<br>        <span class="hljs-built_in">NSTimer</span> *timer = [<span class="hljs-built_in">NSTimer</span> timerWithTimeInterval:<span class="hljs-number">1</span> target:<span class="hljs-keyword">self</span> selector:<span class="hljs-keyword">@selector</span>(doTimerTask1:) userInfo:remotePort repeats:<span class="hljs-literal">YES</span>];<br>        [[<span class="hljs-built_in">NSRunLoop</span> currentRunLoop] addTimer:timer forMode:<span class="hljs-built_in">NSDefaultRunLoopMode</span>];<br>            <br>        <span class="hljs-comment">//最后一个参数，是否处理完事件返回,结束runLoop</span><br>        SInt32 result = <span class="hljs-built_in">CFRunLoopRunInMode</span>(kCFRunLoopDefaultMode, <span class="hljs-number">100</span>, <span class="hljs-literal">YES</span>);<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         kCFRunLoopRunFinished = 1, //Run Loop结束，没有Timer或者其他Input Source</span><br><span class="hljs-comment">         kCFRunLoopRunStopped = 2, //Run Loop被停止，使用CFRunLoopStop停止Run Loop</span><br><span class="hljs-comment">         kCFRunLoopRunTimedOut = 3, //Run Loop超时</span><br><span class="hljs-comment">         kCFRunLoopRunHandledSource = 4 ////Run Loop处理完事件，注意Timer事件的触发是不会让Run Loop退出返回的，即使CFRunLoopRunInMode的第三个参数是YES也不行</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">switch</span> (result) &#123;<br>            <span class="hljs-keyword">case</span> kCFRunLoopRunFinished:<br>                <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;kCFRunLoopRunFinished&quot;</span>);<br>                <br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> kCFRunLoopRunStopped:<br>                <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;kCFRunLoopRunStopped&quot;</span>);<br><br>            <span class="hljs-keyword">case</span> kCFRunLoopRunTimedOut:<br>                <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;kCFRunLoopRunTimedOut&quot;</span>);<br><br>            <span class="hljs-keyword">case</span> kCFRunLoopRunHandledSource:<br>                <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;kCFRunLoopRunHandledSource&quot;</span>);<br>            <span class="hljs-keyword">default</span>:<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;end thread.......&quot;</span>);<br>        <br>    &#125;);<br><br>&#125;<br><br>- (<span class="hljs-keyword">void</span>)doTimerTask1:(<span class="hljs-built_in">NSTimer</span> *)timer<br>&#123;<br>    <br>    count++;<br>    <span class="hljs-keyword">if</span> (count == <span class="hljs-number">2</span>) &#123;<br>        [timer invalidate];<br>    &#125;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;do timer task count:%d&quot;</span>,count);<br></code></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">2016-11-23 09:19:28.342 TestRunloop3[88598:1971412] starting thread.......<br>2016-11-23 09:19:29.347 TestRunloop3[88598:1971412] do timer task count:1<br>2016-11-23 09:19:30.345 TestRunloop3[88598:1971412] do timer task count:2<br>2016-11-23 09:19:30.348 TestRunloop3[88598:1971412] kCFRunLoopRunFinished<br>2016-11-23 09:19:30.348 TestRunloop3[88598:1971412] end thread.......<br><br></code></pre></td></tr></table></figure>

<p><code>很清楚的可以看到，当timer被置无效的时候，runloop里面没有了任何的事件源，所以退出了，退出原因为：kCFRunLoopRunFinished，线程也就结束了。</code></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="RunLoop停止和取消的方法"><a href="#RunLoop停止和取消的方法" class="headerlink" title="RunLoop停止和取消的方法"></a>RunLoop停止和取消的方法</h3><blockquote>
<p>1、移除掉runloop中的所有事件源（timer和source）<br>2、设置一个超时时间。<br>3、只要CFRunloop运行起来就可以用：<br>    <code>void CFRunLoopStop( CFRunLoopRef rl );</code>去停止。<br>4、除此之外用NSRunLoop下面这个方法运行也能使用<br>     <code>void CFRunLoopStop( CFRunLoopRef rl );</code>停止：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">[NSRunLoop currentRunLoop]runMode:&lt;#(nonnull<br> NSRunLoopMode)#&gt; beforeDate:&lt;#(nonnull NSDate *)#&gt;<br></code></pre></td></tr></table></figure>

<p>实际过程中，可以根据需求，我们可以设置一个自己的Bool值，<br>  来控制runloop的开始与停止,类似下面这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">  while (!cancel) &#123;<br>CFRunLoopRunInMode(kCFRunLoopDefaultMode, 1, YES);<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>每次runloop只运行1秒就停止，然后开始下一次的runloop。</li>
<li>这里最后一个参数设置为YES，当有非timer事件进来，也会立即开始下一次runloop。</li>
<li>当然每次进来我们都可以去修改Mode的值，这样我们可以让runloop每次都运行在不同的模式下。</li>
<li>当我们不需要runloop的时候，直接将cancel置为YES即可</li>
</ul>
<h2 id="基于runloop的线程通信"><a href="#基于runloop的线程通信" class="headerlink" title="基于runloop的线程通信"></a>基于runloop的线程通信</h2><p>首先明确一个概念，线程间的通信（不仅限于通信，几乎所有iOS事件都是如此），实际上是各种输入源，触发runloop去处理对应的事件，所以我们先来讲讲输入源：</p>
<p>输入源异步的发送消息给你的线程。事件来源取决于输入源的种类：</p>
<ul>
<li>基于端口的输入源和自定义输入源。基于端口的输入源监听程序相应的端口。自定义输入源则监听自定义的事件源。</li>
</ul>
<p>至于run loop，它不关心输入源的是基于端口的输入源还是自定义的输入源。系统会实现两种输入源供你使用。两类输入源的区别在于：</p>
<ul>
<li>基于端口的输入源由内核自动发送，而自定义的则需要人工从其他线程发送。</li>
</ul>
<p>当你创建输入源，你需要将其分配给<code>RunLoop</code>中的一个或多个模式。模式只会在特定事件影响监听的源。大多数情况下，<code>RunLoop</code>运行在默认模式下，但是你也可以使其运行在自定义模式。若某一源在当前模式下不被监听，那么任何其生成的消息只在<code>RunLoop</code>运行在其关联的模式下才会被传递。</p>
<h3 id="基于端口的输入源"><a href="#基于端口的输入源" class="headerlink" title="基于端口的输入源:"></a>基于端口的输入源:</h3><p>在<code>RunLoop</code>中，被定义名为<code>souce1</code>。Cocoa和Core Foundation内置支持使用端口相关的对象和函数来创建的基于端口的源。例如，在Cocoa里面你从来不需要直接创建输入源。你只要简单的创建端口对象，并使用<code>NSPort</code>的方法把该端口添加到<code>Run Loop</code>。端口对象会自己处理创建和配置输入源。</p>
<p>在Core Foundation，你必须人工创建端口和它的<code>RunLoop</code>源.在两种情况下，你都可以使用端口相关的函数（CFMachPortRef，CFMessagePortRef，CFSocketRef）来创建合适的对象。</p>
<p>这里用Cocoa里的举个例子，Cocoa里用来线程间传值的是NSMachPort，它的父类是NSPort。<br>首先我们看下面：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">NSPort *port1 &#x3D; [[NSPort alloc]init];<br>NSPort *port2 &#x3D; [[NSMachPort alloc]init];<br>NSPort *port3 &#x3D; [NSPort port];<br>NSPort *port4 &#x3D; [NSMachPort port];<br></code></pre></td></tr></table></figure>
<p>我们打断点可以看到如下：<br><img src="http://upload-images.jianshu.io/upload_images/2702646-6364a8544aa941b3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="port图.png"></p>
<ul>
<li>发现我们怎么创建，都返回给我们的是NSMachPort的实例，这应该是NSPort内部做了一个消息的转发，这就有点像是一个抽象类了，它本身只是定义一些公有的属性和方法，然后利用集成它的子类去实现（只是我个人猜测。。）</li>
</ul>
<p>继续看我们写的一个利用NSMachPort来线程通信的实例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">(void)testDemo3<br>&#123;<br>&#x2F;&#x2F;声明两个端口 随便怎么写创建方法，返回的总是一个NSMachPort实例<br>NSMachPort *mainPort &#x3D; [[NSMachPort alloc]init];<br>NSPort *threadPort &#x3D; [NSMachPort port];<br><br>&#x2F;&#x2F;设置线程的端口的代理回调为自己<br>threadPort.delegate &#x3D; self;<br><br>&#x2F;&#x2F;给主线程runloop加一个端口<br>[[NSRunLoop currentRunLoop]addPort:mainPort forMode:NSDefaultRunLoopMode];<br><br>dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;<br><br>  &#x2F;&#x2F;添加一个Port<br>  [[NSRunLoop currentRunLoop]addPort:threadPort forMode:NSDefaultRunLoopMode];<br>  [[NSRunLoop currentRunLoop]runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]];<br>&#125;);<br><br>NSString *s1 &#x3D; @&quot;hello&quot;;<br><br>NSData *data &#x3D; [s1 dataUsingEncoding:NSUTF8StringEncoding];<br><br>dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;<br>NSMutableArray *array &#x3D; [NSMutableArray arrayWithArray:@[mainPort,data]];<br>&#x2F;&#x2F;过2秒向threadPort发送一条消息，第一个参数：发送时间。msgid 消息标识。<br>&#x2F;&#x2F;components，发送消息附带参数。reserved：为头部预留的字节数（从官方文档上看到的，猜测可能是类似请求头的东西...）<br>[threadPort sendBeforeDate:[NSDate date] msgid:1000 components:array from:mainPort reserved:0];<br><br>&#125;);<br><br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>这个NSMachPort收到消息的回调，注意这个参数，可以先给一个id。如果用文档里的NSPortMessage会发现无法取值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">(void)handlePortMessage:(id)message<br>&#123;<br><br>NSLog(@&quot;收到消息了，线程为：%@&quot;,[NSThread currentThread]);<br><br>&#x2F;&#x2F;只能用KVC的方式取值<br>NSArray *array &#x3D; [message valueForKeyPath:@&quot;components&quot;];<br><br>NSData *data &#x3D; array[1];<br>NSString *s1 &#x3D; [[NSString alloc]initWithData:data encoding:NSUTF8StringEncoding];<br>NSLog(@&quot;%@&quot;,s1);<br><br>&#x2F;&#x2F; NSMachPort *localPort &#x3D; [message valueForKeyPath:@&quot;localPort&quot;];<br>&#x2F;&#x2F; NSMachPort *remotePort &#x3D; [message valueForKeyPath:@&quot;remotePort&quot;];<br><br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>结果打印如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">2016-11-23 16:50:20.604 TestRunloop3[1322:120162] 收到消息了，线程为：&lt;NSThread: 0x60800026d700&gt;&#123;number &#x3D; 3, name &#x3D; (null)&#125;<br>2016-11-23 16:50:26.551 TestRunloop3[1322:120162] hello<br><br></code></pre></td></tr></table></figure>

<ul>
<li><p>1、我们跨越线程，确实从主线程往另一个线程发送了消息。</p>
</li>
<li><p>2、这里要注意几个点：</p>
<blockquote>
<p>1、<code>- (void)handlePortMessage:(id)message</code>这里这个代理的参数，从.h里去复制过来的为NSPortMessage类型的一个对象，但是我们发现苹果只是在.h中@class进来，我们无法调用它的任何方法。所以我们用id声明，然后通过KVC去取它的属性。</p>
</blockquote>
<blockquote>
<p>2、关于下面这个传值类型的问题：</p>
</blockquote>
  <figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">NSMutableArray *array &#x3D; [NSMutableArray  <br>arrayWithArray:@[mainPort,data]];<br></code></pre></td></tr></table></figure>


</li>
</ul>
<p>作者在这困惑了好一会。。之前我是往数组里添加的是String或者其他类型的对象，但是发现参数传过去之后，变成nil了。于是去百度查了半天，然后没有结果。。于是去翻官方文档，终于在方法描述里看到（其实很醒目。。然而作者英文水平实在有限。。）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">The components array consists of a series of instances of some subclass of NSData, <br>and instances of some subclass of NSPort; <br>since one subclass of NSPort does not necessarily know  how to transport an instance of another subclass of NSPort (or could do it even if it<br><br>knew about the other subclass), all of the instancesof NSPort in the components array and the<br> &#39;receivePort&#39;argument MUST be of the same subclass of NSPort that receives this message.  If <br> multiple DO transports are being used in the same program, this requires some care.<br></code></pre></td></tr></table></figure>

<p>  从这段描述中我们可以看出，<strong>这个传参数组里面只能装两种类型的数据，一种是NSPort的子类，一种是NSData的子类。</strong>所以我们如果要用这种方式传值必须得先把数据转成NSData类型的才行。</p>
<h3 id="Cocoa-执行-Selector-的源"><a href="#Cocoa-执行-Selector-的源" class="headerlink" title="Cocoa 执行 Selector 的源:"></a>Cocoa 执行 Selector 的源:</h3><p>  除了基于端口的源，Cocoa定义了自定义输入源，允许你在任何线程执行selector。它被称为source0,和基于端口的源一样，执行selector请求会在目标线程上序列化，减缓许多在线程上允许多个方法容易引起的同步问题。不像基于端口的源，一个selector执行完后会自动从run loop里面移除。</p>
<p>有方法如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">[self performSelectorOnMainThread:&lt;#(nonnull SEL)#&gt; withObject:&lt;#(nullable id)#&gt; waitUntilDone:&lt;#(BOOL)#&gt;]<br><br>[self performSelectorOnMainThread:&lt;#(nonnull SEL)#&gt; withObject:&lt;#(nullable id)#&gt; waitUntilDone:&lt;#(BOOL)#&gt; modes:&lt;#(nullable NSArray&lt;NSString *&gt; *)#&gt;]<br><br>[self performSelector:&lt;#(nonnull SEL)#&gt; onThread:&lt;#(nonnull NSThread *)#&gt; withObject:&lt;#(nullable id)#&gt; waitUntilDone:&lt;#(BOOL)#&gt;]<br><br>[self performSelector:&lt;#(nonnull SEL)#&gt; onThread:&lt;#(nonnull NSThread *)#&gt; withObject:&lt;#(nullable id)#&gt; waitUntilDone:&lt;#(BOOL)#&gt; modes:&lt;#(nullable NSArray&lt;NSString *&gt; *)#&gt;]<br><br></code></pre></td></tr></table></figure>

<ul>
<li>这四个方法很类似，一个是在主线程去掉，一个可以指定一个线程。然后一个带Mode，一个不带。</li>
<li>大概讲一下 waitUntilDone 这个参数，顾名思义，就是是否等到结束。<br>1）如果这个值设为YES，那么就需要等到这个方法执行完，线程才能继续往下去执行。它会阻塞提交的线程。<br>2）如果为NO的话，这个调用的方法会异步的实行，不会阻塞提交线程。</li>
</ul>
<h3 id="自定义输入源"><a href="#自定义输入源" class="headerlink" title="自定义输入源:"></a>自定义输入源:</h3><p> 为了自定义输入源，必须使用 Core Foundation里面的 CGRunLoopSourceRef类型相关的函数来创建。你可以使用回调函数来配置自定义输入源。Corefondation 会在配置源的不同地方调用回调函数，处理输入时间，在源从 runloop 移除的时候清理它。<br>除了定义在事件到达时自定义输入源的行为，你也必须定义消息传递机制。源的这部分运行在单独的线程里面，并负责在数据等待处理的时候传递数据给源并源并通知它处理数据。消息传递机制的定义取决于你，但是最好不要过于复杂。<br>创建自定义的输入源包括定义以下内容：<br>1.输入源要处理的信息。<br>2.使感兴趣的客户端知道如何和输入源交互的调度例程。<br>3.处理其他任何客户端发送请求的例程。<br>4.使输入源失效的取消例程。</p>
<p>由于创建输入源来处理自定义消息，实际配置选是灵活配置的。调度<br>例程，处理例程和取消例程都是创建自定义输入源是最关键的例程。<br>二输入源其他的大部分行为都发生在这些例程的外部。比如，由于你决定数据传输到输入源的机制，还有输入源和其他线程的通信机制也<br>是由你决定。</p>
<p>下图中，程序的主线程维护了一个输入源的引用，输入源所需的自定义命令缓冲区和输入源所在的 runloop。当主线程有任务需要分发<br>给工作线程时候，**<em>主线程会给命令缓冲区发送命令和必须的信息来通知工作线程开始执行任务。（因为主线程和输入源所在工作线程<br>都可以访问命令缓冲区，因此这些访问必须是同步的）**</em>一旦命令<br>传送出去，主线程会通知输入源并且唤醒工作线程的 runloop。而一收到唤醒命令，runloop 会调用输入源的处理程序，由它来执行<br>命令缓冲区中响应的命令。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">CFRunLoopRef _runLoopRef;<br>CFRunLoopSourceRef _source;<br>CFRunLoopSourceContext _source_context;<br></code></pre></td></tr></table></figure>

<p><img src="http://upload-images.jianshu.io/upload_images/2702646-532788b8b08ec601.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="自定义输入源.png"></p>
<p>还是一样，我们来写一个实例来讲讲自定义的输入源（注：自定义输入源，只有用CF来实现）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">CFRunLoopRef _runLoopRef;<br>CFRunLoopSourceRef _source;<br>CFRunLoopSourceContext _source_context;<br></code></pre></td></tr></table></figure>
<p>首先我们声明3个成员变量，这是我们自定义输入源所需要的3个参数。具体我们举完例子之后再说。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">(void)testDemo4<br>&#123;<br>dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;<br><br>  NSLog(@&quot;starting thread.......&quot;);<br>  <br>  _runLoopRef &#x3D; CFRunLoopGetCurrent();<br>  &#x2F;&#x2F;初始化_source_context。<br>  bzero(&amp;_source_context, sizeof(_source_context));<br>  &#x2F;&#x2F;这里创建了一个基于事件的源，绑定了一个函数<br>  _source_context.perform &#x3D; fire;<br>  &#x2F;&#x2F;参数<br>  _source_context.info &#x3D; &quot;hello&quot;;<br>  &#x2F;&#x2F;创建一个source<br>  _source &#x3D; CFRunLoopSourceCreate(NULL, 0, &amp;_source_context);<br>  &#x2F;&#x2F;将source添加到当前RunLoop中去<br>  CFRunLoopAddSource(_runLoopRef, _source, kCFRunLoopDefaultMode);<br><br>  &#x2F;&#x2F;开启runloop 第三个参数设置为YES，执行完一次事件后返回<br>  CFRunLoopRunInMode(kCFRunLoopDefaultMode, 9999999, YES);<br>  <br>  NSLog(@&quot;end thread.......&quot;);<br>&#125;);<br>dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;<br>    <br>    if (CFRunLoopIsWaiting(_runLoopRef)) &#123;<br>        NSLog(@&quot;RunLoop 正在等待事件输入&quot;);<br>        &#x2F;&#x2F;添加输入事件<br>        CFRunLoopSourceSignal(_source);<br>        &#x2F;&#x2F;唤醒线程，线程唤醒后发现由事件需要处理，于是立即处理事件<br>        CFRunLoopWakeUp(_runLoopRef);<br>    &#125;else &#123;<br>        NSLog(@&quot;RunLoop 正在处理事件&quot;);<br>        &#x2F;&#x2F;添加输入事件，当前正在处理一个事件，当前事件处理完成后，立即处理当前新输入的事件<br>        CFRunLoopSourceSignal(_source);<br>    &#125;<br>&#125;);<br><br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>此输入源需要处理的后台事件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">static void fire(void* info)&#123;<br><br>NSLog(@&quot;我现在正在处理后台任务&quot;);<br><br>printf(&quot;%s&quot;,info);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">2016-11-24 10:42:24.045 TestRunloop3[4683:238183] starting thread.......<br>2016-11-24 10:42:26.045 TestRunloop3[4683:238082] RunLoop 正在等待事件输入<br>2016-11-24 10:42:31.663 TestRunloop3[4683:238183] 我现在正在处理后台任务<br>hello<br>2016-11-24 10:42:31.663 TestRunloop3[4683:238183] end thread.......<br><br></code></pre></td></tr></table></figure>

<p>例中可见我们创建一个自定义的输入源，绑定了一个函数，一个参数，并且用这个输入源，实现了线程间的通信。</p>
<p>大概讲一下：</p>
<blockquote>
<p>1、<code>CFRunLoopRef _runLoopRef;</code>就不用说了，就是CF的runloop。</p>
</blockquote>
<blockquote>
<p>2、<code>CFRunLoopSourceContext _source_context;</code>注意到例中用了一个c函数<code>bzero(&amp;_source_context, sizeof(_source_context));</code>来初始化。</p>
</blockquote>
<p>其实它本质是一个结构体如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&gt;version<br>Version number of the structure. Must be 0.<br>info<br>An arbitrary pointer to program-defined data, which can be associated with the CFRunLoopSource<br> at creation time. This pointer is passed to all the callbacks defined in the context.<br>retain<br>A retain callback for your program-defined info <br>pointer. Can be NULL.<br>release<br>A release callback for your program-defined info <br>pointer. Can be NULL.<br>copyDescription<br>A copy description callback for your program-<br>defined info pointer. Can be NULL.<br>equal<br>An equality test callback for your program-defined <br>info pointer. Can be NULL.<br>hash<br>A hash calculation callback for your program-<br>defined info pointer. Can be NULL.<br>schedule<br>A scheduling callback for the run loop source. <br>This callback is called when the source is added to a run loop mode. Can be NULL.<br>cancel<br>A cancel callback for the run loop source. This <br>callback is called when the source is removed from a run loop mode. Can be NULL.<br>perform<br>A perform callback for the run loop source. This <br>callback is called when the source has fired.<br><br>typedef struct &#123;<br>CFIndex version;<br>void * info;<br>const void (retain)(const void info);<br>void (release)(const void info);<br>CFStringRef (copyDescription)(const void info);<br>Boolean (equal)(const void *info1, const void info2);<br>CFHashCode (hash)(const void info);<br>void (schedule)(void info, CFRunLoopRef rl, CFRunLoopMode mode);<br>void (cancel)(void info, CFRunLoopRef rl, CFRunLoopMode mode);<br>void (perform)(void *info);<br>&#125; CFRunLoopSourceContext;<br><br></code></pre></td></tr></table></figure>

<p> <code>bzero(&amp;_source_context, sizeof(_source_context));</code>所以这个函数其实就是把所有内容先置为0。</p>
<p><code>CFRunLoopSourceRef _source;</code>这个是自定义输入源中最重要的一个参数。它用来连接runloop与<br>CFRunLoopSourceContext中的一些配置项，<strong>注意我们自定义的输入源，必须由我们手动来触发</strong>。需要先<br><code>CFRunLoopSourceSignal(_source);</code>在看当前runloop是否在休眠中，来看是否需要调用<br><code>CFRunLoopWakeUp(_runLoopRef);</code>(一般都是要调用的)。</p>
<h3 id="定时源"><a href="#定时源" class="headerlink" title="定时源:"></a>定时源:</h3><ul>
<li>定时源在预设的时间点同步方式传递消息。定时器是线程通知自己做某事的一种方法。</li>
<li>尽管定时器可以产生基于时间的通知，但它并不是实时机制。和输入源一样，定时器也和 runloop 的特定模式相关。如果定时器所在的模式当前未被 runloop 监视，那么定时器将不会开始知道 runloop 运行在响应的模式下。类似的。如果定时器在 runloop 处理某一事件期间开始，定时器会一直等待直到下次 runloop 开始响应的处理程序。如果 runloop 不运行了，那么定时器也永远不启动。</li>
<li>配置定时源:<br>Cocoa 中可以使用以下 NSTimer 类方法来创建并调配一个定时器:􏰂</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">[NSTimer scheduledTimerWithTimeInterval:&lt;#(NSTimeInterval)#&gt; target:&lt;#(nonnull id)#&gt; selector:&lt;#(nonnull SEL)#&gt; userInfo:&lt;#(nullable id)#&gt; repeats:&lt;#(BOOL)#&gt;<br><br>[NSTimer timerWithTimeInterval:&lt;#(NSTimeInterval)#&gt; target:&lt;#(nonnull id)#&gt; selector:&lt;#(nonnull SEL)#&gt; userInfo:&lt;#(nullable id)#&gt; repeats:&lt;#(BOOL)#&gt;]<br><br></code></pre></td></tr></table></figure>

<p>当然还有Block ,invocation的形式，就不做赘述了。<br>第一种timer默认是把加到了NSDefaultRunLoopMode模式下。<br>第二种timer没有默认值，我们使用的使用必须调用<br><code>[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSDefaultRunLoopMode];</code>去给它指定一个mode。</p>
<h3 id="Core-Foundation-创建定时器"><a href="#Core-Foundation-创建定时器" class="headerlink" title="Core Foundation 创建定时器"></a>Core Foundation 创建定时器</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">CFRunLoopRef runLoop &#x3D; CFRunLoopGetCurrent();<br>CFRunLoopTimerContext context &#x3D; &#123;0, NULL, NULL, NULL, NULL&#125;;<br>CFRunLoopTimerRef timer &#x3D; CFRunLoopTimerCreate(kCFAllocatorDefault, 0.1, 0.3, 0, 0,<br>&amp;myCFTimerCallback, &amp;context);<br><br></code></pre></td></tr></table></figure>

<p>最后用一张runloop运行时的流程图来梳理一下我们这些源触发的顺序<br><img src="http://upload-images.jianshu.io/upload_images/2702646-60d6d86082e68ce0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="RunLoop_1.png"></p>
<p>如图所示，首先我要明确一个知识点：<strong>runloop跑一圈，只能执行一个事件。</strong></p>
<p><strong>timer和source0进入runloop中，都只是通知Observer我要处理，但是还是会有 678睡眠唤醒这一步。但是source1如果有，就会直接跳到第9步去执行。</strong></p>
<p>我们前面也讲过第7步，这里再提一下。它是一直阻塞在这一行的，直到：</p>
<ul>
<li><p>a.soruce1来了。</p>
</li>
<li><p>b.定时器启动。 </p>
</li>
<li><p>c.runloop超时。</p>
</li>
<li><p>d.runloop被显示唤醒CFRunLoopWakeUp(runloop) (也就是source0来了)。</p>
<p>这里可能大家会奇怪了，之前不是说source1有的话就直接跳到第9步去执行了么？但是仔细想想，如果runloop正处在睡眠状态下，这时候有个soruce1来了，是不是也需要唤醒runloop~</p>
</li>
</ul>
<h3 id="Run-Loop的Observer"><a href="#Run-Loop的Observer" class="headerlink" title="Run Loop的Observer"></a>Run Loop的Observer</h3><p>上图提到了Observer，顺带简单讲讲吧：<br>Core Foundation层的接口可以定义一个Run Loop的观察者在— Run Loop进入以下某个状态时得到通知：</p>
<ul>
<li>Run loop的进入</li>
<li>Run loop处理一个Timer的时刻</li>
<li>Run loop处理一个Input Source的时刻</li>
<li>Run loop进入睡眠的时刻</li>
<li>Run loop被唤醒的时刻，但在唤醒它的事件被处理之前</li>
<li>Run loop的终止</li>
<li>Observer的创建以及添加到Run Loop中需要使用Core Foundation的接口：<br>方法很简单如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&#x2F;&#x2F; 创建observer<br>CFRunLoopObserverRef observer &#x3D; CFRunLoopObserverCreateWithHandler(CFAllocatorGetDefault(), kCFRunLoopAllActivities, YES, 0, ^(CFRunLoopObserverRef observer, CFRunLoopActivity activity) &#123;<br>&#125;);<br><br></code></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&#x2F;&#x2F; 添加观察者：监听RunLoop的状态<br>CFRunLoopAddObserver(CFRunLoopGetCurrent(), observer, kCFRunLoopDefaultMode);<br>&#x2F;&#x2F; 释放Observer<br>CFRelease(observer);<br></code></pre></td></tr></table></figure>

<p> 方法就是创建一个observer，绑定一个runloop和模式，而block回调就是监听到runloop每种状态的时候会触发。</p>
<p>  其中<code>CFRunLoopActivity</code>是一枚举值，与每种状态对应：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123;<br>kCFRunLoopEntry &#x3D; (1UL &lt;&lt; 0), &#x2F;&#x2F; 1 &#x2F;&#x2F; 即将进入Loop<br>kCFRunLoopBeforeTimers &#x3D; (1UL &lt;&lt; 1), &#x2F;&#x2F; 2 &#x2F;&#x2F; 即将处理 Timer<br>kCFRunLoopBeforeSources &#x3D; (1UL &lt;&lt; 2), &#x2F;&#x2F; 4 即将处理 Source<br>kCFRunLoopBeforeWaiting &#x3D; (1UL &lt;&lt; 5), &#x2F;&#x2F; 32 &#x2F;&#x2F; 即将进入休眠<br>kCFRunLoopAfterWaiting &#x3D; (1UL &lt;&lt; 6), &#x2F;&#x2F; 64<br>&#x2F;&#x2F; 刚从休眠中唤醒<br>kCFRunLoopExit &#x3D; (1UL &lt;&lt; 7), &#x2F;&#x2F; 128 &#x2F;&#x2F; 即将退出Loop<br>kCFRunLoopAllActivities &#x3D; 0x0FFFFFFFU &#x2F;&#x2F; 可以监听以上所有状态<br>&#125;;<br><br></code></pre></td></tr></table></figure>


<h2 id="RunLoop-与线程的关系"><a href="#RunLoop-与线程的关系" class="headerlink" title="RunLoop 与线程的关系"></a>RunLoop 与线程的关系</h2><p>iOS 开发中能遇到两个线程对象: pthread_t 和 NSThread,过去苹果有份文档标明了 NSThread 只是 pthread_t 的封装，但那份文档已经失效了，现在它们也有可能都是直接包装自最底层的 mach thread。</p>
<p>苹果并没有提供这两个对象相互转换的接口，但不管怎么样，可以肯定的是 pthread_t 和 NSThread 是一一对应的。比如，你可以通过 pthread_main_thread_np() 或 [NSThread mainThread] 来获取主线程；也可以通过 pthread_self() 或 [NSThread currentThread] 来获取当前线程。CFRunLoop 是基于 pthread 来管理的。</p>
<p>苹果不允许直接创建 RunLoop，它只提供了两个自动获取的函数：CFRunLoopGetMain() 和 CFRunLoopGetCurrent()。 这两个函数内部的逻辑大概是下面这样:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&#x2F;&#x2F;&#x2F; 全局的Dictionary，key 是 pthread_t， value 是 CFRunLoopRef<br>static CFMutableDictionaryRef loopsDic;<br>&#x2F;&#x2F;&#x2F; 访问 loopsDic 时的锁<br>static CFSpinLock_t loopsLock;<br> <br>&#x2F;&#x2F;&#x2F; 获取一个 pthread 对应的 RunLoop。<br>CFRunLoopRef _CFRunLoopGet(pthread_t thread) &#123;<br>    OSSpinLockLock(&amp;loopsLock);<br>    <br>    if (!loopsDic) &#123;<br>        &#x2F;&#x2F; 第一次进入时，初始化全局Dic，并先为主线程创建一个 RunLoop。<br>        loopsDic &#x3D; CFDictionaryCreateMutable();<br>        CFRunLoopRef mainLoop &#x3D; _CFRunLoopCreate();<br>        CFDictionarySetValue(loopsDic, pthread_main_thread_np(), mainLoop);<br>    &#125;<br>    <br>    &#x2F;&#x2F;&#x2F; 直接从 Dictionary 里获取。<br>    CFRunLoopRef loop &#x3D; CFDictionaryGetValue(loopsDic, thread));<br>    <br>    if (!loop) &#123;<br>        &#x2F;&#x2F;&#x2F; 取不到时，创建一个<br>        loop &#x3D; _CFRunLoopCreate();<br>        CFDictionarySetValue(loopsDic, thread, loop);<br>        &#x2F;&#x2F;&#x2F; 注册一个回调，当线程销毁时，顺便也销毁其对应的 RunLoop。<br>        _CFSetTSD(..., thread, loop, __CFFinalizeRunLoop);<br>    &#125;<br>    <br>    OSSpinLockUnLock(&amp;loopsLock);<br>    return loop;<br>&#125;<br> <br>CFRunLoopRef CFRunLoopGetMain() &#123;<br>    return _CFRunLoopGet(pthread_main_thread_np());<br>&#125;<br> <br>CFRunLoopRef CFRunLoopGetCurrent() &#123;<br>    return _CFRunLoopGet(pthread_self());<br>&#125;<br></code></pre></td></tr></table></figure>

<p>从上面的代码可以看出，线程和 RunLoop 之间是一一对应的，其关系是保存在一个全局的 Dictionary 里。线程刚创建时并没有 RunLoop，如果你不主动获取，那它一直都不会有。RunLoop 的创建是发生在第一次获取时，RunLoop 的销毁是发生在线程结束时。你只能在一个线程的内部获取其 RunLoop（<code>主线程除外</code>）。</p>
<h2 id="RunLoop-对外的接口"><a href="#RunLoop-对外的接口" class="headerlink" title="RunLoop 对外的接口"></a>RunLoop 对外的接口</h2><p>在 CoreFoundation 里面关于 RunLoop 有5个类:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">CFRunLoopRef<br>CFRunLoopModeRef<br>CFRunLoopSourceRef<br>CFRunLoopTimerRef<br>CFRunLoopObserverRef<br></code></pre></td></tr></table></figure>

<p>其中 CFRunLoopModeRef 类并没有对外暴露，只是通过 CFRunLoopRef 的接口进行了封装。他们的关系如下:<br><img src="https://blog.ibireme.com/wp-content/uploads/2015/05/RunLoop_0.png"></p>
<p>一个 RunLoop 包含若干个 Mode，每个 Mode 又包含若干个 Source/Timer/Observer。每次调用 RunLoop 的主函数时，只能指定其中一个 Mode，这个Mode被称作 CurrentMode。如果需要切换 Mode，只能退出 Loop，再重新指定一个 Mode 进入。这样做主要是为了分隔开不同组的 Source/Timer/Observer，让其互不影响。</p>
<p><code>CFRunLoopSourceRef</code> 是事件产生的地方。Source有两个版本：<code>Source0</code> 和 <code>Source1</code>。</p>
<blockquote>
<p>Source0 只包含了一个回调（函数指针），它并不能主动触发事件。使用时，你需要先调用 <code>CFRunLoopSourceSignal(source)</code>，将这个 Source 标记为待处理，然后手动调用 <code>CFRunLoopWakeUp(runloop)</code> 来唤醒 RunLoop，让其处理这个事件。<br>Source1 包含了一个 <code>mach_port</code> 和一个回调（函数指针），被用于通过内核和其他线程相互发送消息。这种 Source 能主动唤醒 RunLoop 的线程，其原理在下面会讲到。</p>
</blockquote>
<p><code>CFRunLoopTimerRef</code> 是基于时间的触发器，它和 NSTimer 是<code>toll-free bridged</code> 的，可以混用。其包含一个时间长度和一个回调（函数指针）。当其加入到 RunLoop 时，RunLoop会注册对应的时间点，当时间点到时，RunLoop会被唤醒以执行那个回调。</p>
<p><code>CFRunLoopObserverRef</code> 是观察者，每个 Observer 都包含了一个回调（函数指针），当 RunLoop 的状态发生变化时，观察者就能通过回调接受到这个变化。可以观测的时间点有以下几个：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123;<br>    kCFRunLoopEntry         &#x3D; (1UL &lt;&lt; 0), &#x2F;&#x2F; 即将进入Loop<br>    kCFRunLoopBeforeTimers  &#x3D; (1UL &lt;&lt; 1), &#x2F;&#x2F; 即将处理 Timer<br>    kCFRunLoopBeforeSources &#x3D; (1UL &lt;&lt; 2), &#x2F;&#x2F; 即将处理 Source<br>    kCFRunLoopBeforeWaiting &#x3D; (1UL &lt;&lt; 5), &#x2F;&#x2F; 即将进入休眠<br>    kCFRunLoopAfterWaiting  &#x3D; (1UL &lt;&lt; 6), &#x2F;&#x2F; 刚从休眠中唤醒<br>    kCFRunLoopExit          &#x3D; (1UL &lt;&lt; 7), &#x2F;&#x2F; 即将退出Loop<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>上面的 <code>Source/Timer/Observer</code> 被统称为 <code>mode item</code>，一个 item 可以被同时加入多个 mode。但一个 item 被重复加入同一个 mode 时是不会有效果的。如果一个 mode 中一个 item 都没有，则 RunLoop 会直接退出，不进入循环。</p>
<h2 id="RunLoop-的-Mode"><a href="#RunLoop-的-Mode" class="headerlink" title="RunLoop 的 Mode"></a>RunLoop 的 Mode</h2><p><code>CFRunLoopMode</code> 和 <code>CFRunLoop</code> 的结构大致如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">struct __CFRunLoopMode &#123;<br>    CFStringRef _name;            &#x2F;&#x2F; Mode Name, 例如 @&quot;kCFRunLoopDefaultMode&quot;<br>    CFMutableSetRef _sources0;    &#x2F;&#x2F; Set<br>    CFMutableSetRef _sources1;    &#x2F;&#x2F; Set<br>    CFMutableArrayRef _observers; &#x2F;&#x2F; Array<br>    CFMutableArrayRef _timers;    &#x2F;&#x2F; Array<br>    ...<br>&#125;;<br> <br>struct __CFRunLoop &#123;<br>    CFMutableSetRef _commonModes;     &#x2F;&#x2F; Set<br>    CFMutableSetRef _commonModeItems; &#x2F;&#x2F; Set&lt;Source&#x2F;Observer&#x2F;Timer&gt;<br>    CFRunLoopModeRef _currentMode;    &#x2F;&#x2F; Current Runloop Mode<br>    CFMutableSetRef _modes;           &#x2F;&#x2F; Set<br>    ...<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>这里有个概念叫 “CommonModes”：一个 Mode 可以将自己标记为”Common”属性（通过将其 ModeName 添加到 RunLoop 的 “commonModes” 中）。每当 RunLoop 的内容发生变化时，RunLoop 都会自动将 <code>_commonModeItems</code> 里的 <code>Source/Observer/Timer</code> 同步到具有 “Common” 标记的所有Mode里。</p>
<p>应用场景举例：主线程的 RunLoop 里有两个预置的 Mode：<code>kCFRunLoopDefaultMode</code> 和 <code>UITrackingRunLoopMode</code>。这两个 Mode 都已经被标记为”Common”属性。DefaultMode 是 App 平时所处的状态，<code>TrackingRunLoopMode</code> 是追踪 ScrollView 滑动时的状态。当你创建一个 Timer 并加到 DefaultMode 时，Timer 会得到重复回调，但此时滑动一个TableView时，RunLoop 会将 mode 切换为 <code>TrackingRunLoopMode</code>，这时 Timer 就不会被回调，并且也不会影响到滑动操作。</p>
<p>有时你需要一个 Timer，在两个 Mode 中都能得到回调，一种办法就是将这个 Timer 分别加入这两个 Mode。还有一种方式，就是将 Timer 加入到顶层的 RunLoop 的 “commonModeItems” 中。”commonModeItems” 被 RunLoop 自动更新到所有具有”Common”属性的 Mode 里去。</p>
<ul>
<li>CFRunLoop对外暴露的管理 Mode 接口只有下面2个:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">CFRunLoopAddCommonMode(CFRunLoopRef runloop, CFStringRef modeName);<br>CFRunLoopRunInMode(CFStringRef modeName, ...);<br></code></pre></td></tr></table></figure>

<ul>
<li>Mode 暴露的管理 mode item 的接口有下面几个：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">CFRunLoopAddSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFStringRef modeName);<br><br>CFRunLoopAddObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFStringRef modeName);<br><br>CFRunLoopAddTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFStringRef mode);<br><br>CFRunLoopRemoveSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFStringRef modeName);<br><br>CFRunLoopRemoveObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFStringRef modeName);<br><br>CFRunLoopRemoveTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFStringRef mode);<br><br></code></pre></td></tr></table></figure>

<p>你只能通过 mode name 来操作内部的 mode，当你传入一个新的 mode name 但 RunLoop 内部没有对应 mode 时，RunLoop会自动帮你创建对应的 <code>CFRunLoopModeRef</code>。对于一个 RunLoop 来说，其内部的 mode 只能增加不能删除。</p>
<p>苹果公开提供的 Mode 有两个：<code>kCFRunLoopDefaultMode (NSDefaultRunLoopMode)</code> 和 <code>UITrackingRunLoopMode</code>，你可以用这两个 Mode Name 来操作其对应的 Mode。</p>
<p>同时苹果还提供了一个操作 Common 标记的字符串：<code>kCFRunLoopCommonModes (NSRunLoopCommonModes)</code>，你可以用这个字符串来操作 Common Items，或标记一个 Mode 为 “Common”。使用时注意区分这个字符串和其他 mode name。</p>
<h2 id="苹果用-RunLoop-实现的功能"><a href="#苹果用-RunLoop-实现的功能" class="headerlink" title="苹果用 RunLoop 实现的功能"></a>苹果用 RunLoop 实现的功能</h2><h3 id="AutoreleasePool"><a href="#AutoreleasePool" class="headerlink" title="AutoreleasePool"></a>AutoreleasePool</h3><p>App启动后，苹果在主线程 RunLoop 里注册了两个 Observer，其回调都是 <code>_wrapRunLoopWithAutoreleasePoolHandler()</code>。</p>
<p>第一个 Observer 监视的事件是 <code>Entry</code>(即将进入Loop)，其回调内会调用 <code>_objc_autoreleasePoolPush()</code> 创建自动释放池。其 order 是-2147483647，优先级最高，保证创建释放池发生在其他所有回调之前。</p>
<p>第二个 Observer 监视了两个事件： <code>BeforeWaiting</code>(准备进入休眠) 时调用<code>_objc_autoreleasePoolPop()</code> 和 <code>_objc_autoreleasePoolPush()</code> 释放旧的池并创建新池；Exit(即将退出Loop) 时调用 <code>_objc_autoreleasePoolPop()</code> 来释放自动释放池。这个 Observer 的 order 是 2147483647，优先级最低，保证其释放池子发生在其他所有回调之后。</p>
<p>在主线程执行的代码，通常是写在诸如事件回调、Timer回调内的。这些回调会被 RunLoop 创建好的 AutoreleasePool 环绕着，所以不会出现内存泄漏，开发者也不必显示创建 Pool 了。</p>
<h3 id="事件响应"><a href="#事件响应" class="headerlink" title="事件响应"></a>事件响应</h3><p>苹果注册了一个 Source1 (基于 mach port 的) 用来接收系统事件，其回调函数为 <code>__IOHIDEventSystemClientQueueCallback()。</code></p>
<p>当一个硬件事件(触摸/锁屏/摇晃等)发生后，首先由 <code>IOKit.framework</code> 生成一个 <code>IOHIDEvent</code> 事件并由 <code>SpringBoard</code> 接收。这个过程的详细情况可以参考<a href="http://iphonedevwiki.net/index.php/IOHIDFamily">这里</a>。<code>SpringBoard</code> 只接收按键(锁屏/静音等)，触摸，加速，接近传感器等几种 Event，随后用 <code>mach port</code> 转发给需要的App进程。随后苹果注册的那个 Source1 就会触发回调，并调用 <code>_UIApplicationHandleEventQueue()</code> 进行应用内部的分发。</p>
<p><code>_UIApplicationHandleEventQueue()</code> 会把 <code>IOHIDEvent</code> 处理并包装成 UIEvent 进行处理或分发，其中包括识别 UIGesture/处理屏幕旋转/发送给 UIWindow 等。通常事件比如 UIButton 点击、touchesBegin/Move/End/Cancel 事件都是在这个回调中完成的。</p>
<h3 id="手势识别"><a href="#手势识别" class="headerlink" title="手势识别"></a>手势识别</h3><p>当上面的 <code>_UIApplicationHandleEventQueue() </code>识别了一个手势时，其首先会调用 <code>Cancel</code> 将当前的 <code>touchesBegin/Move/End </code>系列回调打断。随后系统将对应的 <code>UIGestureRecognizer</code> 标记为待处理。</p>
<p>苹果注册了一个 Observer 监测 <code>BeforeWaiting</code> (Loop即将进入休眠) 事件，这个Observer的回调函数是 <code>_UIGestureRecognizerUpdateObserver()</code>，其内部会获取所有刚被标记为待处理的 GestureRecognizer，并执行GestureRecognizer的回调。</p>
<p>当有 UIGestureRecognizer 的变化(创建/销毁/状态改变)时，这个回调都会进行相应处理</p>
<h3 id="界面更新"><a href="#界面更新" class="headerlink" title="界面更新"></a>界面更新</h3><p>当在操作 UI 时，比如改变了 Frame、更新了 <code>UIView/CALayer </code>的层次时，或者手动调用了 <code>UIView/CALayer</code> 的 <code>setNeedsLayout/setNeedsDisplay</code>方法后，这个 <code>UIView/CALayer</code> 就被标记为待处理，并被提交到一个全局的容器去。</p>
<p>苹果注册了一个 Observer 监听 <code>BeforeWaiting</code>(即将进入休眠) 和 <code>Exit</code> (即将退出Loop) 事件，回调去执行一个很长的函数：<br><code>_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()</code>。这个函数里会遍历所有待处理的 <code>UIView/CAlayer</code> 以执行实际的绘制和调整，并更新 UI 界面。</p>
<h3 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h3><p>NSTimer 其实就是 <code>CFRunLoopTimerRef</code>，他们之间是 toll-free bridged 的。一个 NSTimer 注册到 RunLoop 后，RunLoop 会为其重复的时间点注册好事件。例如 10:00, 10:10, 10:20 这几个时间点。RunLoop为了节省资源，并不会在非常准确的时间点回调这个Timer。Timer 有个属性叫做 Tolerance (宽容度)，标示了当时间点到后，容许有多少最大误差。</p>
<p>如果某个时间点被错过了，例如执行了一个很长的任务，则那个时间点的回调也会跳过去，不会延后执行。就比如等公交，如果 10:10 时我忙着玩手机错过了那个点的公交，那我只能等 10:20 这一趟了。</p>
<p><code>CADisplayLink</code> 是一个和屏幕刷新率一致的定时器（但实际实现原理更复杂，和 NSTimer 并不一样，其内部实际是操作了一个 Source）。如果在两次屏幕刷新之间执行了一个长任务，那其中就会有一帧被跳过去（和 NSTimer 相似），造成界面卡顿的感觉。在快速滑动TableView时，即使一帧的卡顿也会让用户有所察觉。Facebook 开源的 AsyncDisplayLink 就是为了解决界面卡顿的问题，其内部也用到了 RunLoop，这个稍后我会再单独写一页博客来分析。</p>
<h3 id="PerformSelecter"><a href="#PerformSelecter" class="headerlink" title="PerformSelecter"></a>PerformSelecter</h3><p>当调用 NSObject 的 <code>performSelecter:afterDelay:</code> 后，实际上其内部会创建一个 Timer 并添加到当前线程的 RunLoop 中。所以如果当前线程没有 RunLoop，则这个方法会失效。</p>
<p>当调用 <code>performSelector:onThread:</code> 时，实际上其会创建一个 Timer 加到对应的线程去，同样的，如果对应线程没有 RunLoop 该方法也会失效。</p>
<h3 id="关于GCD"><a href="#关于GCD" class="headerlink" title="关于GCD"></a>关于GCD</h3><p>实际上 RunLoop 底层也会用到 GCD 的东西</p>
<p>当调用 dispatch_async(dispatch_get_main_queue(), block) 时，libDispatch 会向主线程的 RunLoop 发送消息，RunLoop会被唤醒，并从消息中取得这个 block，并在回调 <strong>CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE</strong>() 里执行这个 block。但这个逻辑仅限于 dispatch 到主线程，dispatch 到其他线程仍然是由 libDispatch 处理的。</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>至此 本次关于RunLoop的所有内容总结完成,主要是汇总下面的两篇文章,看那么长的文章其实很大程度锻炼耐心呀！</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://www.jianshu.com/p/4d5b6fc33519">基于runloop的线程保活、销毁与通信</a><br><a href="http://blog.ibireme.com/2015/05/18/runloop/">深入理解RunLoop</a></p>
]]></content>
      <categories>
        <category>iOS基础</category>
      </categories>
      <tags>
        <tag>Runloop</tag>
      </tags>
  </entry>
  <entry>
    <title>Runtime之KVO</title>
    <url>/2020/12/05/runtime-kvo/</url>
    <content><![CDATA[<p><code>KVO(Key-Value-Observer)</code>即键值监听，我们在平时的开发中通常用来监听对象属性的变化，比如<code>UIScrollView</code>的<code>ContentOffset</code>,不过同时我们要注意在不需要继续监听的时候及时的移除监听，否则可能会导致崩溃。因此这篇文章让我们更好的了解<code>KVO</code>。</p>
<a id="more"></a>

<h2 id="KVO的使用"><a href="#KVO的使用" class="headerlink" title="KVO的使用"></a>KVO的使用</h2><p>下面我们来看下我们平时使用KVO的方式：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">ViewController</span> ()</span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) Person *man;<br><span class="hljs-keyword">@end</span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">ViewController</span></span><br><br>- (<span class="hljs-keyword">void</span>)viewDidLoad &#123;<br>    [<span class="hljs-keyword">super</span> viewDidLoad];<br>    <span class="hljs-comment">// Do any additional setup after loading the view.</span><br>    <span class="hljs-keyword">self</span>.man = [[Person alloc] init];<br>    [<span class="hljs-keyword">self</span> addKVO];<br>&#125;<br><br>- (<span class="hljs-keyword">void</span>)addKVO &#123;<br>    [<span class="hljs-keyword">self</span>.man addObserver:<span class="hljs-keyword">self</span> forKeyPath:<span class="hljs-string">@&quot;name&quot;</span> options:<span class="hljs-built_in">NSKeyValueObservingOptionNew</span>|<span class="hljs-built_in">NSKeyValueObservingOptionOld</span> context:<span class="hljs-literal">nil</span>];<br>&#125;<br><br>- (<span class="hljs-keyword">void</span>)removeKVO &#123;<br>    [<span class="hljs-keyword">self</span>.man removeObserver:<span class="hljs-keyword">self</span> forKeyPath:<span class="hljs-string">@&quot;name&quot;</span>];<br>&#125;<br><br>- (<span class="hljs-keyword">void</span>)touchesBegan:(<span class="hljs-built_in">NSSet</span>&lt;<span class="hljs-built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="hljs-built_in">UIEvent</span> *)event &#123;<br>    [<span class="hljs-keyword">super</span> touchesBegan:touches withEvent:event];<br>    <span class="hljs-keyword">self</span>.man.name = <span class="hljs-string">@&quot;LeeWong&quot;</span>;<br>&#125;<br><br>- (<span class="hljs-keyword">void</span>)observeValueForKeyPath:(<span class="hljs-built_in">NSString</span> *)keyPath ofObject:(<span class="hljs-keyword">id</span>)object change:(<span class="hljs-built_in">NSDictionary</span>&lt;<span class="hljs-built_in">NSKeyValueChangeKey</span>,<span class="hljs-keyword">id</span>&gt; *)change context:(<span class="hljs-keyword">void</span> *)context &#123;<br>    <span class="hljs-keyword">if</span> ([keyPath isEqual:<span class="hljs-string">@&quot;name&quot;</span>]) &#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;keyPath %@ object %@ change%@ context %@&quot;</span>,keyPath,object,change,context);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure>

<p>每次点击屏幕控制台打印如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-06</span> <span class="hljs-number">20</span>:<span class="hljs-number">05</span>:<span class="hljs-number">15.531233</span>+<span class="hljs-number">0800</span> Runtime-KVO[<span class="hljs-number">2252</span>:<span class="hljs-number">11056787</span>] keyPath name object &lt;Person: <span class="hljs-number">0x600001028060</span>&gt; change&#123;<br>    kind = <span class="hljs-number">1</span>;<br>    new = LeeWong;<br>    old = <span class="hljs-string">&quot;&lt;null&gt;&quot;</span>;<br>&#125; context <span class="hljs-keyword">self</span><br></code></pre></td></tr></table></figure>

<p><code>KVO</code>的使用主要有下面三步：</p>
<h3 id="添加监听"><a href="#添加监听" class="headerlink" title="添加监听"></a>添加监听</h3><p> 我们可以通过调用<code>addObserver</code>方法添加对某个对象的某个属性进行监听,同时我们还可以设置什么情况下会触发我们的监听，这里有一个枚举：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">typedef</span> <span class="hljs-built_in">NS_OPTIONS</span>(<span class="hljs-built_in">NSUInteger</span>, <span class="hljs-built_in">NSKeyValueObservingOptions</span>) &#123;<br>    <span class="hljs-comment">// 属性发生改变时是否需要提供属性的新值</span><br>    <span class="hljs-built_in">NSKeyValueObservingOptionNew</span> = <span class="hljs-number">0x01</span>,<br>    <span class="hljs-comment">// 属性发生改变时是否需要提供属性的旧值</span><br>    <span class="hljs-built_in">NSKeyValueObservingOptionOld</span> = <span class="hljs-number">0x02</span>,<br>    <span class="hljs-comment">// 如果指定，则在添加观察者的时候立即发送一个通知给观察者 并且是在注册观察者方法返回之前</span><br>    <span class="hljs-built_in">NSKeyValueObservingOptionInitial</span> API_AVAILABLE(macos(<span class="hljs-number">10.5</span>), ios(<span class="hljs-number">2.0</span>), watchos(<span class="hljs-number">2.0</span>), tvos(<span class="hljs-number">9.0</span>)) = <span class="hljs-number">0x04</span>,<br>    <span class="hljs-comment">// 并且是在注册观察者方法返回之前这与-willChangeValueForKey:被触发的时间是相对应的</span><br>    <span class="hljs-comment">// 这样，在每次修改属性时，实际上是会发送两条通知</span><br>    <span class="hljs-built_in">NSKeyValueObservingOptionPrior</span> API_AVAILABLE(macos(<span class="hljs-number">10.5</span>), ios(<span class="hljs-number">2.0</span>), watchos(<span class="hljs-number">2.0</span>), tvos(<span class="hljs-number">9.0</span>)) = <span class="hljs-number">0x08</span><br><br>&#125;;<br></code></pre></td></tr></table></figure>
<p>  对于<code>context</code>这个字段实际上我们可以看做给我们提供了一个在观察者与被观察者之间传值的属性，当多个对象监听同一个对象的某个属性发生改变时可用来区分来源。</p>
<h3 id="监听改变"><a href="#监听改变" class="headerlink" title="监听改变"></a>监听改变</h3><p>当被监听的属性发生改变时，会触发<code>observeValueForKeyPath</code>方法</p>
<p>这个方法共有四个参数：</p>
<h4 id="keyPath"><a href="#keyPath" class="headerlink" title="keyPath"></a>keyPath</h4><p>被监听的属性 </p>
<h4 id="object"><a href="#object" class="headerlink" title="object"></a>object</h4><p>被监听的属性所属的对象</p>
<h4 id="change"><a href="#change" class="headerlink" title="change"></a>change</h4><p>本次监听的改变 具体值与添加监听者时<code>NSKeyValueObservingOptions</code>设置有关</p>
<p>在上面的例子中<code>change</code>对应的值为：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">change&#123;<br>    kind = <span class="hljs-number">1</span>;<br>    new = LeeWong;<br>    old = <span class="hljs-string">&quot;&lt;null&gt;&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们来看下<code>change</code>中对应信息的<code>key</code>值有哪些分别用来获取哪些<code>value</code>值：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">// 属性变化的类型，是一个NSNumber对象，包含NSKeyValueChange枚举相关的值</span><br><span class="hljs-built_in">NSString</span> *<span class="hljs-keyword">const</span> <span class="hljs-built_in">NSKeyValueChangeKindKey</span>;<br> <br><span class="hljs-comment">// 属性的新值。当NSKeyValueChangeKindKey是 NSKeyValueChangeSetting，</span><br><span class="hljs-comment">// 且添加观察的方法设置了NSKeyValueObservingOptionNew时，我们能获取到属性的新值。</span><br><span class="hljs-comment">// 如果NSKeyValueChangeKindKey是NSKeyValueChangeInsertion或者NSKeyValueChangeReplacement，</span><br><span class="hljs-comment">// 且指定了NSKeyValueObservingOptionNew时，则我们能获取到一个NSArray对象，包含被插入的对象或</span><br><span class="hljs-comment">// 用于替换其它对象的对象。</span><br><span class="hljs-built_in">NSString</span> *<span class="hljs-keyword">const</span> <span class="hljs-built_in">NSKeyValueChangeNewKey</span>;<br> <br><span class="hljs-comment">// 属性的旧值。当NSKeyValueChangeKindKey是 NSKeyValueChangeSetting，</span><br><span class="hljs-comment">// 且添加观察的方法设置了NSKeyValueObservingOptionOld时，我们能获取到属性的旧值。</span><br><span class="hljs-comment">// 如果NSKeyValueChangeKindKey是NSKeyValueChangeRemoval或者NSKeyValueChangeReplacement，</span><br><span class="hljs-comment">// 且指定了NSKeyValueObservingOptionOld时，则我们能获取到一个NSArray对象，包含被移除的对象或</span><br><span class="hljs-comment">// 被替换的对象。</span><br><span class="hljs-built_in">NSString</span> *<span class="hljs-keyword">const</span> <span class="hljs-built_in">NSKeyValueChangeOldKey</span>;<br> <br><span class="hljs-comment">// 如果NSKeyValueChangeKindKey的值是NSKeyValueChangeInsertion、NSKeyValueChangeRemoval</span><br><span class="hljs-comment">// 或者NSKeyValueChangeReplacement，则这个key对应的值是一个NSIndexSet对象，</span><br><span class="hljs-comment">// 包含了被插入、移除或替换的对象的索引</span><br><span class="hljs-built_in">NSString</span> *<span class="hljs-keyword">const</span> <span class="hljs-built_in">NSKeyValueChangeIndexesKey</span>;<br> <br><span class="hljs-comment">// 当指定了NSKeyValueObservingOptionPrior选项时，在属性被修改的通知发送前，</span><br><span class="hljs-comment">// 会先发送一条通知给观察者。我们可以使用NSKeyValueChangeNotificationIsPriorKey</span><br><span class="hljs-comment">// 来获取到通知是否是预先发送的，如果是，获取到的值总是@(YES)</span><br><span class="hljs-built_in">NSString</span> *<span class="hljs-keyword">const</span> <span class="hljs-built_in">NSKeyValueChangeNotificationIsPriorKey</span>;<br></code></pre></td></tr></table></figure>

<p>同时，<code>NSKeyValueChangeKindKey</code>对应的枚举有：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">typedef</span> <span class="hljs-built_in">NS_ENUM</span>(<span class="hljs-built_in">NSUInteger</span>, <span class="hljs-built_in">NSKeyValueChange</span>) &#123;<br>    <span class="hljs-comment">//设置一个新值。被监听的属性可以是一个对象，也可以是一对一关系的属性或一对多关系的属性。</span><br>    <span class="hljs-built_in">NSKeyValueChangeSetting</span> = <span class="hljs-number">1</span>,<br>    <span class="hljs-comment">//表示一个对象被插入到一对多关系的属性。</span><br>    <span class="hljs-built_in">NSKeyValueChangeInsertion</span> = <span class="hljs-number">2</span>,<br>    <span class="hljs-comment">// 表示一个对象被从一对多关系的属性中移除。</span><br>    <span class="hljs-built_in">NSKeyValueChangeRemoval</span> = <span class="hljs-number">3</span>,<br>    <span class="hljs-comment">// 表示一个对象在一对多的关系的属性中被替换</span><br>    <span class="hljs-built_in">NSKeyValueChangeReplacement</span> = <span class="hljs-number">4</span>,<br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="context"><a href="#context" class="headerlink" title="context"></a>context</h4><p>额外数据</p>
<h3 id="移除监听-removeObserver"><a href="#移除监听-removeObserver" class="headerlink" title="移除监听 removeObserver"></a>移除监听 removeObserver</h3><p> 当监听者不需要监听变化时，需要调用<code>removeObserver</code>方法移除监听。需要注意的是，在监听者被释放前，必须要调用<code>removeObserver:forKeyPath:</code>将其移除，否则会<code>crash</code>。我们看下下面这段代码：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">- (<span class="hljs-keyword">void</span>)addKVOCrashTest &#123;<br>    Person *person = [Person new];<br>    Person *person2 = [Person new];<br>    [person2 addObserver:person forKeyPath:<span class="hljs-string">@&quot;name&quot;</span> options:<span class="hljs-built_in">NSKeyValueObservingOptionNew</span>|<span class="hljs-built_in">NSKeyValueObservingOptionOld</span> context:<span class="hljs-string">@&quot;person&quot;</span>];<br>    person2.name = <span class="hljs-string">@&quot;LeeWong&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>很明显，上述代码在<code>person</code>释放时并没有移除监听，因此控制台打印如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">libc++abi.dylib: terminating with uncaught exception of type <span class="hljs-built_in">NSException</span><br>*** Terminating app due to uncaught exception <span class="hljs-string">&#x27;NSInternalInconsistencyException&#x27;</span>, reason: <span class="hljs-string">&#x27;&lt;Person: 0x6000018fc120&gt;: An -observeValueForKeyPath:ofObject:change:context: message was received but not handled.</span><br><span class="hljs-string">Key path: name</span><br><span class="hljs-string">Observed object: &lt;Person: 0x6000018fc100&gt;</span><br><span class="hljs-string">Change: &#123;</span><br><span class="hljs-string">    kind = 1;</span><br><span class="hljs-string">    new = LeeWong;</span><br><span class="hljs-string">    old = &quot;&lt;null&gt;&quot;;</span><br><span class="hljs-string">&#125;</span><br></code></pre></td></tr></table></figure>

<p>通过上面的描述我们对<code>KVO</code>的使用有了一个基本的了解，下面我们来看下KVO相关的干货。</p>
<h2 id="KVO-如何实现"><a href="#KVO-如何实现" class="headerlink" title="KVO 如何实现"></a>KVO 如何实现</h2><h3 id="KVO-如果要你去实现-你会如何实现？"><a href="#KVO-如果要你去实现-你会如何实现？" class="headerlink" title="KVO 如果要你去实现 你会如何实现？"></a>KVO 如果要你去实现 你会如何实现？</h3><p>我们可以先来思考下这个问题，<code>KVO</code>实际上就是监听属性改变，我们可能最先想到的就是重写<code>setter</code>方法，在<code>setter</code>方法被调用时我们额外调用一个代理方法通知外部，如果不如想监听属性的改变，添加代理监听就可以了，而且在<code>setter</code>方法中我们可以拿到对应的新值或者旧值，示例代码如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><br><span class="hljs-class"><span class="hljs-keyword">@protocol</span> <span class="hljs-title">PersonKVODelegate</span> &lt;<span class="hljs-title">NSObject</span>&gt;</span><br><span class="hljs-keyword">@optional</span><br>- (<span class="hljs-keyword">void</span>)personObjectNamePropertyChangeFrom:(<span class="hljs-built_in">NSString</span> *)oldName newName:(<span class="hljs-built_in">NSString</span> *)newName;<br><br><span class="hljs-keyword">@end</span><br><br>- (<span class="hljs-keyword">void</span>)setName:(<span class="hljs-built_in">NSString</span> *)name &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>.delegate &amp;&amp; [<span class="hljs-keyword">self</span>.delegate respondsToSelector:<span class="hljs-keyword">@selector</span>(personObjectNamePropertyChangeFrom:newName:)]) &#123;<br>        [<span class="hljs-keyword">self</span>.delegate personObjectNamePropertyChangeFrom:_name newName:name];<br>    &#125;<br>    _name = name;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这样外部在想监听值改变的时候先设置代理，然后实现对应的方法就可以了。那么系统到底是怎么实现的呢？我们下面来一探究竟。</p>
<h3 id="KVO-实现"><a href="#KVO-实现" class="headerlink" title="KVO 实现"></a>KVO 实现</h3><p>在我们查看<code>KVO</code>监听时我们看到下面这段代码注释：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">// 对于任意类型的属性 NSKeyValueChangeSetting 表示被监听的对象接收到-setValue:forKey:</span><br><span class="hljs-comment">// 消息调用或对象的setter方法被调用或者</span><br><span class="hljs-comment">// -willChangeValueForKey:/-didChangeValueForKey: 被调用</span><br>- For any sort of property (attribute, to-one relationship, or ordered or unordered to-many relationship) <span class="hljs-built_in">NSKeyValueChangeSetting</span> indicates that the observed object has received a -setValue:forKey: message, or that the key-value coding-compliant set method <span class="hljs-keyword">for</span> the key has been invoked, or that a -willChangeValueForKey:/-didChangeValueForKey: pair has otherwise been invoked.<br><br><span class="hljs-comment">// 对于一个有序一对多关系，NSKeyValueChangeInsertion、NSKeyValueChangeRemoval NSKeyValueChangeReplacement 表示通过调用对象的mutableArrayValueForKey：方法给array发送了一个修改消息或者数组或有序集合的修改方法被调用再或者-willChange:valuesAtIndexes:forKey:/-didChange:valuesAtIndexes:forKey 被调用</span><br>- For an _ordered_ to-many relationship, <span class="hljs-built_in">NSKeyValueChangeInsertion</span>, <span class="hljs-built_in">NSKeyValueChangeRemoval</span>, and <span class="hljs-built_in">NSKeyValueChangeReplacement</span> indicate that a mutating message has been sent to the array returned by a -mutableArrayValueForKey: message sent to the object, or sent to the ordered set returned by a -mutableOrderedSetValueForKey: message sent to the object, or that one of the key-value coding-compliant array or ordered set mutation methods <span class="hljs-keyword">for</span> the key has been invoked, or that a -willChange:valuesAtIndexes:forKey:/-didChange:valuesAtIndexes:forKey: pair has otherwise been invoked.<br><span class="hljs-comment">// 对于一个无序的一对多关系 NSKeyValueChangeInsertion NSKeyValueChangeRemoval NSKeyValueChangeReplacement 表示通过调用对象mutableSetValueForKey方法，导致集合的修改方法被调用，或者key-value coding-compliant set 修改方法被调用，或者willChangeValueForKey:withSetMutation:usingObjects:/-didChangeValueForKey:withSetMutation:usingObjects: 方法被调用</span><br>- For an _unordered_ to-many relationship (introduced <span class="hljs-keyword">in</span> Mac OS <span class="hljs-number">10.4</span>), <span class="hljs-built_in">NSKeyValueChangeInsertion</span>, <span class="hljs-built_in">NSKeyValueChangeRemoval</span>, and <span class="hljs-built_in">NSKeyValueChangeReplacement</span> indicate that a mutating message has been sent to the set returned by a -mutableSetValueForKey: message sent to the object, or that one of the key-value coding-compliant set mutation methods <span class="hljs-keyword">for</span> the key has been invoked, or that a -willChangeValueForKey:withSetMutation:usingObjects:/-didChangeValueForKey:withSetMutation:usingObjects: pair has otherwise been invoked.<br></code></pre></td></tr></table></figure>

<p>我们看到无论是一对一还是一对多或者有序还是无序触发的原因之一都有<code>willChangeValueForKey</code>、<code>didChangeValueForKey</code>这两个方法，那么这两个方法是做什么的呢？</p>
<h4 id="NSObject-NSKeyValueObserverNotification"><a href="#NSObject-NSKeyValueObserverNotification" class="headerlink" title="NSObject(NSKeyValueObserverNotification)"></a>NSObject(NSKeyValueObserverNotification)</h4><p>我们在<code>NSKeyValueObserving.h</code>文件中，看到了<code>NSObject(NSKeyValueObserverNotification)</code>分类，在这个分类中，我们我们看到上面提到的几个方法：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">NSObject</span>(<span class="hljs-title">NSKeyValueObserverNotification</span>)</span><br><span class="hljs-comment">// 通知外部对象的某个属性改变</span><br>- (<span class="hljs-keyword">void</span>)willChangeValueForKey:(<span class="hljs-built_in">NSString</span> *)key;<br>- (<span class="hljs-keyword">void</span>)didChangeValueForKey:(<span class="hljs-built_in">NSString</span> *)key;<br><br><span class="hljs-comment">// 有序的一对多的集合 通知外部属性发生了改变</span><br>- (<span class="hljs-keyword">void</span>)willChange:(<span class="hljs-built_in">NSKeyValueChange</span>)changeKind valuesAtIndexes:(<span class="hljs-built_in">NSIndexSet</span> *)indexes forKey:(<span class="hljs-built_in">NSString</span> *)key;<br>- (<span class="hljs-keyword">void</span>)didChange:(<span class="hljs-built_in">NSKeyValueChange</span>)changeKind valuesAtIndexes:(<span class="hljs-built_in">NSIndexSet</span> *)indexes forKey:(<span class="hljs-built_in">NSString</span> *)key;<br><br><span class="hljs-comment">// 无需的一对多的结合 通知外部属性发生了改变</span><br>- (<span class="hljs-keyword">void</span>)willChangeValueForKey:(<span class="hljs-built_in">NSString</span> *)key withSetMutation:(<span class="hljs-built_in">NSKeyValueSetMutationKind</span>)mutationKind usingObjects:(<span class="hljs-built_in">NSSet</span> *)objects;<br>- (<span class="hljs-keyword">void</span>)didChangeValueForKey:(<span class="hljs-built_in">NSString</span> *)key withSetMutation:(<span class="hljs-built_in">NSKeyValueSetMutationKind</span>)mutationKind usingObjects:(<span class="hljs-built_in">NSSet</span> *)objects;<br><br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure>

<p>我们发现分类中的几个方法和上面我们提到的被调用的方法是一一对应的。</p>
<p>我们先简单看下前两个方法</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">/* Given a key that identifies a property (attribute, to-one relationship, or ordered or unordered to-many relationship), send -observeValueForKeyPath:ofObject:change:context: notification messages of kind NSKeyValueChangeSetting to each observer registered for the key, including those that are registered with other objects using key paths that locate the keyed value in this object. Invocations of these methods must always be paired.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">The change dictionaries in notifications resulting from use of these methods contain optional entries if requested at observer registration time:</span><br><span class="hljs-comment">    - The NSKeyValueChangeOldKey entry, if present, contains the value returned by -valueForKey: at the instant that -willChangeValueForKey: is invoked (or an NSNull if -valueForKey: returns nil).</span><br><span class="hljs-comment">    - The NSKeyValueChangeNewKey entry, if present, contains the value returned by -valueForKey: at the instant that -didChangeValueForKey: is invoked (or an NSNull if -valueForKey: returns nil).</span><br><span class="hljs-comment">*/</span><br>- (<span class="hljs-keyword">void</span>)willChangeValueForKey:(<span class="hljs-built_in">NSString</span> *)key;<br>- (<span class="hljs-keyword">void</span>)didChangeValueForKey:(<span class="hljs-built_in">NSString</span> *)key;<br></code></pre></td></tr></table></figure>

<p>给定一个标识属性的键（属性，一对一关系或有序或无序多对关系），向每个注册该键的观察者发送<code>-observeValueForKeyPath：ofObject：change：context：</code>类型为<code>NSKeyValueChangeSetting</code>的通知消息。这些方法的调用必须始终配对。</p>
<p>如果注册监听的时候有添加，改变通知的字典中会包含下面这两个属性：<br><code>NSKeyValueChangeOldKey：</code>旧值，<code>NSKeyValueChangeNewKey</code> 新值</p>
<p>简单一点去理解就是这两个方法被调用时会触发调用<code>observeValueForKeyPath:ofObject:change:context: </code>方法</p>
<p>既然在属性改变的时候回调用这两个方法，我们是否可以通过重写这两个方法来控制KVO的调用呢？或者什么时间我们需要重写呢？</p>
<p>我们先重写这两个方法，然后看下调用时机：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">- (<span class="hljs-keyword">void</span>)willChangeValueForKey:(<span class="hljs-built_in">NSString</span> *)key &#123;<br>    [<span class="hljs-keyword">super</span> willChangeValueForKey:key];<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;Person willChangeValueForKey %@&quot;</span>,key);<br>&#125;<br><br>- (<span class="hljs-keyword">void</span>)didChangeValueForKey:(<span class="hljs-built_in">NSString</span> *)key &#123;<br>    [<span class="hljs-keyword">super</span> didChangeValueForKey:key];<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;Person didChangeValueForKey %@&quot;</span>,key);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>控制台输出结果：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-12</span> <span class="hljs-number">12</span>:<span class="hljs-number">39</span>:<span class="hljs-number">40.433214</span>+<span class="hljs-number">0800</span> Runtime-KVO[<span class="hljs-number">52130</span>:<span class="hljs-number">15055464</span>] Person willChangeValueForKey name<br><span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-12</span> <span class="hljs-number">12</span>:<span class="hljs-number">39</span>:<span class="hljs-number">40.433527</span>+<span class="hljs-number">0800</span> Runtime-KVO[<span class="hljs-number">52130</span>:<span class="hljs-number">15055464</span>] keyPath name object &lt;Person: <span class="hljs-number">0x600002f65740</span>&gt; change&#123;<br>    kind = <span class="hljs-number">1</span>;<br>    new = LeeWong;<br>    old = <span class="hljs-string">&quot;&lt;null&gt;&quot;</span>;<br>&#125; context <span class="hljs-keyword">self</span><br><span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-12</span> <span class="hljs-number">12</span>:<span class="hljs-number">39</span>:<span class="hljs-number">40.433643</span>+<span class="hljs-number">0800</span> Runtime-KVO[<span class="hljs-number">52130</span>:<span class="hljs-number">15055464</span>] Person didChangeValueForKey name<br></code></pre></td></tr></table></figure>
<p>这里我们可以明显的看出<code>willChangeValueForKey</code>、<code>didChangeValueForKey</code>的调用时机。因此我们猜测其具体的实现应该是：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">- (<span class="hljs-keyword">void</span>)setName:(<span class="hljs-built_in">NSString</span> *)name &#123;<br>    [<span class="hljs-keyword">self</span> willChangeValueForKey:name];<br>    _name = name;<br>    [<span class="hljs-keyword">self</span> didChangeValueForKey:name];<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面是我们从方法调用层看到的<code>KVO</code>的实现，下面我们从底层分析下<code>KVO</code>具体是如何实现的。</p>
<h4 id="KVO-底层实现"><a href="#KVO-底层实现" class="headerlink" title="KVO 底层实现"></a>KVO 底层实现</h4><p>我们先从官方文档中看下<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/KeyValueObserving/Articles/KVOImplementation.html">官方对KVO的解释</a>：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">Automatic key-value observing is implemented using a technique called isa-swizzling.<br><br>The isa pointer, as the name suggests, points to the object<span class="hljs-string">&#x27;s class which maintains a dispatch table. This dispatch table essentially contains pointers to the methods the class implements, among other data.</span><br><span class="hljs-string"></span><br><span class="hljs-string">When an observer is registered for an attribute of an object the isa pointer of the observed object is modified, pointing to an intermediate class rather than at the true class. As a result the value of the isa pointer does not necessarily reflect the actual class of the instance.</span><br><span class="hljs-string"></span><br><span class="hljs-string">You should never rely on the isa pointer to determine class membership. Instead, you should use the class method to determine the class of an object instance.</span><br></code></pre></td></tr></table></figure>
<p>自动的键值监听是通过使用<code>isa-swizzling</code>技术实现，即<code>isa</code>交换，下面我们重点看下这段话：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">When an observer is registered <span class="hljs-keyword">for</span> an attribute of an object the isa pointer of the observed object is modified, pointing to an intermediate <span class="hljs-keyword">class</span> rather than at the <span class="hljs-literal">true</span> <span class="hljs-keyword">class</span>.<br></code></pre></td></tr></table></figure>
<p>当注册了某各类的属性监听后，<code>isa</code>指针指向的实际上是另一个中间类而不是真正的类。</p>
<p>我们先通过下面这个例子来验证一下这个说法：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;class %@&quot;</span>,<span class="hljs-built_in">NSStringFromClass</span>([<span class="hljs-keyword">self</span>.man <span class="hljs-keyword">class</span>]));<br><br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;isa class %@&quot;</span>,object_getClass(<span class="hljs-keyword">self</span>.man));<br></code></pre></td></tr></table></figure>

<p>打印结果：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-12</span> <span class="hljs-number">13</span>:<span class="hljs-number">36</span>:<span class="hljs-number">28.533095</span>+<span class="hljs-number">0800</span> Runtime-KVO[<span class="hljs-number">55411</span>:<span class="hljs-number">15105963</span>] <span class="hljs-keyword">class</span> Person<br><span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-12</span> <span class="hljs-number">13</span>:<span class="hljs-number">36</span>:<span class="hljs-number">28.533274</span>+<span class="hljs-number">0800</span> Runtime-KVO[<span class="hljs-number">55411</span>:<span class="hljs-number">15105963</span>] isa <span class="hljs-keyword">class</span> <span class="hljs-built_in">NSKVONotifying_Person</span><br></code></pre></td></tr></table></figure>

<p>果然我们通过<code>Class</code>方法和<code>object_getClass</code>获取到的类是不同的，这也验证了实际上系统对有监听的类实际上实现了一个中间类，那么如果我们移除了监听呢？</p>
<p>下面我们来看下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">- (<span class="hljs-keyword">void</span>)kvoClassChange &#123;<br>    [<span class="hljs-keyword">self</span> printClassInfo];<br>    [<span class="hljs-keyword">self</span> addKVO];<br>    [<span class="hljs-keyword">self</span> printClassInfo];<br>    [<span class="hljs-keyword">self</span> removeKVO];<br>    [<span class="hljs-keyword">self</span> printClassInfo];<br>&#125;<br><br>- (<span class="hljs-keyword">void</span>)printClassInfo &#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;---------------------------------&quot;</span>);<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;class %@&quot;</span>,<span class="hljs-built_in">NSStringFromClass</span>([<span class="hljs-keyword">self</span>.man <span class="hljs-keyword">class</span>]));<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;isa class %@&quot;</span>,object_getClass(<span class="hljs-keyword">self</span>.man));<br>&#125;<br><br>- (<span class="hljs-keyword">void</span>)addKVO &#123;<br>    [<span class="hljs-keyword">self</span>.man addObserver:<span class="hljs-keyword">self</span> forKeyPath:<span class="hljs-string">@&quot;name&quot;</span> options:<span class="hljs-built_in">NSKeyValueObservingOptionNew</span>|<span class="hljs-built_in">NSKeyValueObservingOptionOld</span> context:<span class="hljs-string">@&quot;self&quot;</span>];<br>&#125;<br><br>- (<span class="hljs-keyword">void</span>)removeKVO &#123;<br>    [<span class="hljs-keyword">self</span>.man removeObserver:<span class="hljs-keyword">self</span> forKeyPath:<span class="hljs-string">@&quot;name&quot;</span>];<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们看下打印结果：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-12</span> <span class="hljs-number">14</span>:<span class="hljs-number">10</span>:<span class="hljs-number">07.443251</span>+<span class="hljs-number">0800</span> Runtime-KVO[<span class="hljs-number">57507</span>:<span class="hljs-number">15138615</span>] ---------------------------------<br><span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-12</span> <span class="hljs-number">14</span>:<span class="hljs-number">10</span>:<span class="hljs-number">07.443362</span>+<span class="hljs-number">0800</span> Runtime-KVO[<span class="hljs-number">57507</span>:<span class="hljs-number">15138615</span>] <span class="hljs-keyword">class</span> Person<br><span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-12</span> <span class="hljs-number">14</span>:<span class="hljs-number">10</span>:<span class="hljs-number">07.443446</span>+<span class="hljs-number">0800</span> Runtime-KVO[<span class="hljs-number">57507</span>:<span class="hljs-number">15138615</span>] isa <span class="hljs-keyword">class</span> Person<br><span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-12</span> <span class="hljs-number">14</span>:<span class="hljs-number">10</span>:<span class="hljs-number">07.443787</span>+<span class="hljs-number">0800</span> Runtime-KVO[<span class="hljs-number">57507</span>:<span class="hljs-number">15138615</span>] ---------------------------------<br><span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-12</span> <span class="hljs-number">14</span>:<span class="hljs-number">10</span>:<span class="hljs-number">07.443896</span>+<span class="hljs-number">0800</span> Runtime-KVO[<span class="hljs-number">57507</span>:<span class="hljs-number">15138615</span>] <span class="hljs-keyword">class</span> Person<br><span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-12</span> <span class="hljs-number">14</span>:<span class="hljs-number">10</span>:<span class="hljs-number">07.443988</span>+<span class="hljs-number">0800</span> Runtime-KVO[<span class="hljs-number">57507</span>:<span class="hljs-number">15138615</span>] isa <span class="hljs-keyword">class</span> <span class="hljs-built_in">NSKVONotifying_Person</span><br><span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-12</span> <span class="hljs-number">14</span>:<span class="hljs-number">10</span>:<span class="hljs-number">07.444116</span>+<span class="hljs-number">0800</span> Runtime-KVO[<span class="hljs-number">57507</span>:<span class="hljs-number">15138615</span>] ---------------------------------<br><span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-12</span> <span class="hljs-number">14</span>:<span class="hljs-number">10</span>:<span class="hljs-number">07.444209</span>+<span class="hljs-number">0800</span> Runtime-KVO[<span class="hljs-number">57507</span>:<span class="hljs-number">15138615</span>] <span class="hljs-keyword">class</span> Person<br><span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-12</span> <span class="hljs-number">14</span>:<span class="hljs-number">10</span>:<span class="hljs-number">07.444303</span>+<span class="hljs-number">0800</span> Runtime-KVO[<span class="hljs-number">57507</span>:<span class="hljs-number">15138615</span>] isa <span class="hljs-keyword">class</span> Person<br></code></pre></td></tr></table></figure>

<p>很明显我们发现，在我们添加<code>KVO</code>监听之后和移除<code>KVO</code>监听之前我们的对象的<code>isa</code>指针实际上指向了一个新的类<code>NSKVONotifying_Person</code>,因此我们在判断类型的时候应该使用<code>Class</code>而不是<code>isa</code>指向的<code>class</code>。</p>
<p>那么<code>NSKVONotifying_Person</code>和<code>Person</code>类是什么关系呢？</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">- (<span class="hljs-keyword">void</span>)printKVOClassChain &#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;---------------------------------&quot;</span>);<br>    Class cls = object_getClass(<span class="hljs-keyword">self</span>.man);<br>    <span class="hljs-keyword">while</span> (cls) &#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;claas %@ &#x27;s supercls %@&quot;</span>,cls,class_getSuperclass(cls));<br>        cls = class_getSuperclass(cls);<br>    &#125;<br><br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;---------------------------------&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>打印结果如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-12</span> <span class="hljs-number">14</span>:<span class="hljs-number">38</span>:<span class="hljs-number">51.707598</span>+<span class="hljs-number">0800</span> Runtime-KVO[<span class="hljs-number">59228</span>:<span class="hljs-number">15165470</span>] claas <span class="hljs-built_in">NSKVONotifying_Person</span> <span class="hljs-string">&#x27;s supercls Person</span><br><span class="hljs-string">2020-12-12 14:38:51.707712+0800 Runtime-KVO[59228:15165470] claas Person &#x27;</span>s supercls <span class="hljs-built_in">NSObject</span><br><span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-12</span> <span class="hljs-number">14</span>:<span class="hljs-number">38</span>:<span class="hljs-number">51.707802</span>+<span class="hljs-number">0800</span> Runtime-KVO[<span class="hljs-number">59228</span>:<span class="hljs-number">15165470</span>] claas <span class="hljs-built_in">NSObject</span> <span class="hljs-string">&#x27;s supercls (null)</span><br></code></pre></td></tr></table></figure>

<p>通过打印结果我们发现实际上<code>NSKVONotifying_Person</code>是<code>Person</code>的一个子类。</p>
<p>那么<code>NSKVONotifying_Person</code>这个类的方法列表结构：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">- (<span class="hljs-keyword">void</span>)printClassInfo &#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;---------------------------------&quot;</span>);<br>    Class cls = object_getClass(<span class="hljs-keyword">self</span>.man);<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;isa class %@&quot;</span>,cls);<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;---------------------------class method list &quot;</span>);<br>    <span class="hljs-built_in">NSUInteger</span> methodCount = <span class="hljs-number">0</span>;<br>    Method * methodList = class_copyMethodList(object_getClass(<span class="hljs-keyword">self</span>.man), &amp;methodCount);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-built_in">NSUInteger</span> i = <span class="hljs-number">0</span>; i &lt; methodCount; i++) &#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%@&quot;</span>,<span class="hljs-built_in">NSStringFromSelector</span>(method_getName(methodList[i])));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>打印结果：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-12</span> <span class="hljs-number">14</span>:<span class="hljs-number">33</span>:<span class="hljs-number">57.447079</span>+<span class="hljs-number">0800</span> Runtime-KVO[<span class="hljs-number">58941</span>:<span class="hljs-number">15160616</span>] ---------------------------------<br><span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-12</span> <span class="hljs-number">14</span>:<span class="hljs-number">33</span>:<span class="hljs-number">57.447190</span>+<span class="hljs-number">0800</span> Runtime-KVO[<span class="hljs-number">58941</span>:<span class="hljs-number">15160616</span>] isa <span class="hljs-keyword">class</span> <span class="hljs-built_in">NSKVONotifying_Person</span><br><span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-12</span> <span class="hljs-number">14</span>:<span class="hljs-number">33</span>:<span class="hljs-number">57.447283</span>+<span class="hljs-number">0800</span> Runtime-KVO[<span class="hljs-number">58941</span>:<span class="hljs-number">15160616</span>] ---------------------------<span class="hljs-keyword">class</span> method list<br><span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-12</span> <span class="hljs-number">14</span>:<span class="hljs-number">33</span>:<span class="hljs-number">57.447388</span>+<span class="hljs-number">0800</span> Runtime-KVO[<span class="hljs-number">58941</span>:<span class="hljs-number">15160616</span>] setName:<br><span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-12</span> <span class="hljs-number">14</span>:<span class="hljs-number">33</span>:<span class="hljs-number">57.447481</span>+<span class="hljs-number">0800</span> Runtime-KVO[<span class="hljs-number">58941</span>:<span class="hljs-number">15160616</span>] <span class="hljs-keyword">class</span><br><span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-12</span> <span class="hljs-number">14</span>:<span class="hljs-number">33</span>:<span class="hljs-number">57.447597</span>+<span class="hljs-number">0800</span> Runtime-KVO[<span class="hljs-number">58941</span>:<span class="hljs-number">15160616</span>] dealloc<br><span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-12</span> <span class="hljs-number">14</span>:<span class="hljs-number">33</span>:<span class="hljs-number">57.447694</span>+<span class="hljs-number">0800</span> Runtime-KVO[<span class="hljs-number">58941</span>:<span class="hljs-number">15160616</span>] _isKVOA<br></code></pre></td></tr></table></figure>
<p>上面我们已经知道<code>NSKVONotifying_Person</code>类实际是Person的一个子类:</p>
<ul>
<li>这里<code>setName</code>我们理解就是重写父类<code>Observer</code>监听属性的<code>setter</code>方法，然后内部调用了<code>didChangeValueForKey:</code>、<code>willChangeValueForKey:</code>方法用于通知外部，</li>
<li><code>class</code> 方法重写是为了外部在调用<code>class</code>方法获取类的类型是获取到的是父类的类型</li>
<li><code>dealloc</code> 是为了在父类被释放的时候子类检查是否被释放了</li>
<li><code>_isKVOA</code> 来说明自己是一个<code>KVO</code>类</li>
</ul>
<p>这样我们就了解了<code>KVO</code>的整个实现原理，下面我们来看下<code>KVO</code>的一些扩展用法。</p>
<h2 id="KVO-应用"><a href="#KVO-应用" class="headerlink" title="KVO 应用"></a>KVO 应用</h2><h3 id="如何监听数组个数改变"><a href="#如何监听数组个数改变" class="headerlink" title="如何监听数组个数改变"></a>如何监听数组个数改变</h3><p>我们上面都是用<code>KVO</code>监听对象的某个属性的改变，那么如果我们要监听集合类型的属性呢？</p>
<p>我们上面了解到了实际上系统是重写了属性的<code>setting</code>方法，然后通知到外部属性改变，但是当我们向数组中添加或者删除元素时，实际上我们并没有修改数组的<code>count</code>属性，那么我们该如何监听<code>count</code>的改变呢？</p>
<p>我们先尝试用正常监听对象属性的方式添加监听：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">- (<span class="hljs-keyword">void</span>)arrayKVO &#123;<br>    <span class="hljs-keyword">self</span>.personArray = [@[<span class="hljs-string">@&quot;1&quot;</span>] mutableCopy];<br>    [<span class="hljs-keyword">self</span>.personArray addObserver:<span class="hljs-keyword">self</span> forKeyPath:<span class="hljs-string">@&quot;count&quot;</span> options:<span class="hljs-built_in">NSKeyValueObservingOptionNew</span>|<span class="hljs-built_in">NSKeyValueObservingOptionOld</span> context:<span class="hljs-string">@&quot;aaa&quot;</span>];<br>    [<span class="hljs-keyword">self</span>.personArray addObject:<span class="hljs-string">@&quot;2&quot;</span>];<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们看下输出结果：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-12</span> <span class="hljs-number">14</span>:<span class="hljs-number">51</span>:<span class="hljs-number">30.825912</span>+<span class="hljs-number">0800</span> Runtime-KVO[<span class="hljs-number">59915</span>:<span class="hljs-number">15176280</span>] *** Terminating app due to uncaught exception <span class="hljs-string">&#x27;NSInvalidArgumentException&#x27;</span>, reason: <span class="hljs-string">&#x27;[&lt;__NSArrayM 0x60000246f0c0&gt; addObserver:forKeyPath:options:context:] is not supported. Key path: count&#x27;</span><br>*** First throw call stack:<br></code></pre></td></tr></table></figure>

<p>结果很明显我们无法监听<code>count</code>，系统直接崩溃。那么我们应该如何监听呢？ 但是当我监听一个自定义对象中的一个数组属性时却并没有出现<code>crash</code>，这里苦思不得解。我们先来看下这段代码</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">- (<span class="hljs-keyword">void</span>)personChildrenKVO &#123;<br>    [<span class="hljs-keyword">self</span>.man addObserver:<span class="hljs-keyword">self</span> forKeyPath:<span class="hljs-string">@&quot;children&quot;</span> options:<span class="hljs-built_in">NSKeyValueObservingOptionNew</span>|<span class="hljs-built_in">NSKeyValueObservingOptionOld</span> context:<span class="hljs-string">@&quot;aaa&quot;</span>];<br>    [<span class="hljs-keyword">self</span>.man.children addObject:<span class="hljs-string">@&quot;2&quot;</span>];<br>&#125;<br></code></pre></td></tr></table></figure>
<p>其中children是Person对象中的一个可变数组属性</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">Person</span> : <span class="hljs-title">NSObject</span></span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-built_in">NSMutableArray</span> *children;<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure>
<p>不过虽然没有崩溃但是依然我们无法监听到数组的改变，那么我们究竟如何才可以监听到数组的改变呢？</p>
<p>实际上通过上面对KVO的原理的理解，实际上对于<code>Person</code>对象，我们在<code>KVO</code>监听时，实际上系统实现了<code>KVO</code>的子类并实现了被监听属性的<code>setter</code>方法，然后在内部调用触发<code>KVO</code>的方法，但是很明显这里并没有调用到<code>KVO</code>的监听方法，那么这里对于集合类型的数组和普通的对象是否有区别呢？</p>
<p>我们按照上面的逻辑在进一步的分析一下：</p>
<p>我们修改数组中元素个数实际上是通过给数组增加或者删除元素来实现的，但是根据上面的了解，如果子类对象只是实现了<code>children</code>的<code>setter</code>方法，在我们添加或者删除元素的时候并不会调用到<code>setter</code>方法，而是调用了<code>addObject:</code>或者<code>removeObject:</code>。这样实际并不会通知到外部。我们在最开始讨论<code>KVO</code>实现的时候，我们看到了对于有序集合提到了一个方法<code>mutableArrayValueForKey:</code> 我们先看下这个方法</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">/* Given a key that identifies an _ordered_ to-many relationship, return a mutable array that provides read-write access to the related objects. Objects added to the mutable array will become related to the receiver, and objects removed from the mutable array will become unrelated.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">The default implementation of this method recognizes the same simple accessor methods and array accessor methods as -valueForKey:&#x27;s, and follows the same direct instance variable access policies, but always returns a mutable collection proxy object instead of the immutable collection that -valueForKey: would return. It also:</span><br><span class="hljs-comment">    1. Searches the class of the receiver for methods whose names match the patterns -insertObject:in&lt;Key&gt;AtIndex: and -removeObjectFrom&lt;Key&gt;AtIndex: (corresponding to the two most primitive methods defined by the NSMutableArray class), and (introduced in Mac OS 10.4) also -insert&lt;Key&gt;:atIndexes: and -remove&lt;Key&gt;AtIndexes: (corresponding to -[NSMutableArray insertObjects:atIndexes:] and -[NSMutableArray removeObjectsAtIndexes:). If at least one insertion method and at least one removal method are found each NSMutableArray message sent to the collection proxy object will result in some combination of -insertObject:in&lt;Key&gt;AtIndex:, -removeObjectFrom&lt;Key&gt;AtIndex:, -insert&lt;Key&gt;:atIndexes:, and -remove&lt;Key&gt;AtIndexes: messages being sent to the original receiver of -mutableArrayValueForKey:. If the class of the receiver also implements an optional method whose name matches the pattern -replaceObjectIn&lt;Key&gt;AtIndex:withObject: or (introduced in Mac OS 10.4) -replace&lt;Key&gt;AtIndexes:with&lt;Key&gt;: that method will be used when appropriate for best performance.</span><br><span class="hljs-comment">    2. Otherwise (no set of array mutation methods is found), searches the class of the receiver for an accessor method whose name matches the pattern -set&lt;Key&gt;:. If such a method is found each NSMutableArray message sent to the collection proxy object will result in a -set&lt;Key&gt;: message being sent to the original receiver of -mutableArrayValueForKey:.</span><br><span class="hljs-comment">    3. Otherwise (no set of array mutation methods or simple accessor method is found), if the receiver&#x27;s class&#x27; +accessInstanceVariablesDirectly property returns YES, searches the class of the receiver for an instance variable whose name matches the pattern _&lt;key&gt; or &lt;key&gt;, in that order. If such an instance variable is found, each NSMutableArray message sent to the collection proxy object will be forwarded to the instance variable&#x27;s value, which therefore must typically be an instance of NSMutableArray or a subclass of NSMutableArray.</span><br><span class="hljs-comment">    4. Otherwise (no set of array mutation methods, simple accessor method, or instance variable is found), returns a mutable collection proxy object anyway. Each NSMutableArray message sent to the collection proxy object will result in a -setValue:forUndefinedKey: message being sent to the original receiver of -mutableArrayValueForKey:. The default implementation of -setValue:forUndefinedKey: raises an NSUndefinedKeyException, but you can override it in your application.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">Performance note: the repetitive -set&lt;Key&gt;: messages implied by step 2&#x27;s description are a potential performance problem. For better performance implement insertion and removal methods that fulfill the requirements for step 1 in your KVC-compliant class. For best performance implement a replacement method too.</span><br><span class="hljs-comment">*/</span><br>- (<span class="hljs-built_in">NSMutableArray</span> *)mutableArrayValueForKey:(<span class="hljs-built_in">NSString</span> *)key;<br></code></pre></td></tr></table></figure>

<p>我们来看下官方对这个方法的解释：</p>
<p>调用<code>mutableArrayValueForKey</code>后，<code>KVC</code>先会搜索类中是否有<code>insertObject:in&lt;Key&gt;AtIndex:</code> , <code>removeObjectFrom&lt;Key&gt;AtIndex:</code> 或者 <code>insert&lt;Key&gt;AtIndexes</code> , <code>remove&lt;Key&gt;AtIndexes</code> 格式的方法，如果至少找到一个<code>insert</code>方法和一个<code>remove</code>方法，那么返回一个可以响应<code>NSMutableArray</code>所有方法的代理集合，那么给这个代理集合发送<code>NSMutableArray</code>的方法，以<code>insertObject:in&lt;Key&gt;AtIndex:</code> , <code>removeObjectFrom&lt;Key&gt;AtIndex: </code>或者 <code>insert&lt;Key&gt;AdIndexes </code>, <code>remove&lt;Key&gt;AtIndexes</code>组合的形式调用。<br>如果上述的方法没有找到，则搜索<code>set&lt;Key&gt;:</code> 格式的方法，如果找到，那么发送给代理集合的<code>NSMutableArray</code>最终都会调用<code>set&lt;Key&gt;:</code>方法。</p>
<p>结合我们上面猜测没有触发<code>KVO</code>监听的原因:没有调用到数组的<code>setter</code>方法，在结合上面的解释，我们做下面的尝试：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">- (<span class="hljs-keyword">void</span>)personChildrenKVO &#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;111children class %@ object %p&quot;</span>,object_getClass(<span class="hljs-keyword">self</span>.man.children),<span class="hljs-keyword">self</span>.man.children);<br>    [<span class="hljs-keyword">self</span>.man addObserver:<span class="hljs-keyword">self</span> forKeyPath:<span class="hljs-string">@&quot;children&quot;</span> options:<span class="hljs-built_in">NSKeyValueObservingOptionNew</span>|<span class="hljs-built_in">NSKeyValueObservingOptionOld</span> context:<span class="hljs-string">@&quot;aaa&quot;</span>];<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;222children class %@ object %p&quot;</span>,object_getClass(<span class="hljs-keyword">self</span>.man.children),<span class="hljs-keyword">self</span>.man.children);<br>    [[<span class="hljs-keyword">self</span>.man mutableArrayValueForKey:<span class="hljs-string">@&quot;children&quot;</span>] addObject:<span class="hljs-string">@&quot;2&quot;</span>];<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;333children class %@ object %p&quot;</span>,object_getClass(<span class="hljs-keyword">self</span>.man.children),<span class="hljs-keyword">self</span>.man.children);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>我们在看下打印结果：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-13</span> <span class="hljs-number">13</span>:<span class="hljs-number">46</span>:<span class="hljs-number">35.174397</span>+<span class="hljs-number">0800</span> Runtime-KVO[<span class="hljs-number">76796</span>:<span class="hljs-number">15662273</span>] <span class="hljs-number">111</span>children <span class="hljs-keyword">class</span> __NSArrayM object <span class="hljs-number">0x6000016cc2a0</span><br><span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-13</span> <span class="hljs-number">13</span>:<span class="hljs-number">46</span>:<span class="hljs-number">35.174787</span>+<span class="hljs-number">0800</span> Runtime-KVO[<span class="hljs-number">76796</span>:<span class="hljs-number">15662273</span>] <span class="hljs-number">222</span>children <span class="hljs-keyword">class</span> __NSArrayM object <span class="hljs-number">0x6000016cc2a0</span><br><span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-13</span> <span class="hljs-number">13</span>:<span class="hljs-number">46</span>:<span class="hljs-number">35.175057</span>+<span class="hljs-number">0800</span> Runtime-KVO[<span class="hljs-number">76796</span>:<span class="hljs-number">15662273</span>] observeValueForKeyPath <span class="hljs-keyword">for</span> keyPath children<br><span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-13</span> <span class="hljs-number">13</span>:<span class="hljs-number">46</span>:<span class="hljs-number">35.175175</span>+<span class="hljs-number">0800</span> Runtime-KVO[<span class="hljs-number">76796</span>:<span class="hljs-number">15662273</span>] <span class="hljs-number">333</span>children <span class="hljs-keyword">class</span> __NSArrayM object <span class="hljs-number">0x6000016cccc0</span><br></code></pre></td></tr></table></figure>

<p>我们发现，我们的<code>KVO</code>生效了。</p>
<p>当我们在代理方法中打了断点后，方法调用的堆栈如下：</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glm6lu6wazj324g0eg1eh.jpg"></p>
<p>这也恰好与我们的猜测相对应：我们发现在监听被触发后，我们的<code>children</code>数组的地址也发生了变化，这里跟我们猜测相同，这里应该是有一个<code>children</code>的子类(图中的<code>NSKeyValueNotifyingMutableArray)</code>，实现了<code>children</code>的某些方法。</p>
<p>在刚才了解<code>mutableArrayValueForKey:</code>方法时，我们看到有一个提示：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">Performance note: the repetitive -set&lt;Key&gt;: messages implied by step <span class="hljs-number">2</span><span class="hljs-string">&#x27;s description are a potential performance problem. For better performance implement insertion and removal methods that fulfill the requirements for step 1 in your KVC-compliant class. For best performance implement a replacement method too.</span><br></code></pre></td></tr></table></figure>

<p>因为子类没有实现而调用<code>set</code>方法可能会有性能问题，因此最好实现<code>insert</code>或者<code>remove</code>方法。</p>
<p>那么我们看下该如何实现：<br>依据上面描述的，我们在<code>Person</code>类中新增下面几个方法</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">- (<span class="hljs-keyword">instancetype</span>)initWithChildren:(<span class="hljs-built_in">NSMutableArray</span> *)children;<br><br>- (<span class="hljs-keyword">void</span>)removeObjectFromChildrenAtIndex:(<span class="hljs-built_in">NSUInteger</span>)index;<br>- (<span class="hljs-keyword">void</span>)removeChildrenAtIndexes:(<span class="hljs-built_in">NSIndexSet</span> *)indexes;<br>- (<span class="hljs-keyword">void</span>)insertObject:(<span class="hljs-keyword">id</span>)object inChildrenAtIndex:(<span class="hljs-built_in">NSUInteger</span>)index;<br>- (<span class="hljs-keyword">void</span>)insertChildren:(<span class="hljs-built_in">NSArray</span> *)array atIndexes:(<span class="hljs-built_in">NSIndexSet</span> *)indexes;<br><br></code></pre></td></tr></table></figure>

<p>然后在内部实现这几个方法:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">Person</span></span><br><br>- (<span class="hljs-keyword">instancetype</span>)initWithChildren:(<span class="hljs-built_in">NSMutableArray</span> *)children &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span> = [<span class="hljs-keyword">super</span> init]) &#123;<br>        _children = children;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>;<br>&#125;<br><br>- (<span class="hljs-keyword">instancetype</span>)init &#123;<br>    <span class="hljs-keyword">return</span> [<span class="hljs-keyword">self</span> initWithChildren:[<span class="hljs-built_in">NSMutableArray</span> array]];<br>&#125;<br><br>- (<span class="hljs-keyword">void</span>)setName:(<span class="hljs-built_in">NSString</span> *)name &#123;<br>    [<span class="hljs-keyword">self</span> willChangeValueForKey:name];<br>    _name = name;<br>    [<span class="hljs-keyword">self</span> didChangeValueForKey:name];<br>&#125;<br><br>- (<span class="hljs-keyword">void</span>)willChangeValueForKey:(<span class="hljs-built_in">NSString</span> *)key &#123;<br>    [<span class="hljs-keyword">super</span> willChangeValueForKey:key];<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;Person willChangeValueForKey %@&quot;</span>,key);<br>&#125;<br><br>- (<span class="hljs-keyword">void</span>)didChangeValueForKey:(<span class="hljs-built_in">NSString</span> *)key &#123;<br>    [<span class="hljs-keyword">super</span> didChangeValueForKey:key];<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;Person didChangeValueForKey %@&quot;</span>,key);<br>&#125;<br><br><br>- (<span class="hljs-keyword">void</span>)insertChildren:(<span class="hljs-built_in">NSArray</span> *)array atIndexes:(<span class="hljs-built_in">NSIndexSet</span> *)indexes &#123;<br>    [<span class="hljs-keyword">self</span>.children insertObjects:array atIndexes:indexes];<br>&#125;<br><br>- (<span class="hljs-keyword">void</span>)insertObject:(<span class="hljs-keyword">id</span>)object inChildrenAtIndex:(<span class="hljs-built_in">NSUInteger</span>)index &#123;<br>    [<span class="hljs-keyword">self</span>.children insertObject:object atIndex:index];<br>&#125;<br><br>- (<span class="hljs-keyword">void</span>)removeChildrenAtIndexes:(<span class="hljs-built_in">NSIndexSet</span> *)indexes &#123;<br>    [<span class="hljs-keyword">self</span>.children removeObjectsAtIndexes:indexes];<br>&#125;<br><br>- (<span class="hljs-keyword">void</span>)removeObjectFromChildrenAtIndex:(<span class="hljs-built_in">NSUInteger</span>)index &#123;<br>    [<span class="hljs-keyword">self</span>.children removeObjectAtIndex:index];<br>&#125;<br><br>- (<span class="hljs-keyword">void</span>)willChange:(<span class="hljs-built_in">NSKeyValueChange</span>)changeKind valuesAtIndexes:(<span class="hljs-built_in">NSIndexSet</span> *)indexes forKey:(<span class="hljs-built_in">NSString</span> *)key &#123;<br>    [<span class="hljs-keyword">super</span> willChange:changeKind valuesAtIndexes:indexes forKey:key];<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;Person willChange:changeKind %@ valuesAtIndexes:indexes= %@ forKey:key = %@&quot;</span>,@(changeKind),indexes,key);<br>&#125;<br><br>- (<span class="hljs-keyword">void</span>)didChange:(<span class="hljs-built_in">NSKeyValueChange</span>)changeKind valuesAtIndexes:(<span class="hljs-built_in">NSIndexSet</span> *)indexes forKey:(<span class="hljs-built_in">NSString</span> *)key &#123;<br>    [<span class="hljs-keyword">super</span> didChange:changeKind valuesAtIndexes:indexes forKey:key];<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;Person didChange:changeKind %@ valuesAtIndexes:indexes= %@ forKey:key = %@&quot;</span>,@(changeKind),indexes,key);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>然后我们看下调用的位置：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">- (<span class="hljs-keyword">void</span>)personChildrenKVO &#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;111children class %@ object %p&quot;</span>,object_getClass(<span class="hljs-keyword">self</span>.man),<span class="hljs-keyword">self</span>.man);<br>    [<span class="hljs-keyword">self</span>.man addObserver:<span class="hljs-keyword">self</span> forKeyPath:<span class="hljs-string">@&quot;children&quot;</span> options:<span class="hljs-built_in">NSKeyValueObservingOptionNew</span>|<span class="hljs-built_in">NSKeyValueObservingOptionOld</span> context:<span class="hljs-string">@&quot;aaa&quot;</span>];<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;222children class %@ object %p&quot;</span>,object_getClass(<span class="hljs-keyword">self</span>.man),<span class="hljs-keyword">self</span>.man);<br>    [<span class="hljs-keyword">self</span>.man insertObject:<span class="hljs-string">@&quot;111&quot;</span> inChildrenAtIndex:<span class="hljs-number">0</span>];<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;333children class %@ object %p&quot;</span>,object_getClass(<span class="hljs-keyword">self</span>.man),<span class="hljs-keyword">self</span>.man);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>打印结果：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-13</span> <span class="hljs-number">14</span>:<span class="hljs-number">59</span>:<span class="hljs-number">04.047625</span>+<span class="hljs-number">0800</span> Runtime-KVO[<span class="hljs-number">78041</span>:<span class="hljs-number">15718979</span>] <span class="hljs-number">111</span>children <span class="hljs-keyword">class</span> Person object <span class="hljs-number">0x600000455340</span><br><span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-13</span> <span class="hljs-number">14</span>:<span class="hljs-number">59</span>:<span class="hljs-number">04.047936</span>+<span class="hljs-number">0800</span> Runtime-KVO[<span class="hljs-number">78041</span>:<span class="hljs-number">15718979</span>] <span class="hljs-number">222</span>children <span class="hljs-keyword">class</span> <span class="hljs-built_in">NSKVONotifying_Person</span> object <span class="hljs-number">0x600000455340</span><br><span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-13</span> <span class="hljs-number">14</span>:<span class="hljs-number">59</span>:<span class="hljs-number">04.048149</span>+<span class="hljs-number">0800</span> Runtime-KVO[<span class="hljs-number">78041</span>:<span class="hljs-number">15718979</span>] Person willChange:changeKind <span class="hljs-number">2</span> valuesAtIndexes:indexes= &lt;_NSCachedIndexSet: <span class="hljs-number">0x60000045c5c0</span>&gt;[number of indexes: <span class="hljs-number">1</span> (<span class="hljs-keyword">in</span> <span class="hljs-number">1</span> ranges), indexes: (<span class="hljs-number">0</span>)] forKey:key = children<br><span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-13</span> <span class="hljs-number">14</span>:<span class="hljs-number">59</span>:<span class="hljs-number">04.048284</span>+<span class="hljs-number">0800</span> Runtime-KVO[<span class="hljs-number">78041</span>:<span class="hljs-number">15718979</span>] observeValueForKeyPath <span class="hljs-keyword">for</span> keyPath children<br><span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-13</span> <span class="hljs-number">14</span>:<span class="hljs-number">59</span>:<span class="hljs-number">04.048412</span>+<span class="hljs-number">0800</span> Runtime-KVO[<span class="hljs-number">78041</span>:<span class="hljs-number">15718979</span>] Person didChange:changeKind <span class="hljs-number">2</span> valuesAtIndexes:indexes= &lt;_NSCachedIndexSet: <span class="hljs-number">0x60000045c5c0</span>&gt;[number of indexes: <span class="hljs-number">1</span> (<span class="hljs-keyword">in</span> <span class="hljs-number">1</span> ranges), indexes: (<span class="hljs-number">0</span>)] forKey:key = children<br><span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-13</span> <span class="hljs-number">14</span>:<span class="hljs-number">59</span>:<span class="hljs-number">04.048521</span>+<span class="hljs-number">0800</span> Runtime-KVO[<span class="hljs-number">78041</span>:<span class="hljs-number">15718979</span>] <span class="hljs-number">333</span>children <span class="hljs-keyword">class</span> <span class="hljs-built_in">NSKVONotifying_Person</span> object <span class="hljs-number">0x600000455340</span><br></code></pre></td></tr></table></figure>

<p>从log中我们看到，通过这种方法我们可以使用KVO捕捉到数组的变化。而且我们发现添加<code>KVO</code>之后我们的<code>Person</code>类也变成了<code>NSKVONotifying_Person</code>类型，同样在<code>KVO</code>被触发的前后<code>willChange:changeKind:valuesAtIndexes</code>和<code>didChange:changeKind:valuesAtIndexes</code>方法也被调用了。进而调用<code>KVO</code>的代理方法通知外部属性改变。</p>
<h3 id="如何监听复合改变"><a href="#如何监听复合改变" class="headerlink" title="如何监听复合改变"></a>如何监听复合改变</h3><p>在我们平时的工作中除了监听对象的某个属性的改变，还可能会用到监听某些复合条件的值的改变，尤其是之前用到RAC时，我们可以绑定监听2个属性的信号，两个监听的对象中中任何一个发生改变都需要通知到监听者，这种如果使用KVO该如何实现呢？</p>
<p>例如还是在我们Person对象中，我们有两个属性:姓名和年龄，我们还有一个方法用来获取这个人的简介</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">- (<span class="hljs-built_in">NSString</span> *)personDescription &#123;<br>    <span class="hljs-keyword">return</span> [<span class="hljs-built_in">NSString</span> stringWithFormat:<span class="hljs-string">@&quot;My name is %@,I&#x27;m %@ years old&quot;</span>,<span class="hljs-keyword">self</span>.name,@(<span class="hljs-keyword">self</span>.age)];<br>&#125;<br></code></pre></td></tr></table></figure>
<p>我们希望监听<code>personDescription</code>的改变，但是<code>personDescription</code>的改变实际上依赖<code>name</code>和<code>age</code>的改变。</p>
<p>这种情况下实际上系统也为我们提供了一个方法：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><br><span class="hljs-comment">/* Return a set of key paths for properties whose values affect the value of the keyed property. When an observer for the key is registered with an instance of the receiving class, KVO itself automatically observes all of the key paths for the same instance, and sends change notifications for the key to the observer when the value for any of those key paths changes. The default implementation of this method searches the receiving class for a method whose name matches the pattern +keyPathsForValuesAffecting&lt;Key&gt;, and returns the result of invoking that method if it is found. So, any such method must return an NSSet too. If no such method is found, an NSSet that is computed from information provided by previous invocations of the now-deprecated +setKeys:triggerChangeNotificationsForDependentKey: method is returned, for backward binary compatibility.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">This method and KVO&#x27;s automatic use of it comprise a dependency mechanism that you can use instead of sending -willChangeValueForKey:/-didChangeValueForKey: messages for dependent, computed, properties.</span><br><span class="hljs-comment"> </span><br><span class="hljs-comment">You can override this method when the getter method of one of your properties computes a value to return using the values of other properties, including those that are located by key paths. Your override should typically invoke super and return a set that includes any members in the set that result from doing that (so as not to interfere with overrides of this method in superclasses).</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">You can&#x27;t really override this method when you add a computed property to an existing class using a category, because you&#x27;re not supposed to override methods in categories. In that case, implement a matching +keyPathsForValuesAffecting&lt;Key&gt; to take advantage of this mechanism.</span><br><span class="hljs-comment">*/</span><br>+ (<span class="hljs-built_in">NSSet</span>&lt;<span class="hljs-built_in">NSString</span> *&gt; *)keyPathsForValuesAffectingValueForKey:(<span class="hljs-built_in">NSString</span> *)key API_AVAILABLE(macos(<span class="hljs-number">10.5</span>), ios(<span class="hljs-number">2.0</span>), watchos(<span class="hljs-number">2.0</span>), tvos(<span class="hljs-number">9.0</span>));<br></code></pre></td></tr></table></figure>
<p>这个方法返回一个keypath集合，集合中的keyPath值的改变会影响到关键属性(key)的值，当有观察者被注册监听关键属性(key)时,KVO自身会自动观察这个对象的所有keyPath,当其中的任意一个发生改变时都会通知到注册监听的观察者。这个机制的默认实现是搜索接受者的方法列表查看是否有方法名匹配<code>keyPathsForValuesAffecting</code>的方法，通过调用这个方法返回一个属性集合。</p>
<p>下面我们来尝试实现下这个方法看看有何效果:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">+ (<span class="hljs-built_in">NSSet</span>&lt;<span class="hljs-built_in">NSString</span> *&gt; *)keyPathsForValuesAffectingValueForKey:(<span class="hljs-built_in">NSString</span> *)key &#123;<br>    <span class="hljs-built_in">NSSet</span> *keyPaths = [<span class="hljs-keyword">super</span> keyPathsForValuesAffectingValueForKey:key];<br>    <span class="hljs-keyword">if</span> ([key isEqualToString:<span class="hljs-string">@&quot;personDescription&quot;</span>]) &#123;<br>        keyPaths = [keyPaths setByAddingObjectsFromArray:@[<span class="hljs-string">@&quot;name&quot;</span>,<span class="hljs-string">@&quot;age&quot;</span>]];<br>    &#125;<br>    <span class="hljs-keyword">return</span> keyPaths;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们在项目中添加监听：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">- (<span class="hljs-keyword">void</span>)addPersonInfoDescrption &#123;<br>    [<span class="hljs-keyword">self</span>.man addObserver:<span class="hljs-keyword">self</span> forKeyPath:<span class="hljs-string">@&quot;personDescription&quot;</span> options:<span class="hljs-built_in">NSKeyValueObservingOptionNew</span>|<span class="hljs-built_in">NSKeyValueObservingOptionOld</span> context:<span class="hljs-string">@&quot;&quot;</span>];<br>    <span class="hljs-keyword">self</span>.man.name = <span class="hljs-string">@&quot;LeeWong&quot;</span>;<br>    <span class="hljs-keyword">self</span>.man.age = <span class="hljs-number">30</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>再来看下控制台的输出:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-13</span> <span class="hljs-number">20</span>:<span class="hljs-number">52</span>:<span class="hljs-number">59.084192</span>+<span class="hljs-number">0800</span> Runtime-KVO[<span class="hljs-number">81809</span>:<span class="hljs-number">15903199</span>] Person willChangeValueForKey name<br><span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-13</span> <span class="hljs-number">20</span>:<span class="hljs-number">52</span>:<span class="hljs-number">59.084354</span>+<span class="hljs-number">0800</span> Runtime-KVO[<span class="hljs-number">81809</span>:<span class="hljs-number">15903199</span>] observeValueForKeyPath <span class="hljs-keyword">for</span> keyPath personDescription<br><span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-13</span> <span class="hljs-number">20</span>:<span class="hljs-number">52</span>:<span class="hljs-number">59.084446</span>+<span class="hljs-number">0800</span> Runtime-KVO[<span class="hljs-number">81809</span>:<span class="hljs-number">15903199</span>] Person didChangeValueForKey name<br><span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-13</span> <span class="hljs-number">20</span>:<span class="hljs-number">52</span>:<span class="hljs-number">59.085154</span>+<span class="hljs-number">0800</span> Runtime-KVO[<span class="hljs-number">81809</span>:<span class="hljs-number">15903199</span>] Person willChangeValueForKey age<br><span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-13</span> <span class="hljs-number">20</span>:<span class="hljs-number">52</span>:<span class="hljs-number">59.085245</span>+<span class="hljs-number">0800</span> Runtime-KVO[<span class="hljs-number">81809</span>:<span class="hljs-number">15903199</span>] observeValueForKeyPath <span class="hljs-keyword">for</span> keyPath personDescription<br><span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-13</span> <span class="hljs-number">20</span>:<span class="hljs-number">52</span>:<span class="hljs-number">59.085350</span>+<span class="hljs-number">0800</span> Runtime-KVO[<span class="hljs-number">81809</span>:<span class="hljs-number">15903199</span>] Person didChangeValueForKey age<br></code></pre></td></tr></table></figure>

<p>这样我们就实现了复合属性的监听。</p>
<h3 id="如何手动控制KVO"><a href="#如何手动控制KVO" class="headerlink" title="如何手动控制KVO"></a>如何手动控制KVO</h3><p>在了解了KVO的机制之后，我们发现我们KVO监听的代理方法被调用频次非常高，尤其是无论是我们监听了多少属性的改变，我们的代理方法只有一个，我们要在其中做很多判断。所以是否有方法可以手动的去控制KVO监听的调用频次。</p>
<p>在上面的介绍中我们知道，代理方法被调用是因为<code>willChangeValueForKey</code>、<code>didChangeValueForKey</code>这类方法被调用,那么我们是否可以控制这些方法被调用的频次呢？</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">/* Return YES if the key-value observing machinery should automatically invoke -willChangeValueForKey:/-didChangeValueForKey:, -willChange:valuesAtIndexes:forKey:/-didChange:valuesAtIndexes:forKey:, or -willChangeValueForKey:withSetMutation:usingObjects:/-didChangeValueForKey:withSetMutation:usingObjects: whenever instances of the class receive key-value coding messages for the key, or mutating key-value coding-compliant methods for the key are invoked. Return NO otherwise. Starting in Mac OS 10.5, the default implementation of this method searches the receiving class for a method whose name matches the pattern +automaticallyNotifiesObserversOf&lt;Key&gt;, and returns the result of invoking that method if it is found. So, any such method must return BOOL too. If no such method is found YES is returned.</span><br><span class="hljs-comment">*/</span><br>+ (<span class="hljs-built_in">BOOL</span>)automaticallyNotifiesObserversForKey:(<span class="hljs-built_in">NSString</span> *)key;<br></code></pre></td></tr></table></figure>

<p>这个方法通过返回YES/NO控制是否应该自动调用<code>-willChangeValueForKey:/-didChangeValueForKey:</code>这类方法。当我们返回NO时就不会自动调用上述方法，我们先来尝试下</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">+ (<span class="hljs-built_in">BOOL</span>)automaticallyNotifiesObserversForKey:(<span class="hljs-built_in">NSString</span> *)key &#123;<br>    <span class="hljs-built_in">BOOL</span> automatic = [<span class="hljs-keyword">super</span> automaticallyNotifiesObserversForKey:key];<br>    <span class="hljs-keyword">if</span> ([key isEqualToString:<span class="hljs-string">@&quot;name&quot;</span>]) &#123;<br>        automatic = <span class="hljs-literal">NO</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> automatic;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们在主工程在此添加对属性name的监听:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">- (<span class="hljs-keyword">void</span>)addPersonNameKVO &#123;<br>    [<span class="hljs-keyword">self</span>.man addObserver:<span class="hljs-keyword">self</span> forKeyPath:<span class="hljs-string">@&quot;name&quot;</span> options:<span class="hljs-built_in">NSKeyValueObservingOptionNew</span>|<span class="hljs-built_in">NSKeyValueObservingOptionOld</span> context:<span class="hljs-string">@&quot;&quot;</span>];<br>    <span class="hljs-keyword">self</span>.man.name = <span class="hljs-string">@&quot;LeeWong&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>当我们执行之后控制台没有任何输出，这也证明了我们刚才实现的<code>automaticallyNotifiesObserversForKey</code>生效了，那么我们把系统的调用屏蔽之后需要自己手动调用对应的方法：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">- (<span class="hljs-keyword">void</span>)setName:(<span class="hljs-built_in">NSString</span> *)name &#123;<br>    [<span class="hljs-keyword">self</span> willChangeValueForKey:<span class="hljs-string">@&quot;name&quot;</span>];<br>    _name = name;<br>    [<span class="hljs-keyword">self</span> didChangeValueForKey:<span class="hljs-string">@&quot;name&quot;</span>];<br>&#125;<br></code></pre></td></tr></table></figure>

<p>再次运行，控制台输出:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-13</span> <span class="hljs-number">20</span>:<span class="hljs-number">49</span>:<span class="hljs-number">08.814044</span>+<span class="hljs-number">0800</span> Runtime-KVO[<span class="hljs-number">81739</span>:<span class="hljs-number">15899611</span>] Person willChangeValueForKey name<br><span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-13</span> <span class="hljs-number">20</span>:<span class="hljs-number">49</span>:<span class="hljs-number">08.814166</span>+<span class="hljs-number">0800</span> Runtime-KVO[<span class="hljs-number">81739</span>:<span class="hljs-number">15899611</span>] observeValueForKeyPath <span class="hljs-keyword">for</span> keyPath name<br><span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-13</span> <span class="hljs-number">20</span>:<span class="hljs-number">49</span>:<span class="hljs-number">08.814406</span>+<span class="hljs-number">0800</span> Runtime-KVO[<span class="hljs-number">81739</span>:<span class="hljs-number">15899611</span>] keyPath name object &lt;Person: <span class="hljs-number">0x60000159e610</span>&gt; change&#123;<br>    kind = <span class="hljs-number">1</span>;<br>    new = LeeWong;<br>    old = <span class="hljs-string">&quot;&lt;null&gt;&quot;</span>;<br>&#125; context<br><span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-13</span> <span class="hljs-number">20</span>:<span class="hljs-number">49</span>:<span class="hljs-number">08.814578</span>+<span class="hljs-number">0800</span> Runtime-KVO[<span class="hljs-number">81739</span>:<span class="hljs-number">15899611</span>] Person didChangeValueForKey name<br></code></pre></td></tr></table></figure>
<p>这与系统实现的一致，只是调用KVO代理方法是由我们自己手动控制，这样我们就可以控制频率了。</p>
<h3 id="监听信息"><a href="#监听信息" class="headerlink" title="监听信息"></a>监听信息</h3><p>在最开始介绍KVO时，我们就提到了注册监听时一定要注意移除监听，那么我们是否可以获取，到所有的监听者的信息呢？</p>
<p>在<code>NSObject(NSKeyValueObservingCustomization)</code>分类中我们发现了下面这个方法：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">/* Take or return a pointer that identifies information about all of the observers that are registered with the receiver, the options that were used at registration-time, etc. The default implementation of these methods store observation info in a global dictionary keyed by the receivers&#x27; pointers. For improved performance, you can override these methods to store the opaque data pointer in an instance variable. Overrides of these methods must not attempt to send Objective-C messages to the passed-in observation info, including -retain and -release.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nullable</span>) <span class="hljs-keyword">void</span> *observationInfo <span class="hljs-built_in">NS_RETURNS_INNER_POINTER</span>;<br></code></pre></td></tr></table></figure>

<p>下面我们来看下其中具体包含了哪些信息:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">- (<span class="hljs-keyword">void</span>)printKVOObserverInfo &#123;<br>    [<span class="hljs-keyword">self</span>.man addObserver:<span class="hljs-keyword">self</span> forKeyPath:<span class="hljs-string">@&quot;name&quot;</span> options:<span class="hljs-built_in">NSKeyValueObservingOptionNew</span>|<span class="hljs-built_in">NSKeyValueObservingOptionOld</span> context:<span class="hljs-string">@&quot;&quot;</span>];<br>    [<span class="hljs-keyword">self</span>.man addObserver:<span class="hljs-keyword">self</span> forKeyPath:<span class="hljs-string">@&quot;age&quot;</span> options:<span class="hljs-built_in">NSKeyValueObservingOptionNew</span>|<span class="hljs-built_in">NSKeyValueObservingOptionOld</span> context:<span class="hljs-string">@&quot;&quot;</span>];<br>    <span class="hljs-keyword">id</span> info = <span class="hljs-keyword">self</span>.man.observationInfo;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%@&quot;</span>, [info description]);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>下面我们看下通过断点看到的效果:</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1glmjeqwr1tj316v0u014g.jpg"></p>
<p>我们看到观察者实际上是一个<code>NSKeyValueObservance</code>对象，对象中包含观察者(observer)、监听的属性(property)。但是<code>NSKeyValueObservance</code>类是一个私有类，我们无法查看这个类的结构，不过在<a href="https://blog.csdn.net/quanqinyang/article/details/45226753">这篇文章</a>作者通过dump的方法获取到类的具体结构，感兴趣的可以进一步了解。</p>
<p>既然我们能通过这种方式获取到某个对象都有哪些监听者，那么我们在添加或者删除监听者时都可以根据要添加或者要删除的监听者是否已经在监听者列表中了。这样就可以避免重复添加或者删除监听者，但是需要注意，这个类是私有类因此属性和方法也是私有的。虽然我们可以通过KVC获取到，但是也面临可能出现的各类问题。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在这篇文章中，我们首先从KVO的添加移除以及代理方法的介绍这几个方法中，让我们对KVO有一个初步的了解，然后我们在从实现的角度去看KVO的实现原理。最后，我们谈到了对于数组等集合类型的监听、对于符合类型的监听、以及如何手动控制KVO的触发。最后我们还介绍了如何获取某个对象KVO监听者列表。相信经过这篇文章，你应该对KVO有了一个更加全面的认知和更深层次的了解。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/quanqinyang/article/details/45226753">NSKeyValueObserving(KVO)</a></p>
<p><a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/KeyValueObserving/Articles/KVOCompliance.html#//apple_ref/doc/uid/20002178-BAJEAIEE">Key-Value Observing Programming Guide</a></p>
<p><a href="https://blog.chenyalun.com/2019/05/31/Key-Value%20Observing%E6%BA%90%E7%A0%81%E5%88%9D%E6%8E%A2/#2-4-NSKeyValueObservationInfo%E7%9A%84%E5%AD%98%E5%82%A8-observationInfo">Key-Value Observing源码初探</a></p>
<p><a href="https://github.com/LeeWongSnail/Blog_Demo/tree/master/Runtime-KVO">本文demo</a></p>
]]></content>
      <categories>
        <category>Runtime</category>
      </categories>
      <tags>
        <tag>Runtime KVO</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS KVC 实现探究</title>
    <url>/2020/12/19/runtime-KVC/</url>
    <content><![CDATA[<p>我们都知道iOS开发中有很多<code>黑魔法</code>，KVC就是其中之一，在平时开发中我们也会使用KVC去获取一些系统未公开的API方法，但同时我们可能要承担一些被拒或者因系统API改变导致的问题。这篇文章我们从源码的角度分析KVC的实现。</p>
<a id="more"></a>

<h3 id="KVC使用示例"><a href="#KVC使用示例" class="headerlink" title="KVC使用示例"></a>KVC使用示例</h3><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">- (<span class="hljs-keyword">void</span>)kvcValueForKeyTest &#123;<br>    <span class="hljs-keyword">self</span>.p = [Person new];<br><br>    <span class="hljs-keyword">self</span>.p.name = <span class="hljs-string">@&quot;LeeWong&quot;</span>;<br>    <span class="hljs-keyword">self</span>.p.age = <span class="hljs-number">30</span>;<br><br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;Person age = %@&quot;</span>,<span class="hljs-keyword">self</span>.p.name);<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;Person name = %@&quot;</span>,@(<span class="hljs-keyword">self</span>.p.age));<br>&#125;<br><br>- (<span class="hljs-keyword">void</span>)kvcSetValueForKey &#123;<br>    <span class="hljs-keyword">self</span>.p = [Person new];<br><br>    [<span class="hljs-keyword">self</span>.p setValue:<span class="hljs-string">@&quot;LeeWong&quot;</span> forKey:<span class="hljs-string">@&quot;name&quot;</span>];<br>    [<span class="hljs-keyword">self</span>.p setValue:@(<span class="hljs-number">30</span>) forKey:<span class="hljs-string">@&quot;age&quot;</span>];<br><br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;Person age = %@&quot;</span>,[<span class="hljs-keyword">self</span>.p valueForKey:<span class="hljs-string">@&quot;age&quot;</span>]);<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;Person name = %@&quot;</span>,[<span class="hljs-keyword">self</span>.p valueForKey:<span class="hljs-string">@&quot;name&quot;</span>]);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>打印结果:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-19</span> <span class="hljs-number">18</span>:<span class="hljs-number">52</span>:<span class="hljs-number">54.058580</span>+<span class="hljs-number">0800</span> Runtime-KVC[<span class="hljs-number">99046</span>:<span class="hljs-number">16759483</span>] Person age = <span class="hljs-number">30</span><br><span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-19</span> <span class="hljs-number">18</span>:<span class="hljs-number">52</span>:<span class="hljs-number">54.058700</span>+<span class="hljs-number">0800</span> Runtime-KVC[<span class="hljs-number">99046</span>:<span class="hljs-number">16759483</span>] Person name = LeeWong<br><span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-19</span> <span class="hljs-number">18</span>:<span class="hljs-number">52</span>:<span class="hljs-number">54.058784</span>+<span class="hljs-number">0800</span> Runtime-KVC[<span class="hljs-number">99046</span>:<span class="hljs-number">16759483</span>] -----------------------------<br><span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-19</span> <span class="hljs-number">18</span>:<span class="hljs-number">52</span>:<span class="hljs-number">54.058882</span>+<span class="hljs-number">0800</span> Runtime-KVC[<span class="hljs-number">99046</span>:<span class="hljs-number">16759483</span>] Person age = LeeWong<br><span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-19</span> <span class="hljs-number">18</span>:<span class="hljs-number">52</span>:<span class="hljs-number">54.058990</span>+<span class="hljs-number">0800</span> Runtime-KVC[<span class="hljs-number">99046</span>:<span class="hljs-number">16759483</span>] Person name = <span class="hljs-number">30</span><br></code></pre></td></tr></table></figure>

<p>这两种情况是我们平时应用最广泛的KVC(Key-Value-Coding)的方法，通常用来获取属性值或者给对象的某个属性值赋值,即使对象的属性是私有的只要我们可以确认他的key值，我们就可以获取或者设置值。</p>
<h3 id="KVC原理"><a href="#KVC原理" class="headerlink" title="KVC原理"></a>KVC原理</h3><p>在查看KVC相关方法时，我们发现其主要的方法都集中在<code>NSKeyValueCoding.h</code>这个文件中,下面我们来看下这个文件中的方法：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">class</span>, <span class="hljs-keyword">readonly</span>) <span class="hljs-built_in">BOOL</span> accessInstanceVariablesDirectly;<br>- (<span class="hljs-keyword">void</span>)setValue:(<span class="hljs-keyword">nullable</span> <span class="hljs-keyword">id</span>)value forKey:(<span class="hljs-built_in">NSString</span> *)key;<br>- (<span class="hljs-built_in">BOOL</span>)validateValue:(<span class="hljs-keyword">inout</span> <span class="hljs-keyword">id</span> _Nullable * _Nonnull)ioValue forKey:(<span class="hljs-built_in">NSString</span> *)inKey error:(<span class="hljs-keyword">out</span> <span class="hljs-built_in">NSError</span> **)outError;<br>- (<span class="hljs-built_in">NSMutableArray</span> *)mutableArrayValueForKey:(<span class="hljs-built_in">NSString</span> *)key;<br>- (<span class="hljs-built_in">NSMutableOrderedSet</span> *)mutableOrderedSetValueForKey:(<span class="hljs-built_in">NSString</span> *)key API_AVAILABLE(macos(<span class="hljs-number">10.7</span>), ios(<span class="hljs-number">5.0</span>), watchos(<span class="hljs-number">2.0</span>), tvos(<span class="hljs-number">9.0</span>));<br>- (<span class="hljs-built_in">NSMutableSet</span> *)mutableSetValueForKey:(<span class="hljs-built_in">NSString</span> *)key;<br>- (<span class="hljs-keyword">nullable</span> <span class="hljs-keyword">id</span>)valueForKeyPath:(<span class="hljs-built_in">NSString</span> *)keyPath;<br>- (<span class="hljs-keyword">void</span>)setValue:(<span class="hljs-keyword">nullable</span> <span class="hljs-keyword">id</span>)value forKeyPath:(<span class="hljs-built_in">NSString</span> *)keyPath;<br>- (<span class="hljs-built_in">BOOL</span>)validateValue:(<span class="hljs-keyword">inout</span> <span class="hljs-keyword">id</span> _Nullable * _Nonnull)ioValue forKeyPath:(<span class="hljs-built_in">NSString</span> *)inKeyPath error:(<span class="hljs-keyword">out</span> <span class="hljs-built_in">NSError</span> **)outError;<br>- (<span class="hljs-built_in">NSMutableArray</span> *)mutableArrayValueForKeyPath:(<span class="hljs-built_in">NSString</span> *)keyPath;<br>- (<span class="hljs-built_in">NSMutableOrderedSet</span> *)mutableOrderedSetValueForKeyPath:(<span class="hljs-built_in">NSString</span> *)keyPath API_AVAILABLE(macos(<span class="hljs-number">10.7</span>), ios(<span class="hljs-number">5.0</span>), watchos(<span class="hljs-number">2.0</span>), tvos(<span class="hljs-number">9.0</span>));<br>- (<span class="hljs-built_in">NSMutableSet</span> *)mutableSetValueForKeyPath:(<span class="hljs-built_in">NSString</span> *)keyPath;<br>- (<span class="hljs-keyword">nullable</span> <span class="hljs-keyword">id</span>)valueForUndefinedKey:(<span class="hljs-built_in">NSString</span> *)key;<br>- (<span class="hljs-keyword">void</span>)setValue:(<span class="hljs-keyword">nullable</span> <span class="hljs-keyword">id</span>)value forUndefinedKey:(<span class="hljs-built_in">NSString</span> *)key;<br>- (<span class="hljs-keyword">void</span>)setNilValueForKey:(<span class="hljs-built_in">NSString</span> *)key;<br>- (<span class="hljs-built_in">NSDictionary</span>&lt;<span class="hljs-built_in">NSString</span> *, <span class="hljs-keyword">id</span>&gt; *)dictionaryWithValuesForKeys:(<span class="hljs-built_in">NSArray</span>&lt;<span class="hljs-built_in">NSString</span> *&gt; *)keys;<br>- (<span class="hljs-keyword">void</span>)setValuesForKeysWithDictionary:(<span class="hljs-built_in">NSDictionary</span>&lt;<span class="hljs-built_in">NSString</span> *, <span class="hljs-keyword">id</span>&gt; *)keyedValues;<br><br><span class="hljs-keyword">@end</span><br><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">NSArray</span>&lt;<span class="hljs-title">ObjectType</span>&gt;(<span class="hljs-title">NSKeyValueCoding</span>)</span><br>- (<span class="hljs-keyword">id</span>)valueForKey:(<span class="hljs-built_in">NSString</span> *)key;<br>- (<span class="hljs-keyword">void</span>)setValue:(<span class="hljs-keyword">nullable</span> <span class="hljs-keyword">id</span>)value forKey:(<span class="hljs-built_in">NSString</span> *)key;<br><br><span class="hljs-keyword">@end</span><br><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">NSDictionary</span>&lt;<span class="hljs-title">KeyType</span>, <span class="hljs-title">ObjectType</span>&gt;(<span class="hljs-title">NSKeyValueCoding</span>)</span><br>- (<span class="hljs-keyword">nullable</span> ObjectType)valueForKey:(<span class="hljs-built_in">NSString</span> *)key;<br><br><span class="hljs-keyword">@end</span><br><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">NSMutableDictionary</span>&lt;<span class="hljs-title">KeyType</span>, <span class="hljs-title">ObjectType</span>&gt;(<span class="hljs-title">NSKeyValueCoding</span>)</span><br><br>- (<span class="hljs-keyword">void</span>)setValue:(<span class="hljs-keyword">nullable</span> ObjectType)value forKey:(<span class="hljs-built_in">NSString</span> *)key;<br><br><span class="hljs-keyword">@end</span><br><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">NSOrderedSet</span>&lt;<span class="hljs-title">ObjectType</span>&gt;(<span class="hljs-title">NSKeyValueCoding</span>)</span><br>- (<span class="hljs-keyword">id</span>)valueForKey:(<span class="hljs-built_in">NSString</span> *)key API_AVAILABLE(macos(<span class="hljs-number">10.7</span>), ios(<span class="hljs-number">5.0</span>), watchos(<span class="hljs-number">2.0</span>), tvos(<span class="hljs-number">9.0</span>));<br><br>- (<span class="hljs-keyword">void</span>)setValue:(<span class="hljs-keyword">nullable</span> <span class="hljs-keyword">id</span>)value forKey:(<span class="hljs-built_in">NSString</span> *)key API_AVAILABLE(macos(<span class="hljs-number">10.7</span>), ios(<span class="hljs-number">5.0</span>), watchos(<span class="hljs-number">2.0</span>), tvos(<span class="hljs-number">9.0</span>));<br><br><span class="hljs-keyword">@end</span><br><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">NSSet</span>&lt;<span class="hljs-title">ObjectType</span>&gt;(<span class="hljs-title">NSKeyValueCoding</span>)</span><br><br>- (<span class="hljs-keyword">id</span>)valueForKey:(<span class="hljs-built_in">NSString</span> *)key;<br><br>- (<span class="hljs-keyword">void</span>)setValue:(<span class="hljs-keyword">nullable</span> <span class="hljs-keyword">id</span>)value forKey:(<span class="hljs-built_in">NSString</span> *)key;<br><br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure>

<p>这个文件中主要包含了<br><code>NSObject(NSKeyValueCoding)</code>,<br><code>NSArray&lt;ObjectType&gt;(NSKeyValueCoding)</code>,<br><code>NSDictionary&lt;KeyType,ObjectType&gt;(NSKeyValueCoding)</code>,<br><code>NSMutableDictionary&lt;KeyType,ObjectType&gt;(NSKeyValueCoding)</code>,<br><code>NSOrderedSet&lt;ObjectType&gt;(NSKeyValueCoding)</code>,<br><code>NSSet&lt;ObjectType&gt;(NSKeyValueCoding)</code><br>主要是常用的NSObject以及集合类型<code>NSArray</code>,<code>NSDictionary</code>,<code>NSMutableDictionary</code>,<code>NSOrderedSet</code>,<code>NSSet</code>的KVC相关方法分类。从这个分类中的分组我们也将本篇文章要讲述的内容分为两部分NSOject和集合类型的属性。</p>
<h3 id="KVC实现猜想"><a href="#KVC实现猜想" class="headerlink" title="KVC实现猜想"></a>KVC实现猜想</h3><p>我们在前面一篇文章中提到了KVO的实现,系统实际上继承我们要监听的类创建了一个子类，然后在子类中重写对应属性的<code>setter</code>方法，然后在设置值方法的前后调用了<code>willChangeValueForKey</code>和<code>didChangeValueForKey</code>的方法通知外部的监听者。</p>
<p>那么我们首先看下KVC获取到的对象的类型有没有改变：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">- (<span class="hljs-keyword">void</span>)kvoObjectClassChangeTest &#123;<br>    <span class="hljs-keyword">self</span>.father = [Father new];<br><br>    Son *son1 = [Son new];<br>    Son *son2 = [Son new];<br>    <span class="hljs-keyword">self</span>.father.name = <span class="hljs-string">@&quot;LeeWong&quot;</span>;<br>    <span class="hljs-keyword">self</span>.father.children = @[son1,son2];<br><br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;Father 的children 类型是%@&quot;</span>,[[<span class="hljs-keyword">self</span>.father valueForKey:<span class="hljs-string">@&quot;children&quot;</span>] <span class="hljs-keyword">class</span>]);<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;Father 的children 类型是%@&quot;</span>,object_getClass([<span class="hljs-keyword">self</span>.father valueForKey:<span class="hljs-string">@&quot;children&quot;</span>]));<br><br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;Father 的name 类型是 %@&quot;</span>,[[<span class="hljs-keyword">self</span>.father valueForKey:<span class="hljs-string">@&quot;name&quot;</span>] <span class="hljs-keyword">class</span>]);<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;Father 的name 类型是 %@&quot;</span>,object_getClass([<span class="hljs-keyword">self</span>.father valueForKey:<span class="hljs-string">@&quot;name&quot;</span>]));<br><br>&#125;<br></code></pre></td></tr></table></figure>
<p>打印结果：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-19</span> <span class="hljs-number">20</span>:<span class="hljs-number">40</span>:<span class="hljs-number">29.671973</span>+<span class="hljs-number">0800</span> Runtime-KVC[<span class="hljs-number">1432</span>:<span class="hljs-number">16837560</span>] Father 的children 类型是__NSArrayI<br><span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-19</span> <span class="hljs-number">20</span>:<span class="hljs-number">40</span>:<span class="hljs-number">29.672078</span>+<span class="hljs-number">0800</span> Runtime-KVC[<span class="hljs-number">1432</span>:<span class="hljs-number">16837560</span>] Father 的children 类型是__NSArrayI<br><span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-19</span> <span class="hljs-number">20</span>:<span class="hljs-number">40</span>:<span class="hljs-number">29.672189</span>+<span class="hljs-number">0800</span> Runtime-KVC[<span class="hljs-number">1432</span>:<span class="hljs-number">16837560</span>] Father 的name 类型是 __NSCFConstantString<br><span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-19</span> <span class="hljs-number">20</span>:<span class="hljs-number">40</span>:<span class="hljs-number">29.672306</span>+<span class="hljs-number">0800</span> Runtime-KVC[<span class="hljs-number">1432</span>:<span class="hljs-number">16837560</span>] Father 的name 类型是 __NSCFConstantString<br></code></pre></td></tr></table></figure>

<p>这里我们看出KVC并没有给我们要获取的属性或者类动态添加子类或者其他属性，那么到底是怎么实现的呢？</p>
<p>否定了刚才的想法后，我们知道Runtime是可以动态获取到对象的所有属性的，那是否意味着当我们去给对象的属性通过setValue:forKey方法设值的时候是动态的获取这个对象的属性列表，如果属性列表中包含要设置的key那么久调用这个key对应的设置方法实现的呢？</p>
<p>下面我们通过这段代码验证下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><br><span class="hljs-keyword">@synthesize</span> name = _name;<br><br><br>- (<span class="hljs-keyword">void</span>)setName:(<span class="hljs-built_in">NSString</span> *)name &#123;<br>    _name = name;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;Person setName %@&quot;</span>,name);<br>&#125;<br><br>- (<span class="hljs-built_in">NSString</span> *)name &#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;Person getname %@&quot;</span>,_name);<br>    <span class="hljs-keyword">return</span> _name;<br>&#125;<br><br>- (<span class="hljs-keyword">void</span>)kvoSetMethodCallTest &#123;<br>    <span class="hljs-keyword">self</span>.father = [Father new];<br>    [<span class="hljs-keyword">self</span>.father setValue:<span class="hljs-string">@&quot;LeeWong&quot;</span> forKey:<span class="hljs-string">@&quot;name&quot;</span>];<br><br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;kvoSetMethodCallTest father name %@&quot;</span>,<span class="hljs-keyword">self</span>.father.name);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们调用<code>kvoSetMethodCallTest</code>方法后控制台输出结果如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-19</span> <span class="hljs-number">20</span>:<span class="hljs-number">53</span>:<span class="hljs-number">05.265737</span>+<span class="hljs-number">0800</span> Runtime-KVC[<span class="hljs-number">1701</span>:<span class="hljs-number">16847901</span>] Person setName LeeWong<br><span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-19</span> <span class="hljs-number">20</span>:<span class="hljs-number">53</span>:<span class="hljs-number">05.265856</span>+<span class="hljs-number">0800</span> Runtime-KVC[<span class="hljs-number">1701</span>:<span class="hljs-number">16847901</span>] Person getname LeeWong<br><span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-19</span> <span class="hljs-number">20</span>:<span class="hljs-number">53</span>:<span class="hljs-number">05.265937</span>+<span class="hljs-number">0800</span> Runtime-KVC[<span class="hljs-number">1701</span>:<span class="hljs-number">16847901</span>] kvoSetMethodCallTest father name LeeWong<br></code></pre></td></tr></table></figure>

<p>通过上述输出我们看到实际上无论是<code>setValue:forKey</code>还是<code>valueForKey:</code>最终都是调用到了属性的setter和getter方法。</p>
<p>那么我们的猜想基本得到验证了，那么我们下面就来看下是如何调用到getter和setter方法的呢？</p>
<h3 id="KVC的实现"><a href="#KVC的实现" class="headerlink" title="KVC的实现"></a>KVC的实现</h3><p>在了解KVC实现之前我们首先需要了解下KVC相关方法：</p>
<h4 id="setValue-forKey"><a href="#setValue-forKey" class="headerlink" title="setValue: forKey"></a>setValue: forKey</h4><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><br><span class="hljs-comment">/* Given a value and a key that identifies an attribute, set the value of the attribute. Given an object and a key that identifies a to-one relationship, relate the object to the receiver, unrelating the previously related object if there was one. Given a collection object and a key that identifies a to-many relationship, relate the objects contained in the collection to the receiver, unrelating previously related objects if there were any.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">The default implementation of this method does the following:</span><br><span class="hljs-comment">    1. Searches the class of the receiver for an accessor method whose name</span><br><span class="hljs-comment"> matches the pattern -set&lt;Key&gt;:. If such a method is found the type of its </span><br><span class="hljs-comment"> parameter is checked. If the parameter type is not an object pointer type but the</span><br><span class="hljs-comment">  value is nil -setNilValueForKey: is invoked. The default implementation of </span><br><span class="hljs-comment">  -setNilValueForKey: raises an NSInvalidArgumentException, but you can override </span><br><span class="hljs-comment">  it in your application. Otherwise, if the type of the method&#x27;s parameter is an </span><br><span class="hljs-comment">  object pointer type the method is simply invoked with the value as the argument.</span><br><span class="hljs-comment">   If the type of the method&#x27;s parameter is some other type the inverse of the </span><br><span class="hljs-comment">   NSNumber/NSValue conversion done by -valueForKey: is performed before the </span><br><span class="hljs-comment">   method is invoked.</span><br><span class="hljs-comment">   </span><br><span class="hljs-comment">    2. Otherwise (no accessor method is found), if the receiver&#x27;s class&#x27; +accessInstanceVariablesDirectly property returns YES, searches the class of the</span><br><span class="hljs-comment"> receiver for an instance variable whose name matches the pattern _&lt;key&gt;, </span><br><span class="hljs-comment"> _is&lt;Key&gt;, &lt;key&gt;, or is&lt;Key&gt;, in that order. If such an instance variable is found </span><br><span class="hljs-comment"> and its type is an object pointer type the value is retained and the result is </span><br><span class="hljs-comment"> set in the instance variable, after the instance variable&#x27;s old value is first </span><br><span class="hljs-comment"> released. If the instance variable&#x27;s type is some other type its value is set </span><br><span class="hljs-comment"> after the same sort of conversion from NSNumber or NSValue as in step 1.</span><br><span class="hljs-comment"> </span><br><span class="hljs-comment">    3. Otherwise (no accessor method or instance variable is found), invokes -setValue:forUndefinedKey:. The default implementation of</span><br><span class="hljs-comment">-setValue:forUndefinedKey: raises an NSUndefinedKeyException, but you can override </span><br><span class="hljs-comment">it in your application.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment">Compatibility notes:</span><br><span class="hljs-comment">    - For backward binary compatibility with -takeValue:forKey:&#x27;s behavior, a method whose name matches the pattern -_set&lt;Key&gt;: is also recognized in step 1. KVC accessor methods whose names start with underscores were deprecated as of Mac OS 10.3 though.</span><br><span class="hljs-comment">    - For backward binary compatibility, -unableToSetNilForKey: will be invoked instead of -setNilValueForKey: in step 1, if the implementation of -unableToSetNilForKey: in the receiver&#x27;s class is not NSObject&#x27;s.</span><br><span class="hljs-comment">    - The behavior described in step 2 is different from -takeValue:forKey:&#x27;s, in which the instance variable search order is &lt;key&gt;, _&lt;key&gt;.</span><br><span class="hljs-comment">    - For backward binary compatibility with -takeValue:forKey:&#x27;s behavior, -handleTakeValue:forUnboundKey: will be invoked instead of -setValue:forUndefinedKey: in step 3, if the implementation of -handleTakeValue:forUnboundKey: in the receiver&#x27;s class is not NSObject&#x27;s.</span><br><span class="hljs-comment">*/</span><br>- (<span class="hljs-keyword">void</span>)setValue:(<span class="hljs-keyword">nullable</span> <span class="hljs-keyword">id</span>)value forKey:(<span class="hljs-built_in">NSString</span> *)key;<br></code></pre></td></tr></table></figure>

<p>实际上上面的方法注释中已经明确告知我们方法的实现了：</p>
<ul>
<li>给定一个值和一个标识属性的键，请设置属性的值；</li>
<li>给定一个对象和一个标识一对一关系的key，将该对象与接收者相关联，如果存在则取消先前相关的对象的关联；</li>
<li>给定一个集合对象和一个标识多对多关系的key，将包含在集合中的对象与接收者相关联，如果存在则取消先前相关的对象的关联；</li>
</ul>
<p>方法的实现步骤如下：</p>
<ul>
<li>搜索该类以及父类中名称符合-set<Key>:格式的方法，如果找到，检查其参数类型。如果参数类型不是对象类型且参数为nil，则调用-setNilValueForKey:方法，这个方法的默认实现是抛出NSInvalidArgumentException异常，不过你可以重写该方法自行实现。如果参数类型为对象类型，set<Key>:方法会被直接调用，这个参数也会被直接使用。如果参数能被转化为NSNumber/NSValue类型，参数会在存取器方法被调用之前进行转换。</li>
<li>如果方法没有被找到，如果对象的+accessInstanceVariablesDirectly属性返回的是YES，那么按照_<key>, _is<Key>, <key>, is<Key>的顺序搜索该类的实例变量。如果找到这个实例变量，当其为对象类型时，该实例变量会在旧值释放之后被设置新值。当其为其他类型时，那么按照步骤1中的类型转换规则设置这个实例变量的值。</li>
<li>如果上述两步都失败了，方法和实例变量都没有被找到，-setValue:forUndefinedKey:方法将会被调用。这个方法的默认实现是抛出NSUndefinedKeyException异常，不过你可以重写该方法自行实现。</li>
</ul>
<p>下面我们来验证下API所说：</p>
<h5 id="属性设置为nil"><a href="#属性设置为nil" class="headerlink" title="属性设置为nil"></a>属性设置为nil</h5><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><br>Father.m<br><br>- (<span class="hljs-keyword">void</span>)setNilValueForKey:(<span class="hljs-built_in">NSString</span> *)key &#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;Father setNilValueForKey %@&quot;</span>,key);<br>&#125;<br><br>ViewController.m<br><br>- (<span class="hljs-keyword">void</span>)setValueForKeyTest &#123;<br>    <span class="hljs-keyword">self</span>.father = [Father new];<br>    [<span class="hljs-keyword">self</span>.father setValue:<span class="hljs-literal">nil</span> forKey:<span class="hljs-string">@&quot;name&quot;</span>];<br>    [<span class="hljs-keyword">self</span>.father setValue:<span class="hljs-literal">nil</span> forKey:<span class="hljs-string">@&quot;age&quot;</span>];<br>&#125;<br></code></pre></td></tr></table></figure>

<p>控制台输出结果为:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-19</span> <span class="hljs-number">21</span>:<span class="hljs-number">42</span>:<span class="hljs-number">29.523439</span>+<span class="hljs-number">0800</span> Runtime-KVC[<span class="hljs-number">2388</span>:<span class="hljs-number">16881195</span>] Person setName (null)<br><span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-19</span> <span class="hljs-number">21</span>:<span class="hljs-number">42</span>:<span class="hljs-number">29.523581</span>+<span class="hljs-number">0800</span> Runtime-KVC[<span class="hljs-number">2388</span>:<span class="hljs-number">16881195</span>] Father setNilValueForKey age<br></code></pre></td></tr></table></figure>

<p>这验证了第一步中说的查找set<Key>方法，如果找到了name且未对象类型那么直接调用setName:方法，value会被直接使用，如果找到了setAge方法,但参数不是对象类型且值为nil，那么直接调用setNilValueForKey方法(我们实现了这个方法在内部做了输出操作)。</p>
<h5 id="查找对应的成员变量"><a href="#查找对应的成员变量" class="headerlink" title="查找对应的成员变量"></a>查找对应的成员变量</h5><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">Person</span> ()</span><br>&#123;<br>    <span class="hljs-built_in">NSString</span> *_isName1;<br>    <span class="hljs-built_in">NSInteger</span> _isAge1;<br><br>&#125;<br><br>+ (<span class="hljs-built_in">BOOL</span>)accessInstanceVariablesDirectly &#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;Father accessInstanceVariablesDirectly&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">YES</span>;<br>&#125;<br><br>- (<span class="hljs-built_in">NSString</span> *)getisNameValue &#123;<br>    <span class="hljs-keyword">return</span> _isName1;<br>&#125;<br><br>- (<span class="hljs-built_in">NSInteger</span>)getisAgeValue &#123;<br>    <span class="hljs-keyword">return</span> _isAge1;<br>&#125;<br><br>ViewController.m<br>- (<span class="hljs-keyword">void</span>)setValueForKeyTest &#123;<br>    <span class="hljs-keyword">self</span>.father = [Father new];<br>    [<span class="hljs-keyword">self</span>.father setValue:<span class="hljs-string">@&quot;LeeWong&quot;</span> forKey:<span class="hljs-string">@&quot;name1&quot;</span>];<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;setValueForKeyTest getisNameValue %@&quot;</span>,[<span class="hljs-keyword">self</span>.father getisNameValue]);<br><br>    [<span class="hljs-keyword">self</span>.father setValue:@(<span class="hljs-number">10</span>) forKey:<span class="hljs-string">@&quot;age1&quot;</span>];<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;setValueForKeyTest getisAgeValue %@&quot;</span>,@([<span class="hljs-keyword">self</span>.father getisAgeValue]));<br>&#125;<br></code></pre></td></tr></table></figure>
<p>控制台打印结果为:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-19</span> <span class="hljs-number">21</span>:<span class="hljs-number">54</span>:<span class="hljs-number">26.320358</span>+<span class="hljs-number">0800</span> Runtime-KVC[<span class="hljs-number">2685</span>:<span class="hljs-number">16893209</span>] Father accessInstanceVariablesDirectly<br><span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-19</span> <span class="hljs-number">21</span>:<span class="hljs-number">54</span>:<span class="hljs-number">26.320474</span>+<span class="hljs-number">0800</span> Runtime-KVC[<span class="hljs-number">2685</span>:<span class="hljs-number">16893209</span>] setValueForKeyTest getisNameValue LeeWong<br><span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-19</span> <span class="hljs-number">21</span>:<span class="hljs-number">54</span>:<span class="hljs-number">26.320589</span>+<span class="hljs-number">0800</span> Runtime-KVC[<span class="hljs-number">2685</span>:<span class="hljs-number">16893209</span>] Father accessInstanceVariablesDirectly<br><span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-19</span> <span class="hljs-number">21</span>:<span class="hljs-number">54</span>:<span class="hljs-number">26.320705</span>+<span class="hljs-number">0800</span> Runtime-KVC[<span class="hljs-number">2685</span>:<span class="hljs-number">16893209</span>] setValueForKeyTest getisAgeValue <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure>

<p>这个结果验证了我们setValue:forKey:的的第二步，搜索当前类中是否存在<code>_&lt;key&gt;, _is&lt;Key&gt;, &lt;key&gt;, or is&lt;Key&gt;</code>(示例中我们是存在_age1/_name1)的实例变量。</p>
<h5 id="未找到对应的属性"><a href="#未找到对应的属性" class="headerlink" title="未找到对应的属性"></a>未找到对应的属性</h5><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">Person.m<br><br>- (<span class="hljs-keyword">void</span>)setValue:(<span class="hljs-keyword">id</span>)value forUndefinedKey:(<span class="hljs-built_in">NSString</span> *)key &#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;Person setValue %@ forUndefinedKey %@&quot;</span>,value,key);<br>&#125;<br><br>ViewController.m<br>- (<span class="hljs-keyword">void</span>)setValueForUndefineKeyTest &#123;<br>    <span class="hljs-keyword">self</span>.father = [Father new];<br>    [<span class="hljs-keyword">self</span>.father setValue:<span class="hljs-string">@&quot;LeeWong&quot;</span> forKey:<span class="hljs-string">@&quot;name1&quot;</span>];<br><br>    [<span class="hljs-keyword">self</span>.father setValue:@(<span class="hljs-number">10</span>) forKey:<span class="hljs-string">@&quot;age1&quot;</span>];<br>&#125;<br></code></pre></td></tr></table></figure>

<p>控制台打印结果:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-19</span> <span class="hljs-number">22</span>:<span class="hljs-number">01</span>:<span class="hljs-number">02.601408</span>+<span class="hljs-number">0800</span> Runtime-KVC[<span class="hljs-number">2814</span>:<span class="hljs-number">16898946</span>] Person setValue LeeWong forUndefinedKey name1<br><span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-19</span> <span class="hljs-number">22</span>:<span class="hljs-number">01</span>:<span class="hljs-number">02.601546</span>+<span class="hljs-number">0800</span> Runtime-KVC[<span class="hljs-number">2814</span>:<span class="hljs-number">16898946</span>] Person setValue <span class="hljs-number">10</span> forUndefinedKey age1<br></code></pre></td></tr></table></figure>

<p>综合上面几步，我们总结了下setValue:forKey:的调用流程为:</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gltj1ctkjjj31ja0okdjx.jpg" alt="调用流程"></p>
<h4 id="valueForKey"><a href="#valueForKey" class="headerlink" title="valueForKey:"></a>valueForKey:</h4><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">/* Given a key that identifies an attribute or to-one relationship, return the </span><br><span class="hljs-comment">attribute value or the related object. Given a key that identifies a to-many</span><br><span class="hljs-comment"> relationship, return an immutable array or an immutable set that contains all of </span><br><span class="hljs-comment"> the related objects.</span><br><span class="hljs-comment">    </span><br><span class="hljs-comment">The default implementation of this method does the following:</span><br><span class="hljs-comment">    1.Searches the class of the receiver for an accessor method whose name matches</span><br><span class="hljs-comment">     the pattern -get&lt;Key&gt;, -&lt;key&gt;, or -is&lt;Key&gt;, in that order. If such a method</span><br><span class="hljs-comment">    is found it is invoked. If the type of the method&#x27;s result is an object </span><br><span class="hljs-comment">    pointer type the result is simply returned. If the type of the result is one </span><br><span class="hljs-comment">    of the scalar types supported by NSNumber conversion is done and an NSNumber </span><br><span class="hljs-comment">    is returned. Otherwise, conversion is done and an NSValue is returned (new in Mac OS 10.5: results of arbitrary type are converted to NSValues, not just NSPoint, NRange, NSRect, and NSSize).</span><br><span class="hljs-comment">       </span><br><span class="hljs-comment">    2 (introduced in Mac OS 10.7). Otherwise (no simple accessor method is found), </span><br><span class="hljs-comment">    searches the class of the receiver for methods whose names match the patterns </span><br><span class="hljs-comment">    -countOf&lt;Key&gt; and -indexIn&lt;Key&gt;OfObject: and -objectIn&lt;Key&gt;AtIndex: </span><br><span class="hljs-comment">    (corresponding to the primitive methods defined by the NSOrderedSet class) and </span><br><span class="hljs-comment">    also -&lt;key&gt;AtIndexes: (corresponding to -[NSOrderedSet objectsAtIndexes:]). If </span><br><span class="hljs-comment">    a count method and an indexOf method and at least one of the other two </span><br><span class="hljs-comment">    possible methods are found, a collection proxy object that responds to all </span><br><span class="hljs-comment">    NSOrderedSet methods is returned. Each NSOrderedSet message sent to the </span><br><span class="hljs-comment">    collection proxy object will result in some combination of -countOf&lt;Key&gt;,</span><br><span class="hljs-comment">     -indexIn&lt;Key&gt;OfObject:, -objectIn&lt;Key&gt;AtIndex:, and -&lt;key&gt;AtIndexes: messages</span><br><span class="hljs-comment">      being sent to the original receiver of -valueForKey:. If the class of the </span><br><span class="hljs-comment">      receiver also implements an optional method whose name matches the pattern</span><br><span class="hljs-comment">       -get&lt;Key&gt;:range: that method will be used when appropriate for best </span><br><span class="hljs-comment">       performance.</span><br><span class="hljs-comment">       </span><br><span class="hljs-comment">   3 Otherwise (no simple accessor method or set of ordered set access methods </span><br><span class="hljs-comment">    is found), searches the class of the receiver for methods whose names match</span><br><span class="hljs-comment">    the patterns -countOf&lt;Key&gt; and -objectIn&lt;Key&gt;AtIndex: (corresponding to the</span><br><span class="hljs-comment">    primitive methods defined by the NSArray class) and (introduced in Mac OS</span><br><span class="hljs-comment">    10.4) also -&lt;key&gt;AtIndexes: (corresponding to -[NSArray objectsAtIndexes:]).</span><br><span class="hljs-comment">    If a count method and at least one of the other two possible methods are</span><br><span class="hljs-comment">    found, a collection proxy object that responds to all NSArray methods is</span><br><span class="hljs-comment">    returned. Each NSArray message sent to the collection proxy object will result</span><br><span class="hljs-comment">    in some combination of -countOf&lt;Key&gt;, -objectIn&lt;Key&gt;AtIndex:, and</span><br><span class="hljs-comment">    -&lt;key&gt;AtIndexes: messages being sent to the original receiver of</span><br><span class="hljs-comment">    -valueForKey:. If the class of the receiver also implements an optional method </span><br><span class="hljs-comment">    whose name matches the pattern -get&lt;Key&gt;:range: that method will be used when</span><br><span class="hljs-comment">     appropriate for best performance.</span><br><span class="hljs-comment">     </span><br><span class="hljs-comment">    4 (introduced in Mac OS 10.4). Otherwise (no simple accessor method or set of </span><br><span class="hljs-comment">    ordered set or array access methods is found), searches the class of the </span><br><span class="hljs-comment">    receiver for a threesome of methods whose names match the patterns </span><br><span class="hljs-comment">    -countOf&lt;Key&gt;, -enumeratorOf&lt;Key&gt;, and -memberOf&lt;Key&gt;: (corresponding to the </span><br><span class="hljs-comment">    primitive methods defined by the NSSet class). If all three such methods are</span><br><span class="hljs-comment">     found a collection proxy object that responds to all NSSet methods is </span><br><span class="hljs-comment">     returned. Each NSSet message sent to the collection proxy object will result </span><br><span class="hljs-comment">     in some combination of -countOf&lt;Key&gt;, -enumeratorOf&lt;Key&gt;, and -memberOf&lt;Key&gt;:</span><br><span class="hljs-comment">      messages being sent to the original receiver of -valueForKey:.</span><br><span class="hljs-comment">      </span><br><span class="hljs-comment">    5 Otherwise (no simple accessor method or set of collection access methods is</span><br><span class="hljs-comment">     found), if the receiver&#x27;s class&#x27; +accessInstanceVariablesDirectly property</span><br><span class="hljs-comment">    returns YES, searches the class of the receiver for an instance variable whose</span><br><span class="hljs-comment">    name matches the pattern _&lt;key&gt;, _is&lt;Key&gt;, &lt;key&gt;, or is&lt;Key&gt;, in that order.</span><br><span class="hljs-comment">    If such an instance variable is found, the value of the instance variable in</span><br><span class="hljs-comment">    the receiver is returned, with the same sort of conversion to NSNumber or</span><br><span class="hljs-comment">    NSValue as in step 1.</span><br><span class="hljs-comment">    </span><br><span class="hljs-comment">    6 Otherwise (no simple accessor method, set of collection access methods, or</span><br><span class="hljs-comment">    instance variable is found), invokes -valueForUndefinedKey: and returns the</span><br><span class="hljs-comment">    result. The default implementation of -valueForUndefinedKey: raises an</span><br><span class="hljs-comment">    NSUndefinedKeyException, but you can override it in your application.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">Compatibility notes:</span><br><span class="hljs-comment">    - For backward binary compatibility, an accessor method whose name matches the pattern -_get&lt;Key&gt;, or -_&lt;key&gt; is searched for between steps 1 and 3. If such a method is found it is invoked, with the same sort of conversion to NSNumber or NSValue as in step 1. KVC accessor methods whose names start with underscores were deprecated as of Mac OS 10.3 though.</span><br><span class="hljs-comment">    - The behavior described in step 5 is a change from Mac OS 10.2, in which the instance variable search order was &lt;key&gt;, _&lt;key&gt;.</span><br><span class="hljs-comment">    - For backward binary compatibility, -handleQueryWithUnboundKey: will be invoked instead of -valueForUndefinedKey: in step 6, if the implementation of -handleQueryWithUnboundKey: in the receiver&#x27;s class is not NSObject&#x27;s.</span><br><span class="hljs-comment">*/</span><br>- (<span class="hljs-keyword">nullable</span> <span class="hljs-keyword">id</span>)valueForKey:(<span class="hljs-built_in">NSString</span> *)key;<br></code></pre></td></tr></table></figure>

<p>这个方法的默认实现如下：</p>
<ul>
<li>按照-get<Key>, -<key>, -is<Key>的顺序搜索该类的获取方法，若找到，则直接调用。如果方法调用的结果是id类型，直接把结果返回。如果方法调用的结果是能够被NSNumber转换的标量类型，则结果会被转为NSNumber返回。否则对于一般的标量类型，这些类型将会被转化为NSValue（在Mac OS 10.5及以后，不仅仅支持NSPoint, NRange, NSRect，以及NSSize这些类型</li>
<li>搜索该类的-countOf<Key>, -indexIn<Key>OfObject:方法，还有-objectIn<Key>AtIndex:（对应被NSOrderedSet类所定义的方法），-<key>AtIndexes:（对应-[NSOrderedSet objectsAtIndexes:]）方法。如果-countOf<Key>, -indexIn<Key>OfObject:这两个方法被找到，另外两个方法中的至少一个被找到，那么这个能响应NSOrderedSet所有方法的集合代理对象会被返回。发送给原来消息接收者的-valueForKey:消息，将会被这个集合代理对象的-countOf<Key>, -indexIn<Key>OfObject:, -objectIn<Key>AtIndex:, -<key>AtIndexes:这些方法共同处理。如果这个代理对象也实现了可选的-get<Key>:range:方法，这将有助于增强性能。</li>
<li>搜索该类的-countOf<Key>方法，还有-objectIn<Key>AtIndex:（对应被NSArray类所定义的方法），-<key>AtIndexes:（对应-[NSArray objectsAtIndexes:]）方法。如果-countOf<Key>这个方法被找到，另外两个方法中的至少一个被找到，那么这个能响应NSArray所有方法的集合代理对象会被返回。发送给原来消息接收者的-valueForKey:消息，将会被这个集合代理对象的-countOf<Key>, -objectIn<Key>AtIndex:, -<key>AtIndexes:这些方法共同处理。如果这个代理对象也实现了可选的-get<Key>:range:方法，这将有助于增强性能</li>
<li>搜索-countOf<Key>, -enumeratorOf<Key>, -memberOf<Key>:这些被NSSet类所定义的方法。如果这三个方法都能被找到，那么这个能响应NSSet所有方法的集合代理对象会被返回。发送给原来消息接收者的-valueForKey:消息，将会被这个集合代理对象的countOf<Key>, -enumeratorOf<Key>, -memberOf<Key>:这些方法共同处理。</li>
<li>如果存取器方法、ordered set、array以及set的代理方法都没有被找到，倘若此时消息接收者的+accessInstanceVariablesDirectly属性返回的是YES（默认实现就是返回YES），那么按照_<key>, _is<Key>, <key>, is<Key>的顺序搜索该类的实例变量。如果找到这个实例变量，那么按照步骤1中的类型转换规则返回这个实例变量的值。</li>
<li>调用-valueForUndefinedKey:方法并返回结果。这个方法的默认实现是抛出NSUndefinedKeyException异常，不过你可以重写该方法自行实现。</li>
</ul>
<p>下面我们来验证下上述步骤：</p>
<h5 id="查找key对应的方法"><a href="#查找key对应的方法" class="headerlink" title="查找key对应的方法"></a>查找key对应的方法</h5><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">ViewController.m<br>- (<span class="hljs-keyword">void</span>)valueForKeyTestStep1 &#123;<br>    <span class="hljs-keyword">self</span>.son = [Son new];<br>    <span class="hljs-keyword">id</span> result = [<span class="hljs-keyword">self</span>.son valueForKey:<span class="hljs-string">@&quot;school&quot;</span>];<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;valueForKeyTestStep1 result %@ result class %@&quot;</span>,result,[result <span class="hljs-keyword">class</span>]);<br>&#125;<br><br>Son.m<br><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> mark - valueForKey</span><br><span class="hljs-comment">// 优先级由高到低</span><br>- (<span class="hljs-built_in">NSString</span> *)getSchool &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">@&quot;Beijiing&quot;</span>;<br>&#125;<br><br>- (<span class="hljs-built_in">NSString</span> *)school &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">@&quot;Shanghai&quot;</span>;<br>&#125;<br><br>- (<span class="hljs-built_in">NSString</span> *)isSchool &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">@&quot;HongKong&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>控制台输出</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-26</span> <span class="hljs-number">20</span>:<span class="hljs-number">45</span>:<span class="hljs-number">27.422284</span>+<span class="hljs-number">0800</span> Runtime-KVC[<span class="hljs-number">47753</span>:<span class="hljs-number">19135113</span>] valueForKeyTestStep1 result HongKong result <span class="hljs-keyword">class</span> __NSCFConstantString<br></code></pre></td></tr></table></figure>

<p>我们可以通过依次注释上述三个方法，控制台输出分别为:<code>Beijiing</code>、<code>Shanghai</code>、<code>HongKong</code>,如果三个方法都注释了，那么程序会因为找不到key对应的value而crash</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">libc++abi.dylib: terminating with uncaught exception of type <span class="hljs-built_in">NSException</span><br>*** Terminating app due to uncaught exception <span class="hljs-string">&#x27;NSUnknownKeyException&#x27;</span>, reason: <span class="hljs-string">&#x27;[&lt;Son 0x600003707240&gt; valueForUndefinedKey:]: this class is not key value coding-compliant for the key school.&#x27;</span><br>terminating with uncaught exception of type <span class="hljs-built_in">NSException</span><br></code></pre></td></tr></table></figure>

<h5 id="搜索集合类型相关方法"><a href="#搜索集合类型相关方法" class="headerlink" title="搜索集合类型相关方法"></a>搜索集合类型相关方法</h5><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><br>ViewController.m<br><br>- (<span class="hljs-keyword">void</span>)valueForKeyTestStep2 &#123;<br>    <span class="hljs-keyword">self</span>.son = [Son new];<br>    <span class="hljs-keyword">id</span> result = [<span class="hljs-keyword">self</span>.son valueForKey:<span class="hljs-string">@&quot;school&quot;</span>];<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;valueForKeyTestStep2 result %@ result class %@&quot;</span>,result,[result <span class="hljs-keyword">class</span>]);<br>&#125;<br><br>Son.m<br><br><span class="hljs-comment">// school key 对应的值有几个</span><br>- (<span class="hljs-built_in">NSInteger</span>)countOfSchool &#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;countOfSchool&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>&#125;<br><br><span class="hljs-comment">// school对应index是多少</span><br>- (<span class="hljs-built_in">NSInteger</span>)indexInSchoolOfObject:(<span class="hljs-built_in">NSString</span> *)school &#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;indexInSchoolOfObject %@&quot;</span>,school);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">// index 下标对应的值是多少</span><br>- (<span class="hljs-built_in">NSString</span> *)objectInSchoolAtIndex:(<span class="hljs-built_in">NSInteger</span>)index &#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;objectInSchoolAtIndex %@&quot;</span>,@(index));<br>    <span class="hljs-keyword">if</span> (index % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">@&quot;Beijing&quot;</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">@&quot;HongKong&quot;</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>控制台输出：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-number">12</span><span class="hljs-number">-26</span> <span class="hljs-number">20</span>:<span class="hljs-number">58</span>:<span class="hljs-number">29.557431</span>+<span class="hljs-number">0800</span> Runtime-KVC[<span class="hljs-number">48005</span>:<span class="hljs-number">19146834</span>] countOfSchool<br><span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-26</span> <span class="hljs-number">20</span>:<span class="hljs-number">58</span>:<span class="hljs-number">29.557542</span>+<span class="hljs-number">0800</span> Runtime-KVC[<span class="hljs-number">48005</span>:<span class="hljs-number">19146834</span>] countOfSchool<br><span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-26</span> <span class="hljs-number">20</span>:<span class="hljs-number">58</span>:<span class="hljs-number">29.557652</span>+<span class="hljs-number">0800</span> Runtime-KVC[<span class="hljs-number">48005</span>:<span class="hljs-number">19146834</span>] objectInSchoolAtIndex <span class="hljs-number">0</span><br><span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-26</span> <span class="hljs-number">20</span>:<span class="hljs-number">58</span>:<span class="hljs-number">29.557739</span>+<span class="hljs-number">0800</span> Runtime-KVC[<span class="hljs-number">48005</span>:<span class="hljs-number">19146834</span>] objectInSchoolAtIndex <span class="hljs-number">1</span><br><span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-26</span> <span class="hljs-number">20</span>:<span class="hljs-number">58</span>:<span class="hljs-number">29.557856</span>+<span class="hljs-number">0800</span> Runtime-KVC[<span class="hljs-number">48005</span>:<span class="hljs-number">19146834</span>] valueForKeyTestStep2 result &#123;(<br>    Beijing,<br>    HongKong<br>)&#125; result <span class="hljs-keyword">class</span> <span class="hljs-built_in">NSKeyValueOrderedSet</span><br></code></pre></td></tr></table></figure>

<p>从上面的打印结果来看，实际上并非如API所说:<code>indexInSchoolOfObject</code>为必须实现，<code>因为我们在调用valueForKey时并未调用到该方法</code>。数据结果也验证了countOfSchool表示key对应的集合value有几个值，每个index对应的值为什么。从最终打印结果看valueForKey最终返回的是<code>NSKeyValueOrderedSet</code></p>
<h5 id="NSArray-搜索数组相关方法"><a href="#NSArray-搜索数组相关方法" class="headerlink" title="NSArray 搜索数组相关方法"></a>NSArray 搜索数组相关方法</h5><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">ViewController.m <br><br>- (<span class="hljs-keyword">void</span>)valueForKeyTestStep3 &#123;<br>    <span class="hljs-keyword">self</span>.son = [Son new];<br>    <span class="hljs-keyword">id</span> result = [<span class="hljs-keyword">self</span>.son valueForKey:<span class="hljs-string">@&quot;school&quot;</span>];<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;valueForKeyTestStep3 result %@ result class %@&quot;</span>,result,[result <span class="hljs-keyword">class</span>]);<br>&#125;<br><br>Son.m<br><br>- (<span class="hljs-built_in">NSInteger</span>)countOfSchool &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<br>&#125;<br><br>- (<span class="hljs-built_in">NSString</span> *)objectInSchoolAtIndex:(<span class="hljs-built_in">NSInteger</span>)index &#123;<br>    <span class="hljs-keyword">if</span> (index % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">@&quot;Beijing&quot;</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">@&quot;HongKong&quot;</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>控制台输出结果:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-26</span> <span class="hljs-number">21</span>:<span class="hljs-number">00</span>:<span class="hljs-number">54.850506</span>+<span class="hljs-number">0800</span> Runtime-KVC[<span class="hljs-number">48058</span>:<span class="hljs-number">19149212</span>] countOfSchool<br><span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-26</span> <span class="hljs-number">21</span>:<span class="hljs-number">00</span>:<span class="hljs-number">54.850608</span>+<span class="hljs-number">0800</span> Runtime-KVC[<span class="hljs-number">48058</span>:<span class="hljs-number">19149212</span>] countOfSchool<br><span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-26</span> <span class="hljs-number">21</span>:<span class="hljs-number">00</span>:<span class="hljs-number">54.850710</span>+<span class="hljs-number">0800</span> Runtime-KVC[<span class="hljs-number">48058</span>:<span class="hljs-number">19149212</span>] objectInSchoolAtIndex <span class="hljs-number">0</span><br><span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-26</span> <span class="hljs-number">21</span>:<span class="hljs-number">00</span>:<span class="hljs-number">54.850815</span>+<span class="hljs-number">0800</span> Runtime-KVC[<span class="hljs-number">48058</span>:<span class="hljs-number">19149212</span>] objectInSchoolAtIndex <span class="hljs-number">1</span><br><span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-26</span> <span class="hljs-number">21</span>:<span class="hljs-number">00</span>:<span class="hljs-number">54.850920</span>+<span class="hljs-number">0800</span> Runtime-KVC[<span class="hljs-number">48058</span>:<span class="hljs-number">19149212</span>] objectInSchoolAtIndex <span class="hljs-number">2</span><br><span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-26</span> <span class="hljs-number">21</span>:<span class="hljs-number">00</span>:<span class="hljs-number">54.851031</span>+<span class="hljs-number">0800</span> Runtime-KVC[<span class="hljs-number">48058</span>:<span class="hljs-number">19149212</span>] valueForKeyTestStep3 result (<br>    Beijing,<br>    HongKong,<br>    Beijing<br>) result <span class="hljs-keyword">class</span> <span class="hljs-built_in">NSKeyValueArray</span><br></code></pre></td></tr></table></figure>

<p>与上面NSKeyValueOrderedSet集合类似，本次搜索方法返回的结果为NSKeyValueArray即数组类型，countOfSchool表示返回的数组中有几个元素，objectInSchoolAtIndex表示返回的数组每个元素是什么,valueForKey最终返回的是数组和数组中的每一个元素。</p>
<h5 id="NSSet-相关搜索方法"><a href="#NSSet-相关搜索方法" class="headerlink" title="NSSet 相关搜索方法"></a>NSSet 相关搜索方法</h5><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">ViewController.m<br><br>- (<span class="hljs-keyword">void</span>)valueForKeyTestStep4 &#123;<br>    <span class="hljs-keyword">self</span>.son = [Son new];<br>    <span class="hljs-keyword">id</span> result = [<span class="hljs-keyword">self</span>.son valueForKey:<span class="hljs-string">@&quot;school&quot;</span>];<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;valueForKeyTestStep4 result %@ result class %@&quot;</span>,result,[result <span class="hljs-keyword">class</span>]);<br>&#125;<br><br>Son.m<br>- (<span class="hljs-built_in">NSInteger</span>)countOfSchool &#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;countOfSchool&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>&#125;<br><br>- (<span class="hljs-built_in">NSEnumerator</span>&lt;<span class="hljs-keyword">id</span>&gt; *)enumeratorOfSchool &#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;objectInSchoolAtIndex &quot;</span>);<br>    <span class="hljs-built_in">NSSet</span> *schools = [<span class="hljs-built_in">NSSet</span> setWithArray:@[<span class="hljs-string">@&quot;Beijing&quot;</span>,<span class="hljs-string">@&quot;Hongkong&quot;</span>]];<br>    <span class="hljs-keyword">return</span> [schools objectEnumerator];<br>&#125;<br><br>- (<span class="hljs-built_in">BOOL</span>)memberOfSchool:(<span class="hljs-built_in">NSString</span> *)school &#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;memberOfSchool %@&quot;</span>,school);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">YES</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>控制台输出:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-26</span> <span class="hljs-number">21</span>:<span class="hljs-number">24</span>:<span class="hljs-number">41.942115</span>+<span class="hljs-number">0800</span> Runtime-KVC[<span class="hljs-number">48572</span>:<span class="hljs-number">19174700</span>] countOfSchool<br><span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-26</span> <span class="hljs-number">21</span>:<span class="hljs-number">24</span>:<span class="hljs-number">41.942285</span>+<span class="hljs-number">0800</span> Runtime-KVC[<span class="hljs-number">48572</span>:<span class="hljs-number">19174700</span>] countOfSchool<br><span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-26</span> <span class="hljs-number">21</span>:<span class="hljs-number">24</span>:<span class="hljs-number">41.942370</span>+<span class="hljs-number">0800</span> Runtime-KVC[<span class="hljs-number">48572</span>:<span class="hljs-number">19174700</span>] objectInSchoolAtIndex<br><span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-26</span> <span class="hljs-number">21</span>:<span class="hljs-number">24</span>:<span class="hljs-number">41.942503</span>+<span class="hljs-number">0800</span> Runtime-KVC[<span class="hljs-number">48572</span>:<span class="hljs-number">19174700</span>] valueForKeyTestStep4 result &#123;(<br>    Beijing,<br>    Hongkong<br>)&#125; result <span class="hljs-keyword">class</span> <span class="hljs-built_in">NSKeyValueSet</span><br></code></pre></td></tr></table></figure>

<p><code>countOfSchool</code>和<code>enumeratorOfSchool</code>两个方法比较好理解，表示school的个数和school集合的遍历器。memberOfSchool实际并未清楚到底是什么意思，这里有两种猜想</p>
<ul>
<li>是否是某个类型</li>
<li>是否是集合中的对象</li>
</ul>
<p>当我们去掉这个方法的实现时,会直接崩溃</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">libc++abi.dylib: terminating with uncaught exception of type <span class="hljs-built_in">NSException</span><br>*** Terminating app due to uncaught exception <span class="hljs-string">&#x27;NSUnknownKeyException&#x27;</span>, reason: <span class="hljs-string">&#x27;[&lt;Son 0x60000298fdc0&gt; valueForUndefinedKey:]: this class is not key value coding-compliant for the key school.&#x27;</span><br>terminating with uncaught exception of type <span class="hljs-built_in">NSException</span><br></code></pre></td></tr></table></figure>

<p>当我们将这个方法的实现改为：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">- (<span class="hljs-keyword">void</span>)memberOfSchool:(<span class="hljs-built_in">NSString</span> *)school &#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;memberOfSchool %@&quot;</span>,school);<br><span class="hljs-comment">//    return YES;</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>依然得到与上述相同的结果，因此这里无法判断这个方法的实现应该是什么样的</p>
<h5 id="搜索实例变量"><a href="#搜索实例变量" class="headerlink" title="搜索实例变量"></a>搜索实例变量</h5><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">ViewController.m<br><br>- (<span class="hljs-keyword">void</span>)valueForKeyTestStep5 &#123;<br>    <span class="hljs-keyword">self</span>.son = [Son new];<br>    <span class="hljs-keyword">id</span> result = [<span class="hljs-keyword">self</span>.son valueForKey:<span class="hljs-string">@&quot;school&quot;</span>];<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;valueForKeyTestStep5 result %@ result class %@&quot;</span>,result,[result <span class="hljs-keyword">class</span>]);<br>&#125;<br><br>Son.m<br><br>- (<span class="hljs-keyword">instancetype</span>)init &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span> = [<span class="hljs-keyword">super</span> init]) &#123;<br>        _isSchool = <span class="hljs-string">@&quot;Beijing&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>;<br>&#125;<br><br>+ (<span class="hljs-built_in">BOOL</span>)accessInstanceVariablesDirectly &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">YES</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>控制台输出:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-26</span> <span class="hljs-number">21</span>:<span class="hljs-number">29</span>:<span class="hljs-number">52.568972</span>+<span class="hljs-number">0800</span> Runtime-KVC[<span class="hljs-number">48691</span>:<span class="hljs-number">19180589</span>] valueForKeyTestStep5 result Beijing result <span class="hljs-keyword">class</span> __NSCFConstantString<br></code></pre></td></tr></table></figure>

<p>这里我们定义了一个实例变量_isSchool,valueForKey方法在搜索集合相关属性无果后，会查找是否存在对应名称的实例变量，如果找到对应的实例变量，则返回。</p>
<h5 id="valueForUndefinedKey"><a href="#valueForUndefinedKey" class="headerlink" title="valueForUndefinedKey"></a>valueForUndefinedKey</h5><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">- (<span class="hljs-keyword">void</span>)valueForKeyTestStep6 &#123;<br>    <span class="hljs-keyword">self</span>.son = [Son new];<br>    <span class="hljs-keyword">id</span> result = [<span class="hljs-keyword">self</span>.son valueForKey:<span class="hljs-string">@&quot;school&quot;</span>];<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;valueForKeyTestStep6 result %@ result class %@&quot;</span>,result,[result <span class="hljs-keyword">class</span>]);<br>&#125;<br><br>- (<span class="hljs-keyword">id</span>)valueForUndefinedKey:(<span class="hljs-built_in">NSString</span> *)key &#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;valueForUndefinedKey %@&quot;</span>,key);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">@&quot;Beijing&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>控制台输出:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-26</span> <span class="hljs-number">21</span>:<span class="hljs-number">35</span>:<span class="hljs-number">16.596774</span>+<span class="hljs-number">0800</span> Runtime-KVC[<span class="hljs-number">48788</span>:<span class="hljs-number">19185406</span>] valueForUndefinedKey school<br><span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-26</span> <span class="hljs-number">21</span>:<span class="hljs-number">35</span>:<span class="hljs-number">20.486420</span>+<span class="hljs-number">0800</span> Runtime-KVC[<span class="hljs-number">48788</span>:<span class="hljs-number">19185406</span>] valueForKeyTestStep6 result Beijing result <span class="hljs-keyword">class</span> __NSCFConstantString<br></code></pre></td></tr></table></figure>

<p>当上述5步均无法找到对应方法，那么系统最终会调用valueForUndefinedKey方法，这个方法的默认实现就是上面我们贴的崩溃，不过我们可以重写这个方法，并在这个方法中记录对应的key值并返回一个默认值。</p>
<p>综上我们可以总结valueForKey方法调用的流程实际上是一个方法查找的流程，具体如下图</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gm1lwez70ij30u01gx110.jpg"></p>
<h3 id="集合类型"><a href="#集合类型" class="headerlink" title="集合类型"></a>集合类型</h3><p>KVC除了上述对于所有对象都适用的设置方法setValue:forKey:和获取方法valueForKey:外还有专门对于集合类型对象的方法</p>
<ul>
<li>mutableArrayValueForKey:</li>
<li>mutableOrderedSetValueForKey:</li>
<li>mutableSetValueForKey:</li>
</ul>
<p>这里我们拿mutableArrayValueForKey方法举例说明</p>
<p>同样我们先来看下方法的API说明</p>
<h4 id="mutableArrayValueForKey"><a href="#mutableArrayValueForKey" class="headerlink" title="mutableArrayValueForKey"></a>mutableArrayValueForKey</h4><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">/* Given a key that identifies an _ordered_ to-many relationship, return a mutable </span><br><span class="hljs-comment">array that provides read-write access to the related objects. Objects added to the </span><br><span class="hljs-comment">mutable array will become related to the receiver, and objects removed from the </span><br><span class="hljs-comment">mutable array will become unrelated.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">The default implementation of this method recognizes the same simple accessor </span><br><span class="hljs-comment">methods and array accessor methods as -valueForKey:&#x27;s, and follows the same direct</span><br><span class="hljs-comment">instance variable access policies, but always returns a mutable collection proxy </span><br><span class="hljs-comment">object instead of the immutable collection that -valueForKey: would return. It</span><br><span class="hljs-comment">also:</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    1 Searches the class of the receiver for methods whose names match the</span><br><span class="hljs-comment">    patterns -insertObject:in&lt;Key&gt;AtIndex: and -removeObjectFrom&lt;Key&gt;AtIndex:</span><br><span class="hljs-comment">    (corresponding to the two most primitive methods defined by the NSMutableArray</span><br><span class="hljs-comment">    class), and (introduced in Mac OS 10.4) also -insert&lt;Key&gt;:atIndexes: and</span><br><span class="hljs-comment">    -remove&lt;Key&gt;AtIndexes: (corresponding to -[NSMutableArray</span><br><span class="hljs-comment">    insertObjects:atIndexes:] and -[NSMutableArray removeObjectsAtIndexes:). </span><br><span class="hljs-comment">    If at least one insertion method and at least one removal method are found</span><br><span class="hljs-comment">    each NSMutableArray message sent to the collection proxy object will result</span><br><span class="hljs-comment">    in some combination of -insertObject:in&lt;Key&gt;AtIndex:,</span><br><span class="hljs-comment">    -removeObjectFrom&lt;Key&gt;AtIndex:, -insert&lt;Key&gt;:atIndexes:, and</span><br><span class="hljs-comment">    -remove&lt;Key&gt;AtIndexes: messages being sent to the original receiver of</span><br><span class="hljs-comment">    -mutableArrayValueForKey:. If the class of the receiver also implements an</span><br><span class="hljs-comment">    optional method whose name matches the pattern</span><br><span class="hljs-comment">    -replaceObjectIn&lt;Key&gt;AtIndex:withObject: or (introduced in Mac OS 10.4)</span><br><span class="hljs-comment">    -replace&lt;Key&gt;AtIndexes:with&lt;Key&gt;: that method will be used when appropriate</span><br><span class="hljs-comment">    for best performance.</span><br><span class="hljs-comment">    </span><br><span class="hljs-comment">    2 Otherwise (no set of array mutation methods is found), searches the class of</span><br><span class="hljs-comment">    the receiver for an accessor method whose name matches the pattern -set&lt;Key&gt;:.</span><br><span class="hljs-comment">    If such a method is found each NSMutableArray message sent to the collection</span><br><span class="hljs-comment">    proxy object will result in a -set&lt;Key&gt;: message being sent to the original</span><br><span class="hljs-comment">    receiver of -mutableArrayValueForKey:.</span><br><span class="hljs-comment">    </span><br><span class="hljs-comment">    3 Otherwise (no set of array mutation methods or simple accessor method is</span><br><span class="hljs-comment">    found), if the receiver&#x27;s class&#x27; +accessInstanceVariablesDirectly property</span><br><span class="hljs-comment">    returns YES, searches the class of the receiver for an instance variable whose</span><br><span class="hljs-comment">    name matches the pattern _&lt;key&gt; or &lt;key&gt;, in that order. If such an instance</span><br><span class="hljs-comment">    variable is found, each NSMutableArray message sent to the collection proxy</span><br><span class="hljs-comment">    object will be forwarded to the instance variable&#x27;s value, which therefore</span><br><span class="hljs-comment">    must typically be an instance of NSMutableArray or a subclass of </span><br><span class="hljs-comment">    NSMutableArray.</span><br><span class="hljs-comment">    </span><br><span class="hljs-comment">    4 Otherwise (no set of array mutation methods, simple accessor method, or</span><br><span class="hljs-comment">    instance variable is found), returns a mutable collection proxy object anyway.</span><br><span class="hljs-comment">    Each NSMutableArray message sent to the collection proxy object will result in</span><br><span class="hljs-comment">    a -setValue:forUndefinedKey: message being sent to the original receiver of</span><br><span class="hljs-comment">    -mutableArrayValueForKey:. The default implementation of</span><br><span class="hljs-comment">    -setValue:forUndefinedKey: raises an NSUndefinedKeyException, but you can</span><br><span class="hljs-comment">    override it in your application.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">Performance note: the repetitive -set&lt;Key&gt;: messages implied by step 2&#x27;s description are a potential performance problem. For better performance implement insertion and removal methods that fulfill the requirements for step 1 in your KVC-compliant class. For best performance implement a replacement method too.</span><br><span class="hljs-comment">*/</span><br>- (<span class="hljs-built_in">NSMutableArray</span> *)mutableArrayValueForKey:(<span class="hljs-built_in">NSString</span> *)key;<br></code></pre></td></tr></table></figure>

<p>该方法的查找路径为：</p>
<ul>
<li>查找类中是否有-insertObject:in<Key>AtIndex:和-removeObjectFrom<Key>AtIndex:(同NSMutableArray的-insert<Key>:atIndexes:和-removeObjectFrom<Key>AtIndex:方法)，如果找到至少一个insert和至少一个remove方法。</li>
<li>查找类中是否有-set<Key>:方法，如果有则调用这个方法进行赋值</li>
<li>accessInstanceVariablesDirectly方法是否返回YES，如果返回YES查找类中是否有对应名称为_<key> 或者 <key> 的成员变量(必须是NSMutableArray或者子类) 给其赋值</li>
<li>调用-setValue:forUndefinedKey:方法默认为NSUndefinedKeyException的crash</li>
</ul>
<h4 id="疑问？"><a href="#疑问？" class="headerlink" title="疑问？"></a>疑问？</h4><p>在尝试写测试代码时，按照valueForKey:方法的实现想法，我们通过mutableArrayValueForKey获取一个可变数组然后进行增删改查。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">- (<span class="hljs-keyword">void</span>)mutableArrayValueForKey &#123;<br>    <span class="hljs-keyword">self</span>.father = [Father new];<br>    [[<span class="hljs-keyword">self</span>.father mutableArrayValueForKey:<span class="hljs-string">@&quot;children&quot;</span>] addObject:<span class="hljs-string">@&quot;farmer&quot;</span>];<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;mutableArrayValueForKey -- addObject %@&quot;</span>,[<span class="hljs-keyword">self</span>.father mutableArrayValueForKey:<span class="hljs-string">@&quot;children&quot;</span>].firstObject);<br>    [[<span class="hljs-keyword">self</span>.father mutableArrayValueForKey:<span class="hljs-string">@&quot;children&quot;</span>] removeObjectAtIndex:<span class="hljs-number">0</span>];<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;mutableArrayValueForKey -- removeObject %@&quot;</span>,[<span class="hljs-keyword">self</span>.father mutableArrayValueForKey:<span class="hljs-string">@&quot;children&quot;</span>]);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>当我直接运行上述代码时，Demo直接crash</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-26</span> <span class="hljs-number">23</span>:<span class="hljs-number">36</span>:<span class="hljs-number">46.702341</span>+<span class="hljs-number">0800</span> Runtime-KVC[<span class="hljs-number">51145</span>:<span class="hljs-number">19283102</span>] *** Terminating app due to uncaught exception <span class="hljs-string">&#x27;NSUnknownKeyException&#x27;</span>, reason: <span class="hljs-string">&#x27;[&lt;Father 0x6000004dd260&gt; valueForUndefinedKey:]: this class is not key value coding-compliant for the key children.&#x27;</span><br></code></pre></td></tr></table></figure>
<p>valueForUndefinedKey 这里提示我们father类中没有children这个属性，但是在使用valueForKey时，我们即使key值是一个有问题的但并不影响我们的操作，我们依然可以实现数据的存取。但是这里就不可以! 如果有了解的同学可以给我留言，万分感谢。</p>
<h4 id="mutableArrayValueForKey-amp-KVO"><a href="#mutableArrayValueForKey-amp-KVO" class="headerlink" title="mutableArrayValueForKey&amp;KVO"></a>mutableArrayValueForKey&amp;KVO</h4><p>在网上搜索这个方法的使用时，大部分都提到与KVO一起使用,下面我们来看下这个例子:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">Father</span> : <span class="hljs-title">Person</span></span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-built_in">NSMutableArray</span> *children;<br><span class="hljs-keyword">@end</span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">Father</span></span><br><br>- (<span class="hljs-keyword">instancetype</span>)init &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span> = [<span class="hljs-keyword">super</span> init]) &#123;<br>        _children = [<span class="hljs-built_in">NSMutableArray</span> array];<br>        [<span class="hljs-keyword">self</span> addObserver];<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>;<br>&#125;<br><br>- (<span class="hljs-keyword">void</span>)addObserver &#123;<br>    [<span class="hljs-keyword">self</span> addObserver:<span class="hljs-keyword">self</span> forKeyPath:<span class="hljs-string">@&quot;children&quot;</span> options:<span class="hljs-built_in">NSKeyValueObservingOptionNew</span> | <span class="hljs-built_in">NSKeyValueObservingOptionOld</span> context:<span class="hljs-literal">nil</span>];<br>&#125;<br><br>- (<span class="hljs-keyword">void</span>)removeObserver &#123;<br>    [<span class="hljs-keyword">self</span> removeObserver:<span class="hljs-keyword">self</span> forKeyPath:<span class="hljs-string">@&quot;children&quot;</span>];<br>&#125;<br><br>- (<span class="hljs-keyword">void</span>)dealloc &#123;<br>    [<span class="hljs-keyword">self</span> removeObserver];<br>&#125;<br><br>- (<span class="hljs-keyword">void</span>)observeValueForKeyPath:(<span class="hljs-built_in">NSString</span> *)keyPath ofObject:(<span class="hljs-keyword">id</span>)object change:(<span class="hljs-built_in">NSDictionary</span>&lt;<span class="hljs-built_in">NSKeyValueChangeKey</span>,<span class="hljs-keyword">id</span>&gt; *)change context:(<span class="hljs-keyword">void</span> *)context &#123;<br>    <span class="hljs-keyword">if</span> ([keyPath isEqualToString:<span class="hljs-string">@&quot;children&quot;</span>]) &#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%@&quot;</span>,change);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">@end</span><br><br><br><span class="hljs-comment">// 外部使用</span><br>- (<span class="hljs-keyword">void</span>)mutableArrayValueForKey &#123;<br>    <span class="hljs-keyword">self</span>.father = [Father new];<br>    [<span class="hljs-keyword">self</span>.father.children addObject:<span class="hljs-string">@&quot;son1&quot;</span>];<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>控制台输出为空，这里可以看出即使我们添加了KVO监听数组的变化我们仍无法在数组元素改变时监听到数组改变。</p>
<p>但是当我们把调用改为</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">- (<span class="hljs-keyword">void</span>)mutableArrayValueForKey &#123;<br>    <span class="hljs-keyword">self</span>.father = [Father new];<br>    [[<span class="hljs-keyword">self</span>.father mutableArrayValueForKey:<span class="hljs-string">@&quot;children&quot;</span>] addObject:<span class="hljs-string">@&quot;farmer&quot;</span>];<br>&#125;<br></code></pre></td></tr></table></figure>

<p>控制台输出变为:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-26</span> <span class="hljs-number">23</span>:<span class="hljs-number">52</span>:<span class="hljs-number">17.776620</span>+<span class="hljs-number">0800</span> Runtime-KVC[<span class="hljs-number">51402</span>:<span class="hljs-number">19295413</span>] insertObject: farmer inChildrenAtIndex: <span class="hljs-number">1</span><br><span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-26</span> <span class="hljs-number">23</span>:<span class="hljs-number">52</span>:<span class="hljs-number">17.776865</span>+<span class="hljs-number">0800</span> Runtime-KVC[<span class="hljs-number">51402</span>:<span class="hljs-number">19295413</span>] &#123;<br>    indexes = <span class="hljs-string">&quot;&lt;_NSCachedIndexSet: 0x600003278320&gt;[number of indexes: 1 (in 1 ranges), indexes: (1)]&quot;</span>;<br>    kind = <span class="hljs-number">2</span>;<br>    new =     (<br>        farmer<br>    );<br>&#125;<br></code></pre></td></tr></table></figure>

<p>显然通过mutableArrayValueForKey方法获取father对象的children数组时触发了KVO对数组的监听。在联想到mutableArrayValueForKey查找路径,因为默认我们没有实现第一步查找的方法会自动走到第二步通过setKey方法进行赋值，而KVO的实现原理就是通过重写Set方法进行监听，因此我们使用mutableArrayValueForKey就可以实现对数组的监听。</p>
<p>同样我们可以使用下面的方式验证：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">- (<span class="hljs-keyword">void</span>)mutableArrayValueForKey &#123;<br>    <span class="hljs-keyword">self</span>.father = [Father new];<br>    [<span class="hljs-keyword">self</span>.father.children addObject:<span class="hljs-string">@&quot;son1&quot;</span>];<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;befor ---- children = %p&quot;</span>,<span class="hljs-keyword">self</span>.father.children);<br>    [[<span class="hljs-keyword">self</span>.father mutableArrayValueForKey:<span class="hljs-string">@&quot;children&quot;</span>] addObject:<span class="hljs-string">@&quot;farmer&quot;</span>];<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;after ---- children = %p&quot;</span>,<span class="hljs-keyword">self</span>.father.children);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>控制台输出结果:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-27</span> <span class="hljs-number">00</span>:<span class="hljs-number">07</span>:<span class="hljs-number">09.558349</span>+<span class="hljs-number">0800</span> Runtime-KVC[<span class="hljs-number">51645</span>:<span class="hljs-number">19310184</span>] befor ---- children = <span class="hljs-number">0x600000a81020</span><br><span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-27</span> <span class="hljs-number">00</span>:<span class="hljs-number">07</span>:<span class="hljs-number">09.558632</span>+<span class="hljs-number">0800</span> Runtime-KVC[<span class="hljs-number">51645</span>:<span class="hljs-number">19310184</span>] &#123;<br>    indexes = <span class="hljs-string">&quot;&lt;_NSCachedIndexSet: 0x6000004d0ca0&gt;[number of indexes: 1 (in 1 ranges), indexes: (1)]&quot;</span>;<br>    kind = <span class="hljs-number">2</span>;<br>    new =     (<br>        farmer<br>    );<br>&#125;<br><span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-27</span> <span class="hljs-number">00</span>:<span class="hljs-number">07</span>:<span class="hljs-number">09.558717</span>+<span class="hljs-number">0800</span> Runtime-KVC[<span class="hljs-number">51645</span>:<span class="hljs-number">19310184</span>] after ---- children = <span class="hljs-number">0x600000a80f90</span><br></code></pre></td></tr></table></figure>
<p>从打印结果我们可以看出在调用了mutableArrayValueForKey方法后，self.father.children的对象地址就发生了改变。</p>
<p>加入我们再想数组中继续添加数据</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">- (<span class="hljs-keyword">void</span>)mutableArrayValueForKey &#123;<br>    <span class="hljs-keyword">self</span>.father = [Father new];<br>    [<span class="hljs-keyword">self</span>.father.children addObject:<span class="hljs-string">@&quot;son1&quot;</span>];<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;befor ---- children = %p  children class %@&quot;</span>,<span class="hljs-keyword">self</span>.father.children,[<span class="hljs-keyword">self</span>.father.children <span class="hljs-keyword">class</span>]);<br>    [[<span class="hljs-keyword">self</span>.father mutableArrayValueForKey:<span class="hljs-string">@&quot;children&quot;</span>] addObject:<span class="hljs-string">@&quot;farmer&quot;</span>];<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;after ---- children = %p  children class %@&quot;</span>,<span class="hljs-keyword">self</span>.father.children,[<span class="hljs-keyword">self</span>.father.children <span class="hljs-keyword">class</span>]);<br>    [[<span class="hljs-keyword">self</span>.father mutableArrayValueForKey:<span class="hljs-string">@&quot;children&quot;</span>] addObject:<span class="hljs-string">@&quot;air&quot;</span>];<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;after ---- children = %p  children class %@&quot;</span>,<span class="hljs-keyword">self</span>.father.children,[<span class="hljs-keyword">self</span>.father.children <span class="hljs-keyword">class</span>]);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>控制台打印:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-27</span> <span class="hljs-number">00</span>:<span class="hljs-number">11</span>:<span class="hljs-number">15.866438</span>+<span class="hljs-number">0800</span> Runtime-KVC[<span class="hljs-number">51719</span>:<span class="hljs-number">19314394</span>] befor ---- children = <span class="hljs-number">0x600003330360</span>  children <span class="hljs-keyword">class</span> __NSArrayM<br><span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-27</span> <span class="hljs-number">00</span>:<span class="hljs-number">11</span>:<span class="hljs-number">15.866768</span>+<span class="hljs-number">0800</span> Runtime-KVC[<span class="hljs-number">51719</span>:<span class="hljs-number">19314394</span>] &#123;<br>    indexes = <span class="hljs-string">&quot;&lt;_NSCachedIndexSet: 0x600003d57c40&gt;[number of indexes: 1 (in 1 ranges), indexes: (1)]&quot;</span>;<br>    kind = <span class="hljs-number">2</span>;<br>    new =     (<br>        farmer<br>    );<br>&#125;<br><span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-27</span> <span class="hljs-number">00</span>:<span class="hljs-number">11</span>:<span class="hljs-number">15.866870</span>+<span class="hljs-number">0800</span> Runtime-KVC[<span class="hljs-number">51719</span>:<span class="hljs-number">19314394</span>] after ---- children = <span class="hljs-number">0x600003330900</span>  children <span class="hljs-keyword">class</span> __NSArrayM<br><span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-27</span> <span class="hljs-number">00</span>:<span class="hljs-number">11</span>:<span class="hljs-number">15.867033</span>+<span class="hljs-number">0800</span> Runtime-KVC[<span class="hljs-number">51719</span>:<span class="hljs-number">19314394</span>] &#123;<br>    indexes = <span class="hljs-string">&quot;&lt;_NSCachedIndexSet: 0x600003d57c60&gt;[number of indexes: 1 (in 1 ranges), indexes: (2)]&quot;</span>;<br>    kind = <span class="hljs-number">2</span>;<br>    new =     (<br>        air<br>    );<br>&#125;<br><span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-27</span> <span class="hljs-number">00</span>:<span class="hljs-number">11</span>:<span class="hljs-number">15.867115</span>+<span class="hljs-number">0800</span> Runtime-KVC[<span class="hljs-number">51719</span>:<span class="hljs-number">19314394</span>] after ---- children = <span class="hljs-number">0x6000033590b0</span>  children <span class="hljs-keyword">class</span> __NSArrayM<br></code></pre></td></tr></table></figure>
<p>三次添加元素数组的地址分别为: <code>0x600003330360</code>,<code>0x600003330900</code>,<code>0x6000033590b0</code> 由此可见每次我们修改数组时都是重新创建一个数组然后调用setter方法重新赋值而非修改之前的数组。</p>
<p>如果我们每次增删改的时候都要重新创建数组，一旦我们的数组元素比较多时，效率肯定会受到一定的影响。所以这类方法一定要慎用。</p>
<p>但是如果我们必须要使用时，通过上面我们对查找顺序的了解我们需要在Father类中实现</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">- (<span class="hljs-keyword">void</span>)removeObjectFromChildrenAtIndex:(<span class="hljs-built_in">NSUInteger</span>)index &#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;removeObjectFromChildrenAtIndex %@&quot;</span>,@(index));<br>    [<span class="hljs-keyword">self</span>.children removeObjectAtIndex:index];<br>&#125;<br><br>- (<span class="hljs-keyword">void</span>)insertObject:(<span class="hljs-built_in">NSString</span> *)object inChildrenAtIndex:(<span class="hljs-built_in">NSUInteger</span>)index &#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;insertObject: %@inChildrenAtIndex: %@&quot;</span>,object,@(index));<br>    [<span class="hljs-keyword">self</span>.children insertObject:object atIndex:index];<br>&#125;<br></code></pre></td></tr></table></figure>
<p>实现这两个方法后，就可以保证在第一步查找时就可以找到对应的方法，这样就不需要走setter方法，我们也可以实现KVO的监听。</p>
<p>我们可以通过下面代码验证:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">- (<span class="hljs-keyword">void</span>)mutableArrayValueForKey &#123;<br>    <span class="hljs-keyword">self</span>.father = [Father new];<br>    [<span class="hljs-keyword">self</span>.father.children addObject:<span class="hljs-string">@&quot;son1&quot;</span>];<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;befor ---- children = %p  children class %@&quot;</span>,<span class="hljs-keyword">self</span>.father.children,[<span class="hljs-keyword">self</span>.father.children <span class="hljs-keyword">class</span>]);<br>    [[<span class="hljs-keyword">self</span>.father mutableArrayValueForKey:<span class="hljs-string">@&quot;children&quot;</span>] addObject:<span class="hljs-string">@&quot;farmer&quot;</span>];<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;after ---- children = %p  children class %@&quot;</span>,<span class="hljs-keyword">self</span>.father.children,[<span class="hljs-keyword">self</span>.father.children <span class="hljs-keyword">class</span>]);<br>    [[<span class="hljs-keyword">self</span>.father mutableArrayValueForKey:<span class="hljs-string">@&quot;children&quot;</span>] addObject:<span class="hljs-string">@&quot;air&quot;</span>];<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;after ---- children = %p  children class %@&quot;</span>,<span class="hljs-keyword">self</span>.father.children,[<span class="hljs-keyword">self</span>.father.children <span class="hljs-keyword">class</span>]);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>控制台输出:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-27</span> <span class="hljs-number">00</span>:<span class="hljs-number">30</span>:<span class="hljs-number">06.297870</span>+<span class="hljs-number">0800</span> Runtime-KVC[<span class="hljs-number">51979</span>:<span class="hljs-number">19331763</span>] befor ---- children = <span class="hljs-number">0x6000008b9a40</span>  children <span class="hljs-keyword">class</span> __NSArrayM<br><span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-27</span> <span class="hljs-number">00</span>:<span class="hljs-number">30</span>:<span class="hljs-number">06.298069</span>+<span class="hljs-number">0800</span> Runtime-KVC[<span class="hljs-number">51979</span>:<span class="hljs-number">19331763</span>] insertObject: farmerinChildrenAtIndex: <span class="hljs-number">1</span><br><span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-27</span> <span class="hljs-number">00</span>:<span class="hljs-number">30</span>:<span class="hljs-number">06.298360</span>+<span class="hljs-number">0800</span> Runtime-KVC[<span class="hljs-number">51979</span>:<span class="hljs-number">19331763</span>] &#123;<br>    indexes = <span class="hljs-string">&quot;&lt;_NSCachedIndexSet: 0x6000006d02e0&gt;[number of indexes: 1 (in 1 ranges), indexes: (1)]&quot;</span>;<br>    kind = <span class="hljs-number">2</span>;<br>    new =     (<br>        farmer<br>    );<br>&#125;<br><span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-27</span> <span class="hljs-number">00</span>:<span class="hljs-number">30</span>:<span class="hljs-number">06.298480</span>+<span class="hljs-number">0800</span> Runtime-KVC[<span class="hljs-number">51979</span>:<span class="hljs-number">19331763</span>] after ---- children = <span class="hljs-number">0x6000008b9a40</span>  children <span class="hljs-keyword">class</span> __NSArrayM<br><span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-27</span> <span class="hljs-number">00</span>:<span class="hljs-number">30</span>:<span class="hljs-number">06.298595</span>+<span class="hljs-number">0800</span> Runtime-KVC[<span class="hljs-number">51979</span>:<span class="hljs-number">19331763</span>] insertObject: airinChildrenAtIndex: <span class="hljs-number">2</span><br><span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-27</span> <span class="hljs-number">00</span>:<span class="hljs-number">30</span>:<span class="hljs-number">06.298754</span>+<span class="hljs-number">0800</span> Runtime-KVC[<span class="hljs-number">51979</span>:<span class="hljs-number">19331763</span>] &#123;<br>    indexes = <span class="hljs-string">&quot;&lt;_NSCachedIndexSet: 0x6000006d0300&gt;[number of indexes: 1 (in 1 ranges), indexes: (2)]&quot;</span>;<br>    kind = <span class="hljs-number">2</span>;<br>    new =     (<br>        air<br>    );<br>&#125;<br><span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-27</span> <span class="hljs-number">00</span>:<span class="hljs-number">30</span>:<span class="hljs-number">06.298854</span>+<span class="hljs-number">0800</span> Runtime-KVC[<span class="hljs-number">51979</span>:<span class="hljs-number">19331763</span>] after ---- children = <span class="hljs-number">0x6000008b9a40</span>  children <span class="hljs-keyword">class</span> __NSArrayM<br></code></pre></td></tr></table></figure>
<p>从上面的log中我们可以看到在直接调用addObject和使用mutableArrayValueForKey方法获取到数组后在进行添加操作数组对象并没有发生改变均为<code>0x6000008b9a40</code>。</p>
<p>但是我们同时也发现了一个问题，在没有调用setter方法时我们也可以通过KVO监听到了数据的变化？</p>
<p>因此，我们猜想必定是子类也重写了对应的方法，然后在方法的前后调用了willChange和didChange方法，因此我们先在Father类中实现willChange和didChange的集合方法</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">- (<span class="hljs-keyword">void</span>)willChange:(<span class="hljs-built_in">NSKeyValueChange</span>)changeKind valuesAtIndexes:(<span class="hljs-built_in">NSIndexSet</span> *)indexes forKey:(<span class="hljs-built_in">NSString</span> *)key &#123;<br>    [<span class="hljs-keyword">super</span> willChange:changeKind valuesAtIndexes:indexes forKey:key];<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;willChange: valuesAtIndexes: forKey:%@&quot;</span>,key);<br>&#125;<br><br>- (<span class="hljs-keyword">void</span>)didChange:(<span class="hljs-built_in">NSKeyValueChange</span>)changeKind valuesAtIndexes:(<span class="hljs-built_in">NSIndexSet</span> *)indexes forKey:(<span class="hljs-built_in">NSString</span> *)key &#123;<br>    [<span class="hljs-keyword">super</span> didChange:changeKind valuesAtIndexes:indexes forKey:key];<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;didChange: valuesAtIndexes: forKey:%@&quot;</span>,key);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>接下来我们在进行测试:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">- (<span class="hljs-keyword">void</span>)mutableArrayValueForKey &#123;<br>    <span class="hljs-keyword">self</span>.father = [Father new];<br>    [[<span class="hljs-keyword">self</span>.father mutableArrayValueForKey:<span class="hljs-string">@&quot;children&quot;</span>] addObject:<span class="hljs-string">@&quot;farmer&quot;</span>];<br>&#125;<br></code></pre></td></tr></table></figure>
<p>控制台输出:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-27</span> <span class="hljs-number">12</span>:<span class="hljs-number">26</span>:<span class="hljs-number">07.867838</span>+<span class="hljs-number">0800</span> Runtime-KVC[<span class="hljs-number">56961</span>:<span class="hljs-number">19600302</span>] willChange: valuesAtIndexes: forKey:children<br><span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-27</span> <span class="hljs-number">12</span>:<span class="hljs-number">26</span>:<span class="hljs-number">07.868068</span>+<span class="hljs-number">0800</span> Runtime-KVC[<span class="hljs-number">56961</span>:<span class="hljs-number">19600302</span>] insertObject: farmerinChildrenAtIndex: <span class="hljs-number">1</span><br><span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-27</span> <span class="hljs-number">12</span>:<span class="hljs-number">26</span>:<span class="hljs-number">07.868480</span>+<span class="hljs-number">0800</span> Runtime-KVC[<span class="hljs-number">56961</span>:<span class="hljs-number">19600302</span>] &#123;<br>    indexes = <span class="hljs-string">&quot;&lt;_NSCachedIndexSet: 0x600001a17b80&gt;[number of indexes: 1 (in 1 ranges), indexes: (1)]&quot;</span>;<br>    kind = <span class="hljs-number">2</span>;<br>    new =     (<br>        farmer<br>    );<br>&#125;<br><span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-27</span> <span class="hljs-number">12</span>:<span class="hljs-number">26</span>:<span class="hljs-number">07.868618</span>+<span class="hljs-number">0800</span> Runtime-KVC[<span class="hljs-number">56961</span>:<span class="hljs-number">19600302</span>] didChange: valuesAtIndexes: forKey:children<br></code></pre></td></tr></table></figure>

<p>从日志我们看出在修改方法`insertObject:inChildrenAtIndex:的前后willChange: valuesAtIndexes: forKey:children和didChange: valuesAtIndexes: forKey:children方法被调用我们通过断点看下</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gm2azjmsh4j32600iaqtg.jpg"></p>
<p>从上图我们可以看出willChange: valuesAtIndexes: forKey:children方法是在NSKeyValueNotifyingMutableArray._mutableArray 调用addObject时被调用。<br>很明显NSKeyValueNotifyingMutableArray就是KVO动态创建的子类，即[self.father mutableArrayValueForKey:@”children”]返回的集合代理类,这个类也实现了removeObjectFromChildrenAtIndex:和insertObject:inChildrenAtIndex:两个方法，并在方法调用前后分别调用了KVO的方法通知给外部。</p>
<h3 id="KVC-应用"><a href="#KVC-应用" class="headerlink" title="KVC 应用"></a>KVC 应用</h3><p>除了我们常用的获取对象的某些属性值以外，还有一些高级用法比如：</p>
<h4 id="常规操作符"><a href="#常规操作符" class="headerlink" title="常规操作符"></a>常规操作符</h4><ul>
<li>@sum：值的总和</li>
<li>@avg：平均值</li>
<li>@count：总个数</li>
<li>@max：最大值</li>
<li>@min：最小值</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">- (<span class="hljs-keyword">void</span>)advanceKVCMethod &#123;<br>    Person *p1 = [Person new];<br>    p1.age = <span class="hljs-number">10</span>;<br><br>    Person *p2 = [Person new];<br>    p2.age = <span class="hljs-number">20</span>;<br><br>    Person *p3 = [Person new];<br>    p3.age = <span class="hljs-number">30</span>;<br><br>    Person *p4 = [Person new];<br>    p4.age = <span class="hljs-number">40</span>;<br><br>    <span class="hljs-built_in">NSArray</span> *pArray = @[p1,p2,p3,p4];<br><br>    <span class="hljs-built_in">NSNumber</span> *ageSum = [pArray valueForKeyPath:<span class="hljs-string">@&quot;@sum.age&quot;</span>];<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;年龄的总和为 %@&quot;</span>,ageSum);<br><br>    <span class="hljs-built_in">NSNumber</span> *average = [pArray valueForKeyPath:<span class="hljs-string">@&quot;@avg.age&quot;</span>];<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;年龄的平均值为 %@&quot;</span>,average);<br><br>    <span class="hljs-built_in">NSNumber</span> *count = [pArray valueForKeyPath:<span class="hljs-string">@&quot;@count&quot;</span>];<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;年龄的个数 %@&quot;</span>,count);<br><br>    <span class="hljs-built_in">NSNumber</span> *max = [pArray valueForKeyPath:<span class="hljs-string">@&quot;@max.age&quot;</span>];<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;年龄最大的为 %@&quot;</span>,max);<br><br>    <span class="hljs-built_in">NSNumber</span> *min = [pArray valueForKeyPath:<span class="hljs-string">@&quot;@min.age&quot;</span>];<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;年龄最小的为 %@&quot;</span>,min);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>打印结果:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-27</span> <span class="hljs-number">12</span>:<span class="hljs-number">58</span>:<span class="hljs-number">50.510127</span>+<span class="hljs-number">0800</span> Runtime-KVC[<span class="hljs-number">57474</span>:<span class="hljs-number">19627879</span>] 年龄的总和为 <span class="hljs-number">100</span><br><span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-27</span> <span class="hljs-number">12</span>:<span class="hljs-number">58</span>:<span class="hljs-number">50.510338</span>+<span class="hljs-number">0800</span> Runtime-KVC[<span class="hljs-number">57474</span>:<span class="hljs-number">19627879</span>] 年龄的平均值为 <span class="hljs-number">25</span><br><span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-27</span> <span class="hljs-number">12</span>:<span class="hljs-number">58</span>:<span class="hljs-number">50.510549</span>+<span class="hljs-number">0800</span> Runtime-KVC[<span class="hljs-number">57474</span>:<span class="hljs-number">19627879</span>] 年龄的个数 <span class="hljs-number">4</span><br><span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-27</span> <span class="hljs-number">12</span>:<span class="hljs-number">58</span>:<span class="hljs-number">50.510718</span>+<span class="hljs-number">0800</span> Runtime-KVC[<span class="hljs-number">57474</span>:<span class="hljs-number">19627879</span>] 年龄最大的为 <span class="hljs-number">40</span><br><span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-27</span> <span class="hljs-number">12</span>:<span class="hljs-number">58</span>:<span class="hljs-number">50.510872</span>+<span class="hljs-number">0800</span> Runtime-KVC[<span class="hljs-number">57474</span>:<span class="hljs-number">19627879</span>] 年龄最小的为 <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure>

<h4 id="集合去重"><a href="#集合去重" class="headerlink" title="集合去重"></a>集合去重</h4><ul>
<li>@distinctUnionOfObjects：元素唯一，会进行去重</li>
<li>@unionOfObjects：不会去重</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">- (<span class="hljs-keyword">void</span>)advanceKVCDistinctMethod &#123;<br>    Person *p1 = [Person new];<br>    p1.age = <span class="hljs-number">10</span>;<br><br>    Person *p2 = [Person new];<br>    p2.age = <span class="hljs-number">20</span>;<br><br>    Person *p3 = [Person new];<br>    p3.age = <span class="hljs-number">20</span>;<br><br>    Person *p4 = [Person new];<br>    p4.age = <span class="hljs-number">30</span>;<br><br>    <span class="hljs-built_in">NSArray</span> *pArray = @[p1,p2,p3,p4];<br><br>    <span class="hljs-built_in">NSArray</span> *distinctUnionOfObjectsArray=[pArray valueForKeyPath:<span class="hljs-string">@&quot;@distinctUnionOfObjects.age&quot;</span>];<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;distinctUnionOfObjects:%@&quot;</span>,distinctUnionOfObjectsArray);<br><br>    <span class="hljs-built_in">NSArray</span> *unionOfObjectsArray=[pArray valueForKeyPath:<span class="hljs-string">@&quot;@unionOfObjects.age&quot;</span>];<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;unionOfObjects:%@&quot;</span>,unionOfObjectsArray);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-27</span> <span class="hljs-number">13</span>:<span class="hljs-number">16</span>:<span class="hljs-number">42.349274</span>+<span class="hljs-number">0800</span> Runtime-KVC[<span class="hljs-number">57721</span>:<span class="hljs-number">19644904</span>] distinctUnionOfObjects:(<br>    <span class="hljs-number">10</span>,<br>    <span class="hljs-number">20</span>,<br>    <span class="hljs-number">30</span><br>)<br><span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-27</span> <span class="hljs-number">13</span>:<span class="hljs-number">16</span>:<span class="hljs-number">42.349493</span>+<span class="hljs-number">0800</span> Runtime-KVC[<span class="hljs-number">57721</span>:<span class="hljs-number">19644904</span>] unionOfObjects:(<br>    <span class="hljs-number">10</span>,<br>    <span class="hljs-number">20</span>,<br>    <span class="hljs-number">20</span>,<br>    <span class="hljs-number">30</span><br>)<br></code></pre></td></tr></table></figure>


<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这篇文章我们主要从setValue:forKey:和valueForyKey:以及集合类型的mutableArrayValueForKey:去讲解KVC的实现和查找策略，让我们对KVC的实现有了一个比较清楚的认知，最后我们还介绍了几种KVC的高级用法，在某些场景也可以减少我们遍历的依赖。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://blog.xtxiete.com/2018/12/11/KVOMutableArray%E7%9A%84%E5%88%86%E6%9E%90%E5%92%8C%E7%90%86%E8%A7%A3/">KVOMutableArray的分析和理解</a></p>
<p><a href="https://blog.chenyalun.com/2019/05/05/%E8%AF%A6%E8%A7%A3Key-Value%20Coding%E6%BA%90%E7%A0%81/">详解Key-Value Coding源码</a></p>
<p><a href="https://github.com/LeeWongSnail/Blog_Demo/tree/master/Runtime-KVC">本文demo</a></p>
]]></content>
      <categories>
        <category>KVC</category>
      </categories>
      <tags>
        <tag>KVC、KVO、实现原理</tag>
      </tags>
  </entry>
  <entry>
    <title>Runtime之MetaClass</title>
    <url>/2021/01/01/rumtime-metaclass/</url>
    <content><![CDATA[<p>对于iOS开发者来说，<code>元类</code>一直是一个在面试时被重点考察的点，为什么在语言设计时要增加<code>元类</code>这个概念？他的优点是什么？他到底有什么作用呢？这篇文章我们从<code>Runtime</code>源码的角度和语言设计的角度来探讨<code>MetaClass</code>存在的原因以及他的存在解决了哪些问题。</p>
<a id="more"></a>

<h2 id="测试题"><a href="#测试题" class="headerlink" title="测试题"></a>测试题</h2><p>下面我们先看一下下面这个题目：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">- (<span class="hljs-keyword">void</span>)classJudge &#123;<br>    Class ccls = [<span class="hljs-built_in">NSObject</span> <span class="hljs-keyword">class</span>];<br>    Class icls =  [Person <span class="hljs-keyword">class</span>];<br>    <br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%@ isKindOfClass %@  result %@&quot;</span>, <span class="hljs-built_in">NSStringFromClass</span>(ccls),<span class="hljs-built_in">NSStringFromClass</span>(ccls),@([ccls isKindOfClass:ccls]));<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%@ isKindOfClass %@  result %@&quot;</span>, <span class="hljs-built_in">NSStringFromClass</span>(icls),<span class="hljs-built_in">NSStringFromClass</span>(icls),@([icls isKindOfClass:icls]));<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%@ isKindOfClass %@  result %@&quot;</span>, <span class="hljs-built_in">NSStringFromClass</span>(icls),<span class="hljs-built_in">NSStringFromClass</span>(ccls),@([icls isKindOfClass:ccls]));<br>    <br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%@ isMemberOfClass %@  result %@&quot;</span>, <span class="hljs-built_in">NSStringFromClass</span>(ccls),<span class="hljs-built_in">NSStringFromClass</span>(ccls),@([ccls isMemberOfClass:ccls]));<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%@ isMemberOfClass %@  result %@&quot;</span>, <span class="hljs-built_in">NSStringFromClass</span>(icls),<span class="hljs-built_in">NSStringFromClass</span>(icls),@([icls isMemberOfClass:icls]));<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%@ isMemberOfClass %@  result %@&quot;</span>, <span class="hljs-built_in">NSStringFromClass</span>(icls),<span class="hljs-built_in">NSStringFromClass</span>(ccls),@([icls isMemberOfClass:ccls]));<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>请问上述代码的执行结果是什么？为什么？上面的代码中主要涉及到三个方法</p>
<ul>
<li><code>+class</code> 类方法</li>
<li><code>isKindOfClass</code></li>
<li><code>isMemberOfClass</code></li>
</ul>
<p>下面我们带着这些问题，看下上面这三个方法</p>
<h3 id="Class-方法"><a href="#Class-方法" class="headerlink" title="Class 方法"></a>Class 方法</h3><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">+ (Class)<span class="hljs-keyword">class</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>;<br>&#125;<br><br>- (Class)<span class="hljs-keyword">class</span> &#123;<br>    <span class="hljs-keyword">return</span> object_getClass(<span class="hljs-keyword">self</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>不过我们在<code>NSObject.h</code>中只发现了</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">- (Class)<span class="hljs-keyword">class</span><br></code></pre></td></tr></table></figure>

<p>对象方法的声明，且当我们点击我们自己代码中的方法名进行跳转时也是跳转到了对应的对象方法中，因此我们可以知道在我们平时开发中调用class方法时，都是调用的对象方法(即使是使用类调用)。</p>
<p>我们看到对于对象方法中实际上是调用了<code>object_getClass</code>方法，因此我们继续看这个方法的实现：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">Class object_getClass(<span class="hljs-keyword">id</span> obj)<br>&#123;<br>    <span class="hljs-keyword">if</span> (obj) <span class="hljs-keyword">return</span> obj-&gt;getIsa();<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> Nil;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这个方法是返回了当前对象的元类。</p>
<p>看完了方法的实现我们来分析下我们上面示例代码中获取到的类是什么：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">Class ccls = [<span class="hljs-built_in">NSObject</span> <span class="hljs-keyword">class</span>];<br>Class icls =  [Person <span class="hljs-keyword">class</span>];<br></code></pre></td></tr></table></figure>

<p>根据源码我们很容易得出结论：<code>ccls</code>为<code>NSObject</code>类的元类 <code>icls</code>为<code>Person</code>类的元类</p>
<h3 id="isKindOfClass"><a href="#isKindOfClass" class="headerlink" title="isKindOfClass"></a>isKindOfClass</h3><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">+ (<span class="hljs-built_in">BOOL</span>)isKindOfClass:(Class)cls &#123;<br>    <span class="hljs-keyword">for</span> (Class tcls = <span class="hljs-keyword">self</span>-&gt;ISA(); tcls; tcls = tcls-&gt;superclass) &#123;<br>        <span class="hljs-keyword">if</span> (tcls == cls) <span class="hljs-keyword">return</span> <span class="hljs-literal">YES</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NO</span>;<br>&#125;<br><br>- (<span class="hljs-built_in">BOOL</span>)isKindOfClass:(Class)cls &#123;<br>    <span class="hljs-keyword">for</span> (Class tcls = [<span class="hljs-keyword">self</span> <span class="hljs-keyword">class</span>]; tcls; tcls = tcls-&gt;superclass) &#123;<br>        <span class="hljs-keyword">if</span> (tcls == cls) <span class="hljs-keyword">return</span> <span class="hljs-literal">YES</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NO</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>与Class方法相同，在<code>NSObject.h</code>文件中我们只发现了</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">- (<span class="hljs-built_in">BOOL</span>)isKindOfClass:(Class)cls<br></code></pre></td></tr></table></figure>

<p>一个方法的声明，因此我们重点分析下这个方法的实现：</p>
<ul>
<li>判断当前类与给定类是否相同 </li>
<li>如果不相同，则查找当前类的父类是否为给定类</li>
<li>如果相同，则返回</li>
<li>如果查找到最后都不等于给定类 则返回NO</li>
</ul>
<p>结合我们上面的示例，我们认为</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%@ isKindOfClass %@  result %@&quot;</span>, <span class="hljs-built_in">NSStringFromClass</span>(ccls),<span class="hljs-built_in">NSStringFromClass</span>(ccls),@([ccls isKindOfClass:ccls]));<br>  <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%@ isKindOfClass %@  result %@&quot;</span>, <span class="hljs-built_in">NSStringFromClass</span>(icls),<span class="hljs-built_in">NSStringFromClass</span>(icls),@([icls isKindOfClass:icls]));<br>  <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%@ isKindOfClass %@  result %@&quot;</span>, <span class="hljs-built_in">NSStringFromClass</span>(icls),<span class="hljs-built_in">NSStringFromClass</span>(ccls),@([icls isKindOfClass:ccls]));<br></code></pre></td></tr></table></figure>

<p>的结果为：1 1 1<br>原因为：</p>
<ul>
<li>1和3均为相同的类 通过因此肯定是相等的</li>
<li>2 因为Person类是继承自NSObject的因此这里也应该为1</li>
</ul>
<h3 id="isMemberOfClass"><a href="#isMemberOfClass" class="headerlink" title="isMemberOfClass"></a>isMemberOfClass</h3><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">+ (<span class="hljs-built_in">BOOL</span>)isMemberOfClass:(Class)cls &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>-&gt;ISA() == cls;<br>&#125;<br><br>- (<span class="hljs-built_in">BOOL</span>)isMemberOfClass:(Class)cls &#123;<br>    <span class="hljs-keyword">return</span> [<span class="hljs-keyword">self</span> <span class="hljs-keyword">class</span>] == cls;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>与前面两个方法相同，在<code>NSObject.h</code>文件中我们也是仅发现了对象方法的声明</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">- (<span class="hljs-built_in">BOOL</span>)isMemberOfClass:(Class)aClass;<br></code></pre></td></tr></table></figure>

<p>根据上述源码的实现，<code>isMemberOfClass</code>方法实际是：</p>
<ul>
<li>判断当前类的class是否为给给定类</li>
</ul>
<p>在结合我们上面的代码示例</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%@ isMemberOfClass %@  result %@&quot;</span>, <span class="hljs-built_in">NSStringFromClass</span>(ccls),<span class="hljs-built_in">NSStringFromClass</span>(ccls),@([ccls isMemberOfClass:ccls]));<br> <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%@ isMemberOfClass %@  result %@&quot;</span>, <span class="hljs-built_in">NSStringFromClass</span>(icls),<span class="hljs-built_in">NSStringFromClass</span>(icls),@([icls isMemberOfClass:icls]));<br> <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%@ isMemberOfClass %@  result %@&quot;</span>, <span class="hljs-built_in">NSStringFromClass</span>(icls),<span class="hljs-built_in">NSStringFromClass</span>(ccls),@([icls isMemberOfClass:ccls]));<br></code></pre></td></tr></table></figure>

<p>这里我们判断输出结果应该为： 1 1 1 </p>
<h3 id="结果分析"><a href="#结果分析" class="headerlink" title="结果分析"></a>结果分析</h3><p>那么我们带着上面的猜测，确认打印输出：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-number">2021</span><span class="hljs-number">-01</span><span class="hljs-number">-01</span> <span class="hljs-number">19</span>:<span class="hljs-number">26</span>:<span class="hljs-number">08.475701</span>+<span class="hljs-number">0800</span> MetaClassDemo[<span class="hljs-number">5964</span>:<span class="hljs-number">166878</span>] <span class="hljs-built_in">NSObject</span> isKindOfClass <span class="hljs-built_in">NSObject</span>  result <span class="hljs-number">1</span><br><span class="hljs-number">2021</span><span class="hljs-number">-01</span><span class="hljs-number">-01</span> <span class="hljs-number">19</span>:<span class="hljs-number">26</span>:<span class="hljs-number">08.475858</span>+<span class="hljs-number">0800</span> MetaClassDemo[<span class="hljs-number">5964</span>:<span class="hljs-number">166878</span>] Person isKindOfClass Person  result <span class="hljs-number">0</span><br><span class="hljs-number">2021</span><span class="hljs-number">-01</span><span class="hljs-number">-01</span> <span class="hljs-number">19</span>:<span class="hljs-number">26</span>:<span class="hljs-number">08.475963</span>+<span class="hljs-number">0800</span> MetaClassDemo[<span class="hljs-number">5964</span>:<span class="hljs-number">166878</span>] Person isKindOfClass <span class="hljs-built_in">NSObject</span>  result <span class="hljs-number">1</span><br><span class="hljs-number">2021</span><span class="hljs-number">-01</span><span class="hljs-number">-01</span> <span class="hljs-number">19</span>:<span class="hljs-number">26</span>:<span class="hljs-number">08.476068</span>+<span class="hljs-number">0800</span> MetaClassDemo[<span class="hljs-number">5964</span>:<span class="hljs-number">166878</span>] <span class="hljs-built_in">NSObject</span> isMemberOfClass <span class="hljs-built_in">NSObject</span>  result <span class="hljs-number">0</span><br><span class="hljs-number">2021</span><span class="hljs-number">-01</span><span class="hljs-number">-01</span> <span class="hljs-number">19</span>:<span class="hljs-number">26</span>:<span class="hljs-number">08.476188</span>+<span class="hljs-number">0800</span> MetaClassDemo[<span class="hljs-number">5964</span>:<span class="hljs-number">166878</span>] Person isMemberOfClass Person  result <span class="hljs-number">0</span><br><span class="hljs-number">2021</span><span class="hljs-number">-01</span><span class="hljs-number">-01</span> <span class="hljs-number">19</span>:<span class="hljs-number">26</span>:<span class="hljs-number">08.476315</span>+<span class="hljs-number">0800</span> MetaClassDemo[<span class="hljs-number">5964</span>:<span class="hljs-number">166878</span>] Person isMemberOfClass <span class="hljs-built_in">NSObject</span>  result <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>

<p>结果很意外，我们猜想的是所有结果都为1，但是结果 2、4、5、6的结果均为0，那么我们来分析下原因：</p>
<h4 id="isKindOfClass-1"><a href="#isKindOfClass-1" class="headerlink" title="isKindOfClass"></a>isKindOfClass</h4><figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">Class ccls = [<span class="hljs-built_in">NSObject</span> <span class="hljs-keyword">class</span>];<br>Class icls =  [Person <span class="hljs-keyword">class</span>];<br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%@ isKindOfClass %@  result %@&quot;</span>, <span class="hljs-built_in">NSStringFromClass</span>(icls),<span class="hljs-built_in">NSStringFromClass</span>(icls),@([icls isKindOfClass:icls]));<br></code></pre></td></tr></table></figure>
<p>上面代码的结果为：0,明显我们知道Person类为NSObject类的子类，那么为何此处返回的是0呢？</p>
<p>我们在来看下<code>isKindOfClass</code>方法的实现：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">- (<span class="hljs-built_in">BOOL</span>)isKindOfClass:(Class)cls &#123;<br>    <span class="hljs-keyword">for</span> (Class tcls = [<span class="hljs-keyword">self</span> <span class="hljs-keyword">class</span>]; tcls; tcls = tcls-&gt;superclass) &#123;<br>        <span class="hljs-keyword">if</span> (tcls == cls) <span class="hljs-keyword">return</span> <span class="hljs-literal">YES</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NO</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>我们发现</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">Class tcls = [<span class="hljs-keyword">self</span> <span class="hljs-keyword">class</span>];<br></code></pre></td></tr></table></figure>
<p>这时候，tcls到底是到底是什么呢？ 因为是对象方法因此这里调用到的是class对象方法，而Class的对象方法实现为：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">- (Class)<span class="hljs-keyword">class</span> &#123;<br>    <span class="hljs-keyword">return</span> object_getClass(<span class="hljs-keyword">self</span>);<br>&#125;<br>Class object_getClass(<span class="hljs-keyword">id</span> obj)<br>&#123;<br>    <span class="hljs-keyword">if</span> (obj) <span class="hljs-keyword">return</span> obj-&gt;getIsa();<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> Nil;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>很明显这里我们得到的变量tcls实际上是类的元类，也就是说我们在for循环里遍历的是元类的superclass,那么for循环里的对比就很明显了 这里是用cls和元类的cls做对比肯定是不相同的。</p>
<p>那么问题又来了，为什么对于NSObject这个判断条件的结果是正确的呢？</p>
<p>这里我们就要贴出我们很熟悉的一张图来解释下了？</p>
<p><img src="https://upload-images.jianshu.io/upload_images/967869-f15ff2bc1baf88d2.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/700"></p>
<p>对于我们的示例</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gm8j9wl9u3j30mu0ioq4h.jpg"></p>
<p>首先对于</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">Class ccls = [<span class="hljs-built_in">NSObject</span> <span class="hljs-keyword">class</span>];<br>Class icls =  [Person <span class="hljs-keyword">class</span>];<br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%@ isKindOfClass %@  result %@&quot;</span>, <span class="hljs-built_in">NSStringFromClass</span>(icls),<span class="hljs-built_in">NSStringFromClass</span>(icls),@([icls isKindOfClass:icls]));<br></code></pre></td></tr></table></figure>

<p>我们在<code>isKindOfClass</code>方法中实际上对比的是</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">if</span> (icls == object_getClass(<span class="hljs-keyword">self</span>)) &#123;<br>    <span class="hljs-comment">// icls 是否等于icls的metacls</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>对于NSObject,NSObject的元类的<code>superclass</code>依然是NSObject(这里是一个闭环)，因此对于NSObject来说上述代码比较结果为YES，而对于Person类对比Person类和Person的元类(以及元类的父类 RootClass为NSObject)是否相等答案显然是NO。</p>
<p>而对于</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">[Person Class] == object_getClass([<span class="hljs-built_in">NSObject</span> <span class="hljs-keyword">class</span>]) <br></code></pre></td></tr></table></figure>

<p>我们实际上比较的是NSobject类和Person的元类的父类(一直向上搜索)即NSObject类。而对于</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">[Person Class] == object_getClass([Person <span class="hljs-keyword">class</span>]) <br></code></pre></td></tr></table></figure>

<p>实际比较的是Person类和Person类的元类的父类(一直向上搜索)即NSObject类 因此这里返回的是NO。</p>
<h4 id="isMemberOfClass-1"><a href="#isMemberOfClass-1" class="headerlink" title="isMemberOfClass"></a>isMemberOfClass</h4><p>根据<code>isKindOfClass</code>的提示我们来重新分析下<code>isMemberOfClass</code>方法的实现：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">+ (<span class="hljs-built_in">BOOL</span>)isMemberOfClass:(Class)cls &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>-&gt;ISA() == cls;<br>&#125;<br><br>- (<span class="hljs-built_in">BOOL</span>)isMemberOfClass:(Class)cls &#123;<br>    <span class="hljs-keyword">return</span> [<span class="hljs-keyword">self</span> <span class="hljs-keyword">class</span>] == cls;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>从上面的分析我们已经知道我们实际上调用的是对象方法<code>- (BOOL)isMemberOfClass:(Class)cls</code>,我们发现<code>isMemberOfClass</code>的判断条件为</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">[<span class="hljs-keyword">self</span> <span class="hljs-keyword">class</span>] == cls<br></code></pre></td></tr></table></figure>

<p>对于下面这几种情况</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%@ isMemberOfClass %@  result %@&quot;</span>, <span class="hljs-built_in">NSStringFromClass</span>(ccls),<span class="hljs-built_in">NSStringFromClass</span>(ccls),@([ccls isMemberOfClass:ccls]));<br><br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%@ isMemberOfClass %@  result %@&quot;</span>, <span class="hljs-built_in">NSStringFromClass</span>(icls),<span class="hljs-built_in">NSStringFromClass</span>(icls),@([icls isMemberOfClass:icls]));<br><br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%@ isMemberOfClass %@  result %@&quot;</span>, <span class="hljs-built_in">NSStringFromClass</span>(icls),<span class="hljs-built_in">NSStringFromClass</span>(ccls),@([icls isMemberOfClass:ccls]));<br></code></pre></td></tr></table></figure>

<ul>
<li><code>NSObject == object_getClass([NSObject class])</code> 结果为<code>NO</code></li>
<li><code>Person == object_getClass([Person class])</code> 结果为<code>NO</code></li>
<li><code>Person == object_getClass([NSObject class])</code> 结果也为<code>NO</code></li>
</ul>
<p>我们发现实际上<code>isMemberOfClass</code>并没有像<code>isKindOfClass</code>那样递归的去查找父类，而是只判断了当前类。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过对上面题目的分析，我们了解了这两个重要方法的实现：</p>
<ul>
<li>isKindOfClass</li>
</ul>
<p><code>[A isKindOfClass: B];</code></p>
<p>B类是否为A类的元类或者A类元类的父类,这里因为NSObject的元类的superClass就是NSObject因此对于<code>[[NSObjec class] isKindOfClass:[NSObject class]]</code>返回是YES，更清晰的来说只有在判断某个类是否为NSObject类时这个条件才成立，为此我们特地做下面的测试：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">Class ccls = [<span class="hljs-built_in">NSObject</span> <span class="hljs-keyword">class</span>];<br>Class icls =  [Person <span class="hljs-keyword">class</span>];<br>Class scls =  [Female <span class="hljs-keyword">class</span>];<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%@ isKindOfClass %@  result %@&quot;</span>, <span class="hljs-built_in">NSStringFromClass</span>(icls),<span class="hljs-built_in">NSStringFromClass</span>(ccls),@([icls isKindOfClass:ccls]));<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%@ isKindOfClass %@  result %@&quot;</span>, <span class="hljs-built_in">NSStringFromClass</span>(scls),<span class="hljs-built_in">NSStringFromClass</span>(icls),@([scls isKindOfClass:icls]));<br></code></pre></td></tr></table></figure>

<p>结果：1，0。<br>这也验证了我们上面的结论</p>
<ul>
<li>isMemberOfClass</li>
</ul>
<p><code>[A isMemberOfClass: B]</code></p>
<p>B 类是否为A类元类 对于类方法的调用中这个条件是永远都不成立的。无论A与B之间是否存在继承或者被继承关系。</p>
<ul>
<li>对象方法</li>
</ul>
<p>实际我们平时开发中最常用的是</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">- (<span class="hljs-keyword">void</span>)instanceTest &#123;<br>    Female *f = [Female new];<br>    <br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%@ isKindOfClass %@  result %@&quot;</span>, <span class="hljs-built_in">NSStringFromClass</span>([f <span class="hljs-keyword">class</span>]),<span class="hljs-built_in">NSStringFromClass</span>([Person <span class="hljs-keyword">class</span>]),@([f isKindOfClass:[Person <span class="hljs-keyword">class</span>]]));<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%@ isMemberOfClass %@  result %@&quot;</span>, <span class="hljs-built_in">NSStringFromClass</span>([f <span class="hljs-keyword">class</span>]),<span class="hljs-built_in">NSStringFromClass</span>([Person <span class="hljs-keyword">class</span>]),@([f isMemberOfClass:[Person <span class="hljs-keyword">class</span>]]));<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%@ isMemberOfClass %@  result %@&quot;</span>, <span class="hljs-built_in">NSStringFromClass</span>([f <span class="hljs-keyword">class</span>]),<span class="hljs-built_in">NSStringFromClass</span>([Female <span class="hljs-keyword">class</span>]),@([f isMemberOfClass:[Female <span class="hljs-keyword">class</span>]]));<br><br>&#125;<br></code></pre></td></tr></table></figure>
<p>打印结果：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-number">2021</span><span class="hljs-number">-01</span><span class="hljs-number">-01</span> <span class="hljs-number">23</span>:<span class="hljs-number">27</span>:<span class="hljs-number">53.040093</span>+<span class="hljs-number">0800</span> MetaClassDemo[<span class="hljs-number">8537</span>:<span class="hljs-number">312528</span>] Female isKindOfClass Person  result <span class="hljs-number">1</span><br><span class="hljs-number">2021</span><span class="hljs-number">-01</span><span class="hljs-number">-01</span> <span class="hljs-number">23</span>:<span class="hljs-number">27</span>:<span class="hljs-number">53.040223</span>+<span class="hljs-number">0800</span> MetaClassDemo[<span class="hljs-number">8537</span>:<span class="hljs-number">312528</span>] Female isMemberOfClass Person  result <span class="hljs-number">0</span><br><span class="hljs-number">2021</span><span class="hljs-number">-01</span><span class="hljs-number">-01</span> <span class="hljs-number">23</span>:<span class="hljs-number">27</span>:<span class="hljs-number">53.040337</span>+<span class="hljs-number">0800</span> MetaClassDemo[<span class="hljs-number">8537</span>:<span class="hljs-number">312528</span>] Female isMemberOfClass Female  result <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>

<p>这里我们套用上面的结论：</p>
<ul>
<li>对于<code>isKindOfClass</code> 我们比较的是对象f的元类(即Female类)及其父类是否为Person类 很显然返回值为YES</li>
<li>对于<code>isMemberOfClass</code> 我们比较的是f的元类是否为Person类 很明显这里应该是Female类因此第二行输出NO，第三行输出YES。</li>
</ul>
<h2 id="MetaClass结构"><a href="#MetaClass结构" class="headerlink" title="MetaClass结构"></a>MetaClass结构</h2><p>下面我们先来看看这个类的结构:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">struct</span> objc_class &#123;<br>    Class isa  OBJC_ISA_AVAILABILITY;<br>    <span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> !__OBJC2__</span><br>    Class super_class   OBJC2_UNAVAILABLE;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name    OBJC2_UNAVAILABLE;<br>    <span class="hljs-keyword">long</span> version        OBJC2_UNAVAILABLE;<br>    <span class="hljs-keyword">long</span> info           OBJC2_UNAVAILABLE;<br>    <span class="hljs-keyword">long</span> instance_size  OBJC2_UNAVAILABLE;<br>    <span class="hljs-keyword">struct</span> objc_ivar_list *ivars    OBJC2_UNAVAILABLE;<br>    <span class="hljs-keyword">struct</span> objc_method_list **methodLists   OBJC2_UNAVAILABLE;<br>    <span class="hljs-keyword">struct</span> objc_cache *cache                OBJC2_UNAVAILABLE;<br>    <span class="hljs-keyword">struct</span> objc_protocol_list *protocols    OBJC2_UNAVAILABLE;<br>    <span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>&#125; OBJC2_UNAVAILABLE;<br></code></pre></td></tr></table></figure>

<p>metaClass 也是<code>objc_class</code> 因此结构大概也是这样的！,不过就目前所知到的<code>metaClass</code>是用来存放类方法的！ 因为OC中没有类属性因此 <code>objc_ivar_list</code> 为空！</p>
<p>实际上在OBJC2之后class的结构已经更新为：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">struct</span> objc_class : objc_object &#123;<br>    <span class="hljs-comment">// Class ISA;</span><br>    Class superclass;<br>    cache_t cache;             <span class="hljs-comment">// formerly cache pointer and vtable</span><br>    class_data_bits_t bits;    <span class="hljs-comment">// class_rw_t * plus custom rr/alloc flags</span><br><br>    class_rw_t *data() <span class="hljs-keyword">const</span> &#123;<br>        <span class="hljs-keyword">return</span> bits.data();<br>    &#125;<br>    <span class="hljs-comment">// NOT identical to this-&gt;ISA when this is a metaclass</span><br>    Class getMeta() &#123;<br>        <span class="hljs-keyword">if</span> (isMetaClass()) <span class="hljs-keyword">return</span> (Class)<span class="hljs-keyword">this</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;ISA();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>


<h3 id="MetaClass的创建"><a href="#MetaClass的创建" class="headerlink" title="MetaClass的创建"></a>MetaClass的创建</h3><p>首先了解一点,在OC中每一个类都有一个对应的MetaClass！ 因此 我们在创建一个类的时候,就会一起创建这个类的元类。</p>
<p>因此,我们可以看一下当我们动态创建一个类的时候 运行时实际上都做了什么！</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">Class objc_allocateClassPair(Class superclass, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name, <br>                             size_t extraBytes)<br>&#123;<br>    Class cls, meta;<br><br>    rwlock_writer_t lock(runtimeLock);<br><br>    <span class="hljs-comment">// Fail if the class name is in use.</span><br>    <span class="hljs-comment">// Fail if the superclass isn&#x27;t kosher.</span><br>    <span class="hljs-keyword">if</span> (getClass(name)  ||  !verifySuperclass(superclass, <span class="hljs-literal">true</span><span class="hljs-comment">/*rootOK*/</span>)) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// Allocate new classes.</span><br>    cls  = alloc_class_for_subclass(superclass, extraBytes);<br>    meta = alloc_class_for_subclass(superclass, extraBytes);<br><br>    <span class="hljs-comment">// fixme mangle the name if it looks swift-y?</span><br>    objc_initializeClassPair_internal(superclass, name, cls, meta);<br><br>    <span class="hljs-keyword">return</span> cls;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>从上面的代码中我们可以很明显的看出:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">cls  = alloc_class_for_subclass(superclass, extraBytes);<br>meta = alloc_class_for_subclass(superclass, extraBytes);<br></code></pre></td></tr></table></figure>
<p>没创建一个cls我们都会创建一个<code>metaClass</code>, <code>cls</code>和<code>meta</code>的创建方法和参数也是完全一致的！</p>
<h3 id="怎么获取一个类的MetaClass"><a href="#怎么获取一个类的MetaClass" class="headerlink" title="怎么获取一个类的MetaClass"></a>怎么获取一个类的MetaClass</h3><p><code>objc_getMetaClass(const char * _Nonnull name)</code></p>
<p>我们来看一下这个方法的实现</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">Class objc_getMetaClass(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *aClassName)<br>&#123;<br>    Class cls;<br><br>    <span class="hljs-keyword">if</span> (!aClassName) <span class="hljs-keyword">return</span> Nil;<br><br>    cls = objc_getClass (aClassName);<br>    <span class="hljs-keyword">if</span> (!cls)<br>    &#123;<br>        _objc_inform (<span class="hljs-string">&quot;class `%s&#x27; not linked into application&quot;</span>, aClassName);<br>        <span class="hljs-keyword">return</span> Nil;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> cls-&gt;ISA();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>先是使用<code>objc_getClass</code>获取类名对应的类 然后直接利用<code>cls-&gt;ISA()</code>获取这个类对应的元类</p>
<p>同样在Runtime新版本中我们也能找到下面这个方法:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">Class getMeta() &#123;<br>    <span class="hljs-keyword">if</span> (isMetaClass()) <span class="hljs-keyword">return</span> (Class)<span class="hljs-keyword">this</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;ISA();<br>&#125;<br></code></pre></td></tr></table></figure>


<h3 id="判断一个类是否为元类"><a href="#判断一个类是否为元类" class="headerlink" title="判断一个类是否为元类"></a>判断一个类是否为元类</h3><p><code>bool class_isMetaClass(Class _Nullable cls)</code></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><br><span class="hljs-built_in">BOOL</span> class_isMetaClass(Class cls)<br>&#123;<br>    <span class="hljs-keyword">if</span> (!cls) <span class="hljs-keyword">return</span> <span class="hljs-literal">NO</span>;<br>    <span class="hljs-keyword">return</span> cls-&gt;isMetaClass();<br>&#125;<br><br><span class="hljs-keyword">bool</span> isMetaClass() &#123;<br>   assert(<span class="hljs-keyword">this</span>);<br>   assert(isRealized());<br>   <span class="hljs-keyword">return</span> data()-&gt;ro-&gt;flags &amp; RO_META;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>从上面的代码我们可以看出 判断是否为元类的条件是 <code>data()-&gt;ro-&gt;flags &amp; RO_META</code>。那么这个类的flags是什么时候设置的呢？</p>
<p>找了好久,我们在<code>objc_initializeClassPair_internal</code>方法中找到了下面这段代码</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">cls_ro_w-&gt;flags = <span class="hljs-number">0</span>;<br>meta_ro_w-&gt;flags = RO_META;<br><span class="hljs-keyword">if</span> (!superclass) &#123;<br>   cls_ro_w-&gt;flags |= RO_ROOT;<br>   meta_ro_w-&gt;flags |= RO_ROOT;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>那么这个方法什么时候被调用呢? 追踪了一下我们发现 是在<code>objc_initializeClassPair_internal</code>这个方法中被调用的！ 这个方法是不是很熟悉呢！ 他就是<code>objc_allocateClassPair</code>中的最后一句代码。</p>
<h2 id="MetaClass-存在的意义是什么呢？"><a href="#MetaClass-存在的意义是什么呢？" class="headerlink" title="MetaClass 存在的意义是什么呢？"></a>MetaClass 存在的意义是什么呢？</h2><p>实际上如果没有元类的存在,而是在class中增加一个classmethodlist用来存放这个类的类方法,也是可以达到我们想要实现的目的。</p>
<p>那么MetaClass存在的意义到底是什么呢？</p>
<p>为了更好的了解MetaClass存在的原因,我们先看一下他的作用:</p>
<p>先看一下下面这张图片:</p>
<p><img src="https://upload-images.jianshu.io/upload_images/967869-f15ff2bc1baf88d2.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt="metaclass"></p>
<h3 id="一切皆对象的思想"><a href="#一切皆对象的思想" class="headerlink" title="一切皆对象的思想"></a>一切皆对象的思想</h3><p>我们都知道对象里有一个isa指针</p>
<p><code>ISA指针 实际上就是 is a 的缩写。表示这个对象是一个什么</code></p>
<p>从上面的图上我们也可以看出最顶层的RootMetaClass的isa指向知己superClass指向RootClass,这就形成了一个闭环。</p>
<p>加入 我们将元类去掉,那么我们类的ISA指针应该指向什么呢？如果没办法指向一个RootMetaClass那表明这个类是一个什么类型的对象呢？</p>
<p>当然这个是根据结论反推原因,是不太合逻辑的,但是 更容易被我们理解。</p>
<h3 id="从Smalltalk重新认识面向对象"><a href="#从Smalltalk重新认识面向对象" class="headerlink" title="从Smalltalk重新认识面向对象"></a>从Smalltalk重新认识面向对象</h3><p>以前谈到面向对象，总会提到，面向对象三特征：封装、继承、多态。但其实，面向对象中也分流派，如C++这种来自Simula的设计思想的，更注重的是类的划分，因为方法调用是静态的。而如Objective-C这种借鉴Smalltalk的，更注重的是消息传递，是动态响应消息。</p>
<p>而面向对象三种特征，更基于的是类的划分而提出的。</p>
<p>这两种思想最大的不同，我认为是自上而下和自下而上的思考方式。</p>
<ul>
<li>类的划分，要求类的设计者是以一个很高的层次去设计这个类，提取出类的特性和本质，进行类的构建。<code>知道类型才可以去发送消息给对象</code>。</li>
<li>消息传递，要求的是类的设计者以消息为起点去构建类，也就是对外界的变化进行响应，而不关心自身的类型，设计接口。尝试理解消息，无法处理则进行特殊处理。</li>
</ul>
<p>消息传递对于面向对象的设计，其实在于给出一种对消息的解决方案。而面向对象优点之一的复用，在这种设计里，更多在于复用解决方案，而不是单纯的类本身。这种思想就如设计组件一般，关心接口，关心组合而非类本身。其实之所以有MetaClass这种设计，我的理解并不是先有MetaClass，而是在万物都是对象的Smalltalk里，向对象发送消息的基本解决方案是统一的，希望复用的。而实例和类之间用的这一套通过isa指针指向的Class单例中存储方法列表和查询方法的解决方案的流程，是应该在类上复用的，而MetaClass就顺理成章出现罢了。</p>
<p>上面这部分是摘自:<a href="https://www.jianshu.com/p/ea7c42e16da8">Why is MetaClass in Objective-C</a></p>
<h3 id="维基百科的解释"><a href="#维基百科的解释" class="headerlink" title="维基百科的解释"></a>维基百科的解释</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br>Metaclasses in Objective-C are almost the same as those in Smalltalk-80—not surprising since Objective-C borrows a lot from Smalltalk. Like Smalltalk, in Objective-C, the instance variables and methods are defined by an object&#39;s class. A class is an object, hence it is an instance of a metaclass.(OC中的Metaclasses 基本上和Smalltalk-80相同,鉴于OC从Smalltalk中借鉴了很多因此这并不令人干到奇怪。类似Smalltalk 在OC中实例的变量和方法被定义在对象的类中,class也是一个对象,于是class是mataclass的一个实例。)<br><br>Like Smalltalk, in Objective-C, class methods are simply methods called on the class object, hence a class&#39;s class methods must be defined as instance methods in its metaclass. Because different classes can have different sets of class methods, each class must have its own separate metaclass. Classes and metaclasses are always created as a pair: the runtime has functions objc_allocateClassPair() and objc_registerClassPair() to create and register class-metaclass pairs, respectively.(类似Smalltalk,在OC中类方法通过类对象调用,于是一个类的类方法必须在metaclass中以实例方法的形式定义。因为不同的类可以后不同的类方法集合，每一个类必须有自己独立的metaClass。Class和class-metaClass一起被创建和注册)<br><br>There are no names for the metaclasses; however, a pointer to any class object can be referred to with the generic type Class (similar to the type id being used for a pointer to any object). (metaClass没有名字,然而,指向任何类对象的指针可以用泛型类型引用)（类似id可以指向所有的对象）<br><br>Because class methods are inherited through inheritance, like Smalltalk, metaclasses must follow an inheritance scheme paralleling that of classes (e.g. if class A&#39;s parent class is class B, then A&#39;s metaclass&#39;s parent class is B&#39;s metaclass), except that of the root class.(因为,类方法通过继承获取,类似Smalltalk,元类必须遵循与类类似的继承方案<br><br>Unlike Smalltalk, the metaclass of the root class inherits from the root class (usually NSObject using the Cocoa framework) itself. This ensures that all class objects are ultimately instances of the root class, so that you can use the instance methods of the root class, usually useful utility methods for objects, on class objects themselves.(与Smalltalk不同,根类的metaclass继承自根类本身,这就确保了所有的类对象都是根类的对象。以便您可以使用根类的实例方法，通常是对象的有用实用工具方法，以及类对象本身。)<br><br>Since metaclass objects do not behave differently (you cannot add class methods for a metaclass, so metaclass objects all have the same methods), they are all instances of the same class—the metaclass of the root class (unlike Smalltalk). Thus, the metaclass of the root class is an instance of itself. The reason for this is that all metaclasses inherit from root class; hence, they must inherit the class methods of the root class.<br>(由于元类对象行为不同(你不能为元类添加类方法，所以元类对象都有相同的方法),它们都是同一类的实例 - 根类的元类（与Smalltalk不同）因此，根类的元类是它自己的一个实例。原因是所有元类都继承自根类;因此，他们必须继承根类的类方法。)<br></code></pre></td></tr></table></figure>

<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>回到一开始那个问题，为什么要设计MetaClass，去掉把类方法放到类里面行不行？</p>
<p>我的理解是，可以，但不Smalltalk。这样的设计是C++那种自上而下的设计方式，类方法也是类的一种特征描述。而Smalltalk的精髓正在于消息传递，复用消息传递才是根本目的，而MetaClass只不过是因此需要的一个工具罢了。</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://www.jianshu.com/p/ea7c42e16da8">Why is MetaClass in Objective-C</a><br><a href="https://blog.csdn.net/myan/article/details/5928531">function/bind的救赎（上）</a></p>
]]></content>
      <categories>
        <category>iOS优化</category>
      </categories>
      <tags>
        <tag>metaClass</tag>
      </tags>
  </entry>
  <entry>
    <title>Gif展示对比和优化</title>
    <url>/2021/01/31/gifshowupgrade/</url>
    <content><![CDATA[<p>由于前两年的大量需求开发导致我们核心业务中功能堆积非常严重，同时也衍生出了很多性能相关的问题，近期开始着手安排现有功能的优化，而优化的第一步先从图片展示开始。</p>
<h3 id="发现问题"><a href="#发现问题" class="headerlink" title="发现问题"></a>发现问题</h3><p>我们APP中的某个页面是支持展示动态背景，即gif图片的展示，而且因为图片中包含用户希望展示的某些信息，因此产品要求图片的质量必须要求非常高，因此我们不能将图片过度压缩。</p>
<p>鉴于我们的图片资源全部都存放在阿里云中，阿里云也支持图片的缩放和裁剪功能，因此首先对于图片的缩放我们是直接使用了阿里云自带动态拼接图片地址参数的方式实现，根据图片展示时的大小动态配置图片地址。</p>
<p>举个🌰：</p>
<p>我们有一张全屏展示的图片，那么在iPhone X上他展示的图片地址为：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">http:<span class="hljs-comment">//res.xxx.com.cn/a6a5526e-c226-4e83-b53a-93f1c0cb6141.gif?t=1606124930287&amp;x-oss-process=image/resize,m_mfit,w_1125,h_2436</span><br></code></pre></td></tr></table></figure>

<p>我们可以看到图片地址后面是拼接了我们根据屏幕获取到的宽高然后乘屏幕的系数(1x,2x,3x)。</p>
<p>项目中目前使用的图片展示和下载库为SDWebImage,以上面的图为例，展示过程中CPU和内存占用如下图(未加载图片前内存占用8.4M)：</p>
<table>
<thead>
<tr>
<th></th>
<th>内存</th>
<th>CPU</th>
</tr>
</thead>
<tbody><tr>
<td>FLAnimatedImageView</td>
<td>13.1M</td>
<td>8%</td>
</tr>
</tbody></table>
<p>对于这张图片的信息：</p>
<table>
<thead>
<tr>
<th>大小</th>
<th>尺寸</th>
</tr>
</thead>
<tbody><tr>
<td>1.1M</td>
<td>404x702</td>
</tr>
</tbody></table>
<p>当然在优化过程中由于设计部门提出iOS端在动画展示过程中卡顿的问题，我们升级了SDWebImage至最新版本，我们惊喜的发现动图展示不卡了，但是内存消耗确非常感人。</p>
<table>
<thead>
<tr>
<th></th>
<th>内存</th>
<th>CPU</th>
</tr>
</thead>
<tbody><tr>
<td>SDAnimatedImageView</td>
<td>36.7M</td>
<td>0%</td>
</tr>
</tbody></table>
<p>通过对比我们发现，升级后的SD,Gif图片展示不再卡顿的原因是将图片放到了缓存中，因此CPU利用率也降低了，但是内存(32.3M)接近之前版本(4.7M)的7倍。</p>
<p>因此，这篇文章主要也是针对这个问题，看下市面上几个常用的图片加载库，在展示图片过程中的性能比较。</p>
<h3 id="性能对比"><a href="#性能对比" class="headerlink" title="性能对比"></a>性能对比</h3><p>在iOS开发中我们常用的图片展示库主要有：YYWebImage/SDWebImage/FLAnimateImage</p>
<p>那么我们通过展示同一张动图和静图来对比下这三个三方的性能：</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gn75c238aqj30k40c4mxk.jpg"></p>
<p>接着我们在来看下静态图的性能对比(都是使用UIImageView展示)：</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gn75pihwbwj30k40c4mxi.jpg"></p>
<h3 id="计数选型"><a href="#计数选型" class="headerlink" title="计数选型"></a>计数选型</h3>]]></content>
  </entry>
  <entry>
    <title>为什么要存在MetaClass</title>
    <url>/2018/05/02/why-metaclass/</url>
    <content><![CDATA[<p>最近去外面面试了一次,有一个问题觉得很有意思:OC中为什么要存在metaClass,在类的结构上这么设计的原因是什么？metaClass中都有什么？有什么优点？</p>
<p>这篇文章我们就来讨论一下上面的这几个问题！</p>
<a id="more"></a>

<h2 id="了解-MetaClass"><a href="#了解-MetaClass" class="headerlink" title="了解 MetaClass"></a>了解 MetaClass</h2><h3 id="MetaClass结构"><a href="#MetaClass结构" class="headerlink" title="MetaClass结构"></a>MetaClass结构</h3><p>下面我们先来看看这个类的结构:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">struct</span> objc_class &#123;<br>    Class isa  OBJC_ISA_AVAILABILITY;<br>    <span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> !__OBJC2__</span><br>    Class super_class   OBJC2_UNAVAILABLE;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name    OBJC2_UNAVAILABLE;<br>    <span class="hljs-keyword">long</span> version        OBJC2_UNAVAILABLE;<br>    <span class="hljs-keyword">long</span> info           OBJC2_UNAVAILABLE;<br>    <span class="hljs-keyword">long</span> instance_size  OBJC2_UNAVAILABLE;<br>    <span class="hljs-keyword">struct</span> objc_ivar_list *ivars    OBJC2_UNAVAILABLE;<br>    <span class="hljs-keyword">struct</span> objc_method_list **methodLists   OBJC2_UNAVAILABLE;<br>    <span class="hljs-keyword">struct</span> objc_cache *cache                OBJC2_UNAVAILABLE;<br>    <span class="hljs-keyword">struct</span> objc_protocol_list *protocols    OBJC2_UNAVAILABLE;<br>    <span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>&#125; OBJC2_UNAVAILABLE;<br></code></pre></td></tr></table></figure>

<p>metaClass 也是objc_class 因此结构大概也是这样的！,不过就目前所知到的<code>metaClass</code>是用来存放类方法的！ 因为OC中没有类属性因此 objc_ivar_list 为空！</p>
<h3 id="MetaClass的创建"><a href="#MetaClass的创建" class="headerlink" title="MetaClass的创建"></a>MetaClass的创建</h3><p>首先了解一点,在OC中每一个类都有一个对应的MetaClass！ 因此 我们在创建一个类的时候,就会一起创建这个类的元类。</p>
<p>因此,我们可以看一下当我们动态创建一个类的时候 运行时实际上都做了什么！</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">Class objc_allocateClassPair(Class superclass, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name, <br>                             size_t extraBytes)<br>&#123;<br>    Class cls, meta;<br><br>    rwlock_writer_t lock(runtimeLock);<br><br>    <span class="hljs-comment">// Fail if the class name is in use.</span><br>    <span class="hljs-comment">// Fail if the superclass isn&#x27;t kosher.</span><br>    <span class="hljs-keyword">if</span> (getClass(name)  ||  !verifySuperclass(superclass, <span class="hljs-literal">true</span><span class="hljs-comment">/*rootOK*/</span>)) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// Allocate new classes.</span><br>    cls  = alloc_class_for_subclass(superclass, extraBytes);<br>    meta = alloc_class_for_subclass(superclass, extraBytes);<br><br>    <span class="hljs-comment">// fixme mangle the name if it looks swift-y?</span><br>    objc_initializeClassPair_internal(superclass, name, cls, meta);<br><br>    <span class="hljs-keyword">return</span> cls;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>从上面的代码中我们可以很明显的看出:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">cls  = alloc_class_for_subclass(superclass, extraBytes);<br>meta = alloc_class_for_subclass(superclass, extraBytes);<br></code></pre></td></tr></table></figure>
<p><code>cls</code>和<code>meta</code>的创建方法和参数完全一致！</p>
<h3 id="怎么获取一个类的MetaClass"><a href="#怎么获取一个类的MetaClass" class="headerlink" title="怎么获取一个类的MetaClass"></a>怎么获取一个类的MetaClass</h3><p><code>objc_getMetaClass(const char * _Nonnull name)</code></p>
<p>我们来看一下这个方法的实现</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">Class objc_getMetaClass(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *aClassName)<br>&#123;<br>    Class cls;<br><br>    <span class="hljs-keyword">if</span> (!aClassName) <span class="hljs-keyword">return</span> Nil;<br><br>    cls = objc_getClass (aClassName);<br>    <span class="hljs-keyword">if</span> (!cls)<br>    &#123;<br>        _objc_inform (<span class="hljs-string">&quot;class `%s&#x27; not linked into application&quot;</span>, aClassName);<br>        <span class="hljs-keyword">return</span> Nil;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> cls-&gt;ISA();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>先是使用<code>objc_getClass</code>获取类名对应的类 然后直接利用<code>cls-&gt;ISA()</code>获取这个类对应的元类</p>
<h3 id="判断一个类是否为元类"><a href="#判断一个类是否为元类" class="headerlink" title="判断一个类是否为元类"></a>判断一个类是否为元类</h3><p><code>bool class_isMetaClass(Class _Nullable cls)</code></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><br><span class="hljs-built_in">BOOL</span> class_isMetaClass(Class cls)<br>&#123;<br>    <span class="hljs-keyword">if</span> (!cls) <span class="hljs-keyword">return</span> <span class="hljs-literal">NO</span>;<br>    <span class="hljs-keyword">return</span> cls-&gt;isMetaClass();<br>&#125;<br><br><span class="hljs-keyword">bool</span> isMetaClass() &#123;<br>   assert(<span class="hljs-keyword">this</span>);<br>   assert(isRealized());<br>   <span class="hljs-keyword">return</span> data()-&gt;ro-&gt;flags &amp; RO_META;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>从上面的代码我们可以看出 判断是否为元类的条件是 <code>data()-&gt;ro-&gt;flags &amp; RO_META</code>。那么这个类的flags是什么时候设置的呢？</p>
<p>找了好久,我们在<code>objc_initializeClassPair_internal</code>方法中找到了下面这段代码</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">cls_ro_w-&gt;flags = <span class="hljs-number">0</span>;<br>meta_ro_w-&gt;flags = RO_META;<br><span class="hljs-keyword">if</span> (!superclass) &#123;<br>   cls_ro_w-&gt;flags |= RO_ROOT;<br>   meta_ro_w-&gt;flags |= RO_ROOT;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>那么这个方法什么时候被调用呢? 追踪了一下我们发现 是在<code>objc_initializeClassPair_internal</code>这个方法中被调用的！ 这个方法是不是很熟悉呢！ 他就是<code>objc_allocateClassPair</code>中的最后一句代码。</p>
<h2 id="MetaClass-存在的意义是什么呢？"><a href="#MetaClass-存在的意义是什么呢？" class="headerlink" title="MetaClass 存在的意义是什么呢？"></a>MetaClass 存在的意义是什么呢？</h2><p>实际上如果没有元类的存在,而是在class中增加一个classmethodlist用来存放这个类的类方法,也是可以达到我们想要实现的目的。</p>
<p>那么MetaClass存在的意义到底是什么呢？</p>
<p>为了更好的了解MetaClass存在的原因,我们先看一下他的作用:</p>
<p>先看一下下面这张图片:</p>
<p><img src="https://upload-images.jianshu.io/upload_images/967869-f15ff2bc1baf88d2.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt="metaclass"></p>
<h4 id="一切皆对象的思想"><a href="#一切皆对象的思想" class="headerlink" title="一切皆对象的思想"></a>一切皆对象的思想</h4><p>我们都知道对象里有一个isa指针</p>
<p><code>ISA指针 实际上就是 is a 的缩写。表示这个对象是一个什么</code></p>
<p>从上面的图上我们也可以看出最顶层的RootMetaClass的isa指向知己superClass指向RootClass,这就形成了一个闭环。</p>
<p>加入 我们将元类去掉,那么我们类的ISA指针应该指向什么呢？如果没办法指向一个RootMetaClass那表明这个类是一个什么类型的对象呢？</p>
<p>当然这个是根据结论反推原因,是不太合逻辑的,但是 更容易被我们理解。</p>
<h4 id="从Smalltalk重新认识面向对象"><a href="#从Smalltalk重新认识面向对象" class="headerlink" title="从Smalltalk重新认识面向对象"></a>从Smalltalk重新认识面向对象</h4><p>以前谈到面向对象，总会提到，面向对象三特征：封装、继承、多态。但其实，面向对象中也分流派，如C++这种来自Simula的设计思想的，更注重的是类的划分，因为方法调用是静态的。而如Objective-C这种借鉴Smalltalk的，更注重的是消息传递，是动态响应消息。</p>
<p>而面向对象三种特征，更基于的是类的划分而提出的。</p>
<p>这两种思想最大的不同，我认为是自上而下和自下而上的思考方式。</p>
<ul>
<li>类的划分，要求类的设计者是以一个很高的层次去设计这个类，提取出类的特性和本质，进行类的构建。<code>知道类型才可以去发送消息给对象</code>。</li>
<li>消息传递，要求的是类的设计者以消息为起点去构建类，也就是对外界的变化进行响应，而不关心自身的类型，设计接口。尝试理解消息，无法处理则进行特殊处理。</li>
</ul>
<p>消息传递对于面向对象的设计，其实在于给出一种对消息的解决方案。而面向对象优点之一的复用，在这种设计里，更多在于复用解决方案，而不是单纯的类本身。这种思想就如设计组件一般，关心接口，关心组合而非类本身。其实之所以有MetaClass这种设计，我的理解并不是先有MetaClass，而是在万物都是对象的Smalltalk里，向对象发送消息的基本解决方案是统一的，希望复用的。而实例和类之间用的这一套通过isa指针指向的Class单例中存储方法列表和查询方法的解决方案的流程，是应该在类上复用的，而MetaClass就顺理成章出现罢了。</p>
<p>上面这部分是摘自:<a href="https://www.jianshu.com/p/ea7c42e16da8">Why is MetaClass in Objective-C</a></p>
<h3 id="维基百科的解释"><a href="#维基百科的解释" class="headerlink" title="维基百科的解释"></a>维基百科的解释</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br>Metaclasses in Objective-C are almost the same as those in Smalltalk-80—not surprising since Objective-C borrows a lot from Smalltalk. Like Smalltalk, in Objective-C, the instance variables and methods are defined by an object&#39;s class. A class is an object, hence it is an instance of a metaclass.(OC中的Metaclasses 基本上和Smalltalk-80相同,鉴于OC从Smalltalk中借鉴了很多因此这并不令人干到奇怪。类似Smalltalk 在OC中实例的变量和方法被定义在对象的类中,class也是一个对象,于是class是mataclass的一个实例。)<br><br>Like Smalltalk, in Objective-C, class methods are simply methods called on the class object, hence a class&#39;s class methods must be defined as instance methods in its metaclass. Because different classes can have different sets of class methods, each class must have its own separate metaclass. Classes and metaclasses are always created as a pair: the runtime has functions objc_allocateClassPair() and objc_registerClassPair() to create and register class-metaclass pairs, respectively.(类似Smalltalk,在OC中类方法通过类对象调用,于是一个类的类方法必须在metaclass中以实例方法的形式定义。因为不同的类可以后不同的类方法集合，每一个类必须有自己独立的metaClass。Class和class-metaClass一起被创建和注册)<br><br>There are no names for the metaclasses; however, a pointer to any class object can be referred to with the generic type Class (similar to the type id being used for a pointer to any object). (metaClass没有名字,然而,指向任何类对象的指针可以用泛型类型引用)（类似id可以指向所有的对象）<br><br>Because class methods are inherited through inheritance, like Smalltalk, metaclasses must follow an inheritance scheme paralleling that of classes (e.g. if class A&#39;s parent class is class B, then A&#39;s metaclass&#39;s parent class is B&#39;s metaclass), except that of the root class.(因为,类方法通过继承获取,类似Smalltalk,元类必须遵循与类类似的继承方案<br><br>Unlike Smalltalk, the metaclass of the root class inherits from the root class (usually NSObject using the Cocoa framework) itself. This ensures that all class objects are ultimately instances of the root class, so that you can use the instance methods of the root class, usually useful utility methods for objects, on class objects themselves.(与Smalltalk不同,根类的metaclass继承自根类本身,这就确保了所有的类对象都是根类的对象。以便您可以使用根类的实例方法，通常是对象的有用实用工具方法，以及类对象本身。)<br><br>Since metaclass objects do not behave differently (you cannot add class methods for a metaclass, so metaclass objects all have the same methods), they are all instances of the same class—the metaclass of the root class (unlike Smalltalk). Thus, the metaclass of the root class is an instance of itself. The reason for this is that all metaclasses inherit from root class; hence, they must inherit the class methods of the root class.<br>(由于元类对象行为不同(你不能为元类添加类方法，所以元类对象都有相同的方法),它们都是同一类的实例 - 根类的元类（与Smalltalk不同）因此，根类的元类是它自己的一个实例。原因是所有元类都继承自根类;因此，他们必须继承根类的类方法。)<br></code></pre></td></tr></table></figure>

<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>回到一开始那个问题，为什么要设计MetaClass，去掉把类方法放到类里面行不行？</p>
<p>我的理解是，可以，但不Smalltalk。这样的设计是C++那种自上而下的设计方式，类方法也是类的一种特征描述。而Smalltalk的精髓正在于消息传递，复用消息传递才是根本目的，而MetaClass只不过是因此需要的一个工具罢了。</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://www.jianshu.com/p/ea7c42e16da8">Why is MetaClass in Objective-C</a><br><a href="https://blog.csdn.net/myan/article/details/5928531">function/bind的救赎（上）</a></p>
]]></content>
      <categories>
        <category>iOS优化</category>
      </categories>
      <tags>
        <tag>metaClass</tag>
      </tags>
  </entry>
  <entry>
    <title>0xdead10cc问题调研</title>
    <url>/2021/09/12/0xdead10cc-fix/</url>
    <content><![CDATA[<p>近期我们新做了一个需求，其中一个实现是需要在启动和使用这个功能时，从网络获取大量数据，然后将数据保存到数据库中。后续操作我们均从数据库获取。但是该需求上线后，Xcode中反馈了很多<code>0xdead10cc</code>问题。因此本篇文章主要是介绍对<code>0xdead10cc</code>的了解。</p>
<a id="more"></a>

<h3 id="确定原因"><a href="#确定原因" class="headerlink" title="确定原因"></a>确定原因</h3><p>首先先放出一张Xcode中Crash的堆栈信息<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gu9ehbwjmyj61fy0bogoo02.jpg" alt="crash"><br>我们看到Crash信息中我们可以明确地看到Crash的原因：<br><code>Termination Reason: Namespace RUNNINGBOARD, Code 0xdead10cc</code>。<br>我们先来看下这到底是一个什么错误。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&gt; The exception code<br><br>0xdead10cc (pronounced “dead lock”). The operating system terminated the app <br>because it held on to a file lock or SQLite database lock during suspension. <br>Request additional background execution time on the main thread with <br>beginBackgroundTask(withName:expirationHandler:). Make this request well before <br>starting to write to the file in order to complete those operations and <br>relinquish the lock before the app suspends. In an app extension, <br>use beginActivity(options:reason:) to mange this work.<br></code></pre></td></tr></table></figure>
<p>通过上面的描述我们可以知道，0xdead10cc这个错误出现的原因是：<code>在App被挂起期间，操作系统发现App依然持有一个文件锁或者数据库锁</code></p>
<p>而从堆栈信息中，我们可以看到在崩溃前的确是在执行数据库相关操作，那么这个Crash崩溃的原因应该是在挂起期间依然持有了数据库锁(进行数据库操作)</p>
<h3 id="知识储备"><a href="#知识储备" class="headerlink" title="知识储备"></a>知识储备</h3><p>首先我们应该明白什么是suspension状态，下面是官网截图</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gudji193ocj60nr0pbjsp02.jpg" alt="应用状态分析"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">The following figure shows the state transitions for scenes. When the user or <br>system requests a new scene for your app, UIKit creates it and puts it in the <br>unattached state. User-requested scenes move quickly to the foreground, where they <br>appear onscreen. A system-requested scene typically moves to the background so<br> that it can process an event. For example, the system might launch the scene in <br> the background to process a location event. When the user dismisses your app&#39;s <br> UI, UIKit moves the associated scene to the background state and eventually to <br> the suspended state. UIKit can disconnect a background or suspended scene at any <br> time to reclaim its resources, returning that scene to the unattached state.<br><br></code></pre></td></tr></table></figure>
<p>我们只需要重点看下这句话即可：<br><code>When the user your app&#39;s UI, UIKit moves the associated scene to the background state and eventually to the suspended state. </code> </p>
<p>当用户离开了你的APP，UIKit就会将相关的场景切换到后台状态，最终进入到挂起状态<br>对于当应用即进入后台时应该进行什么操作，苹果官方也给我们提供了详细的描述: <a href="https://developer.apple.com/documentation/uikit/app_and_environment/scenes/preparing_your_ui_to_run_in_the_background">Preparing Your UI to Run in the Background</a></p>
<p>我们都知道在我们进入后台时，App的代码是可以继续执行的，但是挂起态明显不可以，那么从后台状态到挂起态，我们有多久的时间可以继续执行任务呢？</p>
<p>这一点官方文档并没有明确的解释，只是提示我们要<code>As Soon As Possible</code>,因此对于没有申请后台执行时间的APP来说，我们最好尽可能快的在APP进入后台时取消可能会继续持有的资源。当然如果APP需要可以申请额外的后台运行时间，但是时间也是有限的。</p>
<p>这里也找到了<a href="https://abhimuralidharan.medium.com/finite-length-tasks-in-background-ios-swift-60f2db4fa01b">Finite-Length Tasks in background iOS swift</a>供大家参考。</p>
<p>那么系统是否有提供通知，我们可以动态监听应用进入了挂起态呢？<br>在了解挂起态后，我们应该可以猜得到系统并不会给我们提供这个通知，因为在这个阶段App是不允许执行任何操作的，因此即使系统为开发者提供了这个通知，App也是无法监听并执行相应操作的。</p>
<p>这里找到了<a href="http://www.codingexplorer.com/execution-states-swift-ios-app/">Execution States for a Swift iOS App</a>这篇文章，其中介绍了<code>Not Running</code>、<code>Suspended</code>、<code>Background</code>、<code>Inactive</code>、<code>Inactive</code> 这几种状态有兴趣的可以了解下。</p>
<h3 id="场景分析"><a href="#场景分析" class="headerlink" title="场景分析"></a>场景分析</h3><p>经过上面的介绍，我们已经有了这方面的只是储备，那么在回到我们的crash上。下面是我对这次崩溃场景的猜测：<code>App进入启动后，进入我们从接口获取数据保存到数据库的操作，对于数据较多的用户这里可能会持续时间较久，在这个过程中用户进入了后台，接口获取和保存数据库操作持续进行中，在某个接口请求完成后刚好到达临界时间，系统即将把App置为挂起状态。此时接口完成后的数据库操作，刚好导致了App持有数据库锁，因此系统将App强杀，并Report了上面的Crash</code></p>
<h3 id="系统为何要这么做"><a href="#系统为何要这么做" class="headerlink" title="系统为何要这么做"></a>系统为何要这么做</h3><p>因为我们的sqlite db是App Group共用(包括Extension)且文件是位于shared container，这就意味着文件会同时被App和Extension访问，假设App写操作在执行中途被suspend暂停，Extension唤醒后也对同一个App执行写操作，那么当App被重新唤醒继续之前的写操作时，写操作和db文件就会处于一个不可预知的状态，有可能造成写操作失败或者db文件损坏，所以系统选择了强杀App</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>了解了问题出现的场景，我们就比较好去模拟场景，但是App从后台状态进入挂起态的时间是不确定的，因此在模拟该状态时时间点是无法确认的，因此尝试了多次后仍无法复现。</p>
<p>因此对于这个问题，我们只能从业务的角度，当App进入后台时我们将对应的数据库操作暂停，当应用再次回到前台时，通过判断之前是否有因进入后台而暂停的数据库操作，如果有，那么我们重新进行该次的接口+数据库写操作。</p>
<p>不过这样做副作用也很明显：在App进入后台之后，我们无法继续进行接口和网络请求了！这对于一些要求数据完全获取才可以展示的页面是十分不友好的。</p>
<h3 id="期望"><a href="#期望" class="headerlink" title="期望"></a>期望</h3><p>大家如果有什么比较好的复现这类问题的方法，可以留言提供感激不尽，如果有比价好的解决方案就更好了😄</p>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://stackoverflow.com/questions/24244875/how-can-i-tell-if-my-app-has-suspended">How can I tell if my app has suspended?</a></p>
<p><a href="https://developer.apple.com/documentation/uikit/app_and_environment/scenes/preparing_your_ui_to_run_in_the_background/about_the_background_execution_sequence">About the Background Execution Sequence</a></p>
<p><a href="https://stackoverflow.com/questions/40630504/springboard-crashing-when-adding-a-lot-of-triggers-to-unusernotificationcenter">Springboard crashing when adding a lot of triggers to UNUserNotificationCenter</a></p>
<p><a href="https://mp.weixin.qq.com/s/8yOhyTDzFjFlqj_3tol-GQ">iOS App 后台 Crash 调查</a></p>
<p><a href="https://blog.iconfactory.com/2019/08/the-curious-case-of-the-core-data-crash/">The Curious Case of the Core Data Crash</a></p>
<p><a href="https://developer.apple.com/forums/thread/126438">0xdead10cc prevention</a></p>
<p><a href="https://developer.apple.com/documentation/xcode/understanding-the-exception-types-in-a-crash-report">Understanding the Exception Types in a Crash Report</a></p>
]]></content>
      <tags>
        <tag>deadlock、后台crash</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS文本导出为Docx文件</title>
    <url>/2022/09/11/iOS-how-to-create-Docx/</url>
    <content><![CDATA[<p>近期的需求中有一项任务是将用户输入的文字和图片写入Word文件并支持导出，对于苹果和微软的爱恨情仇很早就知道，iOS文本写入Word难度可想而知，所以在接到这个需求的第一时间，我就明确要求这个需求要先调研，然后再开始。所以这篇文章也算是对我调研结果的一个总结。</p>
<a id="more"></a>

<h2 id="技术方案"><a href="#技术方案" class="headerlink" title="技术方案"></a>技术方案</h2><p>之前知识做过将文字写到txt文件中，因为txt文件是纯文本且不包含文本格式，所以非常简单因此我最先想到的就是尝试直接将文本写到Word文件中，如果这个方案不行，那就只能通过其他方式转了，例如html。经过一番谷歌搜索，基本确定了下面几个方向</p>
<ul>
<li>文本直接写入Word文件</li>
<li>将文本写入html模板中 在写入Word文件</li>
<li>其他库实现</li>
</ul>
<p>下面我们根据上面的几个方向一次来看这几种方式的实现</p>
<h2 id="方案验证"><a href="#方案验证" class="headerlink" title="方案验证"></a>方案验证</h2><h3 id="文本直接写入Excel"><a href="#文本直接写入Excel" class="headerlink" title="文本直接写入Excel"></a>文本直接写入Excel</h3><p>方法很简单，我们直接看代码</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">writeToWordFile</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 首先尝试直接文档</span><br>    <span class="hljs-keyword">let</span> text = <span class="hljs-string">&quot;下面我们直接将这段文字写入到Word文档中，然后通过手机端和Mac端查看是否可以打开这个docx文件&quot;</span><br>    <span class="hljs-keyword">let</span> path = <span class="hljs-type">NSHomeDirectory</span>().appending(<span class="hljs-string">&quot;/Documents&quot;</span>)<br>    <span class="hljs-keyword">let</span> filePath = path.appending(<span class="hljs-string">&quot;/1.docx&quot;</span>)<br>    <span class="hljs-keyword">try</span>? text.write(toFile: filePath, atomically: <span class="hljs-literal">true</span>, encoding: .utf8)<br>&#125;<br></code></pre></td></tr></table></figure>

<p>通过沙盒路径我们找到了我们新写的这个文件</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h61cxsh61xj20qs0jct9f.jpg" alt="沙盒文件"></p>
<p>当我们使用Mac的office组件打开时提示</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h61czu49qaj20nu09kmxk.jpg" alt="打开Word文件"><br>因此这种方式应该是不行的。</p>
<p><em>但是</em>，我这里是直接将文字写成docx文件，那如果我在项目里放一个模型，然后往模型文件里写呢？<br>我先找一个空的Word文件，将其放到项目中，然后将这个文件拷贝到沙盒中然后再写入内容到这个文件中<br><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h61d33nz8qj20qg0i2gmm.jpg" alt="模板文件"></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">writeToWord</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 现将示例文件拷贝到沙盒位置 有问题 无法打开对应文件</span><br>    <span class="hljs-keyword">let</span> text = <span class="hljs-string">&quot;下面我们直接将这段文字写入到Word文档中，然后通过手机端和Mac端查看是否可以打开这个docx文件&quot;</span><br>    <span class="hljs-keyword">let</span> examplePath = <span class="hljs-type">Bundle</span>.main.path(forResource: <span class="hljs-string">&quot;example.docx&quot;</span>, ofType: <span class="hljs-literal">nil</span>)<br>    <span class="hljs-keyword">let</span> destinationPath = <span class="hljs-type">NSHomeDirectory</span>().appending(<span class="hljs-string">&quot;/Documents&quot;</span>).appending(<span class="hljs-string">&quot;/2.docx&quot;</span>)<br>    <span class="hljs-keyword">try</span>? <span class="hljs-type">FileManager</span>.<span class="hljs-keyword">default</span>.copyItem(atPath: examplePath!, toPath: destinationPath)<br>    <span class="hljs-keyword">let</span> data = text.data(using: .utf8)<br>    <span class="hljs-keyword">try</span>? data?.write(to: <span class="hljs-type">URL</span>(fileURLWithPath: destinationPath), options: .atomic)<br>&#125;<br></code></pre></td></tr></table></figure>
<p>我们发现实际结果与前面的方式是相同的。我们都无法打开对应文件，而且这里<code>writetofile</code>应该是重新生成的文件，因为模板文件大小为<code>12KB</code>,但是写操作完成时文件变成了<code>173字节</code>。</p>
<p>没关系，我们还有另外一种方式就是通过数据流的形式写入到已存在的文件中，这里要用到的是<code>FileHandle</code>:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">fileHandlerWrite</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">let</span> text = <span class="hljs-string">&quot;若为购买过其它非intro offer（连续月、单年、单月）后降级的用户，\n则两次弹窗均给出连续包年intro offer（和现有收银台一致）的sku&quot;</span><br>    <span class="hljs-keyword">let</span> examplePath = <span class="hljs-type">Bundle</span>.main.path(forResource: <span class="hljs-string">&quot;example.docx&quot;</span>, ofType: <span class="hljs-literal">nil</span>)<br>    <span class="hljs-keyword">let</span> destinationPath = <span class="hljs-type">NSHomeDirectory</span>().appending(<span class="hljs-string">&quot;/Documents&quot;</span>).appending(<span class="hljs-string">&quot;/3.docx&quot;</span>)<br>    <span class="hljs-keyword">try</span>? <span class="hljs-type">FileManager</span>.<span class="hljs-keyword">default</span>.copyItem(atPath: examplePath!, toPath: destinationPath)<br>    <span class="hljs-keyword">let</span> fileHandle = <span class="hljs-type">FileHandle</span>(forWritingAtPath: destinationPath)!<br>    fileHandle.seekToEndOfFile()<br>    fileHandle.write(text.data(using: .utf8)!)<br>    <span class="hljs-keyword">try</span>? fileHandle.close()<br>&#125;<br></code></pre></td></tr></table></figure>
<p>但是结果一样，仍然无法打开文件，因此这了可以认为此方法行不通:broken_heart: 。如果大家有更好的方式也可以评论指出。</p>
<p>不过，当我尝试将文件后缀改为doc时，我发现打开文件时会提示<br><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h61dep5l6lj20yk0u0di6.jpg" alt="doc文件打开提示"><br>当我选择其他编码，并选择有边框中的<code>UTF-8</code>时，我是可以打开文件的。但是目前绝大多数都是使用docx，因此这里也不深入的去讨论doc和docx的区别了。</p>
<h3 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h3><p>既然直接写入文件的方式不行，那么我们必须借助其他手段来实现我们的目的，首先想到的是html,同时我们在网上也搜到了部分方法</p>
<p>我们先来看下效果再去分析实现，</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">writeHtmlFile</span><span class="hljs-params">()</span></span> &#123;<br>     <span class="hljs-keyword">let</span> text = <span class="hljs-string">&quot;&lt;html xmlns:o=&#x27;urn:schemas-microsoft-com:office:office&#x27; xmlns:w=&#x27;urn:schemas-microsoft-com:office:word&#x27; xmlns=&#x27;http://www.w3.org/TR/REC-html40&#x27;&gt; 既然直接写入文件的方式不行，那么我们必须借助其他手段来实现我们的目的，首先想到的是html&lt;/html&gt;&quot;</span><br>     <span class="hljs-keyword">let</span> path = <span class="hljs-type">NSHomeDirectory</span>().appending(<span class="hljs-string">&quot;/Documents&quot;</span>)<br>     <span class="hljs-keyword">let</span> filePath = path.appending(<span class="hljs-string">&quot;/1.doc&quot;</span>)<br>     <span class="hljs-keyword">try</span>? text.write(toFile: filePath, atomically: <span class="hljs-literal">true</span>, encoding: .utf8)<br> &#125;<br></code></pre></td></tr></table></figure>
<p>上面代码中html格式为</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">xmlns:o</span>=<span class="hljs-string">&#x27;urn:schemas-microsoft-com:office:office&#x27;</span> <span class="hljs-attr">xmlns:w</span>=<span class="hljs-string">&#x27;urn:schemas-microsoft-com:office:word&#x27;</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&#x27;http://www.w3.org/TR/REC-html40&#x27;</span>&gt;</span><br>    // 文件内容<br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>我们通过将上面这段包含html标签和格式的文本写入到一个<code>doc文件</code>中,就可以生成一个Word文档，我们打开这个docx文档看下<br><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h61nqozpihj20wk0u0tag.jpg" alt="html简单doc文件"></p>
<p>通过上面的方法，我们验证了可以通过html的方式去写Word文件的思路，既然文本都可以写那么图片呢, 我们知道在写html的时候我们嵌入图片一般都是通过图片路径的方式嵌入到html文件中，但是我们如果是通过改后缀的方式生成Word文件，这就要求我们必须只有一个文件，因此我这里尝试使用直接嵌入图片的base64数据实现</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">xmlns:o</span>=<span class="hljs-string">&#x27;urn:schemas-microsoft-com:office:office&#x27;</span> <span class="hljs-attr">xmlns:w</span>=<span class="hljs-string">&#x27;urn:schemas-microsoft-com:office:word&#x27;</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&#x27;http://www.w3.org/TR/REC-html40&#x27;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Title level 1<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;data:image/jpeg;base64,xxxxx&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br><br></code></pre></td></tr></table></figure>
<p><a href="https://tool.chinaz.com/tools/imgtobase">本地图片生成base64 传送门</a></p>
<p>我们在打开我们生成的<code>doc</code>文件，可以看到图片已经被展示到正确的位置了</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h61o8zzy12j20wk0u0mz2.jpg" alt="带图片的doc文件"></p>
<p><code>格局打开</code>,既然我们都用了html 那么是否html中的其他标签我们都可以使用呢？下面我来来搞一个复杂的例子试试</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">xmlns:o</span>=<span class="hljs-string">&#x27;urn:schemas-microsoft-com:office:office&#x27;</span> <span class="hljs-attr">xmlns:w</span>=<span class="hljs-string">&#x27;urn:schemas-microsoft-com:office:word&#x27;</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&#x27;http://www.w3.org/TR/REC-html40&#x27;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Title level 1<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Title level 1<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>Title level 2<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>Title level 3<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Text in level 3<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>2nd title level 2<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>Another level 3 title<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br> <br>List:<br><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>element 1<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>element 2<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>element 3<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>element 4<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>element 5<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>element 6<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>element 7<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>element 8<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>element 9<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>element 10<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br> <br><span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;100%&quot;</span>,<span class="hljs-attr">border</span>=<span class="hljs-string">&quot;1&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">thead</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;background-color:#A0A0FF;&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">nowrap</span>&gt;</span>Column A<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">nowrap</span>&gt;</span>Column B<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">nowrap</span>&gt;</span>Column C<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">thead</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>A1<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>B1<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>C1<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>A2<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>B2<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>C2<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>A3<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>B3<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>C3<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;data:image/jpeg;xxx&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br><br></code></pre></td></tr></table></figure>
<p>这时候我们在打开对应Word文件 可以发现,html的这些标签都可以支持<br><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h61ojh7xibj20wk0u0q5e.jpg" alt="支持html标签的Word"></p>
<p>那么我们是找到了完美的方案了吗？ <strong>不不不</strong>，如果你仔细看上面的内容你会发现，上面html保存的时候我都保存成了doc文件，而对于最新的docx类型呢？</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h61om1ke9tj20nu09kaah.jpg" alt="无法打开"></p>
<p>:sob: :sob: :sob: :sob: </p>
<p>别放弃，我们继续看其他方法</p>
<h3 id="直接编辑Word内容"><a href="#直接编辑Word内容" class="headerlink" title="直接编辑Word内容"></a>直接编辑Word内容</h3><p>这里的实现主要是参考了 stackoverflow中的这个<a href="https://stackoverflow.com/questions/38751495/create-a-word-document-swift">问题</a>,回答问题的大佬给出了这段解释，Word文件包含了复杂的文件格式，具体可以通过将一个Word文档修改后缀为zip，然后解压查看</p>
<blockquote>
<p>Unfortunately, it is nearly impossible to create a .docx file in Swift, given how complicated they are (you can see for yourself by changing the file extension on any old .docx file to .zip, which will reveal their inner structure). The next best thing is to simply create a .txt file, which can also be opened into Pages (though sadly not Docs). If you’re looking for a more polished format, complete with formatting and possibly even images, you could choose to create a .pdf file.</p>
</blockquote>
<p>我们随便将一个docx，修改后缀后，解压可以看到下面的文件结构:<br><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h61n0dafkcj20p209w3z4.jpg" alt="Word文件结果"></p>
<p>通过查找文件夹中文件的内容我们发现，我们实际写入的文本内容在<code>word/document.xml</code>文件中，如下图<br><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h62evxaacuj21yc0u0kcz.jpg" alt="xml文件内容"></p>
<p>那我们只要能够将我们想写入的内容添加到这个文件中就可以完美实现了，废话不多说直接试一下</p>
<p>我们先新建一个docx文档(包含图片) 如下图<br><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h62gp0839yj20wo0u00w9.jpg" alt="docx文档"><br>我们打开<code>word/document.xml</code>发现文字实际已经直接写在了文件中</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">w:p</span> <span class="hljs-attr">w:rsidR</span>=<span class="hljs-string">&quot;00EB53D0&quot;</span> <span class="hljs-attr">w:rsidRDefault</span>=<span class="hljs-string">&quot;00D6373D&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">w:r</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">w:rPr</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">w:rFonts</span> <span class="hljs-attr">w:hint</span>=<span class="hljs-string">&quot;eastAsia&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">w:rPr</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">w:t</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">w:t</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">w:r</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">w:r</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">w:t</span>&gt;</span>234567<span class="hljs-tag">&lt;/<span class="hljs-name">w:t</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">w:r</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">w:p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">w:p</span> <span class="hljs-attr">w:rsidR</span>=<span class="hljs-string">&quot;00D6373D&quot;</span> <span class="hljs-attr">w:rsidRDefault</span>=<span class="hljs-string">&quot;00D6373D&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">w:pPr</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">w:rPr</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">w:b</span>/&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">w:sz</span> <span class="hljs-attr">w:val</span>=<span class="hljs-string">&quot;32&quot;</span>/&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">w:szCs</span> <span class="hljs-attr">w:val</span>=<span class="hljs-string">&quot;32&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">w:rPr</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">w:pPr</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">w:r</span> <span class="hljs-attr">w:rsidRPr</span>=<span class="hljs-string">&quot;00D6373D&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">w:rPr</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">w:rFonts</span> <span class="hljs-attr">w:hint</span>=<span class="hljs-string">&quot;eastAsia&quot;</span>/&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">w:b</span>/&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">w:sz</span> <span class="hljs-attr">w:val</span>=<span class="hljs-string">&quot;32&quot;</span>/&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">w:szCs</span> <span class="hljs-attr">w:val</span>=<span class="hljs-string">&quot;32&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">w:rPr</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">w:t</span>&gt;</span>啊啊啊啊没有了对吧<span class="hljs-tag">&lt;/<span class="hljs-name">w:t</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">w:r</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">w:p</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>那么如果我们要写入文字时就要按照这种格式写入，不过相对于使用Word软件直接生成的，咱们自己写可以相对简单写，比如对文字Font和等都没有要求。</p>
<p>接着我们在来看下图片是如何保存的呢？我们在来看下xml文件中对应内容</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">pic:pic</span> <span class="hljs-attr">xmlns:pic</span>=<span class="hljs-string">&quot;http://schemas.openxmlformats.org/drawingml/2006/picture&quot;</span>&gt;</span><br>                  <span class="hljs-tag">&lt;<span class="hljs-name">pic:nvPicPr</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">pic:cNvPr</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;1&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;test.jpg&quot;</span>/&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">pic:cNvPicPr</span>/&gt;</span><br>                  <span class="hljs-tag">&lt;/<span class="hljs-name">pic:nvPicPr</span>&gt;</span><br>                  <span class="hljs-tag">&lt;<span class="hljs-name">pic:blipFill</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">a:blip</span> <span class="hljs-attr">r:embed</span>=<span class="hljs-string">&quot;rId4&quot;</span>&gt;</span><br>                      <span class="hljs-tag">&lt;<span class="hljs-name">a:extLst</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">a:ext</span> <span class="hljs-attr">uri</span>=<span class="hljs-string">&quot;&#123;28A0092B-C50C-407E-A947-70E740481C1C&#125;&quot;</span>&gt;</span><br>                          <span class="hljs-tag">&lt;<span class="hljs-name">a14:useLocalDpi</span> <span class="hljs-attr">xmlns:a14</span>=<span class="hljs-string">&quot;http://schemas.microsoft.com/office/drawing/2010/main&quot;</span> <span class="hljs-attr">val</span>=<span class="hljs-string">&quot;0&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a14:useLocalDpi</span>&gt;</span><br>                        <span class="hljs-tag">&lt;/<span class="hljs-name">a:ext</span>&gt;</span><br>                      <span class="hljs-tag">&lt;/<span class="hljs-name">a:extLst</span>&gt;</span><br>                    <span class="hljs-tag">&lt;/<span class="hljs-name">a:blip</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">a:stretch</span>&gt;</span><br>                      <span class="hljs-tag">&lt;<span class="hljs-name">a:fillRect</span>/&gt;</span><br>                    <span class="hljs-tag">&lt;/<span class="hljs-name">a:stretch</span>&gt;</span><br>                  <span class="hljs-tag">&lt;/<span class="hljs-name">pic:blipFill</span>&gt;</span><br>                  <span class="hljs-tag">&lt;<span class="hljs-name">pic:spPr</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">a:xfrm</span>&gt;</span><br>                      <span class="hljs-tag">&lt;<span class="hljs-name">a:off</span> <span class="hljs-attr">x</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">y</span>=<span class="hljs-string">&quot;0&quot;</span>/&gt;</span><br>                      <span class="hljs-tag">&lt;<span class="hljs-name">a:ext</span> <span class="hljs-attr">cx</span>=<span class="hljs-string">&quot;5080000&quot;</span> <span class="hljs-attr">cy</span>=<span class="hljs-string">&quot;3175000&quot;</span>/&gt;</span><br>                    <span class="hljs-tag">&lt;/<span class="hljs-name">a:xfrm</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">a:prstGeom</span> <span class="hljs-attr">prst</span>=<span class="hljs-string">&quot;rect&quot;</span>&gt;</span><br>                      <span class="hljs-tag">&lt;<span class="hljs-name">a:avLst</span>/&gt;</span><br>                    <span class="hljs-tag">&lt;/<span class="hljs-name">a:prstGeom</span>&gt;</span><br>                  <span class="hljs-tag">&lt;/<span class="hljs-name">pic:spPr</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">pic:pic</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>我们发现xml文件中有踢掉一个标识符 <code>&lt;a:blip r:embed=&quot;rId4&quot;&gt;</code>, 然后我们需要知道<code>rId4 </code>表示的是哪一个资源，我们打开<code>document.xml.rels</code>文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;yes&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">Relationships</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://schemas.openxmlformats.org/package/2006/relationships&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">Relationship</span> <span class="hljs-attr">Id</span>=<span class="hljs-string">&quot;rId3&quot;</span> <span class="hljs-attr">Type</span>=<span class="hljs-string">&quot;http://schemas.openxmlformats.org/officeDocument/2006/relationships/webSettings&quot;</span> <span class="hljs-attr">Target</span>=<span class="hljs-string">&quot;webSettings.xml&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">Relationship</span> <span class="hljs-attr">Id</span>=<span class="hljs-string">&quot;rId2&quot;</span> <span class="hljs-attr">Type</span>=<span class="hljs-string">&quot;http://schemas.openxmlformats.org/officeDocument/2006/relationships/settings&quot;</span> <span class="hljs-attr">Target</span>=<span class="hljs-string">&quot;settings.xml&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">Relationship</span> <span class="hljs-attr">Id</span>=<span class="hljs-string">&quot;rId1&quot;</span> <span class="hljs-attr">Type</span>=<span class="hljs-string">&quot;http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles&quot;</span> <span class="hljs-attr">Target</span>=<span class="hljs-string">&quot;styles.xml&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">Relationship</span> <span class="hljs-attr">Id</span>=<span class="hljs-string">&quot;rId6&quot;</span> <span class="hljs-attr">Type</span>=<span class="hljs-string">&quot;http://schemas.openxmlformats.org/officeDocument/2006/relationships/theme&quot;</span> <span class="hljs-attr">Target</span>=<span class="hljs-string">&quot;theme/theme1.xml&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">Relationship</span> <span class="hljs-attr">Id</span>=<span class="hljs-string">&quot;rId5&quot;</span> <span class="hljs-attr">Type</span>=<span class="hljs-string">&quot;http://schemas.openxmlformats.org/officeDocument/2006/relationships/fontTable&quot;</span> <span class="hljs-attr">Target</span>=<span class="hljs-string">&quot;fontTable.xml&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">Relationship</span> <span class="hljs-attr">Id</span>=<span class="hljs-string">&quot;rId4&quot;</span> <span class="hljs-attr">Type</span>=<span class="hljs-string">&quot;http://schemas.openxmlformats.org/officeDocument/2006/relationships/image&quot;</span> <span class="hljs-attr">Target</span>=<span class="hljs-string">&quot;media/image1.jpg&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">Relationships</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>可以看到 <code>rId4</code>表示的是<code>&quot;media/image1.jpg&quot;</code>,然后我们到media文件夹下，果然发现了image1.jpg这张图片，对应的恰好使我们添加到Word文件中的那张图片，这样我们图片的添加方式也找到了。</p>
<p>如果你对于docx中的xml文件标签不熟悉，请参考<a href="https://blog.csdn.net/renfufei/article/details/77481753">Word-docx文件图片信息格式分析</a></p>
<h3 id="如何编辑Word"><a href="#如何编辑Word" class="headerlink" title="如何编辑Word"></a>如何编辑Word</h3><p>根据第一步的讲解，我们导出一个docx文件，那么我们应该有下面几步:</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h62h9nz9gwj20dm0k6dgo.jpg" alt="生成Word文件步骤"></p>
<h4 id="空Docx文件资源"><a href="#空Docx文件资源" class="headerlink" title="空Docx文件资源"></a>空Docx文件资源</h4><p>这一步较为简单，实际上我们新建一个空的文件并进行解压就可以得到，注意这些文件要放到bundle中，生成文件时先拷贝到沙盒，在修改沙盒中的文件。</p>
<h4 id="编辑-word-document-xml-文件"><a href="#编辑-word-document-xml-文件" class="headerlink" title="编辑 word/document.xml 文件"></a>编辑 word/document.xml 文件</h4><p>这一步应该是最难的，在我们搜索时发现了已有的库<a href="https://github.com/shinjukunian/DocX">DocX</a>,唯一的缺点就是目前只支持Swift Package，鉴于我们项目中是直接使用的Cocoapods,因此，我这里直接将用到的三个库，封装为一个pod，大家可以直接使用。</p>
<h4 id="压缩文件为-zip"><a href="#压缩文件为-zip" class="headerlink" title="压缩文件为 zip"></a>压缩文件为 zip</h4><p>压缩文件，我们也不多说，这里直接用的三方<a href="https://github.com/weichsel/ZIPFoundation">ZipFoundation</a></p>
<h4 id="修改文件后缀"><a href="#修改文件后缀" class="headerlink" title="修改文件后缀"></a>修改文件后缀</h4><p>这一步也很简单这里不做赘述</p>
<p>我们来简单看下上面四个步骤的代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"> <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">writeToDocx</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">var</span> attributeString = <span class="hljs-type">NSMutableAttributedString</span>(string: <span class="hljs-string">&quot;1.在QQ上或者微信上搜索关键词“班级群”，一些群无需验证或群管理不到位，骗子就能轻易混进群中。进群后，他们往往潜伏在群里，观察一段时间。 2.骗子趁学生玩手机游戏时，以“免费赠送游戏皮肤、验证身份”为由，要求对方发送班级微信群日常聊天截图和微信群聊二维码，借此混入班级微信群。3.学生、家长和老师的QQ、微信等社交账号被盗，个人信息泄露。进入班级微信群后，骗子还会拉入同伙，克隆班主任的头像和昵称，冒充老师在群里发送有关学校收取书本费、资料费、报名费等信息，同伙则在群里发送缴费截屏，家长见老师发布通知往往不会核实真假，向骗子提供的二维码转账汇款或者在群里发送缴费红包。收取的费用从几十到几百元不等，不易引起家长怀疑。\n&quot;</span>)<br>        <span class="hljs-keyword">let</span> attachment = <span class="hljs-type">NSTextAttachment</span>()<br>        attachment.image = <span class="hljs-type">UIImage</span>(named: <span class="hljs-string">&quot;1&quot;</span>)!<br>        attachment.bounds = <span class="hljs-type">CGRect</span>(origin: .zero, size: <span class="hljs-type">CGSize</span>(width: <span class="hljs-number">300</span>, height: <span class="hljs-number">300</span>))<br>        <span class="hljs-keyword">let</span> attributeImageText = <span class="hljs-type">NSAttributedString</span>(attachment: attachment)<br>        attributeString.append(attributeImageText)<br>        <span class="hljs-keyword">self</span>.textView.attributedText=attributeString<br>        <span class="hljs-keyword">self</span>.textView.backgroundColor = .white<br>        <br>        <span class="hljs-keyword">let</span> temp=<span class="hljs-type">FileManager</span>.<span class="hljs-keyword">default</span>.temporaryDirectory.appendingPathComponent(<span class="hljs-type">UUID</span>().uuidString).appendingPathExtension(<span class="hljs-string">&quot;docx&quot;</span>)<br>        <span class="hljs-keyword">try</span>? <span class="hljs-type">DocXWriter</span>.write(pages: [attributeString, attributeString], to: temp)<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">func</span> <span class="hljs-title">write</span>(<span class="hljs-title">pages</span>:[<span class="hljs-title">NSAttributedString</span>], <span class="hljs-title">to</span> <span class="hljs-title">url</span>:<span class="hljs-title">URL</span>, <span class="hljs-title">options</span>:<span class="hljs-title">DocXOptions</span> = <span class="hljs-title">DocXOptions</span>()) <span class="hljs-title">throws</span></span>&#123;<br>        <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> first=pages.first <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">return</span>&#125;<br>        <span class="hljs-keyword">let</span> result=<span class="hljs-type">NSMutableAttributedString</span>(attributedString: first)<br>        <span class="hljs-keyword">let</span> pageSeperator=<span class="hljs-type">NSAttributedString</span>(string: <span class="hljs-string">&quot;\r&quot;</span>, attributes: [.breakType:<span class="hljs-type">BreakType</span>.page])<br>        <br>        <span class="hljs-keyword">for</span> page <span class="hljs-keyword">in</span> pages.<span class="hljs-built_in">dropFirst</span>()&#123;<br>            result.append(pageSeperator)<br>            result.append(page)<br>        &#125;<br>        <br>        <span class="hljs-keyword">try</span> result.writeDocX(to: url, options: options)<br>  &#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">writeDocX_builtin</span><span class="hljs-params">(to url: URL, options:DocXOptions = DocXOptions<span class="hljs-params">()</span></span></span>) <span class="hljs-keyword">throws</span>&#123;<br>        <span class="hljs-keyword">let</span> tempURL=<span class="hljs-keyword">try</span> <span class="hljs-type">FileManager</span>.<span class="hljs-keyword">default</span>.url(<span class="hljs-keyword">for</span>: .itemReplacementDirectory, <span class="hljs-keyword">in</span>: .userDomainMask, appropriateFor: url, create: <span class="hljs-literal">true</span>)<br>        <br>        <span class="hljs-keyword">defer</span>&#123;<br>            <span class="hljs-keyword">try</span>? <span class="hljs-type">FileManager</span>.<span class="hljs-keyword">default</span>.removeItem(at: tempURL)<br>        &#125;<br>        <br>        <span class="hljs-keyword">let</span> docURL=tempURL.appendingPathComponent(<span class="hljs-type">UUID</span>().uuidString, isDirectory: <span class="hljs-literal">true</span>)<br>        <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> blankURL=<span class="hljs-type">Bundle</span>.blankDocumentURL <span class="hljs-keyword">else</span>&#123;<span class="hljs-keyword">throw</span> <span class="hljs-type">DocXSavingErrors</span>.noBlankDocument&#125;<br>        <span class="hljs-keyword">try</span> <span class="hljs-type">FileManager</span>.<span class="hljs-keyword">default</span>.copyItem(at: blankURL, to: docURL)<br><br>        <span class="hljs-keyword">let</span> docPath=docURL.appendingPathComponent(<span class="hljs-string">&quot;word&quot;</span>).appendingPathComponent(<span class="hljs-string">&quot;document&quot;</span>).appendingPathExtension(<span class="hljs-string">&quot;xml&quot;</span>)<br>        <br>        <span class="hljs-keyword">let</span> linkURL=docURL.appendingPathComponent(<span class="hljs-string">&quot;word&quot;</span>).appendingPathComponent(<span class="hljs-string">&quot;_rels&quot;</span>).appendingPathComponent(<span class="hljs-string">&quot;document.xml.rels&quot;</span>)<br>        <span class="hljs-keyword">let</span> mediaURL=docURL.appendingPathComponent(<span class="hljs-string">&quot;word&quot;</span>).appendingPathComponent(<span class="hljs-string">&quot;media&quot;</span>, isDirectory: <span class="hljs-literal">true</span>)<br>        <span class="hljs-keyword">let</span> propsURL=docURL.appendingPathComponent(<span class="hljs-string">&quot;docProps&quot;</span>).appendingPathComponent(<span class="hljs-string">&quot;core&quot;</span>).appendingPathExtension(<span class="hljs-string">&quot;xml&quot;</span>)<br>        <br>        <br>        <span class="hljs-keyword">let</span> linkData=<span class="hljs-keyword">try</span> <span class="hljs-type">Data</span>(contentsOf: linkURL)<br>        <span class="hljs-keyword">var</span> docOptions=<span class="hljs-type">AEXMLOptions</span>()<br>        docOptions.parserSettings.shouldTrimWhitespace=<span class="hljs-literal">false</span><br>        docOptions.documentHeader.standalone=<span class="hljs-string">&quot;yes&quot;</span><br>        <span class="hljs-keyword">let</span> linkDocument=<span class="hljs-keyword">try</span> <span class="hljs-type">AEXMLDocument</span>(xml: linkData, options: docOptions)<br>        <span class="hljs-keyword">let</span> linkRelations=<span class="hljs-keyword">self</span>.prepareLinks(linkXML: linkDocument, mediaURL: mediaURL)<br>        <span class="hljs-keyword">let</span> updatedLinks=linkDocument.xmlCompact<br>        <span class="hljs-keyword">try</span> updatedLinks.write(to: linkURL, atomically: <span class="hljs-literal">true</span>, encoding: .utf8)<br>        <br>        <span class="hljs-keyword">let</span> xmlData = <span class="hljs-keyword">try</span> <span class="hljs-keyword">self</span>.docXDocument(linkRelations: linkRelations)<br>        <br>        <span class="hljs-keyword">try</span> xmlData.write(to: docPath, atomically: <span class="hljs-literal">true</span>, encoding: .utf8)<br>        <br>        <span class="hljs-keyword">let</span> metaData=options.xml.xmlCompact<br>        <span class="hljs-keyword">try</span> metaData.write(to: propsURL, atomically: <span class="hljs-literal">true</span>, encoding: .utf8)<br><br>        <span class="hljs-keyword">let</span> zipURL=tempURL.appendingPathComponent(<span class="hljs-type">UUID</span>().uuidString).appendingPathExtension(<span class="hljs-string">&quot;zip&quot;</span>)<br>        <span class="hljs-keyword">try</span> <span class="hljs-type">FileManager</span>.<span class="hljs-keyword">default</span>.zipItem(at: docURL, to: zipURL, shouldKeepParent: <span class="hljs-literal">false</span>, compressionMethod: .deflate, progress: <span class="hljs-literal">nil</span>)<br><br>        <span class="hljs-keyword">try</span> <span class="hljs-type">FileManager</span>.<span class="hljs-keyword">default</span>.copyItem(at: zipURL, to: url)<br>    &#125;<br><br></code></pre></td></tr></table></figure>


<p>至此我们就完成了docx的写入!,如果想更详细的了解写入的过程，大家可以仔细看下<code>Word文件结构</code>的文章和<code>docx</code>这个库，相信你们可以做的更好。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对于上面的几种方法我们做一个利弊总结:</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">优点</th>
<th align="left">缺点</th>
<th align="left">建议</th>
</tr>
</thead>
<tbody><tr>
<td align="left">直接写入</td>
<td align="left">简单，纯文本写入doc可行</td>
<td align="left">不支持图片，不支持docx格式</td>
<td align="left">不建议使用，因为生成的文件打不开</td>
</tr>
<tr>
<td align="left">html</td>
<td align="left">简单快捷，支持html的格式，样式较多</td>
<td align="left">不支持docx格式</td>
<td align="left">可接受不支持docx的话 推荐使用</td>
</tr>
<tr>
<td align="left">修改内部结构</td>
<td align="left">完美支持docx格式，使用封装库可直接将富文本转换为word文档</td>
<td align="left">如果要增加样式支持 门槛较高需要了解Word文件格式</td>
<td align="left">没有硬伤，但是后续扩展成本较高</td>
</tr>
</tbody></table>
<p>根据你的需求，选择一个合适你的方案吧！</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://sebsauvage.net/wiki/doku.php?id=word_document_generation">Word document generation</a></p>
<p><a href="https://stackoverflow.com/questions/38751495/create-a-word-document-swift">Create a word document, Swift</a></p>
<p><a href="https://github.com/OfficeDev/Open-XML-SDK">Open-XML-SDK</a></p>
<p><a href="https://blog.csdn.net/renfufei/article/details/77481753">Word-docx文件图片信息格式分析</a></p>
<p><a href="https://kodango.com/talking-about-the-structure-of-word-document">浅谈 Word 文档结构</a></p>
<p><a href="https://www.jianshu.com/p/96362c83e9d9">docx文件基本结构</a></p>
]]></content>
      <tags>
        <tag>docX, Word, iOS</tag>
      </tags>
  </entry>
</search>
